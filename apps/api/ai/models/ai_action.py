"""
AIAction Model - Stores action plans with risk analysis.

Requirements:
- 3.1: Generate action plans using ONLY Tool_API operations
- 3.2: Assign risk levels to each proposed action
- 3.6: Output reversible action plan with rollback steps
- 8.3: Approval token bound to action_plan_hash
- 27.2: Record tool_schema_versions in plan

This model stores the action plans generated by the Action Planner.
"""

from datetime import datetime
from enum import Enum
from typing import Optional, List
from uuid import uuid4

from sqlalchemy import Column, String, Text, DateTime, Integer, Boolean, Index, ForeignKey
from sqlalchemy.dialects.postgresql import JSONB

from database import Base, now_utc


def _gen_id() -> str:
    """Generate a unique ID for AI actions."""
    return f"aiact_{uuid4().hex}"


class RiskLevel(str, Enum):
    """Risk level for AI actions."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ActionStatus(str, Enum):
    """Status of an AI action."""
    DRAFT = "draft"  # Being planned
    PENDING_APPROVAL = "pending_approval"  # Awaiting human approval
    APPROVED = "approved"  # Approved, ready for execution
    REJECTED = "rejected"  # Rejected by approver
    EXECUTING = "executing"  # Currently executing
    COMPLETED = "completed"  # Successfully executed
    FAILED = "failed"  # Execution failed
    ROLLED_BACK = "rolled_back"  # Rolled back after failure
    EXPIRED = "expired"  # Approval token expired


class AIAction(Base):
    """
    Stores action plans with risk analysis and approval tracking.
    
    This is part of AI_Audit_Storage - the AI Layer's dedicated storage.
    
    Attributes:
        id: Unique action identifier (aiact_<uuid>)
        request_id: Reference to the originating AI request
        tenant_id: Tenant isolation boundary
        user_id: User who initiated the action
        
        action_plan: JSON structure of the action plan
        action_plan_hash: SHA-256 hash of action_plan for integrity
        tool_schema_versions: JSON map of tool_id -> schema_version used
        
        risk_level: Assessed risk level
        risk_reasoning: LLM-generated risk explanation
        required_permissions: List of permissions needed
        
        rollback_plan: JSON structure for rollback procedure
        
        status: Current status of the action
        
        approval_token_hash: Hash of the approval token (not stored in plain)
        approval_expires_at: When the approval token expires
        approved_by: User ID of approver
        approved_at: When approved
        rejection_reason: Reason if rejected
        
        execution_started_at: When execution started
        execution_completed_at: When execution completed
        execution_result: JSON result of execution
        execution_error: Error message if failed
        
        dry_run_result: Result of simulation/dry-run
        
        created_at: When the action was created
        updated_at: When last updated
    """
    __tablename__ = "ai_actions"
    
    # Primary key
    id = Column(String(64), primary_key=True, default=_gen_id)
    
    # References
    request_id = Column(String(64), ForeignKey("ai_requests.id"), nullable=False, index=True)
    tenant_id = Column(String(64), nullable=False, index=True)
    user_id = Column(String(64), nullable=False, index=True)
    
    # Action plan
    action_plan = Column(JSONB, nullable=False)
    action_plan_hash = Column(String(64), nullable=False, index=True)  # SHA-256
    tool_schema_versions = Column(JSONB, nullable=False, default=dict)  # {tool_id: version}
    
    # Risk assessment
    risk_level = Column(String(16), nullable=False, default=RiskLevel.LOW.value)
    risk_reasoning = Column(Text, nullable=True)  # LLM-generated explanation
    required_permissions = Column(JSONB, nullable=True, default=list)  # List of permission strings
    
    # Rollback
    rollback_plan = Column(JSONB, nullable=True)
    
    # Status
    status = Column(String(20), nullable=False, default=ActionStatus.DRAFT.value)
    
    # Approval tracking
    approval_token_hash = Column(String(64), nullable=True)  # SHA-256 of token
    approval_expires_at = Column(DateTime, nullable=True)
    approved_by = Column(String(64), nullable=True)
    approved_at = Column(DateTime, nullable=True)
    rejection_reason = Column(Text, nullable=True)
    
    # Execution tracking
    execution_started_at = Column(DateTime, nullable=True)
    execution_completed_at = Column(DateTime, nullable=True)
    execution_result = Column(JSONB, nullable=True)
    execution_error = Column(Text, nullable=True)
    
    # Dry-run/simulation
    dry_run_result = Column(JSONB, nullable=True)
    
    # Idempotency
    idempotency_key = Column(String(128), nullable=True, index=True)
    
    # Timestamps
    created_at = Column(DateTime, nullable=False, default=now_utc)
    updated_at = Column(DateTime, nullable=False, default=now_utc, onupdate=now_utc)
    
    # Indexes
    __table_args__ = (
        Index("ix_ai_actions_tenant_status", "tenant_id", "status"),
        Index("ix_ai_actions_tenant_created", "tenant_id", "created_at"),
        Index("ix_ai_actions_approval_pending", "status", "approval_expires_at"),
    )
    
    def to_dict(self) -> dict:
        """Convert to dictionary for API responses."""
        return {
            "id": self.id,
            "requestId": self.request_id,
            "tenantId": self.tenant_id,
            "userId": self.user_id,
            "actionPlan": self.action_plan,
            "actionPlanHash": self.action_plan_hash,
            "toolSchemaVersions": self.tool_schema_versions,
            "riskLevel": self.risk_level,
            "riskReasoning": self.risk_reasoning,
            "requiredPermissions": self.required_permissions,
            "rollbackPlan": self.rollback_plan,
            "status": self.status,
            "approvalExpiresAt": self.approval_expires_at.isoformat() if self.approval_expires_at else None,
            "approvedBy": self.approved_by,
            "approvedAt": self.approved_at.isoformat() if self.approved_at else None,
            "rejectionReason": self.rejection_reason,
            "executionStartedAt": self.execution_started_at.isoformat() if self.execution_started_at else None,
            "executionCompletedAt": self.execution_completed_at.isoformat() if self.execution_completed_at else None,
            "executionResult": self.execution_result,
            "executionError": self.execution_error,
            "dryRunResult": self.dry_run_result,
            "createdAt": self.created_at.isoformat() if self.created_at else None,
            "updatedAt": self.updated_at.isoformat() if self.updated_at else None,
        }
    
    def requires_approval(self) -> bool:
        """Check if this action requires human approval."""
        return self.risk_level in (RiskLevel.HIGH.value, RiskLevel.CRITICAL.value)
    
    def is_approval_expired(self) -> bool:
        """Check if the approval token has expired."""
        if not self.approval_expires_at:
            return True
        return datetime.utcnow() > self.approval_expires_at
    
    def mark_approved(self, approver_id: str, token_hash: str) -> None:
        """Mark the action as approved."""
        self.status = ActionStatus.APPROVED.value
        self.approved_by = approver_id
        self.approved_at = now_utc()
        self.approval_token_hash = token_hash
    
    def mark_rejected(self, reason: str) -> None:
        """Mark the action as rejected."""
        self.status = ActionStatus.REJECTED.value
        self.rejection_reason = reason
    
    def mark_executing(self) -> None:
        """Mark the action as currently executing."""
        self.status = ActionStatus.EXECUTING.value
        self.execution_started_at = now_utc()
    
    def mark_completed(self, result: dict) -> None:
        """Mark the action as successfully completed."""
        self.status = ActionStatus.COMPLETED.value
        self.execution_completed_at = now_utc()
        self.execution_result = result
    
    def mark_failed(self, error: str) -> None:
        """Mark the action as failed."""
        self.status = ActionStatus.FAILED.value
        self.execution_completed_at = now_utc()
        self.execution_error = error
    
    def mark_rolled_back(self) -> None:
        """Mark the action as rolled back."""
        self.status = ActionStatus.ROLLED_BACK.value
