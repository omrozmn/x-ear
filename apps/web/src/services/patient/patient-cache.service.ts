/**
 * Patient Cache Service
 * @fileoverview Handles patient data caching and offline storage
 * @version 1.0.0
 */

import { Patient } from '../../api/generated/xEarCRMAPIAutoGenerated.schemas';
import { indexedDBManager } from '../../utils/indexeddb';

export interface CacheStats {
  totalPatients: number;
  lastUpdated: string | null;
  cacheSize: number;
  oldestEntry: string | null;
  newestEntry: string | null;
}

export interface CacheOptions {
  ttl?: number; // Time to live in milliseconds
  maxSize?: number; // Maximum number of patients to cache
  priority?: 'high' | 'normal' | 'low';
}

export interface SimpleCacheFilters {
  search?: string;
  status?: string[];
  segment?: string[];
  tags?: string[];
  acquisitionType?: string[];
  page?: number;
  limit?: number;
}

export interface PatientSearchResult {
  patients: PatientSearchItem[];
  totalCount: number;
  filteredCount: number;
}

export interface PatientSearchItem {
  id?: string;
  firstName: string;
  lastName: string;
  tcNumber: string;
  phone: string;
  email?: string;
  status?: string;
  segment?: string;
  registrationDate?: string;
  lastVisitDate?: string;
  deviceCount: number;
  hasInsurance: boolean;
  outstandingBalance: number;
  priority: number;
}

export class PatientCacheService {
  private readonly CACHE_PREFIX = 'patient_cache_';
  private readonly METADATA_KEY = 'patient_cache_metadata';
  private readonly DEFAULT_TTL = 24 * 60 * 60 * 1000; // 24 hours
  private readonly MAX_CACHE_SIZE = 10000;

  async cachePatients(patients: Patient[], options: CacheOptions = {}): Promise<void> {
    try {
      // Store patients in IndexedDB
      await indexedDBManager.savePatients(patients);
      
      // Update cache metadata
      await this.updateCacheMetadata(patients.length);
      
      // Set individual cache entries with TTL
      const ttl = options.ttl || this.DEFAULT_TTL;
      const cachePromises = patients.map(patient => 
        indexedDBManager.setCache(
          `${this.CACHE_PREFIX}${patient.id}`,
          patient,
          ttl
        )
      );
      
      await Promise.all(cachePromises);
    } catch (error) {
      console.error('Failed to cache patients:', error);
      throw error;
    }
  }

  async getCachedPatient(patientId: string): Promise<Patient | null> {
    try {
      // Try IndexedDB first
      const patient = await indexedDBManager.getPatient(patientId);
      if (patient) {
        return patient;
      }

      // Fallback to cache
      const cached = await indexedDBManager.getCache(`${this.CACHE_PREFIX}${patientId}`);
      if (!cached) return null;

      return cached as Patient;
    } catch (error) {
      console.error(`Failed to get cached patient ${patientId}:`, error);
      return null;
    }
  }

  async getCachedPatients(): Promise<Patient[]> {
    try {
      return await indexedDBManager.getPatients();
    } catch (error) {
      console.error('Failed to get cached patients:', error);
      return [];
    }
  }

  async searchCachedPatients(filters: SimpleCacheFilters): Promise<PatientSearchResult> {
    try {
      const allPatients = await this.getCachedPatients();
      let filteredPatients = [...allPatients];

      // Apply filters
      if (filters.search) {
        const searchTerm = filters.search.toLowerCase();
        filteredPatients = filteredPatients.filter(patient =>
          patient.firstName?.toLowerCase().includes(searchTerm) ||
          patient.lastName?.toLowerCase().includes(searchTerm) ||
          patient.phone?.includes(searchTerm) ||
          patient.tcNumber?.includes(searchTerm) ||
          patient.email?.toLowerCase().includes(searchTerm)
        );
      }

      if (filters.status && filters.status.length > 0) {
        filteredPatients = filteredPatients.filter(patient =>
          patient.status && filters.status!.includes(patient.status)
        );
      }

      if (filters.segment && filters.segment.length > 0) {
        filteredPatients = filteredPatients.filter(patient =>
          patient.segment && filters.segment!.includes(patient.segment)
        );
      }

      if (filters.acquisitionType && filters.acquisitionType.length > 0) {
        filteredPatients = filteredPatients.filter(patient =>
          patient.acquisitionType && filters.acquisitionType!.includes(patient.acquisitionType)
        );
      }

      if (filters.tags && filters.tags.length > 0) {
        filteredPatients = filteredPatients.filter(patient =>
          patient.tags?.some(tag => filters.tags!.includes(tag))
        );
      }

      // Apply pagination
      const page = filters.page || 1;
      const limit = filters.limit || 50;
      const offset = (page - 1) * limit;
      const paginatedPatients = filteredPatients.slice(offset, offset + limit);

      // Convert to PatientSearchItem format
      const searchItems: PatientSearchItem[] = paginatedPatients.map(patient => ({
        id: patient.id,
        firstName: patient.firstName,
        lastName: patient.lastName,
        tcNumber: patient.tcNumber,
        phone: patient.phone,
        email: patient.email,
        status: patient.status,
        segment: patient.segment,
        registrationDate: patient.createdAt,
        lastVisitDate: patient.updatedAt,
        deviceCount: 0, // Device count would need to be fetched separately
        hasInsurance: !!(patient.sgkInfo && Object.keys(patient.sgkInfo).length > 0),
        outstandingBalance: 0, // This would need to be calculated from actual data
        priority: patient.priorityScore || 0
      }));

      return {
        patients: searchItems,
        totalCount: filteredPatients.length,
        filteredCount: filteredPatients.length
      };
    } catch (error) {
      console.error('Failed to search cached patients:', error);
      return {
        patients: [],
        totalCount: 0,
        filteredCount: 0
      };
    }
  }

  async updateCachedPatient(patient: Patient): Promise<void> {
    try {
      await indexedDBManager.updatePatient(patient);
      await indexedDBManager.setCache(`${this.CACHE_PREFIX}${patient.id}`, patient);
    } catch (error) {
      console.error(`Failed to update cached patient ${patient.id}:`, error);
      throw error;
    }
  }

  async removeCachedPatient(patientId: string): Promise<void> {
    try {
      await indexedDBManager.deletePatient(patientId);
      await indexedDBManager.deleteCache(`${this.CACHE_PREFIX}${patientId}`);
    } catch (error) {
      console.error(`Failed to remove cached patient ${patientId}:`, error);
      throw error;
    }
  }

  async getCacheStats(): Promise<CacheStats> {
    try {
      const patients = await this.getCachedPatients();
      const metadata = await indexedDBManager.getCache(this.METADATA_KEY) as any;

      const stats: CacheStats = {
        totalPatients: patients.length,
        lastUpdated: metadata?.lastUpdated || null,
        cacheSize: this.calculateCacheSize(patients),
        oldestEntry: null,
        newestEntry: null
      };

      if (patients.length > 0) {
        const patientsWithCreatedAt = patients.filter(p => p.createdAt);
        if (patientsWithCreatedAt.length > 0) {
          const sortedByCreated = [...patientsWithCreatedAt].sort((a, b) =>
            new Date(a.createdAt!).getTime() - new Date(b.createdAt!).getTime()
          );
          stats.oldestEntry = sortedByCreated[0].createdAt!;
          stats.newestEntry = sortedByCreated[sortedByCreated.length - 1].createdAt!;
        }
      }

      return stats;
    } catch (error) {
      console.error('Failed to get cache stats:', error);
      return {
        totalPatients: 0,
        lastUpdated: null,
        cacheSize: 0,
        oldestEntry: null,
        newestEntry: null
      };
    }
  }

  async clearCache(): Promise<void> {
    try {
      // Clear all patients from IndexedDB
      const patients = await this.getCachedPatients();
      const deletePromises = patients
        .filter(patient => patient.id)
        .map(patient => this.removeCachedPatient(patient.id!));

      await Promise.all(deletePromises);

      // Clear metadata
      await indexedDBManager.deleteCache(this.METADATA_KEY);
    } catch (error) {
      console.error('Failed to clear cache:', error);
      throw error;
    }
  }

  async optimizeCache(): Promise<void> {
    try {
      const patients = await this.getCachedPatients();

      // Remove old entries if cache is too large
      if (patients.length > this.MAX_CACHE_SIZE) {
        const patientsWithUpdatedAt = patients.filter(p => p.updatedAt);
        const sortedByUpdated = [...patientsWithUpdatedAt].sort((a, b) =>
          new Date(a.updatedAt!).getTime() - new Date(b.updatedAt!).getTime()
        );

        const toRemove = sortedByUpdated.slice(0, patients.length - this.MAX_CACHE_SIZE);
        const removePromises = toRemove
          .filter(patient => patient.id)
          .map(patient => this.removeCachedPatient(patient.id!));

        await Promise.all(removePromises);
      }
    } catch (error) {
      console.error('Failed to optimize cache:', error);
    }
  }

  async isPatientCached(patientId: string): Promise<boolean> {
    try {
      const patient = await this.getCachedPatient(patientId);
      return patient !== null;
    } catch (error) {
      console.error(`Failed to check if patient ${patientId} is cached:`, error);
      return false;
    }
  }

  async preloadPatients(patientIds: string[]): Promise<void> {
    // This would typically fetch patients from API and cache them
    // For now, it's a placeholder for the actual implementation
    console.log('Preloading patients:', patientIds);
  }

  private async updateCacheMetadata(patientCount: number): Promise<void> {
    try {
      const metadata = {
        lastUpdated: new Date().toISOString(),
        patientCount,
        version: '1.0.0'
      };
      
      await indexedDBManager.setCache(this.METADATA_KEY, metadata);
    } catch (error) {
      console.error('Failed to update cache metadata:', error);
    }
  }

  private calculateCacheSize(patients: Patient[]): number {
    // Rough estimation of cache size in bytes
    const jsonString = JSON.stringify(patients);
    return new Blob([jsonString]).size;
  }

  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }
}

export const patientCacheService = new PatientCacheService();