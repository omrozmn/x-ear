/**
 * Patient Search Service
 * @fileoverview Handles patient search, filtering, and matching operations
 * @version 1.0.0
 */

import { Patient } from '../../api/generated/xEarCRMAPIAutoGenerated.schemas.ts/index';
import { PatientFilters } from '../../types/patient';
import Fuse from 'fuse.js';

export interface PatientSearchResult {
  patients: Patient[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

export interface PatientMatchCandidate {
  patient: Patient;
  score: number;
  matchedFields: string[];
  confidence: 'high' | 'medium' | 'low';
}

export interface PatientMatchRequest {
  firstName?: string;
  lastName?: string;
  tcNo?: string;
  phone?: string;
  birthDate?: string;
}

export class PatientSearchService {
  private fuseInstance: Fuse<Patient> | null = null;

  constructor() {
    this.initializeFuse();
  }

  private initializeFuse(): void {
    const fuseOptions = {
      keys: [
        { name: 'firstName', weight: 0.3 },
        { name: 'lastName', weight: 0.3 },
        { name: 'phone', weight: 0.2 },
        { name: 'tcNumber', weight: 0.15 },
        { name: 'email', weight: 0.1 },
        { name: 'tags', weight: 0.05 }
      ],
      threshold: 0.3,
      includeScore: true,
      includeMatches: true,
      minMatchCharLength: 2
    };

    this.fuseInstance = new Fuse([], fuseOptions);
  }

  updateSearchIndex(patients: Patient[]): void {
    if (this.fuseInstance) {
      this.fuseInstance.setCollection(patients);
    }
  }

  searchPatients(patients: Patient[], filters: PatientFilters = {}): PatientSearchResult {
    let filteredPatients = [...patients];

    // Apply text search first
    if (filters.search && filters.search.trim()) {
      if (this.fuseInstance) {
        const searchResults = this.fuseInstance.search(filters.search.trim());
        filteredPatients = searchResults.map(result => result.item);
      } else {
        // Fallback to simple text search
        const searchTerm = filters.search.toLowerCase();
        filteredPatients = patients.filter(patient => 
          patient.firstName?.toLowerCase().includes(searchTerm) ||
          patient.lastName?.toLowerCase().includes(searchTerm) ||
          patient.phone?.includes(searchTerm) ||
          patient.tcNumber?.includes(searchTerm) ||
          patient.email?.toLowerCase().includes(searchTerm)
        );
      }
    }

    // Apply filters
    filteredPatients = this.applyFilters(filteredPatients, filters);

    // Apply pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedPatients = filteredPatients.slice(startIndex, endIndex);

    return {
      patients: paginatedPatients,
      total: filteredPatients.length,
      page,
      pageSize: limit,
      hasMore: endIndex < filteredPatients.length
    };
  }

  private applyFilters(patients: Patient[], filters: PatientFilters): Patient[] {
    return patients.filter(patient => {
      // Status filter
      if (filters.status && patient.status !== filters.status) {
        return false;
      }

      // Segment filter
      if (filters.segment && patient.segment !== filters.segment) {
        return false;
      }

      // Acquisition type filter
      if (filters.acquisitionType && patient.acquisitionType !== filters.acquisitionType) {
        return false;
      }

      // Tags filter
      if (filters.tags && filters.tags.length > 0) {
        const hasMatchingTag = filters.tags.some(tag =>
          patient.tags?.includes(tag)
        );
        if (!hasMatchingTag) {
          return false;
        }
      }

      return true;
    });
  }

  findMatches(request: PatientMatchRequest, patients: Patient[]): PatientMatchCandidate[] {
    const candidates: PatientMatchCandidate[] = [];

    for (const patient of patients) {
      const match = this.calculatePatientMatch(request, patient);
      if (match.score > 0.3) { // Only include matches above threshold
        candidates.push(match);
      }
    }

    // Sort by score descending
    return candidates.sort((a, b) => b.score - a.score);
  }

  private calculatePatientMatch(request: PatientMatchRequest, patient: Patient): PatientMatchCandidate {
    let totalScore = 0;
    let maxPossibleScore = 0;
    const matchedFields: string[] = [];

    // Name matching (weight: 0.4) - using firstName and lastName
    if ((request.firstName || request.lastName) && (patient.firstName || patient.lastName)) {
      const requestFullName = `${request.firstName || ''} ${request.lastName || ''}`.trim();
      const patientFullName = `${patient.firstName || ''} ${patient.lastName || ''}`.trim();
      const nameScore = this.calculateStringSimilarity(requestFullName, patientFullName);
      totalScore += nameScore * 0.4;
      maxPossibleScore += 0.4;
      if (nameScore > 0.7) {
        matchedFields.push('name');
      }
    }

    // TC Number matching (weight: 0.3)
    if (request.tcNo && patient.tcNumber) {
      const tcScore = request.tcNo === patient.tcNumber ? 1 : 0;
      totalScore += tcScore * 0.3;
      maxPossibleScore += 0.3;
      if (tcScore > 0) {
        matchedFields.push('tcNumber');
      }
    }

    // Phone matching (weight: 0.2)
    if (request.phone && patient.phone) {
      const phoneScore = this.calculatePhoneSimilarity(request.phone, patient.phone);
      totalScore += phoneScore * 0.2;
      maxPossibleScore += 0.2;
      if (phoneScore > 0.8) {
        matchedFields.push('phone');
      }
    }

    // Birth date matching (weight: 0.1)
    if (request.birthDate && patient.birthDate) {
      const birthDateScore = request.birthDate === patient.birthDate ? 1 : 0;
      totalScore += birthDateScore * 0.1;
      maxPossibleScore += 0.1;
      if (birthDateScore > 0) {
        matchedFields.push('birthDate');
      }
    }

    // Normalize score
    const normalizedScore = maxPossibleScore > 0 ? totalScore / maxPossibleScore : 0;

    // Determine confidence level
    let confidence: 'high' | 'medium' | 'low' = 'low';
    if (normalizedScore > 0.8) {
      confidence = 'high';
    } else if (normalizedScore > 0.6) {
      confidence = 'medium';
    }

    return {
      patient,
      score: normalizedScore,
      matchedFields,
      confidence
    };
  }

  private calculateStringSimilarity(str1: string, str2: string): number {
    const s1 = str1.toLowerCase().trim();
    const s2 = str2.toLowerCase().trim();
    
    if (s1 === s2) return 1;
    
    const maxLength = Math.max(s1.length, s2.length);
    if (maxLength === 0) return 1;
    
    const distance = this.levenshteinDistance(s1, s2);
    return 1 - (distance / maxLength);
  }

  private calculatePhoneSimilarity(phone1: string, phone2: string): number {
    // Normalize phone numbers (remove spaces, dashes, parentheses)
    const normalize = (phone: string) => phone.replace(/[\s\-\(\)]/g, '');
    
    const p1 = normalize(phone1);
    const p2 = normalize(phone2);
    
    // Exact match
    if (p1 === p2) return 1;
    
    // Check if one is a substring of the other (for international vs local format)
    if (p1.includes(p2) || p2.includes(p1)) return 0.9;
    
    // Use string similarity as fallback
    return this.calculateStringSimilarity(p1, p2);
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

    for (let i = 0; i <= str1.length; i++) {
      matrix[0][i] = i;
    }

    for (let j = 0; j <= str2.length; j++) {
      matrix[j][0] = j;
    }

    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1, // deletion
          matrix[j - 1][i] + 1, // insertion
          matrix[j - 1][i - 1] + indicator // substitution
        );
      }
    }

    return matrix[str2.length][str1.length];
  }
}

export const patientSearchService = new PatientSearchService();