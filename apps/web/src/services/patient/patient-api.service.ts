// Patient API Service - Simplified Version
import { AxiosResponse } from 'axios';
import { 
  PatientsGetPatients200,
  PaginationInfo
} from "../../api/generated/xEarCRMAPIAutoGenerated.schemas";
import { apiClient, Patient, CreatePatientRequest, UpdatePatientRequest } from '../../api/client';

// Request deduplication and caching
interface CacheEntry {
  data: Patient[];
  timestamp: number;
  promise?: Promise<Patient[]>;
}

class RequestThrottler {
  private activeRequests = 0;
  private readonly maxConcurrentRequests = 3;
  private readonly requestQueue: Array<() => Promise<any>> = [];
  private readonly requestDelay = 100;

  async throttle<T>(requestFn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          this.activeRequests++;
          const result = await requestFn();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.activeRequests--;
          setTimeout(() => this.processQueue(), this.requestDelay);
        }
      });
      this.processQueue();
    });
  }

  private processQueue() {
    if (this.activeRequests < this.maxConcurrentRequests && this.requestQueue.length > 0) {
      const nextRequest = this.requestQueue.shift();
      if (nextRequest) {
        nextRequest();
      }
    }
  }

  getActiveRequestCount(): number {
    return this.activeRequests;
  }

  getQueueLength(): number {
    return this.requestQueue.length;
  }
}

export class PatientApiService {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private ongoingRequests: Map<string, Promise<Patient[]>> = new Map();
  private throttler = new RequestThrottler();

  /**
   * Fetch all patients with caching
   */
  async fetchAllPatients(): Promise<Patient[]> {
    const cacheKey = 'all_patients';
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      console.log('üìã Returning cached patients data');
      return cached.data;
    }

    if (this.ongoingRequests.has(cacheKey)) {
      console.log('‚è≥ Waiting for ongoing request...');
      return this.ongoingRequests.get(cacheKey)!;
    }

    const promise = this._fetchAllPatientsInternal();
    this.ongoingRequests.set(cacheKey, promise);

    try {
      const data = await promise;
      this.cache.set(cacheKey, { data, timestamp: Date.now() });
      return data;
    } finally {
      this.ongoingRequests.delete(cacheKey);
    }
  }

  /**
   * Fetch all patients (simplified implementation)
   */
  private async _fetchAllPatientsInternal(): Promise<Patient[]> {
    console.log('üîÑ Starting to fetch all patients...');
    
    try {
      const response = await apiClient.getPatients();
      
      if (response.data?.data?.patients) {
        console.log(`‚úÖ Successfully fetched ${response.data.data.patients.length} patients`);
        return response.data.data.patients;
      }
      
      console.warn('‚ö†Ô∏è No patients data in response:', response);
      return [];
    } catch (error) {
      console.error('‚ùå Error fetching patients:', error);
      throw error;
    }
  }

  /**
   * Get patient sales (simplified implementation)
   */
  async getSales(patientId: string): Promise<any> {
    try {
      return {
        data: [],
        success: true,
        message: 'Sales data not available in simplified version'
      };
    } catch (error) {
      console.error('‚ùå Error fetching sales:', error);
      throw error;
    }
  }

  clearCache(): void {
    this.cache.clear();
    console.log('üóëÔ∏è Cache cleared');
  }

  invalidateCache(key: string = 'all_patients'): void {
    this.cache.delete(key);
    console.log(`üóëÔ∏è Cache invalidated for key: ${key}`);
  }

  async fetchPatient(id: string): Promise<Patient | null> {
    try {
      const response = await apiClient.getPatient(id);
      if (response.data?.patient) {
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error fetching patient ${id}:`, error);
      throw error;
    }
  }

  async createPatient(patientData: CreatePatientRequest): Promise<Patient> {
    try {
      const response = await apiClient.createPatient(patientData);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      throw new Error('Failed to create patient');
    } catch (error) {
      console.error('‚ùå Error creating patient:', error);
      throw error;
    }
  }

  async updatePatient(id: string, updates: UpdatePatientRequest): Promise<Patient | null> {
    try {
      const response = await apiClient.updatePatient(id, updates);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error updating patient ${id}:`, error);
      throw error;
    }
  }

  async deletePatient(id: string): Promise<boolean> {
    try {
      const response = await apiClient.deletePatient(id);
      if (response.data?.success) {
        this.invalidateCache();
        return true;
      }
      return false;
    } catch (error) {
      console.error(`‚ùå Error deleting patient ${id}:`, error);
      throw error;
    }
  }

  // Simplified mock implementations for other methods
  async createSale(patientId: string, saleData: any): Promise<any> {
    return { data: [], success: true, message: 'Sales not available in simplified version' };
  }

  async updateSale(saleId: string, updates: any): Promise<any> {
    return { data: [], success: true, message: 'Sales not available in simplified version' };
  }

  async getTimeline(patientId: string): Promise<any> {
    return { data: [], success: true, message: 'Timeline not available in simplified version' };
  }

  async getSgk(patientId: string): Promise<any> {
    return { data: [], success: true, message: 'SGK not available in simplified version' };
  }

  async getAppointments(patientId: string): Promise<any> {
    return { data: [], success: true, message: 'Appointments not available in simplified version' };
  }

  async getHearingTests(patientId: string): Promise<any> {
    return { data: [], success: true, message: 'Hearing tests not available in simplified version' };
  }

  async getNotes(patientId: string): Promise<any> {
    return { data: [], success: true, message: 'Notes not available in simplified version' };
  }

  async bulkUpload(formData: any): Promise<any> {
    return { data: [], success: true, message: 'Bulk upload not available in simplified version' };
  }

  async search(searchParams: any): Promise<any> {
    return { data: [], success: true, message: 'Search not available in simplified version' };
  }

  async exportCsv(filters: any): Promise<any> {
    return { data: [], success: true, message: 'Export not available in simplified version' };
  }

  async list(filters: any): Promise<any> {
    return this.fetchAllPatients();
  }

  async getPatients(params?: any): Promise<any> {
    return this.fetchAllPatients();
  }

  async createNote(patientId: string, noteData: any): Promise<any> {
    return { data: [], success: true, message: 'Notes not available in simplified version' };
  }

  async deleteNote(patientId: string, noteId: string): Promise<any> {
    return { data: [], success: true, message: 'Notes not available in simplified version' };
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}

export const patientApiService = new PatientApiService();