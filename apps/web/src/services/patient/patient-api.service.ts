// Patient API Service - Simplified Version
import {
  PatientsGetPatients200,
  Sale,
  SalesCreateSaleBody,
  SalesUpdateSaleBody,
  PaginationInfo
} from "../../api/generated/xEarCRMAPIAutoGenerated.schemas";
import { apiClient, Patient, CreatePatientRequest, UpdatePatientRequest } from '../../api/client';
import {
  patientsGetPatients,
  salesGetPatientSales,
  salesCreateSale,
  salesUpdateSale,
  timelineGetPatientTimeline,
  sgkGetPatientSgkDocuments,
  appointmentsListAppointments,
  patientSubresourcesCreatePatientNote,
  patientSubresourcesDeletePatientNote
} from '../../api/generated/xEarCRMAPIAutoGenerated';
import type { Patient as OrvalPatient } from '../../api/generated/xEarCRMAPIAutoGenerated.schemas';

// Request deduplication and caching
interface CacheEntry {

  data: Patient[];
  timestamp: number;
  promise?: Promise<Patient[]>;
}

type ApiEnvelope<T> = {
  data: T;
  success: boolean;
  message?: string;
  error?: string;
  meta?: PaginationInfo | Record<string, unknown>;
};

class RequestThrottler {
  private activeRequests = 0;
  private readonly maxConcurrentRequests = 3;
  private readonly requestQueue: Array<() => Promise<unknown>> = [];
  private readonly requestDelay = 100;

  async throttle<T>(requestFn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          this.activeRequests++;
          const result = await requestFn();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.activeRequests--;
          setTimeout(() => this.processQueue(), this.requestDelay);
        }
      });
      this.processQueue();
    });
  }

  private processQueue() {
    if (this.activeRequests < this.maxConcurrentRequests && this.requestQueue.length > 0) {
      const nextRequest = this.requestQueue.shift();
      if (nextRequest) {
        nextRequest();
      }
    }
  }

  getActiveRequestCount(): number {
    return this.activeRequests;
  }

  getQueueLength(): number {
    return this.requestQueue.length;
  }
}

export class PatientApiService {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private ongoingRequests: Map<string, Promise<Patient[]>> = new Map();
  private throttler = new RequestThrottler();

  /**
   * Fetch all patients with caching
   */
  async fetchAllPatients(perPage: number = 200): Promise<Patient[]> {
    const cacheKey = `all_patients_${perPage}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      console.log('üìã Returning cached patients data');
      return cached.data;
    }

    if (this.ongoingRequests.has(cacheKey)) {
      console.log('‚è≥ Waiting for ongoing request...');
      return this.ongoingRequests.get(cacheKey)!;
    }

    const promise = this._fetchAllPatientsInternal(perPage);
    this.ongoingRequests.set(cacheKey, promise);

    try {
      const data = await promise;
      this.cache.set(cacheKey, { data, timestamp: Date.now() });
      return data;
    } finally {
      this.ongoingRequests.delete(cacheKey);
    }
  }

  /**
   * Fetch all patients (simplified implementation)
   */
  private async _fetchAllPatientsInternal(perPage: number = 200): Promise<Patient[]> {
    console.log(`üîÑ Starting to fetch all patients (per_page: ${perPage})...`);

    try {
      const response = await patientsGetPatients({ params: { page: 1, per_page: perPage } });
      const payload = (response as unknown) as { data?: PatientsGetPatients200 };
      const payloadData = payload?.data;
      const list = payloadData?.data ?? [];
      console.log(`‚úÖ Successfully fetched ${list.length} patients`);
      // Map Orval Patient schema to local Patient shape
      return list.map((p: OrvalPatient) => ({
        id: p.id ?? '',
        name: [p.firstName, p.lastName].filter(Boolean).join(' ').trim(),
        email: p.email,
        phone: p.phone ?? '',
        birth_date: p.birthDate,
        created_at: p.createdAt ?? '',
        updated_at: p.updatedAt ?? ''
      })) as Patient[];
    } catch (error) {
      console.error('‚ùå Error fetching patients:', error);
      throw error;
    }
  }

  /**
   * Get patient sales using generated API client with throttling
   */
  async getSales(patientId: string): Promise<ApiEnvelope<Sale[]>> {
    try {
      const response = await this.throttler.throttle(async () => {
        return await salesGetPatientSales(patientId);
      });
      const res = response as unknown as { data?: { data?: Sale[]; meta?: PaginationInfo } };
      const salesArray = Array.isArray(res.data?.data) ? (res.data?.data as Sale[]) : [];

      return {
        data: salesArray,
        success: true,
        message: 'Sales data retrieved successfully',
        meta: res.data?.meta
      };
    } catch (error) {
      console.error('‚ùå Error fetching sales:', error);
      return {
        data: [],
        success: false,
        message: 'Failed to fetch sales data'
      };
    }
  }

  clearCache(): void {
    this.cache.clear();
    console.log('üóëÔ∏è Cache cleared');
  }

  invalidateCache(key: string = 'all_patients'): void {
    this.cache.delete(key);
    console.log(`üóëÔ∏è Cache invalidated for key: ${key}`);
  }

  async fetchPatient(id: string): Promise<Patient | null> {
    try {
      const response = await apiClient.getPatient(id);
      if (response.data?.patient) {
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error fetching patient ${id}:`, error);
      throw error;
    }
  }

  async createPatient(patientData: CreatePatientRequest): Promise<Patient> {
    try {
      const response = await apiClient.createPatient(patientData);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      throw new Error('Failed to create patient');
    } catch (error) {
      console.error('‚ùå Error creating patient:', error);
      throw error;
    }
  }

  async updatePatient(id: string, updates: UpdatePatientRequest): Promise<Patient | null> {
    try {
      const response = await apiClient.updatePatient(id, updates);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error updating patient ${id}:`, error);
      throw error;
    }
  }

  async deletePatient(id: string): Promise<boolean> {
    try {
      const response = await apiClient.deletePatient(id);
      if (response.data?.success) {
        this.invalidateCache();
        return true;
      }
      return false;
    } catch (error) {
      console.error(`‚ùå Error deleting patient ${id}:`, error);
      throw error;
    }
  }

  async createSale(patientId: string, saleData: unknown): Promise<ApiEnvelope<unknown>> {
    try {
      // Extract product ID and basic fields from saleData
      let productId: string | undefined = (saleData as Record<string, unknown>)?.productId as string | undefined;
      const devices = (saleData as Record<string, unknown>)?.devices as unknown[] | undefined;

      if (!productId && Array.isArray(devices) && devices.length > 0) {
        const first = devices[0] as Record<string, unknown>;
        productId = (first.inventoryId as string | undefined) || (first.id as string | undefined);
      }

      if (!productId) {
        throw new Error('Product ID is required for sale creation');
      }

      const body: SalesCreateSaleBody = {
        patient_id: patientId,
        product_id: productId,
        discount_amount: ((saleData as Record<string, unknown>)?.discount as number) || 0,
        payment_method: ((saleData as Record<string, unknown>)?.paymentMethod as string) || 'cash',
        notes: ((saleData as Record<string, unknown>)?.notes as string) || ''
      } as unknown as SalesCreateSaleBody;

      const response = await salesCreateSale(body, {
        headers: {
          'Idempotency-Key': `sale-${patientId}-${productId}-${Date.now()}`
        }
      });

      const payload = (response as unknown) as { data?: unknown };
      return { data: payload?.data ?? null, success: true };
    } catch (error) {
      console.error('Error creating sale:', error);
      throw error;
    }
  }

  async updateSale(saleId: string, updates: SalesUpdateSaleBody): Promise<ApiEnvelope<unknown>> {
    try {
      const response = await this.throttler.throttle(async () => {
        // Note: patientId is required by the API but not passed to this method.
        // We might need to fetch it or change the method signature.
        // For now, using a placeholder or extracting from updates if available.
        const patientId = (updates as any).patientId || 'unknown';
        return await salesUpdateSale(patientId, saleId, updates);
      });
      const payload = (response as unknown) as { data?: unknown };
      return {
        data: payload?.data ?? null,
        success: true,
        message: 'Sale updated successfully'
      };
    } catch (error) {
      console.error('‚ùå Error updating sale:', error);
      return {
        data: null,
        success: false,
        message: 'Failed to update sale'
      };
    }
  }

  async getTimeline(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    try {
      const response = await timelineGetPatientTimeline(patientId);
      const res = response as unknown as { data?: { data?: unknown[]; meta?: PaginationInfo } };
      return {
        data: res.data?.data || [],
        success: true,
        meta: res.data?.meta
      };
    } catch (error) {
      console.error('Failed to fetch patient timeline:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch timeline'
      };
    }
  }

  async getSgk(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    try {
      const response = await this.throttler.throttle(async () => {
        return await sgkGetPatientSgkDocuments(patientId);
      });
      const res = response as unknown as { data?: { data?: unknown[] } };
      return {
        data: res.data?.data || [],
        success: true
      };
    } catch (error) {
      console.error('Failed to fetch patient SGK documents:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch SGK documents'
      };
    }
  }

  async getAppointments(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    try {
      const response = await this.throttler.throttle(async () => {
        return await appointmentsListAppointments();
      });

      // Filter appointments by patient ID on the client side since the API doesn't support filtering
      const allAppointments = (response as any).data?.data || [];
      const patientAppointments = allAppointments.filter((appointment: Record<string, unknown>) =>
        (appointment as Record<string, unknown>)['patientId'] === patientId || (appointment as Record<string, unknown>)['patient_id'] === patientId
      );

      return {
        data: patientAppointments,
        success: true
      };
    } catch (error) {
      console.error('Failed to fetch patient appointments:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch appointments'
      };
    }
  }

  async getHearingTests(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    void patientId;
    try {
      // Note: There's no direct hearing tests endpoint in the generated client
      // This would need to be implemented when the backend endpoint is available
      console.warn('Hearing tests endpoint not yet available in generated client');
      return {
        data: [],
        success: true,
        message: 'Hearing tests endpoint not yet implemented in backend'
      };
    } catch (error) {
      console.error('Failed to fetch patient hearing tests:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch hearing tests'
      };
    }
  }

  async getNotes(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    void patientId;
    try {
      // Note: There's no direct get notes endpoint in the generated client
      // Only create and delete are available
      console.warn('Get notes endpoint not yet available in generated client');
      return {
        data: [],
        success: true,
        message: 'Get notes endpoint not yet implemented in backend'
      };
    } catch (error) {
      console.error('Failed to fetch patient notes:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch notes'
      };
    }
  }

  async getDocuments(patientId: string): Promise<ApiEnvelope<unknown[]>> {
    void patientId;
    try {
      // Note: There's no direct get documents endpoint in the generated client
      console.warn('Get documents endpoint not yet available in generated client');
      return {
        data: [],
        success: true,
        message: 'Get documents endpoint not yet implemented in backend'
      };
    } catch (error) {
      console.error('Failed to fetch patient documents:', error);
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch documents'
      };
    }
  }

  async bulkUpload(formData: unknown): Promise<unknown> {
    void formData;
    return { data: [], success: false, message: 'Not implemented in simplified version' };
  }

  async search(searchParams: unknown): Promise<unknown> {
    void searchParams;
    return { data: [], success: true };
  }

  async exportCsv(_filters: unknown): Promise<unknown> {
    void _filters;
    return { data: [], success: true, message: 'Export not available in simplified version' };
  }

  async list(_filters: unknown): Promise<Patient[]> {
    void _filters;
    return this.fetchAllPatients();
  }

  async getPatients(_params?: unknown): Promise<Patient[]> {
    void _params;
    return this.fetchAllPatients();
  }

  async createNote(patientId: string, noteData: unknown): Promise<unknown> {
    try {
      const response = await this.throttler.throttle(async () => {
        return await patientSubresourcesCreatePatientNote(patientId, noteData as Record<string, unknown>);
      });
      return {
        data: response.data,
        success: true
      };
    } catch (error) {
      console.error('Failed to create patient note:', error);
      return {
        data: null,
        success: false,
        error: error instanceof Error ? error.message : 'Failed to create note'
      };
    }
  }

  async deleteNote(patientId: string, noteId: string): Promise<unknown> {
    try {
      const response = await this.throttler.throttle(async () => {
        return await patientSubresourcesDeletePatientNote(patientId, noteId);
      });
      return {
        data: response.data,
        success: true
      };
    } catch (error) {
      console.error('Failed to delete patient note:', error);
      return {
        data: null,
        success: false,
        error: error instanceof Error ? error.message : 'Failed to delete note'
      };
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}

export const patientApiService = new PatientApiService();