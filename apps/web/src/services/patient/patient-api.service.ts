// Patient API Service - Simplified Version
import { AxiosResponse } from 'axios';
import { 
  PatientsGetPatients200,
  PaginationInfo,
  Sale,
  SalesCreateSaleBody,
  SalesUpdateSaleBody
} from "../../api/generated/xEarCRMAPIAutoGenerated.schemas";
import { apiClient, Patient, CreatePatientRequest, UpdatePatientRequest } from '../../api/client';
import { getXEarCRMAPIAutoGenerated } from '../../api/generated/xEarCRMAPIAutoGenerated';

// Request deduplication and caching
interface CacheEntry {
  data: Patient[];
  timestamp: number;
  promise?: Promise<Patient[]>;
}

class RequestThrottler {
  private activeRequests = 0;
  private readonly maxConcurrentRequests = 3;
  private readonly requestQueue: Array<() => Promise<any>> = [];
  private readonly requestDelay = 100;

  async throttle<T>(requestFn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          this.activeRequests++;
          const result = await requestFn();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.activeRequests--;
          setTimeout(() => this.processQueue(), this.requestDelay);
        }
      });
      this.processQueue();
    });
  }

  private processQueue() {
    if (this.activeRequests < this.maxConcurrentRequests && this.requestQueue.length > 0) {
      const nextRequest = this.requestQueue.shift();
      if (nextRequest) {
        nextRequest();
      }
    }
  }

  getActiveRequestCount(): number {
    return this.activeRequests;
  }

  getQueueLength(): number {
    return this.requestQueue.length;
  }
}

export class PatientApiService {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private ongoingRequests: Map<string, Promise<Patient[]>> = new Map();
  private throttler = new RequestThrottler();

  /**
   * Fetch all patients with caching
   */
  async fetchAllPatients(): Promise<Patient[]> {
    const cacheKey = 'all_patients';
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      console.log('üìã Returning cached patients data');
      return cached.data;
    }

    if (this.ongoingRequests.has(cacheKey)) {
      console.log('‚è≥ Waiting for ongoing request...');
      return this.ongoingRequests.get(cacheKey)!;
    }

    const promise = this._fetchAllPatientsInternal();
    this.ongoingRequests.set(cacheKey, promise);

    try {
      const data = await promise;
      this.cache.set(cacheKey, { data, timestamp: Date.now() });
      return data;
    } finally {
      this.ongoingRequests.delete(cacheKey);
    }
  }

  /**
   * Fetch all patients (simplified implementation)
   */
  private async _fetchAllPatientsInternal(): Promise<Patient[]> {
    console.log('üîÑ Starting to fetch all patients...');
    
    try {
      const response = await apiClient.getPatients();
      
      if (response.data?.data?.patients) {
        console.log(`‚úÖ Successfully fetched ${response.data.data.patients.length} patients`);
        return response.data.data.patients;
      }
      
      console.warn('‚ö†Ô∏è No patients data in response:', response);
      return [];
    } catch (error) {
      console.error('‚ùå Error fetching patients:', error);
      throw error;
    }
  }

  /**
   * Get patient sales using generated API client with throttling
   */
  async getSales(patientId: string): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.salesGetPatientSales(patientId);
      });
      
      // The backend responses are often wrapped as { data: [...], meta: ..., success: true }
      // Unwrap if necessary so callers receive an array of sales directly.
      const payload = response?.data ?? response;
      const salesArray = Array.isArray(payload?.data) ? payload.data : (Array.isArray(payload) ? payload : []);

      return {
        data: salesArray,
        success: true,
        message: 'Sales data retrieved successfully'
      };
    } catch (error) {
      console.error('‚ùå Error fetching sales:', error);
      return {
        data: [],
        success: false,
        message: 'Failed to fetch sales data'
      };
    }
  }

  clearCache(): void {
    this.cache.clear();
    console.log('üóëÔ∏è Cache cleared');
  }

  invalidateCache(key: string = 'all_patients'): void {
    this.cache.delete(key);
    console.log(`üóëÔ∏è Cache invalidated for key: ${key}`);
  }

  async fetchPatient(id: string): Promise<Patient | null> {
    try {
      const response = await apiClient.getPatient(id);
      if (response.data?.patient) {
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error fetching patient ${id}:`, error);
      throw error;
    }
  }

  async createPatient(patientData: CreatePatientRequest): Promise<Patient> {
    try {
      const response = await apiClient.createPatient(patientData);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      throw new Error('Failed to create patient');
    } catch (error) {
      console.error('‚ùå Error creating patient:', error);
      throw error;
    }
  }

  async updatePatient(id: string, updates: UpdatePatientRequest): Promise<Patient | null> {
    try {
      const response = await apiClient.updatePatient(id, updates);
      if (response.data?.patient) {
        this.invalidateCache();
        return response.data.patient;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Error updating patient ${id}:`, error);
      throw error;
    }
  }

  async deletePatient(id: string): Promise<boolean> {
    try {
      const response = await apiClient.deletePatient(id);
      if (response.data?.success) {
        this.invalidateCache();
        return true;
      }
      return false;
    } catch (error) {
      console.error(`‚ùå Error deleting patient ${id}:`, error);
      throw error;
    }
  }

  async createSale(patientId: string, saleData: any): Promise<any> {
    try {
      // Extract product ID from the complex form data structure
      let productId = saleData.productId;
      
      // If productId is not directly available, extract from devices array
      if (!productId && saleData.devices && saleData.devices.length > 0) {
        productId = saleData.devices[0].inventoryId || saleData.devices[0].id;
      }

      if (!productId) {
        throw new Error('Product ID is required for sale creation');
      }

      // Use direct fetch call to the product-sales endpoint since it's not generated in the API client
      const transformedData = {
        product_id: productId,
        discount: saleData.discount || 0,
        payment_type: saleData.paymentMethod || 'cash',
        notes: saleData.notes || ''
      };

      const response = await fetch(`http://localhost:8084/api/patients/${patientId}/product-sales`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Idempotency-Key': `sale-${patientId}-${productId}-${Date.now()}`
        },
        body: JSON.stringify(transformedData)
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('API Error Response:', errorText);
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }

      const result = await response.json();
      return { data: result };
    } catch (error) {
      console.error('Error creating sale:', error);
      throw error;
    }
  }

  async updateSale(saleId: string, updates: any): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.salesUpdateSale(saleId, updates);
      });
      
      return {
        data: response.data,
        success: true,
        message: 'Sale updated successfully'
      };
    } catch (error) {
      console.error('‚ùå Error updating sale:', error);
      return {
        data: null,
        success: false,
        message: 'Failed to update sale'
      };
    }
  }

  async getTimeline(patientId: string): Promise<any> {
    try {
      const api = getXEarCRMAPIAutoGenerated();
      const response = await api.timelineGetPatientTimeline(patientId);
      return { 
        data: response.data?.data || [], 
        success: true, 
        meta: response.data?.meta 
      };
    } catch (error) {
      console.error('Failed to fetch patient timeline:', error);
      return { 
        data: [], 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch timeline' 
      };
    }
  }

  async getSgk(patientId: string): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.sgkGetPatientSgkDocuments(patientId);
      });
      return { 
        data: (response as any)?.data || [], 
        success: true 
      };
    } catch (error) {
      console.error('Failed to fetch patient SGK documents:', error);
      return { 
        data: [], 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch SGK documents' 
      };
    }
  }

  async getAppointments(patientId: string): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.appointmentsListAppointments();
      });
      
      // Filter appointments by patient ID on the client side since the API doesn't support filtering
      const allAppointments = response.data?.data || [];
      const patientAppointments = allAppointments.filter((appointment: any) => 
        appointment.patientId === patientId || appointment.patient_id === patientId
      );
      
      return { 
        data: patientAppointments, 
        success: true 
      };
    } catch (error) {
      console.error('Failed to fetch patient appointments:', error);
      return { 
        data: [], 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch appointments' 
      };
    }
  }

  async getHearingTests(patientId: string): Promise<any> {
    try {
      // Note: There's no direct hearing tests endpoint in the generated client
      // This would need to be implemented when the backend endpoint is available
      console.warn('Hearing tests endpoint not yet available in generated client');
      return { 
        data: [], 
        success: true, 
        message: 'Hearing tests endpoint not yet implemented in backend' 
      };
    } catch (error) {
      console.error('Failed to fetch patient hearing tests:', error);
      return { 
        data: [], 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch hearing tests' 
      };
    }
  }

  async getNotes(patientId: string): Promise<any> {
    try {
      // Note: There's no direct get notes endpoint in the generated client
      // Only create and delete are available
      console.warn('Get notes endpoint not yet available in generated client');
      return { 
        data: [], 
        success: true, 
        message: 'Get notes endpoint not yet implemented in backend' 
      };
    } catch (error) {
      console.error('Failed to fetch patient notes:', error);
      return { 
        data: [], 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch notes' 
      };
    }
  }

  async bulkUpload(formData: any): Promise<any> {
    return { data: [], success: true, message: 'Bulk upload not available in simplified version' };
  }

  async search(searchParams: any): Promise<any> {
    return { data: [], success: true, message: 'Search not available in simplified version' };
  }

  async exportCsv(filters: any): Promise<any> {
    return { data: [], success: true, message: 'Export not available in simplified version' };
  }

  async list(filters: any): Promise<any> {
    return this.fetchAllPatients();
  }

  async getPatients(params?: any): Promise<any> {
    return this.fetchAllPatients();
  }

  async createNote(patientId: string, noteData: any): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.patientSubresourcesCreatePatientNote(patientId, noteData);
      });
      return { 
        data: response.data, 
        success: true 
      };
    } catch (error) {
      console.error('Failed to create patient note:', error);
      return { 
        data: null, 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to create note' 
      };
    }
  }

  async deleteNote(patientId: string, noteId: string): Promise<any> {
    try {
      const response = await this.throttler.throttle(async () => {
        const api = getXEarCRMAPIAutoGenerated();
        return await api.patientSubresourcesDeletePatientNote(patientId, noteId);
      });
      return { 
        data: response.data, 
        success: true 
      };
    } catch (error) {
      console.error('Failed to delete patient note:', error);
      return { 
        data: null, 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to delete note' 
      };
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}

export const patientApiService = new PatientApiService();