import { inventoryGetInventoryItem } from '../api/generated/xEarCRMAPIAutoGenerated';
import type {
  DeviceReplacementRequest,
  DeviceReplacementResponse,
  DeviceInfo,
  DeviceReplacementHistory
} from '../types/device-replacement';

export class DeviceReplacementService {
  private readonly STORAGE_KEY = 'xear_device_replacements';

  /**
   * Create a new device replacement record
   */
  async createReplacement(request: DeviceReplacementRequest): Promise<DeviceReplacementResponse> {
    try {
      // Generate replacement ID
      const replacementId = `REPL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Create replacement history record
      const replacement: DeviceReplacementHistory = {
        id: replacementId,
        patientId: request.patientId,
        oldDeviceId: request.oldDeviceId,
        newDeviceId: request.newInventoryId || `NEW-${Date.now()}`,
        oldDeviceInfo: await this.getDeviceInfo(request.oldDeviceId),
        newDeviceInfo: request.newDeviceInfo as DeviceInfo || await this.getInventoryDeviceInfo(request.newInventoryId!),
        replacementReason: request.replacementReason,
        replacementDate: new Date().toISOString(),
        replacedBy: 'current_user', // TODO: Get from auth context
        status: 'pending',
        notes: request.notes,
        returnInvoiceId: request.createReturnInvoice ? `INV-${Date.now()}` : undefined,
        returnInvoiceStatus: request.createReturnInvoice ? 'pending' : undefined,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Try to save to backend first
      try {
        // API endpoint not implemented yet
        console.log('Mock API call for create replacement:', replacement);
      } catch (apiError) {
        console.warn('Backend API unavailable, using local storage fallback:', apiError);
      }

      // Save to local storage as backup/fallback
      await this.saveToLocalStorage(replacement);

      // If return invoice is requested, create it
      if (request.createReturnInvoice) {
        await this.createReturnInvoice(replacement, request.invoiceType || 'individual');
      }

      return {
        success: true,
        data: replacement,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error creating device replacement:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Get replacement history for a patient
   */
  async getPatientReplacements(patientId: string): Promise<DeviceReplacementHistory[]> {
    try {
      // Try to fetch from backend first (use real API when available)
      try {
        // API endpoint not implemented yet
        // const res = await fetch(`http://localhost:5003/api/patients/${patientId}/replacements`);
        // if (res.ok) {
        //   const j = await res.json();
        //   const items = (j.data || []).map((d: any) => this.normalizeReplacementData(d));
        //   return items;
        // }
        // console.warn('Backend replacements fetch returned non-ok status, falling back to localStorage', res.status);
      } catch (apiError) {
        console.warn('Backend API unavailable for replacements, using local storage fallback:', apiError);
      }

      // Fallback to local storage if backend not available
      return this.getFromLocalStorage().filter(r => r.patientId === patientId);
    } catch (error) {
      console.error('Error fetching patient replacements:', error);
      return [];
    }
  }

  /**
   * Get all replacement history
   */
  async getAllReplacements(): Promise<DeviceReplacementHistory[]> {
    try {
      // Try to fetch from backend first
      try {
        // Note: API endpoint may not exist yet, using mock
        const mockResponse = { success: false };
        console.log('Mock API call for all replacements:', mockResponse);
      } catch (apiError) {
        console.warn('Backend API unavailable, using local storage:', apiError);
      }

      // Fallback to local storage
      return this.getFromLocalStorage();
    } catch (error) {
      console.error('Error fetching all replacements:', error);
      return [];
    }
  }

  /**
   * Update replacement status
   */
  async updateReplacementStatus(
    replacementId: string,
    status: DeviceReplacementHistory['status'],
    notes?: string
  ): Promise<DeviceReplacementResponse> {
    try {
      // Update in backend
      try {
        // Note: API endpoint may not exist yet, using mock
        console.log('Mock API call for update replacement:', { replacementId, status, notes });
      } catch (apiError) {
        console.warn('Backend API unavailable, updating local storage:', apiError);
      }

      // Update in local storage
      const replacements = this.getFromLocalStorage();
      const index = replacements.findIndex(r => r.id === replacementId);

      if (index !== -1) {
        replacements[index].status = status;
        replacements[index].updatedAt = new Date().toISOString();
        if (notes) {
          replacements[index].notes = notes;
        }

        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(replacements));

        return {
          success: true,
          data: replacements[index],
          timestamp: new Date().toISOString()
        };
      }

      throw new Error('Replacement not found');
    } catch (error) {
      console.error('Error updating replacement status:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Create return invoice for replacement
   */
  private async createReturnInvoice(
    replacement: DeviceReplacementHistory,
    invoiceType: 'individual' | 'corporate' | 'e_archive'
  ): Promise<void> {
    try {
      // Simulate return invoice creation
      const returnInvoice = {
        id: `RET-INV-${Date.now()}`,
        replacementId: replacement.id,
        patientId: replacement.patientId,
        deviceInfo: replacement.oldDeviceInfo,
        amount: replacement.oldDeviceInfo.price,
        invoiceType,
        status: 'created',
        createdAt: new Date().toISOString()
      };

      // Update replacement with invoice information
      replacement.returnInvoiceId = returnInvoice.id;
      replacement.returnInvoiceStatus = 'created';

      console.log('Return invoice created:', returnInvoice);
    } catch (error) {
      console.error('Error creating return invoice:', error);
      replacement.returnInvoiceStatus = 'pending';
    }
  }

  /**
   * Get device information
   */
  private async getDeviceInfo(deviceId: string): Promise<DeviceInfo> {
    try {
      // Try to get from API - using mock for now since exact API structure is unclear
      console.log('Mock device info fetch for:', deviceId);
    } catch (error) {
      console.warn('Could not fetch device info from API:', error);
    }

    // Fallback to mock data
    return {
      brand: 'Unknown',
      model: 'Unknown',
      serialNumber: deviceId,
      deviceType: 'hearing_aid',
      price: 0
    };
  }

  /**
   * Get device information from inventory
   */
  private async getInventoryDeviceInfo(inventoryId: string): Promise<DeviceInfo> {
    try {
      // Try to get from API
      const response = await inventoryGetInventoryItem(inventoryId);
      if (response.data?.data) {
        const item = response.data.data;
        return {
          brand: item.brand || '',
          model: item.model || '',
          serialNumber: item.availableSerials?.[0] || '',
          deviceType: item.category || '',
          price: item.price || 0
        };
      }
    } catch (error) {
      console.warn('Could not fetch inventory info from API:', error);
    }

    // Fallback to mock data
    return {
      brand: 'Unknown',
      model: 'Unknown',
      serialNumber: '',
      deviceType: 'Unknown',
      price: 0
    };
  }

  /**
   * Save replacement to local storage
   */
  private async saveToLocalStorage(replacement: DeviceReplacementHistory): Promise<void> {
    const replacements = this.getFromLocalStorage();
    const existingIndex = replacements.findIndex(r => r.id === replacement.id);

    if (existingIndex !== -1) {
      replacements[existingIndex] = replacement;
    } else {
      replacements.push(replacement);
    }

    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(replacements));
  }

  /**
   * Get replacements from local storage
   */
  private getFromLocalStorage(): DeviceReplacementHistory[] {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Error reading from local storage:', error);
      return [];
    }
  }

  /**
   * Normalize replacement data from API
   */
  private normalizeReplacementData(data: any): DeviceReplacementHistory {
    return {
      id: data.id,
      patientId: data.patient_id || data.patientId,
      oldDeviceId: data.old_device_id || data.oldDeviceId,
      newDeviceId: data.new_device_id || data.newDeviceId,
      oldDeviceInfo: typeof data.old_device_info === 'string'
        ? JSON.parse(data.old_device_info)
        : data.old_device_info || data.oldDeviceInfo,
      newDeviceInfo: typeof data.new_device_info === 'string'
        ? JSON.parse(data.new_device_info)
        : data.new_device_info || data.newDeviceInfo,
      replacementReason: data.replacement_reason || data.replacementReason || 'other',
      replacementDate: data.replacement_date || data.replacementDate || new Date().toISOString(),
      status: data.status || 'pending',
      priceDifference: data.price_difference || data.priceDifference || 0,
      notes: data.notes,
      replacedBy: data.replaced_by || data.replacedBy || 'unknown',
      createdAt: data.created_at || data.createdAt || new Date().toISOString(),
      updatedAt: data.updated_at || data.updatedAt || new Date().toISOString(),
      returnInvoiceId: data.return_invoice?.id || data.returnInvoiceId,
      returnInvoiceStatus: data.return_invoice?.status || data.returnInvoiceStatus || 'pending'
    };
  }
}

export const deviceReplacementService = new DeviceReplacementService();