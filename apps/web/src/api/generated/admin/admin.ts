/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdminLoginRequest,
  CreateAdminUserRequest,
  CreateTicketRequest,
  GetAdminAllTenantUsersParams,
  GetAdminTicketsParams,
  GetAdminUsersParams,
  HTTPValidationError,
  RoutersAdminUpdateTenantUserRequest,
  SwitchRoleRequest,
  SwitchTenantRequest,
  TicketResponseRequest,
  UpdateTicketRequest
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Admin login endpoint
 * @summary Admin Login
 */
export const adminLogin = (
    adminLoginRequest: AdminLoginRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminLoginRequest, signal
    },
      );
    }
  


export const getAdminLoginMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginRequest}, TContext> => {

const mutationKey = ['adminLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLogin>>, {data: AdminLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  adminLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminLoginMutationResult = NonNullable<Awaited<ReturnType<typeof adminLogin>>>
    export type AdminLoginMutationBody = AdminLoginRequest
    export type AdminLoginMutationError = HTTPValidationError

    /**
 * @summary Admin Login
 */
export const useAdminLogin = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminLogin>>,
        TError,
        {data: AdminLoginRequest},
        TContext
      > => {

      const mutationOptions = getAdminLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create admin user or tenant user
 * @summary Create Admin User
 */
export const createAdminUser = (
    createAdminUserRequest: CreateAdminUserRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAdminUserRequest, signal
    },
      );
    }
  


export const getCreateAdminUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: CreateAdminUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: CreateAdminUserRequest}, TContext> => {

const mutationKey = ['createAdminUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminUser>>, {data: CreateAdminUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminUserMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminUser>>>
    export type CreateAdminUserMutationBody = CreateAdminUserRequest
    export type CreateAdminUserMutationError = HTTPValidationError

    /**
 * @summary Create Admin User
 */
export const useCreateAdminUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: CreateAdminUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminUser>>,
        TError,
        {data: CreateAdminUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get list of admin users
 * @summary Get Admin Users
 */
export const getAdminUsers = (
    params?: GetAdminUsersParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/users`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminUsersQueryKey = (params?: GetAdminUsersParams,) => {
    return [
    `/api/admin/users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = HTTPValidationError>(params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminUsers>>> = ({ signal }) => getAdminUsers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminUsers>>>
export type GetAdminUsersQueryError = HTTPValidationError


export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = HTTPValidationError>(
 params: undefined |  GetAdminUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = HTTPValidationError>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = HTTPValidationError>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Admin Users
 */

export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = HTTPValidationError>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of ALL users from ALL tenants
 * @summary Get All Tenant Users
 */
export const getAdminAllTenantUsers = (
    params?: GetAdminAllTenantUsersParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/users/all`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminAllTenantUsersQueryKey = (params?: GetAdminAllTenantUsersParams,) => {
    return [
    `/api/admin/users/all`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminAllTenantUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError = HTTPValidationError>(params?: GetAdminAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAllTenantUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAllTenantUsers>>> = ({ signal }) => getAdminAllTenantUsers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAllTenantUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAllTenantUsers>>>
export type GetAdminAllTenantUsersQueryError = HTTPValidationError


export function useGetAdminAllTenantUsers<TData = Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError = HTTPValidationError>(
 params: undefined |  GetAdminAllTenantUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminAllTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAllTenantUsers<TData = Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError = HTTPValidationError>(
 params?: GetAdminAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminAllTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAllTenantUsers<TData = Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError = HTTPValidationError>(
 params?: GetAdminAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get All Tenant Users
 */

export function useGetAdminAllTenantUsers<TData = Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError = HTTPValidationError>(
 params?: GetAdminAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAllTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAllTenantUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update any tenant user (Admin Panel)
 * @summary Update Any Tenant User
 */
export const updateAdminAnyTenantUser = (
    userId: string,
    routersAdminUpdateTenantUserRequest: RoutersAdminUpdateTenantUserRequest,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/users/all/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: routersAdminUpdateTenantUserRequest
    },
      );
    }
  


export const getUpdateAdminAnyTenantUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminAnyTenantUser>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminAnyTenantUser>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext> => {

const mutationKey = ['updateAdminAnyTenantUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminAnyTenantUser>>, {userId: string;data: RoutersAdminUpdateTenantUserRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateAdminAnyTenantUser(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminAnyTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminAnyTenantUser>>>
    export type UpdateAdminAnyTenantUserMutationBody = RoutersAdminUpdateTenantUserRequest
    export type UpdateAdminAnyTenantUserMutationError = HTTPValidationError

    /**
 * @summary Update Any Tenant User
 */
export const useUpdateAdminAnyTenantUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminAnyTenantUser>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminAnyTenantUser>>,
        TError,
        {userId: string;data: RoutersAdminUpdateTenantUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAdminAnyTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get support tickets
 * @summary Get Admin Tickets
 */
export const getAdminTickets = (
    params?: GetAdminTicketsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/tickets`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminTicketsQueryKey = (params?: GetAdminTicketsParams,) => {
    return [
    `/api/admin/tickets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminTicketsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = HTTPValidationError>(params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminTicketsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminTickets>>> = ({ signal }) => getAdminTickets(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminTicketsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminTickets>>>
export type GetAdminTicketsQueryError = HTTPValidationError


export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = HTTPValidationError>(
 params: undefined |  GetAdminTicketsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof getAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = HTTPValidationError>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof getAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = HTTPValidationError>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Admin Tickets
 */

export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = HTTPValidationError>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminTicketsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create support ticket
 * @summary Create Admin Ticket
 */
export const createAdminTicket = (
    createTicketRequest: CreateTicketRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/tickets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTicketRequest, signal
    },
      );
    }
  


export const getCreateAdminTicketMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateTicketRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateTicketRequest}, TContext> => {

const mutationKey = ['createAdminTicket'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminTicket>>, {data: CreateTicketRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminTicket(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminTicket>>>
    export type CreateAdminTicketMutationBody = CreateTicketRequest
    export type CreateAdminTicketMutationError = HTTPValidationError

    /**
 * @summary Create Admin Ticket
 */
export const useCreateAdminTicket = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateTicketRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminTicket>>,
        TError,
        {data: CreateTicketRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update support ticket
 * @summary Update Admin Ticket
 */
export const updateAdminTicket = (
    ticketId: string,
    updateTicketRequest: UpdateTicketRequest,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/tickets/${ticketId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateTicketRequest
    },
      );
    }
  


export const getUpdateAdminTicketMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext> => {

const mutationKey = ['updateAdminTicket'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminTicket>>, {ticketId: string;data: UpdateTicketRequest}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  updateAdminTicket(ticketId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminTicket>>>
    export type UpdateAdminTicketMutationBody = UpdateTicketRequest
    export type UpdateAdminTicketMutationError = HTTPValidationError

    /**
 * @summary Update Admin Ticket
 */
export const useUpdateAdminTicket = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminTicket>>,
        TError,
        {ticketId: string;data: UpdateTicketRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create response for support ticket
 * @summary Create Ticket Response
 */
export const createAdminTicketResponse = (
    ticketId: string,
    ticketResponseRequest: TicketResponseRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/tickets/${ticketId}/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ticketResponseRequest, signal
    },
      );
    }
  


export const getCreateAdminTicketResponseMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponse>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponse>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext> => {

const mutationKey = ['createAdminTicketResponse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminTicketResponse>>, {ticketId: string;data: TicketResponseRequest}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  createAdminTicketResponse(ticketId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminTicketResponseMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminTicketResponse>>>
    export type CreateAdminTicketResponseMutationBody = TicketResponseRequest
    export type CreateAdminTicketResponseMutationError = HTTPValidationError

    /**
 * @summary Create Ticket Response
 */
export const useCreateAdminTicketResponse = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponse>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminTicketResponse>>,
        TError,
        {ticketId: string;data: TicketResponseRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminTicketResponseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Switch to a different role for debugging
 * @summary Debug Switch Role
 */
export const debugSwitchRole = (
    switchRoleRequest: SwitchRoleRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/debug/switch-role`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: switchRoleRequest, signal
    },
      );
    }
  


export const getDebugSwitchRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof debugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext> => {

const mutationKey = ['debugSwitchRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof debugSwitchRole>>, {data: SwitchRoleRequest}> = (props) => {
          const {data} = props ?? {};

          return  debugSwitchRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DebugSwitchRoleMutationResult = NonNullable<Awaited<ReturnType<typeof debugSwitchRole>>>
    export type DebugSwitchRoleMutationBody = SwitchRoleRequest
    export type DebugSwitchRoleMutationError = HTTPValidationError

    /**
 * @summary Debug Switch Role
 */
export const useDebugSwitchRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof debugSwitchRole>>,
        TError,
        {data: SwitchRoleRequest},
        TContext
      > => {

      const mutationOptions = getDebugSwitchRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all available roles for debugging
 * @summary Debug Available Roles
 */
export const debugAvailableRoles = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/debug/available-roles`, method: 'GET', signal
    },
      );
    }
  



export const getDebugAvailableRolesQueryKey = () => {
    return [
    `/api/admin/debug/available-roles`
    ] as const;
    }

    
export const getDebugAvailableRolesQueryOptions = <TData = Awaited<ReturnType<typeof debugAvailableRoles>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDebugAvailableRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof debugAvailableRoles>>> = ({ signal }) => debugAvailableRoles(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DebugAvailableRolesQueryResult = NonNullable<Awaited<ReturnType<typeof debugAvailableRoles>>>
export type DebugAvailableRolesQueryError = unknown


export function useDebugAvailableRoles<TData = Awaited<ReturnType<typeof debugAvailableRoles>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof debugAvailableRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDebugAvailableRoles<TData = Awaited<ReturnType<typeof debugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof debugAvailableRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDebugAvailableRoles<TData = Awaited<ReturnType<typeof debugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Debug Available Roles
 */

export function useDebugAvailableRoles<TData = Awaited<ReturnType<typeof debugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugAvailableRoles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDebugAvailableRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Switch to a different tenant context for debugging
 * @summary Debug Switch Tenant
 */
export const debugSwitchTenant = (
    switchTenantRequest: SwitchTenantRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/debug/switch-tenant`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: switchTenantRequest, signal
    },
      );
    }
  


export const getDebugSwitchTenantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof debugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext> => {

const mutationKey = ['debugSwitchTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof debugSwitchTenant>>, {data: SwitchTenantRequest}> = (props) => {
          const {data} = props ?? {};

          return  debugSwitchTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DebugSwitchTenantMutationResult = NonNullable<Awaited<ReturnType<typeof debugSwitchTenant>>>
    export type DebugSwitchTenantMutationBody = SwitchTenantRequest
    export type DebugSwitchTenantMutationError = HTTPValidationError

    /**
 * @summary Debug Switch Tenant
 */
export const useDebugSwitchTenant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof debugSwitchTenant>>,
        TError,
        {data: SwitchTenantRequest},
        TContext
      > => {

      const mutationOptions = getDebugSwitchTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Exit tenant/role impersonation
 * @summary Debug Exit Impersonation
 */
export const debugExitImpersonation = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/debug/exit-impersonation`, method: 'POST', signal
    },
      );
    }
  


export const getDebugExitImpersonationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugExitImpersonation>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof debugExitImpersonation>>, TError,void, TContext> => {

const mutationKey = ['debugExitImpersonation'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof debugExitImpersonation>>, void> = () => {
          

          return  debugExitImpersonation()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DebugExitImpersonationMutationResult = NonNullable<Awaited<ReturnType<typeof debugExitImpersonation>>>
    
    export type DebugExitImpersonationMutationError = unknown

    /**
 * @summary Debug Exit Impersonation
 */
export const useDebugExitImpersonation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugExitImpersonation>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof debugExitImpersonation>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDebugExitImpersonationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get permissions required for a specific page
 * @summary Debug Page Permissions
 */
export const debugPagePermissions = (
    pageKey: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/admin/debug/page-permissions/${pageKey}`, method: 'GET', signal
    },
      );
    }
  



export const getDebugPagePermissionsQueryKey = (pageKey?: string,) => {
    return [
    `/api/admin/debug/page-permissions/${pageKey}`
    ] as const;
    }

    
export const getDebugPagePermissionsQueryOptions = <TData = Awaited<ReturnType<typeof debugPagePermissions>>, TError = HTTPValidationError>(pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDebugPagePermissionsQueryKey(pageKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof debugPagePermissions>>> = ({ signal }) => debugPagePermissions(pageKey, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(pageKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DebugPagePermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof debugPagePermissions>>>
export type DebugPagePermissionsQueryError = HTTPValidationError


export function useDebugPagePermissions<TData = Awaited<ReturnType<typeof debugPagePermissions>>, TError = HTTPValidationError>(
 pageKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugPagePermissions>>,
          TError,
          Awaited<ReturnType<typeof debugPagePermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDebugPagePermissions<TData = Awaited<ReturnType<typeof debugPagePermissions>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugPagePermissions>>,
          TError,
          Awaited<ReturnType<typeof debugPagePermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDebugPagePermissions<TData = Awaited<ReturnType<typeof debugPagePermissions>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Debug Page Permissions
 */

export function useDebugPagePermissions<TData = Awaited<ReturnType<typeof debugPagePermissions>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugPagePermissions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDebugPagePermissionsQueryOptions(pageKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




