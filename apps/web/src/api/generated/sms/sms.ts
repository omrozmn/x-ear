/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  SmsIntegrationCreateTargetAudienceBody,
  SmsIntegrationRequestSmsHeaderBody,
  SmsIntegrationSetDefaultHeaderBody,
  SmsIntegrationSubmitSmsDocumentsBody,
  SmsIntegrationUpdateSmsConfigBody,
  SmsIntegrationUploadAudienceExcelBody,
  SmsIntegrationUploadSmsDocumentBody
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * @summary List target audiences for tenant.
 */
export const smsIntegrationGetTargetAudiences = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/audiences`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationGetTargetAudiencesQueryKey = () => {
    return [
    `/api/sms/audiences`
    ] as const;
    }

    
export const getSmsIntegrationGetTargetAudiencesQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationGetTargetAudiencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>> = ({ signal }) => smsIntegrationGetTargetAudiences(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationGetTargetAudiencesQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>>
export type SmsIntegrationGetTargetAudiencesQueryError = unknown


export function useSmsIntegrationGetTargetAudiences<TData = Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetTargetAudiences<TData = Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetTargetAudiences<TData = Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List target audiences for tenant.
 */

export function useSmsIntegrationGetTargetAudiences<TData = Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetTargetAudiences>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationGetTargetAudiencesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create a new target audience.
 */
export const smsIntegrationCreateTargetAudience = (
    smsIntegrationCreateTargetAudienceBody?: SmsIntegrationCreateTargetAudienceBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/audiences`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationCreateTargetAudienceBody, signal
    },
      );
    }
  


export const getSmsIntegrationCreateTargetAudienceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>, TError,{data: SmsIntegrationCreateTargetAudienceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>, TError,{data: SmsIntegrationCreateTargetAudienceBody}, TContext> => {

const mutationKey = ['smsIntegrationCreateTargetAudience'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>, {data: SmsIntegrationCreateTargetAudienceBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationCreateTargetAudience(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationCreateTargetAudienceMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>>
    export type SmsIntegrationCreateTargetAudienceMutationBody = SmsIntegrationCreateTargetAudienceBody
    export type SmsIntegrationCreateTargetAudienceMutationError = unknown

    /**
 * @summary Create a new target audience.
 */
export const useSmsIntegrationCreateTargetAudience = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>, TError,{data: SmsIntegrationCreateTargetAudienceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
        TError,
        {data: SmsIntegrationCreateTargetAudienceBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationCreateTargetAudienceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Upload Excel file for audience.
 */
export const smsIntegrationUploadAudienceExcel = (
    smsIntegrationUploadAudienceExcelBody?: SmsIntegrationUploadAudienceExcelBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/audiences/upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationUploadAudienceExcelBody, signal
    },
      );
    }
  


export const getSmsIntegrationUploadAudienceExcelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>, TError,{data: SmsIntegrationUploadAudienceExcelBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>, TError,{data: SmsIntegrationUploadAudienceExcelBody}, TContext> => {

const mutationKey = ['smsIntegrationUploadAudienceExcel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>, {data: SmsIntegrationUploadAudienceExcelBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationUploadAudienceExcel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationUploadAudienceExcelMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>>
    export type SmsIntegrationUploadAudienceExcelMutationBody = SmsIntegrationUploadAudienceExcelBody
    export type SmsIntegrationUploadAudienceExcelMutationError = unknown

    /**
 * @summary Upload Excel file for audience.
 */
export const useSmsIntegrationUploadAudienceExcel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>, TError,{data: SmsIntegrationUploadAudienceExcelBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
        TError,
        {data: SmsIntegrationUploadAudienceExcelBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationUploadAudienceExcelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get SMS configuration for tenant.
 */
export const smsIntegrationGetSmsConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/config`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationGetSmsConfigQueryKey = () => {
    return [
    `/api/sms/config`
    ] as const;
    }

    
export const getSmsIntegrationGetSmsConfigQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationGetSmsConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>> = ({ signal }) => smsIntegrationGetSmsConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationGetSmsConfigQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>>
export type SmsIntegrationGetSmsConfigQueryError = unknown


export function useSmsIntegrationGetSmsConfig<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsConfig<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsConfig<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS configuration for tenant.
 */

export function useSmsIntegrationGetSmsConfig<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationGetSmsConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update SMS configuration for tenant.
 */
export const smsIntegrationUpdateSmsConfig = (
    smsIntegrationUpdateSmsConfigBody?: SmsIntegrationUpdateSmsConfigBody,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationUpdateSmsConfigBody
    },
      );
    }
  


export const getSmsIntegrationUpdateSmsConfigMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>, TError,{data: SmsIntegrationUpdateSmsConfigBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>, TError,{data: SmsIntegrationUpdateSmsConfigBody}, TContext> => {

const mutationKey = ['smsIntegrationUpdateSmsConfig'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>, {data: SmsIntegrationUpdateSmsConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationUpdateSmsConfig(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationUpdateSmsConfigMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>>
    export type SmsIntegrationUpdateSmsConfigMutationBody = SmsIntegrationUpdateSmsConfigBody
    export type SmsIntegrationUpdateSmsConfigMutationError = unknown

    /**
 * @summary Update SMS configuration for tenant.
 */
export const useSmsIntegrationUpdateSmsConfig = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>, TError,{data: SmsIntegrationUpdateSmsConfigBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
        TError,
        {data: SmsIntegrationUpdateSmsConfigBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationUpdateSmsConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get SMS credit balance for tenant.
 */
export const smsIntegrationGetSmsCredit = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/credit`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationGetSmsCreditQueryKey = () => {
    return [
    `/api/sms/credit`
    ] as const;
    }

    
export const getSmsIntegrationGetSmsCreditQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationGetSmsCreditQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>> = ({ signal }) => smsIntegrationGetSmsCredit(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationGetSmsCreditQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>>
export type SmsIntegrationGetSmsCreditQueryError = unknown


export function useSmsIntegrationGetSmsCredit<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsCredit<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsCredit<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS credit balance for tenant.
 */

export function useSmsIntegrationGetSmsCredit<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationGetSmsCreditQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete an uploaded document.
 */
export const smsIntegrationDeleteSmsDocument = (
    documentType: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/documents/${documentType}`, method: 'DELETE'
    },
      );
    }
  


export const getSmsIntegrationDeleteSmsDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsIntegrationDeleteSmsDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsIntegrationDeleteSmsDocument(documentType,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationDeleteSmsDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>>
    
    export type SmsIntegrationDeleteSmsDocumentMutationError = unknown

    /**
 * @summary Delete an uploaded document.
 */
export const useSmsIntegrationDeleteSmsDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationDeleteSmsDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get document URL for preview/download.
 */
export const smsIntegrationDownloadSmsDocument = (
    documentType: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/documents/${documentType}/download`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationDownloadSmsDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsIntegrationDownloadSmsDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = unknown>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationDownloadSmsDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>> = ({ signal }) => smsIntegrationDownloadSmsDocument(documentType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationDownloadSmsDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>>
export type SmsIntegrationDownloadSmsDocumentQueryError = unknown


export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = unknown>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get document URL for preview/download.
 */

export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationDownloadSmsDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Serve document file for preview.
 */
export const smsIntegrationServeSmsDocument = (
    filepath: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/documents/file/${filepath}`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationServeSmsDocumentQueryKey = (filepath?: string,) => {
    return [
    `/api/sms/documents/file/${filepath}`
    ] as const;
    }

    
export const getSmsIntegrationServeSmsDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError = unknown>(filepath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationServeSmsDocumentQueryKey(filepath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>> = ({ signal }) => smsIntegrationServeSmsDocument(filepath, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(filepath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationServeSmsDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>>
export type SmsIntegrationServeSmsDocumentQueryError = unknown


export function useSmsIntegrationServeSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError = unknown>(
 filepath: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationServeSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError = unknown>(
 filepath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationServeSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError = unknown>(
 filepath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve document file for preview.
 */

export function useSmsIntegrationServeSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError = unknown>(
 filepath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationServeSmsDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationServeSmsDocumentQueryOptions(filepath,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Submit all documents for review.
 */
export const smsIntegrationSubmitSmsDocuments = (
    smsIntegrationSubmitSmsDocumentsBody?: SmsIntegrationSubmitSmsDocumentsBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/documents/submit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationSubmitSmsDocumentsBody, signal
    },
      );
    }
  


export const getSmsIntegrationSubmitSmsDocumentsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>, TError,{data: SmsIntegrationSubmitSmsDocumentsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>, TError,{data: SmsIntegrationSubmitSmsDocumentsBody}, TContext> => {

const mutationKey = ['smsIntegrationSubmitSmsDocuments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>, {data: SmsIntegrationSubmitSmsDocumentsBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationSubmitSmsDocuments(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationSubmitSmsDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>>
    export type SmsIntegrationSubmitSmsDocumentsMutationBody = SmsIntegrationSubmitSmsDocumentsBody
    export type SmsIntegrationSubmitSmsDocumentsMutationError = unknown

    /**
 * @summary Submit all documents for review.
 */
export const useSmsIntegrationSubmitSmsDocuments = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>, TError,{data: SmsIntegrationSubmitSmsDocumentsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationSubmitSmsDocuments>>,
        TError,
        {data: SmsIntegrationSubmitSmsDocumentsBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationSubmitSmsDocumentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Upload SMS document to local storage.
 */
export const smsIntegrationUploadSmsDocument = (
    smsIntegrationUploadSmsDocumentBody?: SmsIntegrationUploadSmsDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/documents/upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationUploadSmsDocumentBody, signal
    },
      );
    }
  


export const getSmsIntegrationUploadSmsDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>, TError,{data: SmsIntegrationUploadSmsDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>, TError,{data: SmsIntegrationUploadSmsDocumentBody}, TContext> => {

const mutationKey = ['smsIntegrationUploadSmsDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>, {data: SmsIntegrationUploadSmsDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationUploadSmsDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationUploadSmsDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>>
    export type SmsIntegrationUploadSmsDocumentMutationBody = SmsIntegrationUploadSmsDocumentBody
    export type SmsIntegrationUploadSmsDocumentMutationError = unknown

    /**
 * @summary Upload SMS document to local storage.
 */
export const useSmsIntegrationUploadSmsDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>, TError,{data: SmsIntegrationUploadSmsDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
        TError,
        {data: SmsIntegrationUploadSmsDocumentBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationUploadSmsDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary List SMS headers for tenant.
 */
export const smsIntegrationGetSmsHeaders = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/headers`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationGetSmsHeadersQueryKey = () => {
    return [
    `/api/sms/headers`
    ] as const;
    }

    
export const getSmsIntegrationGetSmsHeadersQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationGetSmsHeadersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>> = ({ signal }) => smsIntegrationGetSmsHeaders(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationGetSmsHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>>
export type SmsIntegrationGetSmsHeadersQueryError = unknown


export function useSmsIntegrationGetSmsHeaders<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsHeaders<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsHeaders<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List SMS headers for tenant.
 */

export function useSmsIntegrationGetSmsHeaders<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationGetSmsHeadersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Request a new SMS header for tenant.
 */
export const smsIntegrationRequestSmsHeader = (
    smsIntegrationRequestSmsHeaderBody?: SmsIntegrationRequestSmsHeaderBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/headers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationRequestSmsHeaderBody, signal
    },
      );
    }
  


export const getSmsIntegrationRequestSmsHeaderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>, TError,{data: SmsIntegrationRequestSmsHeaderBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>, TError,{data: SmsIntegrationRequestSmsHeaderBody}, TContext> => {

const mutationKey = ['smsIntegrationRequestSmsHeader'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>, {data: SmsIntegrationRequestSmsHeaderBody}> = (props) => {
          const {data} = props ?? {};

          return  smsIntegrationRequestSmsHeader(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationRequestSmsHeaderMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>>
    export type SmsIntegrationRequestSmsHeaderMutationBody = SmsIntegrationRequestSmsHeaderBody
    export type SmsIntegrationRequestSmsHeaderMutationError = unknown

    /**
 * @summary Request a new SMS header for tenant.
 */
export const useSmsIntegrationRequestSmsHeader = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>, TError,{data: SmsIntegrationRequestSmsHeaderBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
        TError,
        {data: SmsIntegrationRequestSmsHeaderBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationRequestSmsHeaderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Set a header as the default for the tenant.
 */
export const smsIntegrationSetDefaultHeader = (
    headerId: string,
    smsIntegrationSetDefaultHeaderBody?: SmsIntegrationSetDefaultHeaderBody,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/headers/${headerId}/set-default`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: smsIntegrationSetDefaultHeaderBody
    },
      );
    }
  


export const getSmsIntegrationSetDefaultHeaderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>, TError,{headerId: string;data: SmsIntegrationSetDefaultHeaderBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>, TError,{headerId: string;data: SmsIntegrationSetDefaultHeaderBody}, TContext> => {

const mutationKey = ['smsIntegrationSetDefaultHeader'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>, {headerId: string;data: SmsIntegrationSetDefaultHeaderBody}> = (props) => {
          const {headerId,data} = props ?? {};

          return  smsIntegrationSetDefaultHeader(headerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationSetDefaultHeaderMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>>
    export type SmsIntegrationSetDefaultHeaderMutationBody = SmsIntegrationSetDefaultHeaderBody
    export type SmsIntegrationSetDefaultHeaderMutationError = unknown

    /**
 * @summary Set a header as the default for the tenant.
 */
export const useSmsIntegrationSetDefaultHeader = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>, TError,{headerId: string;data: SmsIntegrationSetDefaultHeaderBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationSetDefaultHeader>>,
        TError,
        {headerId: string;data: SmsIntegrationSetDefaultHeaderBody},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationSetDefaultHeaderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/monitoring`, method: 'GET', signal
    },
      );
    }
  



export const getSmsMonitoringQueryKey = () => {
    return [
    `/api/sms/monitoring`
    ] as const;
    }

    
export const getSmsMonitoringQueryOptions = <TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({ signal }) => smsMonitoring(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsMonitoringQueryResult = NonNullable<Awaited<ReturnType<typeof smsMonitoring>>>
export type SmsMonitoringQueryError = unknown


export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsMonitoringQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary List available SMS packages (public endpoint).
 */
export const smsIntegrationGetSmsPackages = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sms/packages`, method: 'GET', signal
    },
      );
    }
  



export const getSmsIntegrationGetSmsPackagesQueryKey = () => {
    return [
    `/api/sms/packages`
    ] as const;
    }

    
export const getSmsIntegrationGetSmsPackagesQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationGetSmsPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>> = ({ signal }) => smsIntegrationGetSmsPackages(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationGetSmsPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>>
export type SmsIntegrationGetSmsPackagesQueryError = unknown


export function useSmsIntegrationGetSmsPackages<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsPackages<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationGetSmsPackages<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List available SMS packages (public endpoint).
 */

export function useSmsIntegrationGetSmsPackages<TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationGetSmsPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



