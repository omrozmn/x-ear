/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Merged: manual schemas + auto-generated endpoints
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  SmsGetAudiences200,
  SmsGetConfig200,
  SmsGetHeaders200,
  SmsIntegrationCreateTargetAudienceBody,
  SmsIntegrationGetSmsCredit200,
  SmsIntegrationGetSmsPackages200,
  SmsIntegrationRequestSmsHeaderBody,
  SmsIntegrationUpdateSmsConfigBody,
  SmsIntegrationUploadAudienceExcelBody,
  SmsIntegrationUploadSmsDocumentBody,
  SmsUploadDocumentBody,
} from ".././schemas";

import { customInstance } from "../../orval-mutator";

/**
 * Retrieve list of SMS headers
 * @summary Get SMS headers
 */
export const smsGetHeaders = (signal?: AbortSignal) => {
  return customInstance<SmsGetHeaders200>({
    url: `/api/sms/headers`,
    method: "GET",
    signal,
  });
};

export const getSmsGetHeadersQueryKey = () => {
  return [`/api/sms/headers`] as const;
};

export const getSmsGetHeadersQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetHeaders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetHeadersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetHeaders>>> = ({
    signal,
  }) => smsGetHeaders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetHeadersQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetHeaders>>
>;
export type SmsGetHeadersQueryError = unknown;

/**
 * @summary Get SMS headers
 */

export function useSmsGetHeaders<
  TData = Awaited<ReturnType<typeof smsGetHeaders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetHeadersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new SMS header
 * @summary Create SMS header
 */
export const smsIntegrationRequestSmsHeader = (
  smsIntegrationRequestSmsHeaderBody: SmsIntegrationRequestSmsHeaderBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/headers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: smsIntegrationRequestSmsHeaderBody,
    signal,
  });
};

export const getSmsIntegrationRequestSmsHeaderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
    TError,
    { data: SmsIntegrationRequestSmsHeaderBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
  TError,
  { data: SmsIntegrationRequestSmsHeaderBody },
  TContext
> => {
  const mutationKey = ["smsIntegrationRequestSmsHeader"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
    { data: SmsIntegrationRequestSmsHeaderBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsIntegrationRequestSmsHeader(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationRequestSmsHeaderMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>
>;
export type SmsIntegrationRequestSmsHeaderMutationBody =
  SmsIntegrationRequestSmsHeaderBody;
export type SmsIntegrationRequestSmsHeaderMutationError = unknown;

/**
 * @summary Create SMS header
 */
export const useSmsIntegrationRequestSmsHeader = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
    TError,
    { data: SmsIntegrationRequestSmsHeaderBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationRequestSmsHeader>>,
  TError,
  { data: SmsIntegrationRequestSmsHeaderBody },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationRequestSmsHeaderMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve list of SMS audiences
 * @summary Get SMS audiences
 */
export const smsGetAudiences = (signal?: AbortSignal) => {
  return customInstance<SmsGetAudiences200>({
    url: `/api/sms/audiences`,
    method: "GET",
    signal,
  });
};

export const getSmsGetAudiencesQueryKey = () => {
  return [`/api/sms/audiences`] as const;
};

export const getSmsGetAudiencesQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetAudiences>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetAudiencesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetAudiences>>> = ({
    signal,
  }) => smsGetAudiences(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetAudiencesQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetAudiences>>
>;
export type SmsGetAudiencesQueryError = unknown;

/**
 * @summary Get SMS audiences
 */

export function useSmsGetAudiences<
  TData = Awaited<ReturnType<typeof smsGetAudiences>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetAudiencesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new SMS audience
 * @summary Create SMS audience
 */
export const smsIntegrationCreateTargetAudience = (
  smsIntegrationCreateTargetAudienceBody: SmsIntegrationCreateTargetAudienceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/audiences`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: smsIntegrationCreateTargetAudienceBody,
    signal,
  });
};

export const getSmsIntegrationCreateTargetAudienceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
    TError,
    { data: SmsIntegrationCreateTargetAudienceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
  TError,
  { data: SmsIntegrationCreateTargetAudienceBody },
  TContext
> => {
  const mutationKey = ["smsIntegrationCreateTargetAudience"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
    { data: SmsIntegrationCreateTargetAudienceBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsIntegrationCreateTargetAudience(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationCreateTargetAudienceMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>
>;
export type SmsIntegrationCreateTargetAudienceMutationBody =
  SmsIntegrationCreateTargetAudienceBody;
export type SmsIntegrationCreateTargetAudienceMutationError = unknown;

/**
 * @summary Create SMS audience
 */
export const useSmsIntegrationCreateTargetAudience = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
    TError,
    { data: SmsIntegrationCreateTargetAudienceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationCreateTargetAudience>>,
  TError,
  { data: SmsIntegrationCreateTargetAudienceBody },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationCreateTargetAudienceMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Upload a file to create SMS audience
 * @summary Upload SMS audience file
 */
export const smsIntegrationUploadAudienceExcel = (
  smsIntegrationUploadAudienceExcelBody: SmsIntegrationUploadAudienceExcelBody,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (smsIntegrationUploadAudienceExcelBody.file !== undefined) {
    formData.append(`file`, smsIntegrationUploadAudienceExcelBody.file);
  }

  return customInstance<void>({
    url: `/api/sms/audiences/upload`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getSmsIntegrationUploadAudienceExcelMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
    TError,
    { data: SmsIntegrationUploadAudienceExcelBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
  TError,
  { data: SmsIntegrationUploadAudienceExcelBody },
  TContext
> => {
  const mutationKey = ["smsIntegrationUploadAudienceExcel"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
    { data: SmsIntegrationUploadAudienceExcelBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsIntegrationUploadAudienceExcel(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationUploadAudienceExcelMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>
>;
export type SmsIntegrationUploadAudienceExcelMutationBody =
  SmsIntegrationUploadAudienceExcelBody;
export type SmsIntegrationUploadAudienceExcelMutationError = unknown;

/**
 * @summary Upload SMS audience file
 */
export const useSmsIntegrationUploadAudienceExcel = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
    TError,
    { data: SmsIntegrationUploadAudienceExcelBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationUploadAudienceExcel>>,
  TError,
  { data: SmsIntegrationUploadAudienceExcelBody },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationUploadAudienceExcelMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve SMS configuration settings
 * @summary Get SMS configuration
 */
export const smsGetConfig = (signal?: AbortSignal) => {
  return customInstance<SmsGetConfig200>({
    url: `/api/sms/config`,
    method: "GET",
    signal,
  });
};

export const getSmsGetConfigQueryKey = () => {
  return [`/api/sms/config`] as const;
};

export const getSmsGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetConfig>>> = ({
    signal,
  }) => smsGetConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetConfig>>
>;
export type SmsGetConfigQueryError = unknown;

/**
 * @summary Get SMS configuration
 */

export function useSmsGetConfig<
  TData = Awaited<ReturnType<typeof smsGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update SMS configuration settings
 * @summary Update SMS configuration
 */
export const smsIntegrationUpdateSmsConfig = (
  smsIntegrationUpdateSmsConfigBody: SmsIntegrationUpdateSmsConfigBody,
) => {
  return customInstance<void>({
    url: `/api/sms/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: smsIntegrationUpdateSmsConfigBody,
  });
};

export const getSmsIntegrationUpdateSmsConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
    TError,
    { data: SmsIntegrationUpdateSmsConfigBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
  TError,
  { data: SmsIntegrationUpdateSmsConfigBody },
  TContext
> => {
  const mutationKey = ["smsIntegrationUpdateSmsConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
    { data: SmsIntegrationUpdateSmsConfigBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsIntegrationUpdateSmsConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationUpdateSmsConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>
>;
export type SmsIntegrationUpdateSmsConfigMutationBody =
  SmsIntegrationUpdateSmsConfigBody;
export type SmsIntegrationUpdateSmsConfigMutationError = unknown;

/**
 * @summary Update SMS configuration
 */
export const useSmsIntegrationUpdateSmsConfig = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
    TError,
    { data: SmsIntegrationUpdateSmsConfigBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationUpdateSmsConfig>>,
  TError,
  { data: SmsIntegrationUpdateSmsConfigBody },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationUpdateSmsConfigMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve available SMS packages
 * @summary Get SMS packages
 */
export const smsIntegrationGetSmsPackages = (signal?: AbortSignal) => {
  return customInstance<SmsIntegrationGetSmsPackages200>({
    url: `/api/sms/packages`,
    method: "GET",
    signal,
  });
};

export const getSmsIntegrationGetSmsPackagesQueryKey = () => {
  return [`/api/sms/packages`] as const;
};

export const getSmsIntegrationGetSmsPackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSmsIntegrationGetSmsPackagesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>
  > = ({ signal }) => smsIntegrationGetSmsPackages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsIntegrationGetSmsPackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>
>;
export type SmsIntegrationGetSmsPackagesQueryError = unknown;

/**
 * @summary Get SMS packages
 */

export function useSmsIntegrationGetSmsPackages<
  TData = Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsPackages>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsIntegrationGetSmsPackagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve current SMS credit balance
 * @summary Get SMS credit balance
 */
export const smsIntegrationGetSmsCredit = (signal?: AbortSignal) => {
  return customInstance<SmsIntegrationGetSmsCredit200>({
    url: `/api/sms/credit`,
    method: "GET",
    signal,
  });
};

export const getSmsIntegrationGetSmsCreditQueryKey = () => {
  return [`/api/sms/credit`] as const;
};

export const getSmsIntegrationGetSmsCreditQueryOptions = <
  TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSmsIntegrationGetSmsCreditQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>
  > = ({ signal }) => smsIntegrationGetSmsCredit(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsIntegrationGetSmsCreditQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>
>;
export type SmsIntegrationGetSmsCreditQueryError = unknown;

/**
 * @summary Get SMS credit balance
 */

export function useSmsIntegrationGetSmsCredit<
  TData = Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationGetSmsCredit>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsIntegrationGetSmsCreditQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Upload SMS-related document
 * @summary Upload SMS document
 */
export const smsUploadDocument = (
  smsUploadDocumentBody: SmsUploadDocumentBody,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (smsUploadDocumentBody.file !== undefined) {
    formData.append(`file`, smsUploadDocumentBody.file);
  }

  return customInstance<void>({
    url: `/api/sms/upload`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getSmsUploadDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    TError,
    { data: SmsUploadDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsUploadDocument>>,
  TError,
  { data: SmsUploadDocumentBody },
  TContext
> => {
  const mutationKey = ["smsUploadDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    { data: SmsUploadDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsUploadDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsUploadDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsUploadDocument>>
>;
export type SmsUploadDocumentMutationBody = SmsUploadDocumentBody;
export type SmsUploadDocumentMutationError = unknown;

/**
 * @summary Upload SMS document
 */
export const useSmsUploadDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    TError,
    { data: SmsUploadDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsUploadDocument>>,
  TError,
  { data: SmsUploadDocumentBody },
  TContext
> => {
  const mutationOptions = getSmsUploadDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Download SMS-related document
 * @summary Download SMS document
 */
export const smsDownloadDocument = (
  documentType: string,
  signal?: AbortSignal,
) => {
  return customInstance<Blob>({
    url: `/api/sms/documents/${documentType}/download`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getSmsDownloadDocumentQueryKey = (documentType?: string) => {
  return [`/api/sms/documents/${documentType}/download`] as const;
};

export const getSmsDownloadDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof smsDownloadDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsDownloadDocument>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSmsDownloadDocumentQueryKey(documentType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsDownloadDocument>>
  > = ({ signal }) => smsDownloadDocument(documentType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!documentType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof smsDownloadDocument>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsDownloadDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsDownloadDocument>>
>;
export type SmsDownloadDocumentQueryError = unknown;

/**
 * @summary Download SMS document
 */

export function useSmsDownloadDocument<
  TData = Awaited<ReturnType<typeof smsDownloadDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsDownloadDocument>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsDownloadDocumentQueryOptions(
    documentType,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete SMS-related document
 * @summary Delete SMS document
 */
export const smsDeleteDocument = (documentType: string) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}`,
    method: "DELETE",
  });
};

export const getSmsDeleteDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsDeleteDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationKey = ["smsDeleteDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    { documentType: string }
  > = (props) => {
    const { documentType } = props ?? {};

    return smsDeleteDocument(documentType);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsDeleteDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsDeleteDocument>>
>;

export type SmsDeleteDocumentMutationError = unknown;

/**
 * @summary Delete SMS document
 */
export const useSmsDeleteDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsDeleteDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationOptions = getSmsDeleteDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/sms/monitoring`,
    method: "GET",
    signal,
  });
};

export const getSmsMonitoringQueryKey = () => {
  return [`/api/sms/monitoring`] as const;
};

export const getSmsMonitoringQueryOptions = <
  TData = Awaited<ReturnType<typeof smsMonitoring>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({
    signal,
  }) => smsMonitoring(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsMonitoringQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsMonitoring>>
>;
export type SmsMonitoringQueryError = unknown;

/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<
  TData = Awaited<ReturnType<typeof smsMonitoring>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsMonitoringQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Generate presigned URL for document download
 */
export const smsIntegrationDownloadSmsDocument = (
  documentType: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}/download`,
    method: "GET",
    signal,
  });
};

export const getSmsIntegrationDownloadSmsDocumentQueryKey = (
  documentType?: string,
) => {
  return [`/api/sms/documents/${documentType}/download`] as const;
};

export const getSmsIntegrationDownloadSmsDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSmsIntegrationDownloadSmsDocumentQueryKey(documentType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
  > = ({ signal }) => smsIntegrationDownloadSmsDocument(documentType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!documentType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsIntegrationDownloadSmsDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
>;
export type SmsIntegrationDownloadSmsDocumentQueryError = unknown;

/**
 * @summary Generate presigned URL for document download
 */

export function useSmsIntegrationDownloadSmsDocument<
  TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsIntegrationDownloadSmsDocumentQueryOptions(
    documentType,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete an uploaded document
 */
export const smsIntegrationDeleteSmsDocument = (documentType: string) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}`,
    method: "DELETE",
  });
};

export const getSmsIntegrationDeleteSmsDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationKey = ["smsIntegrationDeleteSmsDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    { documentType: string }
  > = (props) => {
    const { documentType } = props ?? {};

    return smsIntegrationDeleteSmsDocument(documentType);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationDeleteSmsDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>
>;

export type SmsIntegrationDeleteSmsDocumentMutationError = unknown;

/**
 * @summary Delete an uploaded document
 */
export const useSmsIntegrationDeleteSmsDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationDeleteSmsDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Upload SMS document to S3
 */
export const smsIntegrationUploadSmsDocument = (
  smsIntegrationUploadSmsDocumentBody?: SmsIntegrationUploadSmsDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/documents/upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: smsIntegrationUploadSmsDocumentBody,
    signal,
  });
};

export const getSmsIntegrationUploadSmsDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
    TError,
    { data: SmsIntegrationUploadSmsDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
  TError,
  { data: SmsIntegrationUploadSmsDocumentBody },
  TContext
> => {
  const mutationKey = ["smsIntegrationUploadSmsDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
    { data: SmsIntegrationUploadSmsDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsIntegrationUploadSmsDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationUploadSmsDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>
>;
export type SmsIntegrationUploadSmsDocumentMutationBody =
  SmsIntegrationUploadSmsDocumentBody;
export type SmsIntegrationUploadSmsDocumentMutationError = unknown;

/**
 * @summary Upload SMS document to S3
 */
export const useSmsIntegrationUploadSmsDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
    TError,
    { data: SmsIntegrationUploadSmsDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationUploadSmsDocument>>,
  TError,
  { data: SmsIntegrationUploadSmsDocumentBody },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationUploadSmsDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};
