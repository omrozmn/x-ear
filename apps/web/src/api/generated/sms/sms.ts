/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  AdminSmsCreatePackageBody,
  AdminSmsGetHeaders200,
  AdminSmsGetHeadersParams,
  AdminSmsGetPackages200,
  AdminSmsUpdateHeaderStatusBody,
  AdminSmsUpdatePackageBody,
  SMSHeaderRequest,
  SMSPackage,
  SmsCreateAudienceBody,
  SmsCreateHeaderBody,
  SmsGetAudiences200,
  SmsGetConfig200,
  SmsGetCredit200,
  SmsGetHeaders200,
  SmsGetPackages200,
  SmsUpdateConfigBody,
  SmsUploadAudienceBody,
  SmsUploadDocumentBody,
  SmsUploadDocumentV2200,
  SmsUploadDocumentV2Body
} from '.././schemas';





/**
 * Retrieve list of SMS headers
 * @summary Get SMS headers
 */
export const smsGetHeaders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetHeaders200>> => {
    
    
    return axios.get(
      `/api/sms/headers`,options
    );
  }




export const getSmsGetHeadersQueryKey = () => {
    return [
    `/api/sms/headers`
    ] as const;
    }

    
export const getSmsGetHeadersQueryOptions = <TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetHeadersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetHeaders>>> = ({ signal }) => smsGetHeaders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetHeaders>>>
export type SmsGetHeadersQueryError = AxiosError<unknown>


export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS headers
 */

export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetHeadersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new SMS header
 * @summary Create SMS header
 */
export const smsCreateHeader = (
    smsCreateHeaderBody: SmsCreateHeaderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sms/headers`,
      smsCreateHeaderBody,options
    );
  }



export const getSmsCreateHeaderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext> => {

const mutationKey = ['smsCreateHeader'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsCreateHeader>>, {data: SmsCreateHeaderBody}> = (props) => {
          const {data} = props ?? {};

          return  smsCreateHeader(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsCreateHeaderMutationResult = NonNullable<Awaited<ReturnType<typeof smsCreateHeader>>>
    export type SmsCreateHeaderMutationBody = SmsCreateHeaderBody
    export type SmsCreateHeaderMutationError = AxiosError<unknown>

    /**
 * @summary Create SMS header
 */
export const useSmsCreateHeader = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsCreateHeader>>,
        TError,
        {data: SmsCreateHeaderBody},
        TContext
      > => {

      const mutationOptions = getSmsCreateHeaderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve list of SMS audiences
 * @summary Get SMS audiences
 */
export const smsGetAudiences = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetAudiences200>> => {
    
    
    return axios.get(
      `/api/sms/audiences`,options
    );
  }




export const getSmsGetAudiencesQueryKey = () => {
    return [
    `/api/sms/audiences`
    ] as const;
    }

    
export const getSmsGetAudiencesQueryOptions = <TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetAudiencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetAudiences>>> = ({ signal }) => smsGetAudiences({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetAudiencesQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetAudiences>>>
export type SmsGetAudiencesQueryError = AxiosError<unknown>


export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsGetAudiences>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsGetAudiences>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS audiences
 */

export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetAudiencesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new SMS audience
 * @summary Create SMS audience
 */
export const smsCreateAudience = (
    smsCreateAudienceBody: SmsCreateAudienceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sms/audiences`,
      smsCreateAudienceBody,options
    );
  }



export const getSmsCreateAudienceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext> => {

const mutationKey = ['smsCreateAudience'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsCreateAudience>>, {data: SmsCreateAudienceBody}> = (props) => {
          const {data} = props ?? {};

          return  smsCreateAudience(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsCreateAudienceMutationResult = NonNullable<Awaited<ReturnType<typeof smsCreateAudience>>>
    export type SmsCreateAudienceMutationBody = SmsCreateAudienceBody
    export type SmsCreateAudienceMutationError = AxiosError<unknown>

    /**
 * @summary Create SMS audience
 */
export const useSmsCreateAudience = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsCreateAudience>>,
        TError,
        {data: SmsCreateAudienceBody},
        TContext
      > => {

      const mutationOptions = getSmsCreateAudienceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Upload a file to create SMS audience
 * @summary Upload SMS audience file
 */
export const smsUploadAudience = (
    smsUploadAudienceBody: SmsUploadAudienceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    const formData = new FormData();
if(smsUploadAudienceBody.file !== undefined) {
 formData.append(`file`, smsUploadAudienceBody.file)
 }

    return axios.post(
      `/api/sms/audiences/upload`,
      formData,options
    );
  }



export const getSmsUploadAudienceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext> => {

const mutationKey = ['smsUploadAudience'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadAudience>>, {data: SmsUploadAudienceBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadAudience(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadAudienceMutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadAudience>>>
    export type SmsUploadAudienceMutationBody = SmsUploadAudienceBody
    export type SmsUploadAudienceMutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS audience file
 */
export const useSmsUploadAudience = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadAudience>>,
        TError,
        {data: SmsUploadAudienceBody},
        TContext
      > => {

      const mutationOptions = getSmsUploadAudienceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve SMS configuration settings
 * @summary Get SMS configuration
 */
export const smsGetConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetConfig200>> => {
    
    
    return axios.get(
      `/api/sms/config`,options
    );
  }




export const getSmsGetConfigQueryKey = () => {
    return [
    `/api/sms/config`
    ] as const;
    }

    
export const getSmsGetConfigQueryOptions = <TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetConfig>>> = ({ signal }) => smsGetConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetConfig>>>
export type SmsGetConfigQueryError = AxiosError<unknown>


export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetConfig>>,
          TError,
          Awaited<ReturnType<typeof smsGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetConfig>>,
          TError,
          Awaited<ReturnType<typeof smsGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS configuration
 */

export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update SMS configuration settings
 * @summary Update SMS configuration
 */
export const smsUpdateConfig = (
    smsUpdateConfigBody: SmsUpdateConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/sms/config`,
      smsUpdateConfigBody,options
    );
  }



export const getSmsUpdateConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext> => {

const mutationKey = ['smsUpdateConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUpdateConfig>>, {data: SmsUpdateConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUpdateConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUpdateConfigMutationResult = NonNullable<Awaited<ReturnType<typeof smsUpdateConfig>>>
    export type SmsUpdateConfigMutationBody = SmsUpdateConfigBody
    export type SmsUpdateConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update SMS configuration
 */
export const useSmsUpdateConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUpdateConfig>>,
        TError,
        {data: SmsUpdateConfigBody},
        TContext
      > => {

      const mutationOptions = getSmsUpdateConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve available SMS packages
 * @summary Get SMS packages
 */
export const smsGetPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetPackages200>> => {
    
    
    return axios.get(
      `/api/sms/packages`,options
    );
  }




export const getSmsGetPackagesQueryKey = () => {
    return [
    `/api/sms/packages`
    ] as const;
    }

    
export const getSmsGetPackagesQueryOptions = <TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetPackages>>> = ({ signal }) => smsGetPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetPackages>>>
export type SmsGetPackagesQueryError = AxiosError<unknown>


export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof smsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof smsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS packages
 */

export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve current SMS credit balance
 * @summary Get SMS credit balance
 */
export const smsGetCredit = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetCredit200>> => {
    
    
    return axios.get(
      `/api/sms/credit`,options
    );
  }




export const getSmsGetCreditQueryKey = () => {
    return [
    `/api/sms/credit`
    ] as const;
    }

    
export const getSmsGetCreditQueryOptions = <TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetCreditQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetCredit>>> = ({ signal }) => smsGetCredit({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetCreditQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetCredit>>>
export type SmsGetCreditQueryError = AxiosError<unknown>


export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetCredit>>,
          TError,
          Awaited<ReturnType<typeof smsGetCredit>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetCredit>>,
          TError,
          Awaited<ReturnType<typeof smsGetCredit>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS credit balance
 */

export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetCreditQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload SMS-related document
 * @summary Upload SMS document
 */
export const smsUploadDocument = (
    smsUploadDocumentBody: SmsUploadDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    const formData = new FormData();
if(smsUploadDocumentBody.file !== undefined) {
 formData.append(`file`, smsUploadDocumentBody.file)
 }

    return axios.post(
      `/api/sms/upload`,
      formData,options
    );
  }



export const getSmsUploadDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext> => {

const mutationKey = ['smsUploadDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadDocument>>, {data: SmsUploadDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadDocument>>>
    export type SmsUploadDocumentMutationBody = SmsUploadDocumentBody
    export type SmsUploadDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS document
 */
export const useSmsUploadDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadDocument>>,
        TError,
        {data: SmsUploadDocumentBody},
        TContext
      > => {

      const mutationOptions = getSmsUploadDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Download SMS-related document
 * @summary Download SMS document
 */
export const smsDownloadDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/sms/documents/${documentType}/download`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getSmsDownloadDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsDownloadDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsDownloadDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsDownloadDocument>>> = ({ signal }) => smsDownloadDocument(documentType, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsDownloadDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsDownloadDocument>>>
export type SmsDownloadDocumentQueryError = AxiosError<unknown>


export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Download SMS document
 */

export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsDownloadDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete SMS-related document
 * @summary Delete SMS document
 */
export const smsDeleteDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sms/documents/${documentType}`,options
    );
  }



export const getSmsDeleteDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsDeleteDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsDeleteDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsDeleteDocument(documentType,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsDeleteDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsDeleteDocument>>>
    
    export type SmsDeleteDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Delete SMS document
 */
export const useSmsDeleteDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsDeleteDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsDeleteDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sms/monitoring`,options
    );
  }




export const getSmsMonitoringQueryKey = () => {
    return [
    `/api/sms/monitoring`
    ] as const;
    }

    
export const getSmsMonitoringQueryOptions = <TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({ signal }) => smsMonitoring({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsMonitoringQueryResult = NonNullable<Awaited<ReturnType<typeof smsMonitoring>>>
export type SmsMonitoringQueryError = AxiosError<unknown>


export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsMonitoringQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Admin List SMS Headers
 */
export const adminSmsGetHeaders = (
    params?: AdminSmsGetHeadersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminSmsGetHeaders200>> => {
    
    
    return axios.get(
      `/api/admin/sms/headers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getAdminSmsGetHeadersQueryKey = (params?: AdminSmsGetHeadersParams,) => {
    return [
    `/api/admin/sms/headers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAdminSmsGetHeadersQueryOptions = <TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminSmsGetHeadersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminSmsGetHeaders>>> = ({ signal }) => adminSmsGetHeaders(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminSmsGetHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof adminSmsGetHeaders>>>
export type AdminSmsGetHeadersQueryError = AxiosError<unknown>


export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params: undefined |  AdminSmsGetHeadersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Headers
 */

export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminSmsGetHeadersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Admin Update SMS Header Status
 */
export const adminSmsUpdateHeaderStatus = (
    headerId: string,
    adminSmsUpdateHeaderStatusBody: AdminSmsUpdateHeaderStatusBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSHeaderRequest>> => {
    
    
    return axios.put(
      `/api/admin/sms/headers/${headerId}/status`,
      adminSmsUpdateHeaderStatusBody,options
    );
  }



export const getAdminSmsUpdateHeaderStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext> => {

const mutationKey = ['adminSmsUpdateHeaderStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, {headerId: string;data: AdminSmsUpdateHeaderStatusBody}> = (props) => {
          const {headerId,data} = props ?? {};

          return  adminSmsUpdateHeaderStatus(headerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsUpdateHeaderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>>
    export type AdminSmsUpdateHeaderStatusMutationBody = AdminSmsUpdateHeaderStatusBody
    export type AdminSmsUpdateHeaderStatusMutationError = AxiosError<unknown>

    /**
 * @summary Admin Update SMS Header Status
 */
export const useAdminSmsUpdateHeaderStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
        TError,
        {headerId: string;data: AdminSmsUpdateHeaderStatusBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsUpdateHeaderStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Admin List SMS Packages
 */
export const adminSmsGetPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminSmsGetPackages200>> => {
    
    
    return axios.get(
      `/api/admin/sms/packages`,options
    );
  }




export const getAdminSmsGetPackagesQueryKey = () => {
    return [
    `/api/admin/sms/packages`
    ] as const;
    }

    
export const getAdminSmsGetPackagesQueryOptions = <TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminSmsGetPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminSmsGetPackages>>> = ({ signal }) => adminSmsGetPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminSmsGetPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof adminSmsGetPackages>>>
export type AdminSmsGetPackagesQueryError = AxiosError<unknown>


export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Packages
 */

export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminSmsGetPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Admin Create SMS Package
 */
export const adminSmsCreatePackage = (
    adminSmsCreatePackageBody: AdminSmsCreatePackageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSPackage>> => {
    
    
    return axios.post(
      `/api/admin/sms/packages`,
      adminSmsCreatePackageBody,options
    );
  }



export const getAdminSmsCreatePackageMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext> => {

const mutationKey = ['adminSmsCreatePackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsCreatePackage>>, {data: AdminSmsCreatePackageBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSmsCreatePackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsCreatePackageMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsCreatePackage>>>
    export type AdminSmsCreatePackageMutationBody = AdminSmsCreatePackageBody
    export type AdminSmsCreatePackageMutationError = AxiosError<unknown>

    /**
 * @summary Admin Create SMS Package
 */
export const useAdminSmsCreatePackage = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsCreatePackage>>,
        TError,
        {data: AdminSmsCreatePackageBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsCreatePackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Admin Update SMS Package
 */
export const adminSmsUpdatePackage = (
    pkgId: string,
    adminSmsUpdatePackageBody: AdminSmsUpdatePackageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSPackage>> => {
    
    
    return axios.put(
      `/api/admin/sms/packages/${pkgId}`,
      adminSmsUpdatePackageBody,options
    );
  }



export const getAdminSmsUpdatePackageMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext> => {

const mutationKey = ['adminSmsUpdatePackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, {pkgId: string;data: AdminSmsUpdatePackageBody}> = (props) => {
          const {pkgId,data} = props ?? {};

          return  adminSmsUpdatePackage(pkgId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsUpdatePackageMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsUpdatePackage>>>
    export type AdminSmsUpdatePackageMutationBody = AdminSmsUpdatePackageBody
    export type AdminSmsUpdatePackageMutationError = AxiosError<unknown>

    /**
 * @summary Admin Update SMS Package
 */
export const useAdminSmsUpdatePackage = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
        TError,
        {pkgId: string;data: AdminSmsUpdatePackageBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsUpdatePackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Upload SMS Document to S3
 */
export const smsUploadDocumentV2 = (
    smsUploadDocumentV2Body: SmsUploadDocumentV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsUploadDocumentV2200>> => {
    
    const formData = new FormData();
formData.append(`file`, smsUploadDocumentV2Body.file)
formData.append(`documentType`, smsUploadDocumentV2Body.documentType)

    return axios.post(
      `/api/sms/documents/upload`,
      formData,options
    );
  }



export const getSmsUploadDocumentV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext> => {

const mutationKey = ['smsUploadDocumentV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadDocumentV2>>, {data: SmsUploadDocumentV2Body}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadDocumentV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadDocumentV2MutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadDocumentV2>>>
    export type SmsUploadDocumentV2MutationBody = SmsUploadDocumentV2Body
    export type SmsUploadDocumentV2MutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS Document to S3
 */
export const useSmsUploadDocumentV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadDocumentV2>>,
        TError,
        {data: SmsUploadDocumentV2Body},
        TContext
      > => {

      const mutationOptions = getSmsUploadDocumentV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete an uploaded document
 */
export const smsIntegrationDeleteSmsDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sms/documents/${documentType}`,options
    );
  }



export const getSmsIntegrationDeleteSmsDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsIntegrationDeleteSmsDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsIntegrationDeleteSmsDocument(documentType,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationDeleteSmsDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>>
    
    export type SmsIntegrationDeleteSmsDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Delete an uploaded document
 */
export const useSmsIntegrationDeleteSmsDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationDeleteSmsDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Generate presigned URL for document download
 */
export const smsIntegrationDownloadSmsDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sms/documents/${documentType}/download`,options
    );
  }




export const getSmsIntegrationDownloadSmsDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsIntegrationDownloadSmsDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationDownloadSmsDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>> = ({ signal }) => smsIntegrationDownloadSmsDocument(documentType, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationDownloadSmsDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>>
export type SmsIntegrationDownloadSmsDocumentQueryError = AxiosError<unknown>


export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate presigned URL for document download
 */

export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationDownloadSmsDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




