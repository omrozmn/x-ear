/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  AppointmentsCancelAppointmentBody,
  AppointmentsCompleteAppointmentBody,
  AppointmentsCreateAppointment201,
  AppointmentsCreateAppointmentBody,
  AppointmentsGetAppointmentsParams,
  AppointmentsListAppointments200,
  AppointmentsRescheduleAppointmentBody,
  AutomationTriggerBackupBody,
  AutomationTriggerSgkProcessingBody,
  BirfaturaSyncInvoices200,
  BirfaturaSyncInvoicesBody,
  Campaign,
  CampaignsCreateCampaignBody,
  CampaignsSendCampaignBody,
  CommunicationTemplateCreate,
  CommunicationTemplateUpdate,
  CommunicationsCreateTemplate201,
  CommunicationsDeleteTemplate200,
  CommunicationsGetTemplate200,
  CommunicationsListMessages200,
  CommunicationsListMessagesParams,
  CommunicationsListTemplates200,
  CommunicationsListTemplatesParams,
  CommunicationsUpdateTemplate200,
  CreateSupplierBody,
  DashboardGetDashboardData200,
  Device,
  DevicesCreateDeviceBody,
  DevicesCreateDeviceBrandBody,
  DevicesCreateDeviceCategory201,
  DevicesCreateDeviceCategoryBody,
  DevicesGetDevices200,
  DevicesGetDevicesParams,
  DevicesUpdateDeviceStockBody,
  ErrorResponse,
  InventoryAddSerialNumbersBody,
  InventoryAssignToPatientBody,
  InventoryCreateBrand201,
  InventoryCreateBrandBody,
  InventoryCreateCategory201,
  InventoryCreateCategoryBody,
  InventoryCreateInventoryItemBody,
  InventoryGetBrands200,
  InventoryGetCategories200,
  InventoryGetInventoryItem200,
  InventoryGetInventoryItems200,
  InventoryGetInventoryItemsParams,
  InventoryItem,
  InventoryUpdateInventoryItem200,
  InvoicesBulkUploadInvoices200,
  InvoicesBulkUploadInvoicesBody,
  InvoicesCreateInvoice201,
  InvoicesCreateInvoiceBody,
  InvoicesDeleteInvoice200,
  InvoicesGetInvoice200,
  InvoicesSendToGib200,
  Notification,
  NotificationsMarkNotificationReadBody,
  OcrCalculateSimilarityBody,
  OcrExtractEntitiesBody,
  OcrExtractPatientNameBody,
  OcrInitDatabaseBody,
  OcrInitializeNlpEndpointBody,
  OcrProcessDocumentBody,
  Patient,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesCreatePatientNoteBody,
  PatientsBulkUploadPatientsBody,
  PatientsCreatePatientBody,
  PatientsGetPatientDevices200,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  PatientsUpdatePatientBody,
  PaymentRecord,
  PaymentsCollectPromissoryNoteBody,
  PaymentsCreatePromissoryNotesBody,
  PaymentsUpdatePromissoryNoteBody,
  RegistrationRegisterPhoneBody,
  RegistrationVerifyRegistrationOtpBody,
  Sale,
  SalesAssignDevicesExtendedBody,
  SalesCreateSaleBody,
  SalesCreateSaleInvoice201,
  SalesCreateSaleInvoiceBody,
  SalesCreateSalePaymentPlanBody,
  SalesGetSaleInvoice200,
  SalesPricingPreviewBody,
  SalesUpdateSaleBody,
  SgkProcessOcrBody,
  SgkUploadSgkDocumentBody,
  SuccessResponse,
  Supplier,
  SuppliersAcceptSuggestedSupplier200,
  SuppliersAcceptSuggestedSupplier201,
  SuppliersAddProductSupplierBody,
  SuppliersBulkUploadSuppliersBody,
  SuppliersCreateSupplierBody,
  SuppliersGetSuggestedSuppliers200,
  SuppliersGetSupplierInvoices200,
  SuppliersGetSupplierInvoicesParams,
  SuppliersGetSuppliers200,
  SuppliersGetSuppliersParams,
  SuppliersRejectSuggestedSupplier200,
  TenantUsersDelete200,
  TenantUsersInvite201,
  TenantUsersInviteBody,
  TenantUsersList200,
  TimelineAddTimelineEvent201,
  TimelineAddTimelineEventBody,
  TimelineDeleteTimelineEvent200,
  TimelineGetPatientTimeline200,
  TimelineLogPatientActivityBody,
  UpdateSettingsBody,
  User,
  UsersChangePassword200,
  UsersChangePasswordBody,
  UsersCreateUserBody,
  UsersUpdateMeBody,
  UsersUpdateUserBody
} from './schemas';

/**
 * @summary Get list of appointments
 */
export const appointmentsGetAppointments = (
    params?: AppointmentsGetAppointmentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/appointments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getAppointmentsGetAppointmentsQueryKey = (params?: AppointmentsGetAppointmentsParams,) => {
    return [
    `/api/appointments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAppointmentsGetAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAppointmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAppointments>>> = ({ signal }) => appointmentsGetAppointments(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAppointments>>>
export type AppointmentsGetAppointmentsQueryError = AxiosError<unknown>


export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params: undefined |  AppointmentsGetAppointmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of appointments
 */

export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAppointmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new appointment
 */
export const appointmentsCreateAppointment = (
    appointmentsCreateAppointmentBody: AppointmentsCreateAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppointmentsCreateAppointment201>> => {
    
    
    return axios.post(
      `/api/appointments`,
      appointmentsCreateAppointmentBody,options
    );
  }



export const getAppointmentsCreateAppointmentMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCreateAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, {data: AppointmentsCreateAppointmentBody}> = (props) => {
          const {data} = props ?? {};

          return  appointmentsCreateAppointment(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCreateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCreateAppointment>>>
    export type AppointmentsCreateAppointmentMutationBody = AppointmentsCreateAppointmentBody
    export type AppointmentsCreateAppointmentMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new appointment
 */
export const useAppointmentsCreateAppointment = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
        TError,
        {data: AppointmentsCreateAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCreateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of communication messages (SMS and Email)
 */
export const communicationsListMessages = (
    params?: CommunicationsListMessagesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsListMessages200>> => {
    
    
    return axios.get(
      `/api/communications/messages`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getCommunicationsListMessagesQueryKey = (params?: CommunicationsListMessagesParams,) => {
    return [
    `/api/communications/messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCommunicationsListMessagesQueryOptions = <TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsListMessagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsListMessages>>> = ({ signal }) => communicationsListMessages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsListMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsListMessages>>>
export type CommunicationsListMessagesQueryError = AxiosError<ErrorResponse>


export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  CommunicationsListMessagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListMessages>>,
          TError,
          Awaited<ReturnType<typeof communicationsListMessages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListMessages>>,
          TError,
          Awaited<ReturnType<typeof communicationsListMessages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of communication messages (SMS and Email)
 */

export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsListMessagesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get list of communication templates
 */
export const communicationsListTemplates = (
    params?: CommunicationsListTemplatesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsListTemplates200>> => {
    
    
    return axios.get(
      `/api/communications/templates`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getCommunicationsListTemplatesQueryKey = (params?: CommunicationsListTemplatesParams,) => {
    return [
    `/api/communications/templates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCommunicationsListTemplatesQueryOptions = <TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsListTemplatesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsListTemplates>>> = ({ signal }) => communicationsListTemplates(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsListTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsListTemplates>>>
export type CommunicationsListTemplatesQueryError = AxiosError<unknown>


export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params: undefined |  CommunicationsListTemplatesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of communication templates
 */

export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsListTemplatesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new communication template
 */
export const communicationsCreateTemplate = (
    communicationTemplateCreate: CommunicationTemplateCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsCreateTemplate201>> => {
    
    
    return axios.post(
      `/api/communications/templates`,
      communicationTemplateCreate,options
    );
  }



export const getCommunicationsCreateTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext> => {

const mutationKey = ['communicationsCreateTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsCreateTemplate>>, {data: CommunicationTemplateCreate}> = (props) => {
          const {data} = props ?? {};

          return  communicationsCreateTemplate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsCreateTemplate>>>
    export type CommunicationsCreateTemplateMutationBody = CommunicationTemplateCreate
    export type CommunicationsCreateTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Create a new communication template
 */
export const useCommunicationsCreateTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsCreateTemplate>>,
        TError,
        {data: CommunicationTemplateCreate},
        TContext
      > => {

      const mutationOptions = getCommunicationsCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific communication template
 */
export const communicationsGetTemplate = (
    templateId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsGetTemplate200>> => {
    
    
    return axios.get(
      `/api/communications/templates/${templateId}`,options
    );
  }




export const getCommunicationsGetTemplateQueryKey = (templateId?: string,) => {
    return [
    `/api/communications/templates/${templateId}`
    ] as const;
    }

    
export const getCommunicationsGetTemplateQueryOptions = <TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsGetTemplateQueryKey(templateId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsGetTemplate>>> = ({ signal }) => communicationsGetTemplate(templateId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(templateId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsGetTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsGetTemplate>>>
export type CommunicationsGetTemplateQueryError = AxiosError<unknown>


export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific communication template
 */

export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsGetTemplateQueryOptions(templateId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update a communication template
 */
export const communicationsUpdateTemplate = (
    templateId: string,
    communicationTemplateUpdate: CommunicationTemplateUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsUpdateTemplate200>> => {
    
    
    return axios.put(
      `/api/communications/templates/${templateId}`,
      communicationTemplateUpdate,options
    );
  }



export const getCommunicationsUpdateTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext> => {

const mutationKey = ['communicationsUpdateTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, {templateId: string;data: CommunicationTemplateUpdate}> = (props) => {
          const {templateId,data} = props ?? {};

          return  communicationsUpdateTemplate(templateId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsUpdateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsUpdateTemplate>>>
    export type CommunicationsUpdateTemplateMutationBody = CommunicationTemplateUpdate
    export type CommunicationsUpdateTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Update a communication template
 */
export const useCommunicationsUpdateTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
        TError,
        {templateId: string;data: CommunicationTemplateUpdate},
        TContext
      > => {

      const mutationOptions = getCommunicationsUpdateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a communication template
 */
export const communicationsDeleteTemplate = (
    templateId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsDeleteTemplate200>> => {
    
    
    return axios.delete(
      `/api/communications/templates/${templateId}`,options
    );
  }



export const getCommunicationsDeleteTemplateMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext> => {

const mutationKey = ['communicationsDeleteTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, {templateId: string}> = (props) => {
          const {templateId} = props ?? {};

          return  communicationsDeleteTemplate(templateId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsDeleteTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsDeleteTemplate>>>
    
    export type CommunicationsDeleteTemplateMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete a communication template
 */
export const useCommunicationsDeleteTemplate = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
        TError,
        {templateId: string},
        TContext
      > => {

      const mutationOptions = getCommunicationsDeleteTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete an existing appointment by its unique identifier
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const appointmentsDeleteAppointment = (
    appointmentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/appointments/${appointmentId}`,options
    );
  }



export const getAppointmentsDeleteAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['appointmentsDeleteAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  appointmentsDeleteAppointment(appointmentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsDeleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>>
    
    export type AppointmentsDeleteAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const useAppointmentsDeleteAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getAppointmentsDeleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Cancel an appointment and optionally provide cancellation reason
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const appointmentsCancelAppointment = (
    appointmentId: string,
    appointmentsCancelAppointmentBody?: AppointmentsCancelAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/cancel`,
      appointmentsCancelAppointmentBody,options
    );
  }



export const getAppointmentsCancelAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCancelAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, {appointmentId: string;data: AppointmentsCancelAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCancelAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCancelAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCancelAppointment>>>
    export type AppointmentsCancelAppointmentMutationBody = AppointmentsCancelAppointmentBody
    export type AppointmentsCancelAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const useAppointmentsCancelAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCancelAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCancelAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Mark an appointment as completed and add completion notes
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const appointmentsCompleteAppointment = (
    appointmentId: string,
    appointmentsCompleteAppointmentBody?: AppointmentsCompleteAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/complete`,
      appointmentsCompleteAppointmentBody,options
    );
  }



export const getAppointmentsCompleteAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCompleteAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, {appointmentId: string;data: AppointmentsCompleteAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCompleteAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCompleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>>
    export type AppointmentsCompleteAppointmentMutationBody = AppointmentsCompleteAppointmentBody
    export type AppointmentsCompleteAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const useAppointmentsCompleteAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCompleteAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCompleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reschedule an existing appointment to a new date and time
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const appointmentsRescheduleAppointment = (
    appointmentId: string,
    appointmentsRescheduleAppointmentBody?: AppointmentsRescheduleAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/reschedule`,
      appointmentsRescheduleAppointmentBody,options
    );
  }



export const getAppointmentsRescheduleAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsRescheduleAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, {appointmentId: string;data: AppointmentsRescheduleAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsRescheduleAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsRescheduleAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>>
    export type AppointmentsRescheduleAppointmentMutationBody = AppointmentsRescheduleAppointmentBody
    export type AppointmentsRescheduleAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const useAppointmentsRescheduleAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsRescheduleAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsRescheduleAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get available appointment slots for scheduling
 * @summary GET /api/appointments/availability
 */
export const appointmentsGetAvailability = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/appointments/availability`,options
    );
  }




export const getAppointmentsGetAvailabilityQueryKey = () => {
    return [
    `/api/appointments/availability`
    ] as const;
    }

    
export const getAppointmentsGetAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAvailabilityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAvailability>>> = ({ signal }) => appointmentsGetAvailability({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAvailability>>>
export type AppointmentsGetAvailabilityQueryError = AxiosError<unknown>


export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/availability
 */

export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAvailabilityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of appointments with optional filtering
 * @summary GET /api/appointments/list
 */
export const appointmentsListAppointments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppointmentsListAppointments200>> => {
    
    
    return axios.get(
      `/api/appointments/list`,options
    );
  }




export const getAppointmentsListAppointmentsQueryKey = () => {
    return [
    `/api/appointments/list`
    ] as const;
    }

    
export const getAppointmentsListAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsListAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsListAppointments>>> = ({ signal }) => appointmentsListAppointments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsListAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsListAppointments>>>
export type AppointmentsListAppointmentsQueryError = AxiosError<unknown>


export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/list
 */

export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsListAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Trigger automated system backup process
 * @summary Trigger system backup
 */
export const automationTriggerBackup = (
    automationTriggerBackupBody?: AutomationTriggerBackupBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/automation/backup`,
      automationTriggerBackupBody,options
    );
  }



export const getAutomationTriggerBackupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext> => {

const mutationKey = ['automationTriggerBackup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerBackup>>, {data: AutomationTriggerBackupBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerBackup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerBackupMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerBackup>>>
    export type AutomationTriggerBackupMutationBody = AutomationTriggerBackupBody
    export type AutomationTriggerBackupMutationError = AxiosError<unknown>

    /**
 * @summary Trigger system backup
 */
export const useAutomationTriggerBackup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerBackup>>,
        TError,
        {data: AutomationTriggerBackupBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerBackupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve logs from automated processes and tasks
 * @summary Get automation logs
 */
export const automationGetAutomationLogs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/automation/logs`,options
    );
  }




export const getAutomationGetAutomationLogsQueryKey = () => {
    return [
    `/api/automation/logs`
    ] as const;
    }

    
export const getAutomationGetAutomationLogsQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationLogs>>> = ({ signal }) => automationGetAutomationLogs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationLogsQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationLogs>>>
export type AutomationGetAutomationLogsQueryError = AxiosError<unknown>


export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation logs
 */

export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Trigger automated SGK document processing workflow
 * @summary Trigger SGK document processing
 */
export const automationTriggerSgkProcessing = (
    automationTriggerSgkProcessingBody?: AutomationTriggerSgkProcessingBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/automation/sgk/process`,
      automationTriggerSgkProcessingBody,options
    );
  }



export const getAutomationTriggerSgkProcessingMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext> => {

const mutationKey = ['automationTriggerSgkProcessing'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, {data: AutomationTriggerSgkProcessingBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerSgkProcessing(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerSgkProcessingMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>>
    export type AutomationTriggerSgkProcessingMutationBody = AutomationTriggerSgkProcessingBody
    export type AutomationTriggerSgkProcessingMutationError = AxiosError<unknown>

    /**
 * @summary Trigger SGK document processing
 */
export const useAutomationTriggerSgkProcessing = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
        TError,
        {data: AutomationTriggerSgkProcessingBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerSgkProcessingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve status information
 * @summary Get automation system status
 */
export const automationGetAutomationStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/automation/status`,options
    );
  }




export const getAutomationGetAutomationStatusQueryKey = () => {
    return [
    `/api/automation/status`
    ] as const;
    }

    
export const getAutomationGetAutomationStatusQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationStatus>>> = ({ signal }) => automationGetAutomationStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationStatus>>>
export type AutomationGetAutomationStatusQueryError = AxiosError<unknown>


export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation system status
 */

export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new marketing campaign with target audience and content
 * @summary POST /api/campaigns
 */
export const campaignsCreateCampaign = (
    campaignsCreateCampaignBody?: CampaignsCreateCampaignBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Campaign>> => {
    
    
    return axios.post(
      `/api/campaigns`,
      campaignsCreateCampaignBody,options
    );
  }



export const getCampaignsCreateCampaignMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext> => {

const mutationKey = ['campaignsCreateCampaign'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof campaignsCreateCampaign>>, {data: CampaignsCreateCampaignBody}> = (props) => {
          const {data} = props ?? {};

          return  campaignsCreateCampaign(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CampaignsCreateCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof campaignsCreateCampaign>>>
    export type CampaignsCreateCampaignMutationBody = CampaignsCreateCampaignBody
    export type CampaignsCreateCampaignMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/campaigns
 */
export const useCampaignsCreateCampaign = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof campaignsCreateCampaign>>,
        TError,
        {data: CampaignsCreateCampaignBody},
        TContext
      > => {

      const mutationOptions = getCampaignsCreateCampaignMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve dashboard overview data including statistics and recent activities
 * @summary Get dashboard data
 */
export const dashboardGetDashboardData = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DashboardGetDashboardData200>> => {
    
    
    return axios.get(
      `/api/dashboard`,options
    );
  }




export const getDashboardGetDashboardDataQueryKey = () => {
    return [
    `/api/dashboard`
    ] as const;
    }

    
export const getDashboardGetDashboardDataQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetDashboardDataQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetDashboardData>>> = ({ signal }) => dashboardGetDashboardData({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetDashboardDataQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetDashboardData>>>
export type DashboardGetDashboardDataQueryError = AxiosError<ErrorResponse>


export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboardData>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboardData>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboardData>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboardData>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get dashboard data
 */

export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetDashboardDataQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new send
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const campaignsSendCampaign = (
    campaignId: string,
    campaignsSendCampaignBody?: CampaignsSendCampaignBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/campaigns/${campaignId}/send`,
      campaignsSendCampaignBody,options
    );
  }



export const getCampaignsSendCampaignMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext> => {

const mutationKey = ['campaignsSendCampaign'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof campaignsSendCampaign>>, {campaignId: string;data: CampaignsSendCampaignBody}> = (props) => {
          const {campaignId,data} = props ?? {};

          return  campaignsSendCampaign(campaignId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CampaignsSendCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof campaignsSendCampaign>>>
    export type CampaignsSendCampaignMutationBody = CampaignsSendCampaignBody
    export type CampaignsSendCampaignMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const useCampaignsSendCampaign = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof campaignsSendCampaign>>,
        TError,
        {campaignId: string;data: CampaignsSendCampaignBody},
        TContext
      > => {

      const mutationOptions = getCampaignsSendCampaignMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve turnstile information
 * @summary GET /api/config/turnstile
 */
export const registrationGetTurnstileConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/config/turnstile`,options
    );
  }




export const getRegistrationGetTurnstileConfigQueryKey = () => {
    return [
    `/api/config/turnstile`
    ] as const;
    }

    
export const getRegistrationGetTurnstileConfigQueryOptions = <TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRegistrationGetTurnstileConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>> = ({ signal }) => registrationGetTurnstileConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type RegistrationGetTurnstileConfigQueryResult = NonNullable<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>>
export type RegistrationGetTurnstileConfigQueryError = AxiosError<unknown>


export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/config/turnstile
 */

export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRegistrationGetTurnstileConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve patient-trends information
 * @summary GET /api/dashboard/charts/patient-trends
 */
export const dashboardPatientTrends = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/charts/patient-trends`,options
    );
  }




export const getDashboardPatientTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/patient-trends`
    ] as const;
    }

    
export const getDashboardPatientTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardPatientTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardPatientTrends>>> = ({ signal }) => dashboardPatientTrends({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardPatientTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardPatientTrends>>>
export type DashboardPatientTrendsQueryError = AxiosError<unknown>


export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/patient-trends
 */

export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardPatientTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve revenue-trends information
 * @summary GET /api/dashboard/charts/revenue-trends
 */
export const dashboardRevenueTrends = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/charts/revenue-trends`,options
    );
  }




export const getDashboardRevenueTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/revenue-trends`
    ] as const;
    }

    
export const getDashboardRevenueTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRevenueTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRevenueTrends>>> = ({ signal }) => dashboardRevenueTrends({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRevenueTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRevenueTrends>>>
export type DashboardRevenueTrendsQueryError = AxiosError<unknown>


export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/revenue-trends
 */

export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRevenueTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve kpis information
 * @summary GET /api/dashboard/kpis
 */
export const dashboardGetKpis = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/kpis`,options
    );
  }




export const getDashboardGetKpisQueryKey = () => {
    return [
    `/api/dashboard/kpis`
    ] as const;
    }

    
export const getDashboardGetKpisQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetKpisQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetKpis>>> = ({ signal }) => dashboardGetKpis({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetKpisQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetKpis>>>
export type DashboardGetKpisQueryError = AxiosError<unknown>


export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/kpis
 */

export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetKpisQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve recent-activity information
 * @summary GET /api/dashboard/recent-activity
 */
export const dashboardRecentActivity = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/recent-activity`,options
    );
  }




export const getDashboardRecentActivityQueryKey = () => {
    return [
    `/api/dashboard/recent-activity`
    ] as const;
    }

    
export const getDashboardRecentActivityQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRecentActivityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRecentActivity>>> = ({ signal }) => dashboardRecentActivity({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRecentActivityQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRecentActivity>>>
export type DashboardRecentActivityQueryError = AxiosError<unknown>


export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/recent-activity
 */

export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRecentActivityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of devices with optional filtering and pagination
 * @summary Get list of devices
 */
export const devicesGetDevices = (
    params?: DevicesGetDevicesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DevicesGetDevices200>> => {
    
    
    return axios.get(
      `/api/devices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getDevicesGetDevicesQueryKey = (params?: DevicesGetDevicesParams,) => {
    return [
    `/api/devices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getDevicesGetDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDevicesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDevices>>> = ({ signal }) => devicesGetDevices(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDevices>>>
export type DevicesGetDevicesQueryError = AxiosError<ErrorResponse>


export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  DevicesGetDevicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of devices
 */

export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDevicesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new hearing aid device in the system
 * @summary Create a new device
 */
export const devicesCreateDevice = (
    devicesCreateDeviceBody?: DevicesCreateDeviceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Device>> => {
    
    
    return axios.post(
      `/api/devices`,
      devicesCreateDeviceBody,options
    );
  }



export const getDevicesCreateDeviceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext> => {

const mutationKey = ['devicesCreateDevice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDevice>>, {data: DevicesCreateDeviceBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDevice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDevice>>>
    export type DevicesCreateDeviceMutationBody = DevicesCreateDeviceBody
    export type DevicesCreateDeviceMutationError = AxiosError<unknown>

    /**
 * @summary Create a new device
 */
export const useDevicesCreateDevice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDevice>>,
        TError,
        {data: DevicesCreateDeviceBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a device from the system
 * @summary Delete a device
 */
export const devicesDeleteDevice = (
    deviceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/devices/${deviceId}`,options
    );
  }



export const getDevicesDeleteDeviceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext> => {

const mutationKey = ['devicesDeleteDevice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesDeleteDevice>>, {deviceId: string}> = (props) => {
          const {deviceId} = props ?? {};

          return  devicesDeleteDevice(deviceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesDeleteDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesDeleteDevice>>>
    
    export type DevicesDeleteDeviceMutationError = AxiosError<unknown>

    /**
 * @summary Delete a device
 */
export const useDevicesDeleteDevice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesDeleteDevice>>,
        TError,
        {deviceId: string},
        TContext
      > => {

      const mutationOptions = getDevicesDeleteDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally permissive for tests ‚Äî real inventory logic
should live in a dedicated inventory table/service.
 * @summary Update device stock levels (simplified).
 */
export const devicesUpdateDeviceStock = (
    deviceId: string,
    devicesUpdateDeviceStockBody?: DevicesUpdateDeviceStockBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/devices/${deviceId}/stock-update`,
      devicesUpdateDeviceStockBody,options
    );
  }



export const getDevicesUpdateDeviceStockMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext> => {

const mutationKey = ['devicesUpdateDeviceStock'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, {deviceId: string;data: DevicesUpdateDeviceStockBody}> = (props) => {
          const {deviceId,data} = props ?? {};

          return  devicesUpdateDeviceStock(deviceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesUpdateDeviceStockMutationResult = NonNullable<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>>
    export type DevicesUpdateDeviceStockMutationBody = DevicesUpdateDeviceStockBody
    export type DevicesUpdateDeviceStockMutationError = AxiosError<unknown>

    /**
 * @summary Update device stock levels (simplified).
 */
export const useDevicesUpdateDeviceStock = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
        TError,
        {deviceId: string;data: DevicesUpdateDeviceStockBody},
        TContext
      > => {

      const mutationOptions = getDevicesUpdateDeviceStockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve brands information
 * @summary Get available device brands
 */
export const devicesGetDeviceBrands = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/brands`,options
    );
  }




export const getDevicesGetDeviceBrandsQueryKey = () => {
    return [
    `/api/devices/brands`
    ] as const;
    }

    
export const getDevicesGetDeviceBrandsQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceBrands>>> = ({ signal }) => devicesGetDeviceBrands({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceBrands>>>
export type DevicesGetDeviceBrandsQueryError = AxiosError<unknown>


export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device brands
 */

export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new device brand
 * @summary Create a new device brand
 */
export const devicesCreateDeviceBrand = (
    devicesCreateDeviceBrandBody: DevicesCreateDeviceBrandBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/devices/brands`,
      devicesCreateDeviceBrandBody,options
    );
  }



export const getDevicesCreateDeviceBrandMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext> => {

const mutationKey = ['devicesCreateDeviceBrand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, {data: DevicesCreateDeviceBrandBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDeviceBrand(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceBrandMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>>
    export type DevicesCreateDeviceBrandMutationBody = DevicesCreateDeviceBrandBody
    export type DevicesCreateDeviceBrandMutationError = AxiosError<void>

    /**
 * @summary Create a new device brand
 */
export const useDevicesCreateDeviceBrand = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
        TError,
        {data: DevicesCreateDeviceBrandBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceBrandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve categories information
 * @summary Get available device categories
 */
export const devicesGetDeviceCategories = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/categories`,options
    );
  }




export const getDevicesGetDeviceCategoriesQueryKey = () => {
    return [
    `/api/devices/categories`
    ] as const;
    }

    
export const getDevicesGetDeviceCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceCategories>>> = ({ signal }) => devicesGetDeviceCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceCategories>>>
export type DevicesGetDeviceCategoriesQueryError = AxiosError<unknown>


export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device categories
 */

export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new device category
 * @summary Create a new device category
 */
export const devicesCreateDeviceCategory = (
    devicesCreateDeviceCategoryBody: DevicesCreateDeviceCategoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DevicesCreateDeviceCategory201>> => {
    
    
    return axios.post(
      `/api/devices/categories`,
      devicesCreateDeviceCategoryBody,options
    );
  }



export const getDevicesCreateDeviceCategoryMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext> => {

const mutationKey = ['devicesCreateDeviceCategory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, {data: DevicesCreateDeviceCategoryBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDeviceCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>>
    export type DevicesCreateDeviceCategoryMutationBody = DevicesCreateDeviceCategoryBody
    export type DevicesCreateDeviceCategoryMutationError = AxiosError<void>

    /**
 * @summary Create a new device category
 */
export const useDevicesCreateDeviceCategory = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
        TError,
        {data: DevicesCreateDeviceCategoryBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve low-stock information
 * @summary Get devices with low stock levels
 */
export const devicesGetLowStockDevices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/low-stock`,options
    );
  }




export const getDevicesGetLowStockDevicesQueryKey = () => {
    return [
    `/api/devices/low-stock`
    ] as const;
    }

    
export const getDevicesGetLowStockDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetLowStockDevicesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetLowStockDevices>>> = ({ signal }) => devicesGetLowStockDevices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetLowStockDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetLowStockDevices>>>
export type DevicesGetLowStockDevicesQueryError = AxiosError<unknown>


export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get devices with low stock levels
 */

export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetLowStockDevicesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns 200 when read+write ok, 503 when write fails, and 500 when other errors occur.
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */
export const healthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/health`,options
    );
  }




export const getHealthCheckQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = AxiosError<unknown>


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of inventory items with optional filtering and pagination
 * @summary Get list of inventory items
 */
export const inventoryGetInventoryItems = (
    params?: InventoryGetInventoryItemsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetInventoryItems200>> => {
    
    
    return axios.get(
      `/api/inventory`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getInventoryGetInventoryItemsQueryKey = (params?: InventoryGetInventoryItemsParams,) => {
    return [
    `/api/inventory`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInventoryGetInventoryItemsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryItemsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryItems>>> = ({ signal }) => inventoryGetInventoryItems(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryItemsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryItems>>>
export type InventoryGetInventoryItemsQueryError = AxiosError<ErrorResponse>


export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  InventoryGetInventoryItemsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of inventory items
 */

export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryItemsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new item to inventory with quantity and details
 * @summary Create a new inventory item
 */
export const inventoryCreateInventoryItem = (
    inventoryCreateInventoryItemBody?: InventoryCreateInventoryItemBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryItem>> => {
    
    
    return axios.post(
      `/api/inventory`,
      inventoryCreateInventoryItemBody,options
    );
  }



export const getInventoryCreateInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext> => {

const mutationKey = ['inventoryCreateInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, {data: InventoryCreateInventoryItemBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateInventoryItem(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>>
    export type InventoryCreateInventoryItemMutationBody = InventoryCreateInventoryItemBody
    export type InventoryCreateInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Create a new inventory item
 */
export const useInventoryCreateInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
        TError,
        {data: InventoryCreateInventoryItemBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a single inventory item by its ID
 * @summary Get a single inventory item by ID
 */
export const inventoryGetInventoryItem = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetInventoryItem200>> => {
    
    
    return axios.get(
      `/api/inventory/${itemId}`,options
    );
  }




export const getInventoryGetInventoryItemQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}`
    ] as const;
    }

    
export const getInventoryGetInventoryItemQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryItemQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryItem>>> = ({ signal }) => inventoryGetInventoryItem(itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryItemQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryItem>>>
export type InventoryGetInventoryItemQueryError = AxiosError<ErrorResponse>


export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a single inventory item by ID
 */

export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryItemQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Remove an item from inventory
 * @summary Delete an inventory item
 */
export const inventoryDeleteInventoryItem = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/inventory/${itemId}`,options
    );
  }



export const getInventoryDeleteInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['inventoryDeleteInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  inventoryDeleteInventoryItem(itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryDeleteInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>>
    
    export type InventoryDeleteInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Delete an inventory item
 */
export const useInventoryDeleteInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getInventoryDeleteInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update an inventory item
 */
export const inventoryUpdateInventoryItem = (
    itemId: string,
    inventoryItem?: InventoryItem, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryUpdateInventoryItem200>> => {
    
    
    return axios.put(
      `/api/inventory/${itemId}`,
      inventoryItem,options
    );
  }



export const getInventoryUpdateInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext> => {

const mutationKey = ['inventoryUpdateInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, {itemId: string;data: InventoryItem}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryUpdateInventoryItem(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryUpdateInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>>
    export type InventoryUpdateInventoryItemMutationBody = InventoryItem
    export type InventoryUpdateInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Update an inventory item
 */
export const useInventoryUpdateInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
        TError,
        {itemId: string;data: InventoryItem},
        TContext
      > => {

      const mutationOptions = getInventoryUpdateInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve activity information
 * @summary Get activity log for an inventory item
 */
export const inventoryGetInventoryActivities = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/${itemId}/activity`,options
    );
  }




export const getInventoryGetInventoryActivitiesQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}/activity`
    ] as const;
    }

    
export const getInventoryGetInventoryActivitiesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryActivitiesQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>> = ({ signal }) => inventoryGetInventoryActivities(itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryActivitiesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>>
export type InventoryGetInventoryActivitiesQueryError = AxiosError<unknown>


export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get activity log for an inventory item
 */

export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryActivitiesQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new assign
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const inventoryAssignToPatient = (
    itemId: string,
    inventoryAssignToPatientBody?: InventoryAssignToPatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/${itemId}/assign`,
      inventoryAssignToPatientBody,options
    );
  }



export const getInventoryAssignToPatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext> => {

const mutationKey = ['inventoryAssignToPatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAssignToPatient>>, {itemId: string;data: InventoryAssignToPatientBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAssignToPatient(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAssignToPatientMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAssignToPatient>>>
    export type InventoryAssignToPatientMutationBody = InventoryAssignToPatientBody
    export type InventoryAssignToPatientMutationError = AxiosError<unknown>

    /**
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const useInventoryAssignToPatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAssignToPatient>>,
        TError,
        {itemId: string;data: InventoryAssignToPatientBody},
        TContext
      > => {

      const mutationOptions = getInventoryAssignToPatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new serials
 * @summary Add serial numbers to an inventory item
 */
export const inventoryAddSerialNumbers = (
    itemId: string,
    inventoryAddSerialNumbersBody?: InventoryAddSerialNumbersBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/${itemId}/serials`,
      inventoryAddSerialNumbersBody,options
    );
  }



export const getInventoryAddSerialNumbersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext> => {

const mutationKey = ['inventoryAddSerialNumbers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, {itemId: string;data: InventoryAddSerialNumbersBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAddSerialNumbers(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAddSerialNumbersMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>>
    export type InventoryAddSerialNumbersMutationBody = InventoryAddSerialNumbersBody
    export type InventoryAddSerialNumbersMutationError = AxiosError<unknown>

    /**
 * @summary Add serial numbers to an inventory item
 */
export const useInventoryAddSerialNumbers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
        TError,
        {itemId: string;data: InventoryAddSerialNumbersBody},
        TContext
      > => {

      const mutationOptions = getInventoryAddSerialNumbersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve low-stock information
 * @summary Get all items with low stock levels
 */
export const inventoryGetLowStockItems = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/low-stock`,options
    );
  }




export const getInventoryGetLowStockItemsQueryKey = () => {
    return [
    `/api/inventory/low-stock`
    ] as const;
    }

    
export const getInventoryGetLowStockItemsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetLowStockItemsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetLowStockItems>>> = ({ signal }) => inventoryGetLowStockItems({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetLowStockItemsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetLowStockItems>>>
export type InventoryGetLowStockItemsQueryError = AxiosError<unknown>


export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all items with low stock levels
 */

export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetLowStockItemsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get inventory statistics including low stock alerts
 * @summary Get inventory statistics
 */
export const inventoryGetInventoryStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/stats`,options
    );
  }




export const getInventoryGetInventoryStatsQueryKey = () => {
    return [
    `/api/inventory/stats`
    ] as const;
    }

    
export const getInventoryGetInventoryStatsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryStats>>> = ({ signal }) => inventoryGetInventoryStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryStatsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryStats>>>
export type InventoryGetInventoryStatsQueryError = AxiosError<unknown>


export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get inventory statistics
 */

export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get list of all available inventory categories
 * @summary Get all inventory categories
 */
export const inventoryGetCategories = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetCategories200>> => {
    
    
    return axios.get(
      `/api/inventory/categories`,options
    );
  }




export const getInventoryGetCategoriesQueryKey = () => {
    return [
    `/api/inventory/categories`
    ] as const;
    }

    
export const getInventoryGetCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetCategories>>> = ({ signal }) => inventoryGetCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetCategories>>>
export type InventoryGetCategoriesQueryError = AxiosError<ErrorResponse>


export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all inventory categories
 */

export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new inventory category
 * @summary Create new inventory category
 */
export const inventoryCreateCategory = (
    inventoryCreateCategoryBody: InventoryCreateCategoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryCreateCategory201>> => {
    
    
    return axios.post(
      `/api/inventory/categories`,
      inventoryCreateCategoryBody,options
    );
  }



export const getInventoryCreateCategoryMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext> => {

const mutationKey = ['inventoryCreateCategory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateCategory>>, {data: InventoryCreateCategoryBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateCategory>>>
    export type InventoryCreateCategoryMutationBody = InventoryCreateCategoryBody
    export type InventoryCreateCategoryMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create new inventory category
 */
export const useInventoryCreateCategory = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateCategory>>,
        TError,
        {data: InventoryCreateCategoryBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get list of all available inventory brands
 * @summary Get all inventory brands
 */
export const inventoryGetBrands = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetBrands200>> => {
    
    
    return axios.get(
      `/api/inventory/brands`,options
    );
  }




export const getInventoryGetBrandsQueryKey = () => {
    return [
    `/api/inventory/brands`
    ] as const;
    }

    
export const getInventoryGetBrandsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetBrands>>> = ({ signal }) => inventoryGetBrands({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetBrands>>>
export type InventoryGetBrandsQueryError = AxiosError<ErrorResponse>


export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrands>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrands>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all inventory brands
 */

export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new inventory brand
 * @summary Create new inventory brand
 */
export const inventoryCreateBrand = (
    inventoryCreateBrandBody: InventoryCreateBrandBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryCreateBrand201>> => {
    
    
    return axios.post(
      `/api/inventory/brands`,
      inventoryCreateBrandBody,options
    );
  }



export const getInventoryCreateBrandMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext> => {

const mutationKey = ['inventoryCreateBrand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateBrand>>, {data: InventoryCreateBrandBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateBrand(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateBrand>>>
    export type InventoryCreateBrandMutationBody = InventoryCreateBrandBody
    export type InventoryCreateBrandMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create new inventory brand
 */
export const useInventoryCreateBrand = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateBrand>>,
        TError,
        {data: InventoryCreateBrandBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateBrandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new invoice for a patient
 * @summary Create a new invoice
 */
export const invoicesCreateInvoice = (
    invoicesCreateInvoiceBody: InvoicesCreateInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesCreateInvoice201>> => {
    
    
    return axios.post(
      `/api/invoices`,
      invoicesCreateInvoiceBody,options
    );
  }



export const getInvoicesCreateInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext> => {

const mutationKey = ['invoicesCreateInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateInvoice>>, {data: InvoicesCreateInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateInvoice>>>
    export type InvoicesCreateInvoiceMutationBody = InvoicesCreateInvoiceBody
    export type InvoicesCreateInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new invoice
 */
export const useInvoicesCreateInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateInvoice>>,
        TError,
        {data: InvoicesCreateInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint returns a summary of created/updated rows and reports per-row errors without aborting the entire batch.
 * @summary Accept a multipart/form-data CSV/XLSX file containing invoices and create or update them in the DB.
 */
export const invoicesBulkUploadInvoices = (
    invoicesBulkUploadInvoicesBody: InvoicesBulkUploadInvoicesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesBulkUploadInvoices200>> => {
    
    const formData = new FormData();
if(invoicesBulkUploadInvoicesBody.file !== undefined) {
 formData.append(`file`, invoicesBulkUploadInvoicesBody.file)
 }

    return axios.post(
      `/api/invoices/bulk_upload`,
      formData,options
    );
  }



export const getInvoicesBulkUploadInvoicesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext> => {

const mutationKey = ['invoicesBulkUploadInvoices'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, {data: InvoicesBulkUploadInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesBulkUploadInvoices(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesBulkUploadInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>>
    export type InvoicesBulkUploadInvoicesMutationBody = InvoicesBulkUploadInvoicesBody
    export type InvoicesBulkUploadInvoicesMutationError = AxiosError<unknown>

    /**
 * @summary Accept a multipart/form-data CSV/XLSX file containing invoices and create or update them in the DB.
 */
export const useInvoicesBulkUploadInvoices = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
        TError,
        {data: InvoicesBulkUploadInvoicesBody},
        TContext
      > => {

      const mutationOptions = getInvoicesBulkUploadInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve an invoice by its ID
 * @summary Get invoice by ID
 */
export const invoicesGetInvoice = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesGetInvoice200>> => {
    
    
    return axios.get(
      `/api/invoices/${invoiceId}`,options
    );
  }




export const getInvoicesGetInvoiceQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}`
    ] as const;
    }

    
export const getInvoicesGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetInvoiceQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetInvoice>>> = ({ signal }) => invoicesGetInvoice(invoiceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetInvoice>>>
export type InvoicesGetInvoiceQueryError = AxiosError<ErrorResponse>


export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice by ID
 */

export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetInvoiceQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete an invoice by its ID
 * @summary Delete invoice by ID
 */
export const invoicesDeleteInvoice = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesDeleteInvoice200>> => {
    
    
    return axios.delete(
      `/api/invoices/${invoiceId}`,options
    );
  }



export const getInvoicesDeleteInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesDeleteInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesDeleteInvoice(invoiceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesDeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesDeleteInvoice>>>
    
    export type InvoicesDeleteInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete invoice by ID
 */
export const useInvoicesDeleteInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate and download a PDF for the specified invoice
 * @summary Generate invoice PDF
 */
export const invoicesGenerateInvoicePdf = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/invoices/${invoiceId}/pdf`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getInvoicesGenerateInvoicePdfQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}/pdf`
    ] as const;
    }

    
export const getInvoicesGenerateInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGenerateInvoicePdfQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>> = ({ signal }) => invoicesGenerateInvoicePdf(invoiceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGenerateInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>>
export type InvoicesGenerateInvoicePdfQueryError = AxiosError<ErrorResponse>


export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate invoice PDF
 */

export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGenerateInvoicePdfQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Send the invoice to Gƒ∞B (Turkish Revenue Administration)
 * @summary Send invoice to Gƒ∞B
 */
export const invoicesSendToGib = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesSendToGib200>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/send-to-gib`,undefined,options
    );
  }



export const getInvoicesSendToGibMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesSendToGib'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesSendToGib>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesSendToGib(invoiceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesSendToGibMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesSendToGib>>>
    
    export type InvoicesSendToGibMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Send invoice to Gƒ∞B
 */
export const useInvoicesSendToGib = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesSendToGib>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesSendToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve notifications information
 * @summary GET /api/notifications
 */
export const notificationsListNotifications = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Notification[]>> => {
    
    
    return axios.get(
      `/api/notifications`,options
    );
  }




export const getNotificationsListNotificationsQueryKey = () => {
    return [
    `/api/notifications`
    ] as const;
    }

    
export const getNotificationsListNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationsListNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationsListNotifications>>> = ({ signal }) => notificationsListNotifications({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationsListNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationsListNotifications>>>
export type NotificationsListNotificationsQueryError = AxiosError<unknown>


export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsListNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsListNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsListNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsListNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/notifications
 */

export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationsListNotificationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a specific notification
 * @summary DELETE /api/notifications/{notification_id}
 */
export const notificationsDeleteNotification = (
    notificationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/notifications/${notificationId}`,options
    );
  }



export const getNotificationsDeleteNotificationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext> => {

const mutationKey = ['notificationsDeleteNotification'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsDeleteNotification>>, {notificationId: string}> = (props) => {
          const {notificationId} = props ?? {};

          return  notificationsDeleteNotification(notificationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsDeleteNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsDeleteNotification>>>
    
    export type NotificationsDeleteNotificationMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/notifications/{notification_id}
 */
export const useNotificationsDeleteNotification = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsDeleteNotification>>,
        TError,
        {notificationId: string},
        TContext
      > => {

      const mutationOptions = getNotificationsDeleteNotificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update read information
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const notificationsMarkNotificationRead = (
    notificationId: string,
    notificationsMarkNotificationReadBody?: NotificationsMarkNotificationReadBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/notifications/${notificationId}/read`,
      notificationsMarkNotificationReadBody,options
    );
  }



export const getNotificationsMarkNotificationReadMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext> => {

const mutationKey = ['notificationsMarkNotificationRead'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, {notificationId: string;data: NotificationsMarkNotificationReadBody}> = (props) => {
          const {notificationId,data} = props ?? {};

          return  notificationsMarkNotificationRead(notificationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsMarkNotificationReadMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>>
    export type NotificationsMarkNotificationReadMutationBody = NotificationsMarkNotificationReadBody
    export type NotificationsMarkNotificationReadMutationError = AxiosError<unknown>

    /**
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const useNotificationsMarkNotificationRead = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
        TError,
        {notificationId: string;data: NotificationsMarkNotificationReadBody},
        TContext
      > => {

      const mutationOptions = getNotificationsMarkNotificationReadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve stats information
 * @summary GET /api/notifications/stats
 */
export const notificationsNotificationStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/notifications/stats`,options
    );
  }




export const getNotificationsNotificationStatsQueryKey = () => {
    return [
    `/api/notifications/stats`
    ] as const;
    }

    
export const getNotificationsNotificationStatsQueryOptions = <TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationsNotificationStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationsNotificationStats>>> = ({ signal }) => notificationsNotificationStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationsNotificationStatsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationsNotificationStats>>>
export type NotificationsNotificationStatsQueryError = AxiosError<unknown>


export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsNotificationStats>>,
          TError,
          Awaited<ReturnType<typeof notificationsNotificationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsNotificationStats>>,
          TError,
          Awaited<ReturnType<typeof notificationsNotificationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/notifications/stats
 */

export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationsNotificationStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new process
 * @summary POST /api/ocr/process
 */
export const sgkProcessOcr = (
    sgkProcessOcrBody?: SgkProcessOcrBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/process`,
      sgkProcessOcrBody,options
    );
  }



export const getSgkProcessOcrMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext> => {

const mutationKey = ['sgkProcessOcr'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkProcessOcr>>, {data: SgkProcessOcrBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkProcessOcr(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkProcessOcrMutationResult = NonNullable<Awaited<ReturnType<typeof sgkProcessOcr>>>
    export type SgkProcessOcrMutationBody = SgkProcessOcrBody
    export type SgkProcessOcrMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/ocr/process
 */
export const useSgkProcessOcr = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkProcessOcr>>,
        TError,
        {data: SgkProcessOcrBody},
        TContext
      > => {

      const mutationOptions = getSgkProcessOcrMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns CORS headers so the static Swagger UI served from a different origin (e.g. localhost:8080)
can fetch the YAML without browser CORS errors.
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */
export const serveOpenapiYaml = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/openapi.yaml`,options
    );
  }




export const getServeOpenapiYamlQueryKey = () => {
    return [
    `/api/openapi.yaml`
    ] as const;
    }

    
export const getServeOpenapiYamlQueryOptions = <TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeOpenapiYamlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveOpenapiYaml>>> = ({ signal }) => serveOpenapiYaml({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeOpenapiYamlQueryResult = NonNullable<Awaited<ReturnType<typeof serveOpenapiYaml>>>
export type ServeOpenapiYamlQueryError = AxiosError<unknown>


export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */

export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeOpenapiYamlQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
    params?: PatientsGetPatientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatients200>> => {
    
    
    return axios.get(
      `/api/patients`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getPatientsGetPatientsQueryKey = (params?: PatientsGetPatientsParams,) => {
    return [
    `/api/patients`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsGetPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatients>>> = ({ signal }) => patientsGetPatients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatients>>>
export type PatientsGetPatientsQueryError = AxiosError<ErrorResponse>


export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  PatientsGetPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.post(
      `/api/patients`,
      patientsCreatePatientBody,options
    );
  }



export const getPatientsCreatePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a specific patient by ID
 * @summary GET /api/patients/{patient_id}
 */
export const patientsGetPatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}`,options
    );
  }




export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<ErrorResponse>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = AxiosError<ErrorResponse>


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<ErrorResponse>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<ErrorResponse>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<ErrorResponse>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<ErrorResponse>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update patient information including demographics, contact, and CRM fields
 * @summary PUT /api/patients/{patient_id}
 */
export const patientsUpdatePatient = (
    patientId: string,
    patientsUpdatePatientBody: PatientsUpdatePatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.put(
      `/api/patients/${patientId}`,
      patientsUpdatePatientBody,options
    );
  }



export const getPatientsUpdatePatientMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: PatientsUpdatePatientBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = PatientsUpdatePatientBody
    export type PatientsUpdatePatientMutationError = AxiosError<ErrorResponse>

    /**
 * @summary PUT /api/patients/{patient_id}
 */
export const usePatientsUpdatePatient = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: PatientsUpdatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}`,options
    );
  }



export const getPatientsDeletePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/assign-devices-extended`,
      salesAssignDevicesExtendedBody,options
    );
  }



export const getSalesAssignDevicesExtendedMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatientDevices200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/devices`,options
    );
  }




export const getPatientsGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientsGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientDevices>>> = ({ signal }) => patientsGetPatientDevices(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientDevices>>>
export type PatientsGetPatientDevicesQueryError = AxiosError<unknown>


export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/ereceipts`,
      patientSubresourcesCreatePatientEreceiptBody,options
    );
  }



export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/ereceipts/${ereceiptId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/hearing-tests`,
      patientSubresourcesAddPatientHearingTestBody,options
    );
  }



export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/hearing-tests/${testId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
    patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/notes`,
      patientSubresourcesCreatePatientNoteBody,options
    );
  }



export const getPatientSubresourcesCreatePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, {patientId: string;data: PatientSubresourcesCreatePatientNoteBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientNote(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>>
    export type PatientSubresourcesCreatePatientNoteMutationBody = PatientSubresourcesCreatePatientNoteBody
    export type PatientSubresourcesCreatePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
    patientId: string,
    noteId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/notes/${noteId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  patientSubresourcesDeletePatientNote(patientId,noteId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>>
    
    export type PatientSubresourcesDeletePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/promissory-notes`,options
    );
  }




export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = AxiosError<unknown>


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sales`,options
    );
  }




export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = AxiosError<unknown>


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sgk-documents`,options
    );
  }




export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = AxiosError<unknown>


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieves all timeline events for a specific patient, including events from both custom data and activity logs
 * @summary Get timeline events for a patient
 */
export const timelineGetPatientTimeline = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineGetPatientTimeline200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/timeline`,options
    );
  }




export const getTimelineGetPatientTimelineQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/timeline`
    ] as const;
    }

    
export const getTimelineGetPatientTimelineQueryOptions = <TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineGetPatientTimelineQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineGetPatientTimeline>>> = ({ signal }) => timelineGetPatientTimeline(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineGetPatientTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof timelineGetPatientTimeline>>>
export type TimelineGetPatientTimelineQueryError = AxiosError<void>


export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get timeline events for a patient
 */

export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineGetPatientTimelineQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Creates a new timeline event for a specific patient and logs it to both custom data and activity logs
 * @summary Add a new timeline event for a patient
 */
export const timelineAddTimelineEvent = (
    patientId: string,
    timelineAddTimelineEventBody: TimelineAddTimelineEventBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineAddTimelineEvent201>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/timeline`,
      timelineAddTimelineEventBody,options
    );
  }



export const getTimelineAddTimelineEventMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext> => {

const mutationKey = ['timelineAddTimelineEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, {patientId: string;data: TimelineAddTimelineEventBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineAddTimelineEvent(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineAddTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineAddTimelineEvent>>>
    export type TimelineAddTimelineEventMutationBody = TimelineAddTimelineEventBody
    export type TimelineAddTimelineEventMutationError = AxiosError<void>

    /**
 * @summary Add a new timeline event for a patient
 */
export const useTimelineAddTimelineEvent = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
        TError,
        {patientId: string;data: TimelineAddTimelineEventBody},
        TContext
      > => {

      const mutationOptions = getTimelineAddTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Removes a specific timeline event from a patient's timeline
 * @summary Delete a timeline event
 */
export const timelineDeleteTimelineEvent = (
    patientId: string,
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineDeleteTimelineEvent200>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/timeline/${eventId}`,options
    );
  }



export const getTimelineDeleteTimelineEventMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext> => {

const mutationKey = ['timelineDeleteTimelineEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, {patientId: string;eventId: string}> = (props) => {
          const {patientId,eventId} = props ?? {};

          return  timelineDeleteTimelineEvent(patientId,eventId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineDeleteTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>>
    
    export type TimelineDeleteTimelineEventMutationError = AxiosError<void>

    /**
 * @summary Delete a timeline event
 */
export const useTimelineDeleteTimelineEvent = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
        TError,
        {patientId: string;eventId: string},
        TContext
      > => {

      const mutationOptions = getTimelineDeleteTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Alternative endpoint for adding timeline events, provides the same functionality as POST /api/patients/{patient_id}/timeline
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const timelineLogPatientActivity = (
    patientId: string,
    timelineLogPatientActivityBody: TimelineLogPatientActivityBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/activities`,
      timelineLogPatientActivityBody,options
    );
  }



export const getTimelineLogPatientActivityMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext> => {

const mutationKey = ['timelineLogPatientActivity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineLogPatientActivity>>, {patientId: string;data: TimelineLogPatientActivityBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineLogPatientActivity(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineLogPatientActivityMutationResult = NonNullable<Awaited<ReturnType<typeof timelineLogPatientActivity>>>
    export type TimelineLogPatientActivityMutationBody = TimelineLogPatientActivityBody
    export type TimelineLogPatientActivityMutationError = AxiosError<void>

    /**
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const useTimelineLogPatientActivity = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineLogPatientActivity>>,
        TError,
        {patientId: string;data: TimelineLogPatientActivityBody},
        TContext
      > => {

      const mutationOptions = getTimelineLogPatientActivityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/bulk_upload`,
      patientsBulkUploadPatientsBody,options
    );
  }



export const getPatientsBulkUploadPatientsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = AxiosError<unknown>

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/export`,options
    );
  }




export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = AxiosError<unknown>


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/search`,options
    );
  }




export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = AxiosError<unknown>


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new pricing-preview
 * @summary POST /api/pricing-preview
 */
export const salesPricingPreview = (
    salesPricingPreviewBody?: SalesPricingPreviewBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/pricing-preview`,
      salesPricingPreviewBody,options
    );
  }



export const getSalesPricingPreviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext> => {

const mutationKey = ['salesPricingPreview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesPricingPreview>>, {data: SalesPricingPreviewBody}> = (props) => {
          const {data} = props ?? {};

          return  salesPricingPreview(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesPricingPreviewMutationResult = NonNullable<Awaited<ReturnType<typeof salesPricingPreview>>>
    export type SalesPricingPreviewMutationBody = SalesPricingPreviewBody
    export type SalesPricingPreviewMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/pricing-preview
 */
export const useSalesPricingPreview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesPricingPreview>>,
        TError,
        {data: SalesPricingPreviewBody},
        TContext
      > => {

      const mutationOptions = getSalesPricingPreviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {ps_id}
 * @summary Delete a product-supplier relationship
 */
export const suppliersDeleteProductSupplier = (
    psId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/product-suppliers/${psId}`,options
    );
  }



export const getSuppliersDeleteProductSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext> => {

const mutationKey = ['suppliersDeleteProductSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, {psId: string}> = (props) => {
          const {psId} = props ?? {};

          return  suppliersDeleteProductSupplier(psId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>>
    
    export type SuppliersDeleteProductSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Delete a product-supplier relationship
 */
export const useSuppliersDeleteProductSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
        TError,
        {psId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new suppliers
 * @summary Add a supplier to a product
 */
export const suppliersAddProductSupplier = (
    productId: string,
    suppliersAddProductSupplierBody?: SuppliersAddProductSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/products/${productId}/suppliers`,
      suppliersAddProductSupplierBody,options
    );
  }



export const getSuppliersAddProductSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext> => {

const mutationKey = ['suppliersAddProductSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, {productId: string;data: SuppliersAddProductSupplierBody}> = (props) => {
          const {productId,data} = props ?? {};

          return  suppliersAddProductSupplier(productId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersAddProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersAddProductSupplier>>>
    export type SuppliersAddProductSupplierMutationBody = SuppliersAddProductSupplierBody
    export type SuppliersAddProductSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Add a supplier to a product
 */
export const useSuppliersAddProductSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
        TError,
        {productId: string;data: SuppliersAddProductSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersAddProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create multiple promissory notes
 */
export const paymentsCreatePromissoryNotes = (
    paymentsCreatePromissoryNotesBody?: PaymentsCreatePromissoryNotesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes`,
      paymentsCreatePromissoryNotesBody,options
    );
  }



export const getPaymentsCreatePromissoryNotesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext> => {

const mutationKey = ['paymentsCreatePromissoryNotes'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, {data: PaymentsCreatePromissoryNotesBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePromissoryNotes(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePromissoryNotesMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>>
    export type PaymentsCreatePromissoryNotesMutationBody = PaymentsCreatePromissoryNotesBody
    export type PaymentsCreatePromissoryNotesMutationError = AxiosError<unknown>

    /**
 * @summary Create multiple promissory notes
 */
export const usePaymentsCreatePromissoryNotes = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
        TError,
        {data: PaymentsCreatePromissoryNotesBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePromissoryNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a promissory note
 */
export const paymentsUpdatePromissoryNote = (
    noteId: string,
    paymentsUpdatePromissoryNoteBody?: PaymentsUpdatePromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/promissory-notes/${noteId}`,
      paymentsUpdatePromissoryNoteBody,options
    );
  }



export const getPaymentsUpdatePromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsUpdatePromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, {noteId: string;data: PaymentsUpdatePromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsUpdatePromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>>
    export type PaymentsUpdatePromissoryNoteMutationBody = PaymentsUpdatePromissoryNoteBody
    export type PaymentsUpdatePromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Update a promissory note
 */
export const usePaymentsUpdatePromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsUpdatePromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const paymentsCollectPromissoryNote = (
    noteId: string,
    paymentsCollectPromissoryNoteBody?: PaymentsCollectPromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes/${noteId}/collect`,
      paymentsCollectPromissoryNoteBody,options
    );
  }



export const getPaymentsCollectPromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsCollectPromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, {noteId: string;data: PaymentsCollectPromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsCollectPromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCollectPromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>>
    export type PaymentsCollectPromissoryNoteMutationBody = PaymentsCollectPromissoryNoteBody
    export type PaymentsCollectPromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const usePaymentsCollectPromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsCollectPromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCollectPromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new register-phone
 * @summary POST /api/register-phone
 */
export const registrationRegisterPhone = (
    registrationRegisterPhoneBody?: RegistrationRegisterPhoneBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/register-phone`,
      registrationRegisterPhoneBody,options
    );
  }



export const getRegistrationRegisterPhoneMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext> => {

const mutationKey = ['registrationRegisterPhone'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationRegisterPhone>>, {data: RegistrationRegisterPhoneBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationRegisterPhone(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationRegisterPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof registrationRegisterPhone>>>
    export type RegistrationRegisterPhoneMutationBody = RegistrationRegisterPhoneBody
    export type RegistrationRegisterPhoneMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/register-phone
 */
export const useRegistrationRegisterPhone = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationRegisterPhone>>,
        TError,
        {data: RegistrationRegisterPhoneBody},
        TContext
      > => {

      const mutationOptions = getRegistrationRegisterPhoneMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve appointments information
 * @summary GET /api/reports/appointments
 */
export const reportsReportAppointments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/appointments`,options
    );
  }




export const getReportsReportAppointmentsQueryKey = () => {
    return [
    `/api/reports/appointments`
    ] as const;
    }

    
export const getReportsReportAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportAppointments>>> = ({ signal }) => reportsReportAppointments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportAppointments>>>
export type ReportsReportAppointmentsQueryError = AxiosError<unknown>


export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/appointments
 */

export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve campaigns information
 * @summary Kampanya raporu
 */
export const reportsReportCampaigns = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/campaigns`,options
    );
  }




export const getReportsReportCampaignsQueryKey = () => {
    return [
    `/api/reports/campaigns`
    ] as const;
    }

    
export const getReportsReportCampaignsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportCampaignsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportCampaigns>>> = ({ signal }) => reportsReportCampaigns({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportCampaigns>>>
export type ReportsReportCampaignsQueryError = AxiosError<unknown>


export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Kampanya raporu
 */

export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportCampaignsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve financial information
 * @summary Mali rapor
 */
export const reportsReportFinancial = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/financial`,options
    );
  }




export const getReportsReportFinancialQueryKey = () => {
    return [
    `/api/reports/financial`
    ] as const;
    }

    
export const getReportsReportFinancialQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportFinancialQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportFinancial>>> = ({ signal }) => reportsReportFinancial({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportFinancialQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportFinancial>>>
export type ReportsReportFinancialQueryError = AxiosError<unknown>


export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Mali rapor
 */

export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportFinancialQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve overview information
 * @summary Genel rapor √∂zeti
 */
export const reportsReportOverview = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/overview`,options
    );
  }




export const getReportsReportOverviewQueryKey = () => {
    return [
    `/api/reports/overview`
    ] as const;
    }

    
export const getReportsReportOverviewQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportOverviewQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportOverview>>> = ({ signal }) => reportsReportOverview({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportOverviewQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportOverview>>>
export type ReportsReportOverviewQueryError = AxiosError<unknown>


export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Genel rapor √∂zeti
 */

export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportOverviewQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve patients information
 * @summary Hasta analizi raporu
 */
export const reportsReportPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/patients`,options
    );
  }




export const getReportsReportPatientsQueryKey = () => {
    return [
    `/api/reports/patients`
    ] as const;
    }

    
export const getReportsReportPatientsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPatients>>> = ({ signal }) => reportsReportPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPatients>>>
export type ReportsReportPatientsQueryError = AxiosError<unknown>


export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Hasta analizi raporu
 */

export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve revenue information
 * @summary GET /api/reports/revenue
 */
export const reportsReportRevenue = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/revenue`,options
    );
  }




export const getReportsReportRevenueQueryKey = () => {
    return [
    `/api/reports/revenue`
    ] as const;
    }

    
export const getReportsReportRevenueQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportRevenueQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportRevenue>>> = ({ signal }) => reportsReportRevenue({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportRevenueQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportRevenue>>>
export type ReportsReportRevenueQueryError = AxiosError<unknown>


export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/revenue
 */

export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportRevenueQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all sales
 * @summary GET /api/sales
 */
export const salesListSales = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale[]>> => {
    
    
    return axios.get(
      `/api/sales`,options
    );
  }




export const getSalesListSalesQueryKey = () => {
    return [
    `/api/sales`
    ] as const;
    }

    
export const getSalesListSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesListSalesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesListSales>>> = ({ signal }) => salesListSales({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesListSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesListSales>>>
export type SalesListSalesQueryError = AxiosError<unknown>


export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesListSales>>,
          TError,
          Awaited<ReturnType<typeof salesListSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesListSales>>,
          TError,
          Awaited<ReturnType<typeof salesListSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sales
 */

export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesListSalesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new sale
 * @summary POST /api/sales
 */
export const salesCreateSale = (
    salesCreateSaleBody: SalesCreateSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.post(
      `/api/sales`,
      salesCreateSaleBody,options
    );
  }



export const getSalesCreateSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext> => {

const mutationKey = ['salesCreateSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSale>>, {data: SalesCreateSaleBody}> = (props) => {
          const {data} = props ?? {};

          return  salesCreateSale(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSale>>>
    export type SalesCreateSaleMutationBody = SalesCreateSaleBody
    export type SalesCreateSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary POST /api/sales
 */
export const useSalesCreateSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSale>>,
        TError,
        {data: SalesCreateSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get sale details by ID
 * @summary GET /api/sales/{sale_id}
 */
export const salesGetSale = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}`,options
    );
  }




export const getSalesGetSaleQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}`
    ] as const;
    }

    
export const getSalesGetSaleQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSaleQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSale>>> = ({ signal }) => salesGetSale(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSaleQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSale>>>
export type SalesGetSaleQueryError = AxiosError<ErrorResponse>


export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSale>>,
          TError,
          Awaited<ReturnType<typeof salesGetSale>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSale>>,
          TError,
          Awaited<ReturnType<typeof salesGetSale>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sales/{sale_id}
 */

export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSaleQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update sale information
 * @summary PUT /api/sales/{sale_id}
 */
export const salesUpdateSale = (
    saleId: string,
    salesUpdateSaleBody: SalesUpdateSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.put(
      `/api/sales/${saleId}`,
      salesUpdateSaleBody,options
    );
  }



export const getSalesUpdateSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext> => {

const mutationKey = ['salesUpdateSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSale>>, {saleId: string;data: SalesUpdateSaleBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesUpdateSale(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSale>>>
    export type SalesUpdateSaleMutationBody = SalesUpdateSaleBody
    export type SalesUpdateSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary PUT /api/sales/{sale_id}
 */
export const useSalesUpdateSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSale>>,
        TError,
        {saleId: string;data: SalesUpdateSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a sale
 * @summary DELETE /api/sales/{sale_id}
 */
export const salesDeleteSale = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sales/${saleId}`,options
    );
  }



export const getSalesDeleteSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext> => {

const mutationKey = ['salesDeleteSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesDeleteSale>>, {saleId: string}> = (props) => {
          const {saleId} = props ?? {};

          return  salesDeleteSale(saleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesDeleteSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesDeleteSale>>>
    
    export type SalesDeleteSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary DELETE /api/sales/{sale_id}
 */
export const useSalesDeleteSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesDeleteSale>>,
        TError,
        {saleId: string},
        TContext
      > => {

      const mutationOptions = getSalesDeleteSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new payment-plan
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const salesCreateSalePaymentPlan = (
    saleId: string,
    salesCreateSalePaymentPlanBody?: SalesCreateSalePaymentPlanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentRecord>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/payment-plan`,
      salesCreateSalePaymentPlanBody,options
    );
  }



export const getSalesCreateSalePaymentPlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext> => {

const mutationKey = ['salesCreateSalePaymentPlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, {saleId: string;data: SalesCreateSalePaymentPlanBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSalePaymentPlan(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalePaymentPlanMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>>
    export type SalesCreateSalePaymentPlanMutationBody = SalesCreateSalePaymentPlanBody
    export type SalesCreateSalePaymentPlanMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const useSalesCreateSalePaymentPlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
        TError,
        {saleId: string;data: SalesCreateSalePaymentPlanBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalePaymentPlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all promissory notes for a specific sale
 */
export const paymentsGetSalePromissoryNotes = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/promissory-notes`,options
    );
  }




export const getPaymentsGetSalePromissoryNotesQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetSalePromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetSalePromissoryNotesQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>> = ({ signal }) => paymentsGetSalePromissoryNotes(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetSalePromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>>
export type PaymentsGetSalePromissoryNotesQueryError = AxiosError<unknown>


export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a specific sale
 */

export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetSalePromissoryNotesQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create an invoice for the specified sale
 * @summary Create invoice for sale
 */
export const salesCreateSaleInvoice = (
    saleId: string,
    salesCreateSaleInvoiceBody: SalesCreateSaleInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SalesCreateSaleInvoice201>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/invoice`,
      salesCreateSaleInvoiceBody,options
    );
  }



export const getSalesCreateSaleInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext> => {

const mutationKey = ['salesCreateSaleInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, {saleId: string;data: SalesCreateSaleInvoiceBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSaleInvoice(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSaleInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSaleInvoice>>>
    export type SalesCreateSaleInvoiceMutationBody = SalesCreateSaleInvoiceBody
    export type SalesCreateSaleInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create invoice for sale
 */
export const useSalesCreateSaleInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
        TError,
        {saleId: string;data: SalesCreateSaleInvoiceBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSaleInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve the invoice for the specified sale
 * @summary Get invoice for sale
 */
export const salesGetSaleInvoice = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SalesGetSaleInvoice200>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/invoice`,options
    );
  }




export const getSalesGetSaleInvoiceQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice`
    ] as const;
    }

    
export const getSalesGetSaleInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSaleInvoiceQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSaleInvoice>>> = ({ signal }) => salesGetSaleInvoice(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSaleInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSaleInvoice>>>
export type SalesGetSaleInvoiceQueryError = AxiosError<ErrorResponse>


export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof salesGetSaleInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof salesGetSaleInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice for sale
 */

export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSaleInvoiceQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Generate and download a PDF for the specified sale invoice
 * @summary Generate sale invoice PDF
 */
export const salesGenerateSaleInvoicePdf = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/invoice/pdf`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getSalesGenerateSaleInvoicePdfQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice/pdf`
    ] as const;
    }

    
export const getSalesGenerateSaleInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGenerateSaleInvoicePdfQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>> = ({ signal }) => salesGenerateSaleInvoicePdf(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGenerateSaleInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>>
export type SalesGenerateSaleInvoicePdfQueryError = AxiosError<ErrorResponse>


export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate sale invoice PDF
 */

export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGenerateSaleInvoicePdfQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update settings information
 * @summary Update system settings
 */
export const updateSettings = (
    updateSettingsBody?: UpdateSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/settings`,
      updateSettingsBody,options
    );
  }



export const getUpdateSettingsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext> => {

const mutationKey = ['updateSettings'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSettings>>, {data: UpdateSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  updateSettings(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateSettings>>>
    export type UpdateSettingsMutationBody = UpdateSettingsBody
    export type UpdateSettingsMutationError = AxiosError<unknown>

    /**
 * @summary Update system settings
 */
export const useUpdateSettings = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSettings>>,
        TError,
        {data: UpdateSettingsBody},
        TContext
      > => {

      const mutationOptions = getUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
    sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/documents`,
      sgkUploadSgkDocumentBody,options
    );
  }



export const getSgkUploadSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext> => {

const mutationKey = ['sgkUploadSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, {data: SgkUploadSgkDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadSgkDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadSgkDocument>>>
    export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody
    export type SgkUploadSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
        TError,
        {data: SgkUploadSgkDocumentBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (
    documentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sgk/documents/${documentId}`,options
    );
  }



export const getSgkDeleteSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['sgkDeleteSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  sgkDeleteSgkDocument(documentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkDeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>>
    
    export type SgkDeleteSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sms/monitoring`,options
    );
  }




export const getSmsMonitoringQueryKey = () => {
    return [
    `/api/sms/monitoring`
    ] as const;
    }

    
export const getSmsMonitoringQueryOptions = <TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({ signal }) => smsMonitoring({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsMonitoringQueryResult = NonNullable<Awaited<ReturnType<typeof smsMonitoring>>>
export type SmsMonitoringQueryError = AxiosError<unknown>


export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsMonitoringQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of suppliers with optional filtering and pagination
 * @summary Get list of suppliers
 */
export const suppliersGetSuppliers = (
    params?: SuppliersGetSuppliersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSuppliers200>> => {
    
    
    return axios.get(
      `/api/suppliers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSuppliersGetSuppliersQueryKey = (params?: SuppliersGetSuppliersParams,) => {
    return [
    `/api/suppliers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSuppliersGetSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSuppliersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSuppliers>>> = ({ signal }) => suppliersGetSuppliers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSuppliers>>>
export type SuppliersGetSuppliersQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  SuppliersGetSuppliersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of suppliers
 */

export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSuppliersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new supplier with contact and business information
 * @summary Create a new supplier
 */
export const suppliersCreateSupplier = (
    suppliersCreateSupplierBody?: SuppliersCreateSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supplier>> => {
    
    
    return axios.post(
      `/api/suppliers`,
      suppliersCreateSupplierBody,options
    );
  }



export const getSuppliersCreateSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext> => {

const mutationKey = ['suppliersCreateSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersCreateSupplier>>, {data: SuppliersCreateSupplierBody}> = (props) => {
          const {data} = props ?? {};

          return  suppliersCreateSupplier(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersCreateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersCreateSupplier>>>
    export type SuppliersCreateSupplierMutationBody = SuppliersCreateSupplierBody
    export type SuppliersCreateSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Create a new supplier
 */
export const useSuppliersCreateSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersCreateSupplier>>,
        TError,
        {data: SuppliersCreateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersCreateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a supplier from the system
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const suppliersDeleteSupplier = (
    supplierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/suppliers/${supplierId}`,options
    );
  }



export const getSuppliersDeleteSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext> => {

const mutationKey = ['suppliersDeleteSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, {supplierId: string}> = (props) => {
          const {supplierId} = props ?? {};

          return  suppliersDeleteSupplier(supplierId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteSupplier>>>
    
    export type SuppliersDeleteSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const useSuppliersDeleteSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
        TError,
        {supplierId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update an existing supplier's information
 * @summary Update supplier details
 */
export const suppliersUpdateSupplier = (
    supplierId: string,
    createSupplierBody: CreateSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supplier>> => {
    
    
    return axios.put(
      `/api/suppliers/${supplierId}`,
      createSupplierBody,options
    );
  }



export const getSuppliersUpdateSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: CreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: CreateSupplierBody}, TContext> => {

const mutationKey = ['suppliersUpdateSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, {supplierId: string;data: CreateSupplierBody}> = (props) => {
          const {supplierId,data} = props ?? {};

          return  suppliersUpdateSupplier(supplierId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersUpdateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersUpdateSupplier>>>
    export type SuppliersUpdateSupplierMutationBody = CreateSupplierBody
    export type SuppliersUpdateSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update supplier details
 */
export const useSuppliersUpdateSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: CreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
        TError,
        {supplierId: string;data: CreateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersUpdateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get list of products available from a specific supplier
 * @summary Get all products for a specific supplier
 */
export const suppliersGetSupplierProducts = (
    supplierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/suppliers/${supplierId}/products`,options
    );
  }




export const getSuppliersGetSupplierProductsQueryKey = (supplierId?: string,) => {
    return [
    `/api/suppliers/${supplierId}/products`
    ] as const;
    }

    
export const getSuppliersGetSupplierProductsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierProductsQueryKey(supplierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>> = ({ signal }) => suppliersGetSupplierProducts(supplierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierProductsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>>
export type SuppliersGetSupplierProductsQueryError = AxiosError<unknown>


export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all products for a specific supplier
 */

export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierProductsQueryOptions(supplierId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get supplier statistics including order history
 * @summary Get supplier statistics
 */
export const suppliersGetSupplierStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/suppliers/stats`,options
    );
  }




export const getSuppliersGetSupplierStatsQueryKey = () => {
    return [
    `/api/suppliers/stats`
    ] as const;
    }

    
export const getSuppliersGetSupplierStatsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierStats>>> = ({ signal }) => suppliersGetSupplierStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierStatsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierStats>>>
export type SuppliersGetSupplierStatsQueryError = AxiosError<unknown>


export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get supplier statistics
 */

export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This endpoint returns a summary of created/updated rows and reports per-row errors without aborting the entire batch.
 * @summary Accept a multipart/form-data CSV/XLSX file containing suppliers and upsert them into the DB.
 */
export const suppliersBulkUploadSuppliers = (
    suppliersBulkUploadSuppliersBody?: SuppliersBulkUploadSuppliersBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/suppliers/bulk_upload`,
      suppliersBulkUploadSuppliersBody,options
    );
  }



export const getSuppliersBulkUploadSuppliersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext> => {

const mutationKey = ['suppliersBulkUploadSuppliers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, {data: SuppliersBulkUploadSuppliersBody}> = (props) => {
          const {data} = props ?? {};

          return  suppliersBulkUploadSuppliers(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersBulkUploadSuppliersMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>>
    export type SuppliersBulkUploadSuppliersMutationBody = SuppliersBulkUploadSuppliersBody
    export type SuppliersBulkUploadSuppliersMutationError = AxiosError<unknown>

    /**
 * @summary Accept a multipart/form-data CSV/XLSX file containing suppliers and upsert them into the DB.
 */
export const useSuppliersBulkUploadSuppliers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
        TError,
        {data: SuppliersBulkUploadSuppliersBody},
        TContext
      > => {

      const mutationOptions = getSuppliersBulkUploadSuppliersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve purchase invoices for the specified supplier
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */
export const suppliersGetSupplierInvoices = (
    supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSupplierInvoices200>> => {
    
    
    return axios.get(
      `/api/suppliers/${supplierId}/invoices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSuppliersGetSupplierInvoicesQueryKey = (supplierId?: string,
    params?: SuppliersGetSupplierInvoicesParams,) => {
    return [
    `/api/suppliers/${supplierId}/invoices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSuppliersGetSupplierInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierInvoicesQueryKey(supplierId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>> = ({ signal }) => suppliersGetSupplierInvoices(supplierId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>>
export type SuppliersGetSupplierInvoicesQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params: undefined |  SuppliersGetSupplierInvoicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */

export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierInvoicesQueryOptions(supplierId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of suggested suppliers based on incoming invoices
 * @summary Get suggested suppliers (pending approval)
 */
export const suppliersGetSuggestedSuppliers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSuggestedSuppliers200>> => {
    
    
    return axios.get(
      `/api/suppliers/suggested`,options
    );
  }




export const getSuppliersGetSuggestedSuppliersQueryKey = () => {
    return [
    `/api/suppliers/suggested`
    ] as const;
    }

    
export const getSuppliersGetSuggestedSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSuggestedSuppliersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>> = ({ signal }) => suppliersGetSuggestedSuppliers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSuggestedSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>>
export type SuppliersGetSuggestedSuppliersQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get suggested suppliers (pending approval)
 */

export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSuggestedSuppliersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Accept a suggested supplier and create or link to a supplier by tax number
 * @summary Accept suggested supplier and create/link supplier record
 */
export const suppliersAcceptSuggestedSupplier = (
    suggestedId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersAcceptSuggestedSupplier200 | SuppliersAcceptSuggestedSupplier201>> => {
    
    
    return axios.post(
      `/api/suppliers/suggested/${suggestedId}/accept`,undefined,options
    );
  }



export const getSuppliersAcceptSuggestedSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext> => {

const mutationKey = ['suppliersAcceptSuggestedSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, {suggestedId: string}> = (props) => {
          const {suggestedId} = props ?? {};

          return  suppliersAcceptSuggestedSupplier(suggestedId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersAcceptSuggestedSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>>
    
    export type SuppliersAcceptSuggestedSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Accept suggested supplier and create/link supplier record
 */
export const useSuppliersAcceptSuggestedSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
        TError,
        {suggestedId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersAcceptSuggestedSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reject and mark a suggested supplier as rejected
 * @summary Reject a suggested supplier
 */
export const suppliersRejectSuggestedSupplier = (
    suggestedId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersRejectSuggestedSupplier200>> => {
    
    
    return axios.delete(
      `/api/suppliers/suggested/${suggestedId}`,options
    );
  }



export const getSuppliersRejectSuggestedSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext> => {

const mutationKey = ['suppliersRejectSuggestedSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, {suggestedId: string}> = (props) => {
          const {suggestedId} = props ?? {};

          return  suppliersRejectSuggestedSupplier(suggestedId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersRejectSuggestedSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>>
    
    export type SuppliersRejectSuggestedSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Reject a suggested supplier
 */
export const useSuppliersRejectSuggestedSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
        TError,
        {suggestedId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersRejectSuggestedSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Trigger invoice synchronization from integrator to local database
 * @summary Sync invoices from BirFatura provider
 */
export const birfaturaSyncInvoices = (
    birfaturaSyncInvoicesBody?: BirfaturaSyncInvoicesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BirfaturaSyncInvoices200>> => {
    
    
    return axios.post(
      `/api/birfatura/sync-invoices`,
      birfaturaSyncInvoicesBody,options
    );
  }



export const getBirfaturaSyncInvoicesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext> => {

const mutationKey = ['birfaturaSyncInvoices'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, {data: BirfaturaSyncInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaSyncInvoices(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaSyncInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaSyncInvoices>>>
    export type BirfaturaSyncInvoicesMutationBody = BirfaturaSyncInvoicesBody
    export type BirfaturaSyncInvoicesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Sync invoices from BirFatura provider
 */
export const useBirfaturaSyncInvoices = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
        TError,
        {data: BirfaturaSyncInvoicesBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaSyncInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new verify-registration-otp
 * @summary POST /api/verify-registration-otp
 */
export const registrationVerifyRegistrationOtp = (
    registrationVerifyRegistrationOtpBody?: RegistrationVerifyRegistrationOtpBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/verify-registration-otp`,
      registrationVerifyRegistrationOtpBody,options
    );
  }



export const getRegistrationVerifyRegistrationOtpMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext> => {

const mutationKey = ['registrationVerifyRegistrationOtp'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, {data: RegistrationVerifyRegistrationOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationVerifyRegistrationOtp(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationVerifyRegistrationOtpMutationResult = NonNullable<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>>
    export type RegistrationVerifyRegistrationOtpMutationBody = RegistrationVerifyRegistrationOtpBody
    export type RegistrationVerifyRegistrationOtpMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/verify-registration-otp
 */
export const useRegistrationVerifyRegistrationOtp = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
        TError,
        {data: RegistrationVerifyRegistrationOtpBody},
        TContext
      > => {

      const mutationOptions = getRegistrationVerifyRegistrationOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a list of all users
 * @summary GET /api/users
 */
export const usersListUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User[]>> => {
    
    
    return axios.get(
      `/api/users`,options
    );
  }




export const getUsersListUsersQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getUsersListUsersQueryOptions = <TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersListUsers>>> = ({ signal }) => usersListUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersListUsers>>>
export type UsersListUsersQueryError = AxiosError<unknown>


export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users
 */

export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user
 * @summary POST /api/users
 */
export const usersCreateUser = (
    usersCreateUserBody: UsersCreateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.post(
      `/api/users`,
      usersCreateUserBody,options
    );
  }



export const getUsersCreateUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext> => {

const mutationKey = ['usersCreateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreateUser>>, {data: UsersCreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  usersCreateUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreateUser>>>
    export type UsersCreateUserMutationBody = UsersCreateUserBody
    export type UsersCreateUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary POST /api/users
 */
export const useUsersCreateUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersCreateUser>>,
        TError,
        {data: UsersCreateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get user details by ID
 * @summary GET /api/users/{user_id}
 */
export const usersGetUser = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.get(
      `/api/users/${userId}`,options
    );
  }




export const getUsersGetUserQueryKey = (userId?: string,) => {
    return [
    `/api/users/${userId}`
    ] as const;
    }

    
export const getUsersGetUserQueryOptions = <TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUser>>> = ({ signal }) => usersGetUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersGetUserQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetUser>>>
export type UsersGetUserQueryError = AxiosError<ErrorResponse>


export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users/{user_id}
 */

export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update user information
 * @summary PUT /api/users/{user_id}
 */
export const usersUpdateUser = (
    userId: string,
    usersUpdateUserBody: UsersUpdateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.put(
      `/api/users/${userId}`,
      usersUpdateUserBody,options
    );
  }



export const getUsersUpdateUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext> => {

const mutationKey = ['usersUpdateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateUser>>, {userId: string;data: UsersUpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersUpdateUser(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateUser>>>
    export type UsersUpdateUserMutationBody = UsersUpdateUserBody
    export type UsersUpdateUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary PUT /api/users/{user_id}
 */
export const useUsersUpdateUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateUser>>,
        TError,
        {userId: string;data: UsersUpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a user
 * @summary DELETE /api/users/{user_id}
 */
export const usersDeleteUser = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/users/${userId}`,options
    );
  }



export const getUsersDeleteUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['usersDeleteUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  usersDeleteUser(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUser>>>
    
    export type UsersDeleteUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary DELETE /api/users/{user_id}
 */
export const useUsersDeleteUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getUsersDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get current authenticated user information
 * @summary GET /api/users/me
 */
export const usersGetCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.get(
      `/api/users/me`,options
    );
  }




export const getUsersGetCurrentUserQueryKey = () => {
    return [
    `/api/users/me`
    ] as const;
    }

    
export const getUsersGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetCurrentUser>>> = ({ signal }) => usersGetCurrentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersGetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetCurrentUser>>>
export type UsersGetCurrentUserQueryError = AxiosError<ErrorResponse>


export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users/me
 */

export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update current user profile
 */
export const usersUpdateMe = (
    usersUpdateMeBody: UsersUpdateMeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.put(
      `/api/users/me`,
      usersUpdateMeBody,options
    );
  }



export const getUsersUpdateMeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext> => {

const mutationKey = ['usersUpdateMe'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateMe>>, {data: UsersUpdateMeBody}> = (props) => {
          const {data} = props ?? {};

          return  usersUpdateMe(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateMe>>>
    export type UsersUpdateMeMutationBody = UsersUpdateMeBody
    export type UsersUpdateMeMutationError = AxiosError<unknown>

    /**
 * @summary Update current user profile
 */
export const useUsersUpdateMe = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateMe>>,
        TError,
        {data: UsersUpdateMeBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateMeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Change current user password
 */
export const usersChangePassword = (
    usersChangePasswordBody: UsersChangePasswordBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UsersChangePassword200>> => {
    
    
    return axios.post(
      `/api/users/me/password`,
      usersChangePasswordBody,options
    );
  }



export const getUsersChangePasswordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext> => {

const mutationKey = ['usersChangePassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersChangePassword>>, {data: UsersChangePasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  usersChangePassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersChangePassword>>>
    export type UsersChangePasswordMutationBody = UsersChangePasswordBody
    export type UsersChangePasswordMutationError = AxiosError<unknown>

    /**
 * @summary Change current user password
 */
export const useUsersChangePassword = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersChangePassword>>,
        TError,
        {data: UsersChangePasswordBody},
        TContext
      > => {

      const mutationOptions = getUsersChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List tenant users
 */
export const tenantUsersList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersList200>> => {
    
    
    return axios.get(
      `/api/tenant/users`,options
    );
  }




export const getTenantUsersListQueryKey = () => {
    return [
    `/api/tenant/users`
    ] as const;
    }

    
export const getTenantUsersListQueryOptions = <TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTenantUsersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantUsersList>>> = ({ signal }) => tenantUsersList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TenantUsersListQueryResult = NonNullable<Awaited<ReturnType<typeof tenantUsersList>>>
export type TenantUsersListQueryError = AxiosError<unknown>


export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersList>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersList>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List tenant users
 */

export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTenantUsersListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Invite/Create tenant user
 */
export const tenantUsersInvite = (
    tenantUsersInviteBody: TenantUsersInviteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersInvite201>> => {
    
    
    return axios.post(
      `/api/tenant/users`,
      tenantUsersInviteBody,options
    );
  }



export const getTenantUsersInviteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext> => {

const mutationKey = ['tenantUsersInvite'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersInvite>>, {data: TenantUsersInviteBody}> = (props) => {
          const {data} = props ?? {};

          return  tenantUsersInvite(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersInviteMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersInvite>>>
    export type TenantUsersInviteMutationBody = TenantUsersInviteBody
    export type TenantUsersInviteMutationError = AxiosError<unknown>

    /**
 * @summary Invite/Create tenant user
 */
export const useTenantUsersInvite = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersInvite>>,
        TError,
        {data: TenantUsersInviteBody},
        TContext
      > => {

      const mutationOptions = getTenantUsersInviteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete tenant user
 */
export const tenantUsersDelete = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersDelete200>> => {
    
    
    return axios.delete(
      `/api/tenant/users/${userId}`,options
    );
  }



export const getTenantUsersDeleteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext> => {

const mutationKey = ['tenantUsersDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersDelete>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  tenantUsersDelete(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersDelete>>>
    
    export type TenantUsersDeleteMutationError = AxiosError<unknown>

    /**
 * @summary Delete tenant user
 */
export const useTenantUsersDelete = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersDelete>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getTenantUsersDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new entities
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntities = (
    ocrExtractEntitiesBody?: OcrExtractEntitiesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/entities`,
      ocrExtractEntitiesBody,options
    );
  }



export const getOcrExtractEntitiesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext> => {

const mutationKey = ['ocrExtractEntities'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractEntities>>, {data: OcrExtractEntitiesBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractEntities(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractEntitiesMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractEntities>>>
    export type OcrExtractEntitiesMutationBody = OcrExtractEntitiesBody
    export type OcrExtractEntitiesMutationError = AxiosError<unknown>

    /**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntities = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractEntities>>,
        TError,
        {data: OcrExtractEntitiesBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractEntitiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Extract patient name from document image using OCR
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientName = (
    ocrExtractPatientNameBody?: OcrExtractPatientNameBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/extract_patient`,
      ocrExtractPatientNameBody,options
    );
  }



export const getOcrExtractPatientNameMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext> => {

const mutationKey = ['ocrExtractPatientName'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractPatientName>>, {data: OcrExtractPatientNameBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractPatientName(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractPatientNameMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractPatientName>>>
    export type OcrExtractPatientNameMutationBody = OcrExtractPatientNameBody
    export type OcrExtractPatientNameMutationError = AxiosError<unknown>

    /**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientName = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractPatientName>>,
        TError,
        {data: OcrExtractPatientNameBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractPatientNameMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Health check for OCR service availability
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/health`,options
    );
  }




export const getOcrHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getOcrHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOcrHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheck>>> = ({ signal }) => ocrHealthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type OcrHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof ocrHealthCheck>>>
export type OcrHealthCheckQueryError = AxiosError<unknown>


export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getOcrHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Initialize OCR service database and create required tables
 * @summary Initialize database and create tables
 */
export const ocrInitDatabase = (
    ocrInitDatabaseBody?: OcrInitDatabaseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/init-db`,
      ocrInitDatabaseBody,options
    );
  }



export const getOcrInitDatabaseMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext> => {

const mutationKey = ['ocrInitDatabase'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitDatabase>>, {data: OcrInitDatabaseBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitDatabase(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitDatabase>>>
    export type OcrInitDatabaseMutationBody = OcrInitDatabaseBody
    export type OcrInitDatabaseMutationError = AxiosError<unknown>

    /**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabase = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitDatabase>>,
        TError,
        {data: OcrInitDatabaseBody},
        TContext
      > => {

      const mutationOptions = getOcrInitDatabaseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Initialize NLP/OCR processing service
 * @summary Initialize NLP/OCR service
 */
export const ocrInitializeNlpEndpoint = (
    ocrInitializeNlpEndpointBody?: OcrInitializeNlpEndpointBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/initialize`,
      ocrInitializeNlpEndpointBody,options
    );
  }



export const getOcrInitializeNlpEndpointMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext> => {

const mutationKey = ['ocrInitializeNlpEndpoint'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, {data: OcrInitializeNlpEndpointBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitializeNlpEndpoint(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitializeNlpEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>>
    export type OcrInitializeNlpEndpointMutationBody = OcrInitializeNlpEndpointBody
    export type OcrInitializeNlpEndpointMutationError = AxiosError<unknown>

    /**
 * @summary Initialize NLP/OCR service
 */
export const useOcrInitializeNlpEndpoint = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
        TError,
        {data: OcrInitializeNlpEndpointBody},
        TContext
      > => {

      const mutationOptions = getOcrInitializeNlpEndpointMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Process document using OCR to extract text and data
 * @summary Process document with OCR
 */
export const ocrProcessDocument = (
    ocrProcessDocumentBody?: OcrProcessDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/process`,
      ocrProcessDocumentBody,options
    );
  }



export const getOcrProcessDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext> => {

const mutationKey = ['ocrProcessDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrProcessDocument>>, {data: OcrProcessDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrProcessDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrProcessDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof ocrProcessDocument>>>
    export type OcrProcessDocumentMutationBody = OcrProcessDocumentBody
    export type OcrProcessDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Process document with OCR
 */
export const useOcrProcessDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrProcessDocument>>,
        TError,
        {data: OcrProcessDocumentBody},
        TContext
      > => {

      const mutationOptions = getOcrProcessDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Calculate similarity between documents using OCR text analysis
 * @summary Calculate similarity between two images using OCR text
 */
export const ocrCalculateSimilarity = (
    ocrCalculateSimilarityBody?: OcrCalculateSimilarityBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/similarity`,
      ocrCalculateSimilarityBody,options
    );
  }



export const getOcrCalculateSimilarityMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext> => {

const mutationKey = ['ocrCalculateSimilarity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, {data: OcrCalculateSimilarityBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrCalculateSimilarity(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCalculateSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof ocrCalculateSimilarity>>>
    export type OcrCalculateSimilarityMutationBody = OcrCalculateSimilarityBody
    export type OcrCalculateSimilarityMutationError = AxiosError<unknown>

    /**
 * @summary Calculate similarity between two images using OCR text
 */
export const useOcrCalculateSimilarity = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
        TError,
        {data: OcrCalculateSimilarityBody},
        TContext
      > => {

      const mutationOptions = getOcrCalculateSimilarityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This helps local development: visit http://<backend-host>:<port>/swagger.html so the
Swagger UI and `/api/openapi.yaml` are on the same origin and no CORS overrides are needed.
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */
export const serveSwaggerUi = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/swagger.html`,options
    );
  }




export const getServeSwaggerUiQueryKey = () => {
    return [
    `/swagger.html`
    ] as const;
    }

    
export const getServeSwaggerUiQueryOptions = <TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeSwaggerUiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveSwaggerUi>>> = ({ signal }) => serveSwaggerUi({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeSwaggerUiQueryResult = NonNullable<Awaited<ReturnType<typeof serveSwaggerUi>>>
export type ServeSwaggerUiQueryError = AxiosError<unknown>


export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */

export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeSwaggerUiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
