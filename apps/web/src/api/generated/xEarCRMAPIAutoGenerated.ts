/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ActivityLogsGetActivityLogs200,
  ActivityLogsGetActivityLogsParams,
  ActivityLogsGetFilterOptions200,
  AddonsListActive200,
  AdminAddonsCreateAddonBody,
  AdminAdminLoginBody,
  AdminApiKeysCreateApiKeyBody,
  AdminApiKeysInitDbBody,
  AdminCreateTicketResponseBody,
  AdminDebugAvailableRoles200,
  AdminDebugPagePermissions200,
  AdminDebugSwitchRole200,
  AdminDebugSwitchRoleBody,
  AdminIntegrationsInitDbBody,
  AdminIntegrationsUpdateBirfaturaConfigBody,
  AdminIntegrationsUpdateVatanSmsConfigBody,
  AdminInvoicesCreateAdminInvoiceBody,
  AdminInvoicesRecordPaymentBody,
  AdminMarketplacesCreateIntegrationBody,
  AdminMarketplacesInitDbBody,
  AdminMarketplacesSyncIntegrationBody,
  AdminNotificationsCreateTemplateBody,
  AdminNotificationsInitDbBody,
  AdminNotificationsSendNotificationBody,
  AdminPlansCreatePlanBody,
  AdminProductionInitDbBody,
  AdminProductionUpdateOrderStatusBody,
  AdminRolesCreateAdminRoleBody,
  AdminRolesUpdateAdminRolePermissionsBody,
  AdminRolesUpdateAdminUserRolesBody,
  AdminScanQueueInitDbBody,
  AdminScanQueueRetryScanBody,
  AdminSettingsClearCacheBody,
  AdminSettingsInitDbBody,
  AdminSettingsTriggerBackupBody,
  AdminSettingsUpdateSettingsBody,
  AdminSmsCreatePackageBody,
  AdminSmsGetHeaders200,
  AdminSmsGetHeadersParams,
  AdminSmsGetPackages200,
  AdminSmsUpdateHeaderStatusBody,
  AdminSmsUpdatePackageBody,
  AdminTenantsAddTenantAddonBody,
  AdminTenantsCreateTenantBody,
  AdminTenantsCreateTenantUserBody,
  AdminTenantsSubscribeTenantBody,
  AdminTenantsUpdateTenantStatusBody,
  AdminTenantsUpdateTenantUserBody,
  AdminTicketsCreateAdminTicketBody,
  AdminTicketsUpdateAdminTicketBody,
  AdminUpdateAdminTicketBody,
  AdminUpdateAnyTenantUserBody,
  ApiResponseSendDocumentAnswerResponse,
  ApiResponseString,
  AppointmentsCancelAppointmentBody,
  AppointmentsCompleteAppointmentBody,
  AppointmentsCreateAppointment201,
  AppointmentsCreateAppointmentBody,
  AppointmentsGetAppointmentsParams,
  AppointmentsListAppointments200,
  AppointmentsRescheduleAppointmentBody,
  AuthForgotPasswordBody,
  AuthLoginBody,
  AuthRefreshBody,
  AuthSendVerificationOtpBody,
  AuthVerifyOtpBody,
  AutomationTriggerBackupBody,
  AutomationTriggerSgkProcessingBody,
  BirfaturaBpOutDocumentDownloadByUuidBody,
  BirfaturaBpOutGetInboxDocumentsBody,
  BirfaturaBpOutGetInboxDocumentsWithDetailBody,
  BirfaturaBpOutPreviewDocumentReturnPdfBody,
  BirfaturaBpOutReceiveDocumentBody,
  BirfaturaBpOutSendBasicInvoiceFromModelBody,
  BirfaturaBpOutSendDocumentBody,
  BirfaturaBpSendBasicInvoiceBody,
  BirfaturaBpSendDocumentBody,
  BirfaturaSyncInvoices200,
  BirfaturaSyncInvoicesBody,
  BranchesGetBranches200,
  Campaign,
  CampaignsCreateCampaignBody,
  CampaignsGetCampaigns200,
  CampaignsGetCampaignsParams,
  CampaignsSendCampaignBody,
  CashRecordsCreateCashRecordBody,
  CheckoutConfirmPaymentBody,
  CheckoutCreateCheckoutSessionBody,
  CommunicationTemplateCreate,
  CommunicationTemplateUpdate,
  CommunicationsCreateCommunicationHistoryBody,
  CommunicationsCreateTemplate201,
  CommunicationsDeleteTemplate200,
  CommunicationsGetTemplate200,
  CommunicationsListMessages200,
  CommunicationsListMessagesParams,
  CommunicationsListTemplates200,
  CommunicationsListTemplatesParams,
  CommunicationsSendEmailBody,
  CommunicationsSendSmsBody,
  CommunicationsUpdateTemplate200,
  DashboardGetDashboardData200,
  Device,
  DevicesCreateDeviceBody,
  DevicesCreateDeviceBrandBody,
  DevicesCreateDeviceCategory201,
  DevicesCreateDeviceCategoryBody,
  DevicesGetDevices200,
  DevicesGetDevicesParams,
  DevicesUpdateDeviceStockBody,
  ErrorResponse,
  InventoryAddSerialNumbersBody,
  InventoryAssignToPatientBody,
  InventoryBulkUploadInventoryBody,
  InventoryCreateBrandBody,
  InventoryCreateCategory201,
  InventoryCreateCategoryBody,
  InventoryCreateInventoryItemBody,
  InventoryGetCategories200,
  InventoryGetInventoryItem200,
  InventoryGetInventoryItems200,
  InventoryGetInventoryItemsParams,
  InventoryItem,
  InventoryUpdateInventoryItem200,
  InvoicesActionsCopyInvoiceBody,
  InvoicesActionsCopyInvoiceCancelBody,
  InvoicesActionsIssueInvoiceBody,
  InvoicesAddToPrintQueueBody,
  InvoicesBatchGenerateInvoicesBody,
  InvoicesBulkUploadInvoicesBody,
  InvoicesCreateInvoice201,
  InvoicesCreateInvoiceBody,
  InvoicesCreateInvoiceTemplateBody,
  InvoicesDeleteInvoice200,
  InvoicesGetInvoice200,
  InvoicesSendToGib200,
  InvoicesUpdateInvoiceGibStatusBody,
  InvoicesUploadInvoiceXmlBody,
  Notification,
  NotificationsMarkNotificationReadBody,
  NotificationsSetUserNotificationSettingsBody,
  OcrCalculateSimilarityBody,
  OcrCalculateSimilarityV2Body,
  OcrCreateJobBody,
  OcrDebugNerBody,
  OcrExtractEntitiesBody,
  OcrExtractEntitiesV2Body,
  OcrExtractPatientNameBody,
  OcrExtractPatientNameV2Body,
  OcrInitDatabaseBody,
  OcrInitDatabaseV2Body,
  OcrInitializeNlpEndpointBody,
  OcrInitializeNlpEndpointV2Body,
  OcrProcessDocumentBody,
  Patient,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesCreatePatientNoteBody,
  PatientsBulkUploadPatientsBody,
  PatientsCountPatients200,
  PatientsCountPatientsParams,
  PatientsCreatePatientBody,
  PatientsGetPatientDevices200,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  PaymentRecord,
  PaymentsCollectPromissoryNoteBody,
  PaymentsCreatePaymentRecordBody,
  PaymentsCreatePromissoryNotesBody,
  PaymentsUpdatePromissoryNoteBody,
  PermissionsCreatePermissionBody,
  PermissionsGetRolePermissions200,
  PermissionsListPermissions200,
  PermissionsUpdateRolePermissionsBody,
  PlansCreatePlanBody,
  PlansUpdatePlanBody,
  ProformasConvertProformaToSaleBody,
  ProformasCreateProformaBody,
  RegistrationRegisterPhoneBody,
  RegistrationVerifyRegistrationOtpBody,
  ReplacementsCreatePatientReplacementBody,
  ReplacementsCreateReturnInvoiceBody,
  ReplacementsSendInvoiceToGibBody,
  ReportsReportCashflowSummaryParams,
  ReportsReportPromissoryNotesByPatientParams,
  ReportsReportPromissoryNotesListParams,
  ReportsReportPromissoryNotesParams,
  ReportsReportRemainingPaymentsParams,
  RolesAddPermissionToRoleBody,
  RolesCreateRoleBody,
  SMSHeaderRequest,
  SMSPackage,
  Sale,
  SalesAssignDevicesExtendedBody,
  SalesCreateProductSaleBody,
  SalesCreateSaleBody,
  SalesCreateSaleInvoice201,
  SalesCreateSaleInvoiceBody,
  SalesCreateSalePaymentPlanBody,
  SalesCreateSalesLogBody,
  SalesGetSaleInvoice200,
  SalesPayInstallmentBody,
  SalesPricingPreviewBody,
  SalesRecalcSalesBody,
  SalesRecordSalePaymentBody,
  SalesUpdateSaleBody,
  SendDocumentAnswerRequestData,
  SgkCreateSgkWorkflowBody,
  SgkProcessOcrBody,
  SgkQueryEReceiptBody,
  SgkQueryPatientRightsBody,
  SgkSeedTestPatientsBody,
  SgkUpdateSgkWorkflowBody,
  SgkUploadAndProcessFilesBody,
  SgkUploadSgkDocumentBody,
  SmsCreateAudienceBody,
  SmsCreateHeaderBody,
  SmsGetAudiences200,
  SmsGetConfig200,
  SmsGetCredit200,
  SmsGetHeaders200,
  SmsGetPackages200,
  SmsUpdateConfigBody,
  SmsUploadAudienceBody,
  SmsUploadDocumentBody,
  SmsUploadDocumentV2200,
  SmsUploadDocumentV2Body,
  SubscriptionsGetCurrent200,
  SubscriptionsRegisterAndSubscribeBody,
  SubscriptionsSubscribeBody,
  SuccessResponse,
  Supplier,
  SuppliersAcceptSuggestedSupplier200,
  SuppliersAcceptSuggestedSupplier201,
  SuppliersAddProductSupplierBody,
  SuppliersBulkUploadSuppliersBody,
  SuppliersCreateSupplierBody,
  SuppliersGetSuggestedSuppliers200,
  SuppliersGetSupplierInvoices200,
  SuppliersGetSupplierInvoicesParams,
  SuppliersGetSuppliers200,
  SuppliersGetSuppliersParams,
  SuppliersRejectSuggestedSupplier200,
  TenantUsersDelete200,
  TenantUsersInvite201,
  TenantUsersInviteBody,
  TenantUsersList200,
  TenantUsersUpdateTenantCompanyBody,
  TimelineAddTimelineEvent201,
  TimelineAddTimelineEventBody,
  TimelineDeleteTimelineEvent200,
  TimelineGetPatientTimeline200,
  TimelineLogPatientActivityBody,
  UpdateSettingsBody,
  UpdateUnreadedStatusRequestData,
  UploadGetPresignedUploadUrlBody,
  User,
  UsersChangePassword200,
  UsersChangePasswordBody,
  UsersCreateUserBody,
  UsersUpdateMeBody,
  UsersUpdateUserBody,
} from "./schemas";

import { customInstance } from "../orval-mutator";

/**
 * @summary Get list of appointments
 */
export const appointmentsGetAppointments = (
  params?: AppointmentsGetAppointmentsParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/appointments`,
    method: "GET",
    params,
    signal,
  });
};

export const getAppointmentsGetAppointmentsQueryKey = (
  params?: AppointmentsGetAppointmentsParams,
) => {
  return [`/api/appointments`, ...(params ? [params] : [])] as const;
};

export const getAppointmentsGetAppointmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>,
  TError = unknown,
>(
  params?: AppointmentsGetAppointmentsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof appointmentsGetAppointments>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAppointmentsGetAppointmentsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appointmentsGetAppointments>>
  > = ({ signal }) => appointmentsGetAppointments(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsGetAppointments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AppointmentsGetAppointmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsGetAppointments>>
>;
export type AppointmentsGetAppointmentsQueryError = unknown;

/**
 * @summary Get list of appointments
 */

export function useAppointmentsGetAppointments<
  TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>,
  TError = unknown,
>(
  params?: AppointmentsGetAppointmentsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof appointmentsGetAppointments>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAppointmentsGetAppointmentsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new appointment
 */
export const appointmentsCreateAppointment = (
  appointmentsCreateAppointmentBody: AppointmentsCreateAppointmentBody,
  signal?: AbortSignal,
) => {
  return customInstance<AppointmentsCreateAppointment201>({
    url: `/api/appointments`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: appointmentsCreateAppointmentBody,
    signal,
  });
};

export const getAppointmentsCreateAppointmentMutationOptions = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
    TError,
    { data: AppointmentsCreateAppointmentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
  TError,
  { data: AppointmentsCreateAppointmentBody },
  TContext
> => {
  const mutationKey = ["appointmentsCreateAppointment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
    { data: AppointmentsCreateAppointmentBody }
  > = (props) => {
    const { data } = props ?? {};

    return appointmentsCreateAppointment(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AppointmentsCreateAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsCreateAppointment>>
>;
export type AppointmentsCreateAppointmentMutationBody =
  AppointmentsCreateAppointmentBody;
export type AppointmentsCreateAppointmentMutationError =
  | ErrorResponse
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Create a new appointment
 */
export const useAppointmentsCreateAppointment = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
    TError,
    { data: AppointmentsCreateAppointmentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
  TError,
  { data: AppointmentsCreateAppointmentBody },
  TContext
> => {
  const mutationOptions =
    getAppointmentsCreateAppointmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get list of communication messages (SMS and Email)
 */
export const communicationsListMessages = (
  params?: CommunicationsListMessagesParams,
  signal?: AbortSignal,
) => {
  return customInstance<CommunicationsListMessages200>({
    url: `/api/communications/messages`,
    method: "GET",
    params,
    signal,
  });
};

export const getCommunicationsListMessagesQueryKey = (
  params?: CommunicationsListMessagesParams,
) => {
  return [`/api/communications/messages`, ...(params ? [params] : [])] as const;
};

export const getCommunicationsListMessagesQueryOptions = <
  TData = Awaited<ReturnType<typeof communicationsListMessages>>,
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
  params?: CommunicationsListMessagesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsListMessages>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCommunicationsListMessagesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof communicationsListMessages>>
  > = ({ signal }) => communicationsListMessages(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof communicationsListMessages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommunicationsListMessagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof communicationsListMessages>>
>;
export type CommunicationsListMessagesQueryError =
  | ErrorResponse
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Get list of communication messages (SMS and Email)
 */

export function useCommunicationsListMessages<
  TData = Awaited<ReturnType<typeof communicationsListMessages>>,
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
  params?: CommunicationsListMessagesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsListMessages>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommunicationsListMessagesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get list of communication templates
 */
export const communicationsListTemplates = (
  params?: CommunicationsListTemplatesParams,
  signal?: AbortSignal,
) => {
  return customInstance<CommunicationsListTemplates200>({
    url: `/api/communications/templates`,
    method: "GET",
    params,
    signal,
  });
};

export const getCommunicationsListTemplatesQueryKey = (
  params?: CommunicationsListTemplatesParams,
) => {
  return [
    `/api/communications/templates`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCommunicationsListTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof communicationsListTemplates>>,
  TError = unknown,
>(
  params?: CommunicationsListTemplatesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsListTemplates>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCommunicationsListTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof communicationsListTemplates>>
  > = ({ signal }) => communicationsListTemplates(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof communicationsListTemplates>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommunicationsListTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof communicationsListTemplates>>
>;
export type CommunicationsListTemplatesQueryError = unknown;

/**
 * @summary Get list of communication templates
 */

export function useCommunicationsListTemplates<
  TData = Awaited<ReturnType<typeof communicationsListTemplates>>,
  TError = unknown,
>(
  params?: CommunicationsListTemplatesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsListTemplates>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommunicationsListTemplatesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new communication template
 */
export const communicationsCreateTemplate = (
  communicationTemplateCreate: CommunicationTemplateCreate,
  signal?: AbortSignal,
) => {
  return customInstance<CommunicationsCreateTemplate201>({
    url: `/api/communications/templates`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: communicationTemplateCreate,
    signal,
  });
};

export const getCommunicationsCreateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsCreateTemplate>>,
    TError,
    { data: CommunicationTemplateCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsCreateTemplate>>,
  TError,
  { data: CommunicationTemplateCreate },
  TContext
> => {
  const mutationKey = ["communicationsCreateTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsCreateTemplate>>,
    { data: CommunicationTemplateCreate }
  > = (props) => {
    const { data } = props ?? {};

    return communicationsCreateTemplate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsCreateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof communicationsCreateTemplate>>
>;
export type CommunicationsCreateTemplateMutationBody =
  CommunicationTemplateCreate;
export type CommunicationsCreateTemplateMutationError = unknown;

/**
 * @summary Create a new communication template
 */
export const useCommunicationsCreateTemplate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsCreateTemplate>>,
    TError,
    { data: CommunicationTemplateCreate },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsCreateTemplate>>,
  TError,
  { data: CommunicationTemplateCreate },
  TContext
> => {
  const mutationOptions =
    getCommunicationsCreateTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get a specific communication template
 */
export const communicationsGetTemplate = (
  templateId: string,
  signal?: AbortSignal,
) => {
  return customInstance<CommunicationsGetTemplate200>({
    url: `/api/communications/templates/${templateId}`,
    method: "GET",
    signal,
  });
};

export const getCommunicationsGetTemplateQueryKey = (templateId?: string) => {
  return [`/api/communications/templates/${templateId}`] as const;
};

export const getCommunicationsGetTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof communicationsGetTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsGetTemplate>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCommunicationsGetTemplateQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof communicationsGetTemplate>>
  > = ({ signal }) => communicationsGetTemplate(templateId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof communicationsGetTemplate>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommunicationsGetTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof communicationsGetTemplate>>
>;
export type CommunicationsGetTemplateQueryError = unknown;

/**
 * @summary Get a specific communication template
 */

export function useCommunicationsGetTemplate<
  TData = Awaited<ReturnType<typeof communicationsGetTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof communicationsGetTemplate>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommunicationsGetTemplateQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a communication template
 */
export const communicationsUpdateTemplate = (
  templateId: string,
  communicationTemplateUpdate: CommunicationTemplateUpdate,
) => {
  return customInstance<CommunicationsUpdateTemplate200>({
    url: `/api/communications/templates/${templateId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: communicationTemplateUpdate,
  });
};

export const getCommunicationsUpdateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
    TError,
    { templateId: string; data: CommunicationTemplateUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
  TError,
  { templateId: string; data: CommunicationTemplateUpdate },
  TContext
> => {
  const mutationKey = ["communicationsUpdateTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
    { templateId: string; data: CommunicationTemplateUpdate }
  > = (props) => {
    const { templateId, data } = props ?? {};

    return communicationsUpdateTemplate(templateId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsUpdateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof communicationsUpdateTemplate>>
>;
export type CommunicationsUpdateTemplateMutationBody =
  CommunicationTemplateUpdate;
export type CommunicationsUpdateTemplateMutationError = unknown;

/**
 * @summary Update a communication template
 */
export const useCommunicationsUpdateTemplate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
    TError,
    { templateId: string; data: CommunicationTemplateUpdate },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
  TError,
  { templateId: string; data: CommunicationTemplateUpdate },
  TContext
> => {
  const mutationOptions =
    getCommunicationsUpdateTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete a communication template
 */
export const communicationsDeleteTemplate = (templateId: string) => {
  return customInstance<CommunicationsDeleteTemplate200>({
    url: `/api/communications/templates/${templateId}`,
    method: "DELETE",
  });
};

export const getCommunicationsDeleteTemplateMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ["communicationsDeleteTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return communicationsDeleteTemplate(templateId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsDeleteTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof communicationsDeleteTemplate>>
>;

export type CommunicationsDeleteTemplateMutationError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Delete a communication template
 */
export const useCommunicationsDeleteTemplate = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions =
    getCommunicationsDeleteTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete an existing appointment by its unique identifier
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const appointmentsDeleteAppointment = (appointmentId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/appointments/${appointmentId}`,
    method: "DELETE",
  });
};

export const getAppointmentsDeleteAppointmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
    TError,
    { appointmentId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
  TError,
  { appointmentId: string },
  TContext
> => {
  const mutationKey = ["appointmentsDeleteAppointment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
    { appointmentId: string }
  > = (props) => {
    const { appointmentId } = props ?? {};

    return appointmentsDeleteAppointment(appointmentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AppointmentsDeleteAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsDeleteAppointment>>
>;

export type AppointmentsDeleteAppointmentMutationError = unknown;

/**
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const useAppointmentsDeleteAppointment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
    TError,
    { appointmentId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
  TError,
  { appointmentId: string },
  TContext
> => {
  const mutationOptions =
    getAppointmentsDeleteAppointmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Cancel an appointment and optionally provide cancellation reason
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const appointmentsCancelAppointment = (
  appointmentId: string,
  appointmentsCancelAppointmentBody?: AppointmentsCancelAppointmentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/appointments/${appointmentId}/cancel`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: appointmentsCancelAppointmentBody,
    signal,
  });
};

export const getAppointmentsCancelAppointmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsCancelAppointmentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsCancelAppointmentBody },
  TContext
> => {
  const mutationKey = ["appointmentsCancelAppointment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
    { appointmentId: string; data: AppointmentsCancelAppointmentBody }
  > = (props) => {
    const { appointmentId, data } = props ?? {};

    return appointmentsCancelAppointment(appointmentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AppointmentsCancelAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsCancelAppointment>>
>;
export type AppointmentsCancelAppointmentMutationBody =
  AppointmentsCancelAppointmentBody;
export type AppointmentsCancelAppointmentMutationError = unknown;

/**
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const useAppointmentsCancelAppointment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsCancelAppointmentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsCancelAppointmentBody },
  TContext
> => {
  const mutationOptions =
    getAppointmentsCancelAppointmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Mark an appointment as completed and add completion notes
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const appointmentsCompleteAppointment = (
  appointmentId: string,
  appointmentsCompleteAppointmentBody?: AppointmentsCompleteAppointmentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/appointments/${appointmentId}/complete`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: appointmentsCompleteAppointmentBody,
    signal,
  });
};

export const getAppointmentsCompleteAppointmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsCompleteAppointmentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsCompleteAppointmentBody },
  TContext
> => {
  const mutationKey = ["appointmentsCompleteAppointment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
    { appointmentId: string; data: AppointmentsCompleteAppointmentBody }
  > = (props) => {
    const { appointmentId, data } = props ?? {};

    return appointmentsCompleteAppointment(appointmentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AppointmentsCompleteAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsCompleteAppointment>>
>;
export type AppointmentsCompleteAppointmentMutationBody =
  AppointmentsCompleteAppointmentBody;
export type AppointmentsCompleteAppointmentMutationError = unknown;

/**
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const useAppointmentsCompleteAppointment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsCompleteAppointmentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsCompleteAppointmentBody },
  TContext
> => {
  const mutationOptions =
    getAppointmentsCompleteAppointmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reschedule an existing appointment to a new date and time
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const appointmentsRescheduleAppointment = (
  appointmentId: string,
  appointmentsRescheduleAppointmentBody?: AppointmentsRescheduleAppointmentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/appointments/${appointmentId}/reschedule`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: appointmentsRescheduleAppointmentBody,
    signal,
  });
};

export const getAppointmentsRescheduleAppointmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsRescheduleAppointmentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsRescheduleAppointmentBody },
  TContext
> => {
  const mutationKey = ["appointmentsRescheduleAppointment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
    { appointmentId: string; data: AppointmentsRescheduleAppointmentBody }
  > = (props) => {
    const { appointmentId, data } = props ?? {};

    return appointmentsRescheduleAppointment(appointmentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AppointmentsRescheduleAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>
>;
export type AppointmentsRescheduleAppointmentMutationBody =
  AppointmentsRescheduleAppointmentBody;
export type AppointmentsRescheduleAppointmentMutationError = unknown;

/**
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const useAppointmentsRescheduleAppointment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentsRescheduleAppointmentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentsRescheduleAppointmentBody },
  TContext
> => {
  const mutationOptions =
    getAppointmentsRescheduleAppointmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get available appointment slots for scheduling
 * @summary GET /api/appointments/availability
 */
export const appointmentsGetAvailability = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/appointments/availability`,
    method: "GET",
    signal,
  });
};

export const getAppointmentsGetAvailabilityQueryKey = () => {
  return [`/api/appointments/availability`] as const;
};

export const getAppointmentsGetAvailabilityQueryOptions = <
  TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsGetAvailability>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAppointmentsGetAvailabilityQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appointmentsGetAvailability>>
  > = ({ signal }) => appointmentsGetAvailability(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsGetAvailability>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AppointmentsGetAvailabilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsGetAvailability>>
>;
export type AppointmentsGetAvailabilityQueryError = unknown;

/**
 * @summary GET /api/appointments/availability
 */

export function useAppointmentsGetAvailability<
  TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsGetAvailability>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAppointmentsGetAvailabilityQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of appointments with optional filtering
 * @summary GET /api/appointments/list
 */
export const appointmentsListAppointments = (signal?: AbortSignal) => {
  return customInstance<AppointmentsListAppointments200>({
    url: `/api/appointments/list`,
    method: "GET",
    signal,
  });
};

export const getAppointmentsListAppointmentsQueryKey = () => {
  return [`/api/appointments/list`] as const;
};

export const getAppointmentsListAppointmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof appointmentsListAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsListAppointments>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAppointmentsListAppointmentsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appointmentsListAppointments>>
  > = ({ signal }) => appointmentsListAppointments(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsListAppointments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AppointmentsListAppointmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof appointmentsListAppointments>>
>;
export type AppointmentsListAppointmentsQueryError = unknown;

/**
 * @summary GET /api/appointments/list
 */

export function useAppointmentsListAppointments<
  TData = Awaited<ReturnType<typeof appointmentsListAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof appointmentsListAppointments>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAppointmentsListAppointmentsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Trigger automated system backup process
 * @summary Trigger system backup
 */
export const automationTriggerBackup = (
  automationTriggerBackupBody?: AutomationTriggerBackupBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/automation/backup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: automationTriggerBackupBody,
    signal,
  });
};

export const getAutomationTriggerBackupMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof automationTriggerBackup>>,
    TError,
    { data: AutomationTriggerBackupBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof automationTriggerBackup>>,
  TError,
  { data: AutomationTriggerBackupBody },
  TContext
> => {
  const mutationKey = ["automationTriggerBackup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof automationTriggerBackup>>,
    { data: AutomationTriggerBackupBody }
  > = (props) => {
    const { data } = props ?? {};

    return automationTriggerBackup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AutomationTriggerBackupMutationResult = NonNullable<
  Awaited<ReturnType<typeof automationTriggerBackup>>
>;
export type AutomationTriggerBackupMutationBody = AutomationTriggerBackupBody;
export type AutomationTriggerBackupMutationError = unknown;

/**
 * @summary Trigger system backup
 */
export const useAutomationTriggerBackup = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof automationTriggerBackup>>,
    TError,
    { data: AutomationTriggerBackupBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof automationTriggerBackup>>,
  TError,
  { data: AutomationTriggerBackupBody },
  TContext
> => {
  const mutationOptions = getAutomationTriggerBackupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve logs from automated processes and tasks
 * @summary Get automation logs
 */
export const automationGetAutomationLogs = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/automation/logs`,
    method: "GET",
    signal,
  });
};

export const getAutomationGetAutomationLogsQueryKey = () => {
  return [`/api/automation/logs`] as const;
};

export const getAutomationGetAutomationLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationLogs>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAutomationGetAutomationLogsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof automationGetAutomationLogs>>
  > = ({ signal }) => automationGetAutomationLogs(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationLogs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AutomationGetAutomationLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof automationGetAutomationLogs>>
>;
export type AutomationGetAutomationLogsQueryError = unknown;

/**
 * @summary Get automation logs
 */

export function useAutomationGetAutomationLogs<
  TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationLogs>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAutomationGetAutomationLogsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Trigger automated SGK document processing workflow
 * @summary Trigger SGK document processing
 */
export const automationTriggerSgkProcessing = (
  automationTriggerSgkProcessingBody?: AutomationTriggerSgkProcessingBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/automation/sgk/process`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: automationTriggerSgkProcessingBody,
    signal,
  });
};

export const getAutomationTriggerSgkProcessingMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
    TError,
    { data: AutomationTriggerSgkProcessingBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
  TError,
  { data: AutomationTriggerSgkProcessingBody },
  TContext
> => {
  const mutationKey = ["automationTriggerSgkProcessing"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
    { data: AutomationTriggerSgkProcessingBody }
  > = (props) => {
    const { data } = props ?? {};

    return automationTriggerSgkProcessing(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AutomationTriggerSgkProcessingMutationResult = NonNullable<
  Awaited<ReturnType<typeof automationTriggerSgkProcessing>>
>;
export type AutomationTriggerSgkProcessingMutationBody =
  AutomationTriggerSgkProcessingBody;
export type AutomationTriggerSgkProcessingMutationError = unknown;

/**
 * @summary Trigger SGK document processing
 */
export const useAutomationTriggerSgkProcessing = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
    TError,
    { data: AutomationTriggerSgkProcessingBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
  TError,
  { data: AutomationTriggerSgkProcessingBody },
  TContext
> => {
  const mutationOptions =
    getAutomationTriggerSgkProcessingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve status information
 * @summary Get automation system status
 */
export const automationGetAutomationStatus = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/automation/status`,
    method: "GET",
    signal,
  });
};

export const getAutomationGetAutomationStatusQueryKey = () => {
  return [`/api/automation/status`] as const;
};

export const getAutomationGetAutomationStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationStatus>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAutomationGetAutomationStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof automationGetAutomationStatus>>
  > = ({ signal }) => automationGetAutomationStatus(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AutomationGetAutomationStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof automationGetAutomationStatus>>
>;
export type AutomationGetAutomationStatusQueryError = unknown;

/**
 * @summary Get automation system status
 */

export function useAutomationGetAutomationStatus<
  TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof automationGetAutomationStatus>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAutomationGetAutomationStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve list of branches for the current tenant
 * @summary Get all branches for current tenant
 */
export const branchesGetBranches = (signal?: AbortSignal) => {
  return customInstance<BranchesGetBranches200>({
    url: `/api/branches`,
    method: "GET",
    signal,
  });
};

export const getBranchesGetBranchesQueryKey = () => {
  return [`/api/branches`] as const;
};

export const getBranchesGetBranchesQueryOptions = <
  TData = Awaited<ReturnType<typeof branchesGetBranches>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof branchesGetBranches>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBranchesGetBranchesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof branchesGetBranches>>
  > = ({ signal }) => branchesGetBranches(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof branchesGetBranches>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type BranchesGetBranchesQueryResult = NonNullable<
  Awaited<ReturnType<typeof branchesGetBranches>>
>;
export type BranchesGetBranchesQueryError = unknown;

/**
 * @summary Get all branches for current tenant
 */

export function useBranchesGetBranches<
  TData = Awaited<ReturnType<typeof branchesGetBranches>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof branchesGetBranches>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getBranchesGetBranchesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of marketing campaigns
 * @summary List all campaigns
 */
export const campaignsGetCampaigns = (
  params?: CampaignsGetCampaignsParams,
  signal?: AbortSignal,
) => {
  return customInstance<CampaignsGetCampaigns200>({
    url: `/api/campaigns`,
    method: "GET",
    params,
    signal,
  });
};

export const getCampaignsGetCampaignsQueryKey = (
  params?: CampaignsGetCampaignsParams,
) => {
  return [`/api/campaigns`, ...(params ? [params] : [])] as const;
};

export const getCampaignsGetCampaignsQueryOptions = <
  TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>,
  TError = unknown,
>(
  params?: CampaignsGetCampaignsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof campaignsGetCampaigns>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCampaignsGetCampaignsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof campaignsGetCampaigns>>
  > = ({ signal }) => campaignsGetCampaigns(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof campaignsGetCampaigns>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CampaignsGetCampaignsQueryResult = NonNullable<
  Awaited<ReturnType<typeof campaignsGetCampaigns>>
>;
export type CampaignsGetCampaignsQueryError = unknown;

/**
 * @summary List all campaigns
 */

export function useCampaignsGetCampaigns<
  TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>,
  TError = unknown,
>(
  params?: CampaignsGetCampaignsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof campaignsGetCampaigns>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCampaignsGetCampaignsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new marketing campaign with target audience and content
 * @summary POST /api/campaigns
 */
export const campaignsCreateCampaign = (
  campaignsCreateCampaignBody?: CampaignsCreateCampaignBody,
  signal?: AbortSignal,
) => {
  return customInstance<Campaign>({
    url: `/api/campaigns`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: campaignsCreateCampaignBody,
    signal,
  });
};

export const getCampaignsCreateCampaignMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof campaignsCreateCampaign>>,
    TError,
    { data: CampaignsCreateCampaignBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof campaignsCreateCampaign>>,
  TError,
  { data: CampaignsCreateCampaignBody },
  TContext
> => {
  const mutationKey = ["campaignsCreateCampaign"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof campaignsCreateCampaign>>,
    { data: CampaignsCreateCampaignBody }
  > = (props) => {
    const { data } = props ?? {};

    return campaignsCreateCampaign(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CampaignsCreateCampaignMutationResult = NonNullable<
  Awaited<ReturnType<typeof campaignsCreateCampaign>>
>;
export type CampaignsCreateCampaignMutationBody = CampaignsCreateCampaignBody;
export type CampaignsCreateCampaignMutationError = unknown;

/**
 * @summary POST /api/campaigns
 */
export const useCampaignsCreateCampaign = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof campaignsCreateCampaign>>,
    TError,
    { data: CampaignsCreateCampaignBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof campaignsCreateCampaign>>,
  TError,
  { data: CampaignsCreateCampaignBody },
  TContext
> => {
  const mutationOptions = getCampaignsCreateCampaignMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve dashboard overview data including statistics and recent activities
 * @summary Get dashboard data
 */
export const dashboardGetDashboardData = (signal?: AbortSignal) => {
  return customInstance<DashboardGetDashboardData200>({
    url: `/api/dashboard`,
    method: "GET",
    signal,
  });
};

export const getDashboardGetDashboardDataQueryKey = () => {
  return [`/api/dashboard`] as const;
};

export const getDashboardGetDashboardDataQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>,
  TError = ErrorResponse | ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetDashboardData>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardGetDashboardDataQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardGetDashboardData>>
  > = ({ signal }) => dashboardGetDashboardData(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetDashboardData>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardGetDashboardDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardGetDashboardData>>
>;
export type DashboardGetDashboardDataQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get dashboard data
 */

export function useDashboardGetDashboardData<
  TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>,
  TError = ErrorResponse | ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetDashboardData>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardGetDashboardDataQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new send
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const campaignsSendCampaign = (
  campaignId: string,
  campaignsSendCampaignBody?: CampaignsSendCampaignBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/campaigns/${campaignId}/send`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: campaignsSendCampaignBody,
    signal,
  });
};

export const getCampaignsSendCampaignMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof campaignsSendCampaign>>,
    TError,
    { campaignId: string; data: CampaignsSendCampaignBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof campaignsSendCampaign>>,
  TError,
  { campaignId: string; data: CampaignsSendCampaignBody },
  TContext
> => {
  const mutationKey = ["campaignsSendCampaign"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof campaignsSendCampaign>>,
    { campaignId: string; data: CampaignsSendCampaignBody }
  > = (props) => {
    const { campaignId, data } = props ?? {};

    return campaignsSendCampaign(campaignId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CampaignsSendCampaignMutationResult = NonNullable<
  Awaited<ReturnType<typeof campaignsSendCampaign>>
>;
export type CampaignsSendCampaignMutationBody = CampaignsSendCampaignBody;
export type CampaignsSendCampaignMutationError = unknown;

/**
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const useCampaignsSendCampaign = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof campaignsSendCampaign>>,
    TError,
    { campaignId: string; data: CampaignsSendCampaignBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof campaignsSendCampaign>>,
  TError,
  { campaignId: string; data: CampaignsSendCampaignBody },
  TContext
> => {
  const mutationOptions = getCampaignsSendCampaignMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve turnstile information
 * @summary GET /api/config/turnstile
 */
export const registrationGetTurnstileConfig = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/config/turnstile`,
    method: "GET",
    signal,
  });
};

export const getRegistrationGetTurnstileConfigQueryKey = () => {
  return [`/api/config/turnstile`] as const;
};

export const getRegistrationGetTurnstileConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRegistrationGetTurnstileConfigQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
  > = ({ signal }) => registrationGetTurnstileConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type RegistrationGetTurnstileConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
>;
export type RegistrationGetTurnstileConfigQueryError = unknown;

/**
 * @summary GET /api/config/turnstile
 */

export function useRegistrationGetTurnstileConfig<
  TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getRegistrationGetTurnstileConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve patient-trends information
 * @summary GET /api/dashboard/charts/patient-trends
 */
export const dashboardPatientTrends = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/dashboard/charts/patient-trends`,
    method: "GET",
    signal,
  });
};

export const getDashboardPatientTrendsQueryKey = () => {
  return [`/api/dashboard/charts/patient-trends`] as const;
};

export const getDashboardPatientTrendsQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardPatientTrends>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientTrends>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardPatientTrendsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardPatientTrends>>
  > = ({ signal }) => dashboardPatientTrends(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientTrends>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardPatientTrendsQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardPatientTrends>>
>;
export type DashboardPatientTrendsQueryError = unknown;

/**
 * @summary GET /api/dashboard/charts/patient-trends
 */

export function useDashboardPatientTrends<
  TData = Awaited<ReturnType<typeof dashboardPatientTrends>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientTrends>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardPatientTrendsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve revenue-trends information
 * @summary GET /api/dashboard/charts/revenue-trends
 */
export const dashboardRevenueTrends = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/dashboard/charts/revenue-trends`,
    method: "GET",
    signal,
  });
};

export const getDashboardRevenueTrendsQueryKey = () => {
  return [`/api/dashboard/charts/revenue-trends`] as const;
};

export const getDashboardRevenueTrendsQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRevenueTrends>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardRevenueTrendsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardRevenueTrends>>
  > = ({ signal }) => dashboardRevenueTrends(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRevenueTrends>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardRevenueTrendsQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardRevenueTrends>>
>;
export type DashboardRevenueTrendsQueryError = unknown;

/**
 * @summary GET /api/dashboard/charts/revenue-trends
 */

export function useDashboardRevenueTrends<
  TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRevenueTrends>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardRevenueTrendsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve kpis information
 * @summary GET /api/dashboard/kpis
 */
export const dashboardGetKpis = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/dashboard/kpis`,
    method: "GET",
    signal,
  });
};

export const getDashboardGetKpisQueryKey = () => {
  return [`/api/dashboard/kpis`] as const;
};

export const getDashboardGetKpisQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardGetKpis>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetKpis>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDashboardGetKpisQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardGetKpis>>
  > = ({ signal }) => dashboardGetKpis(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetKpis>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardGetKpisQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardGetKpis>>
>;
export type DashboardGetKpisQueryError = unknown;

/**
 * @summary GET /api/dashboard/kpis
 */

export function useDashboardGetKpis<
  TData = Awaited<ReturnType<typeof dashboardGetKpis>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardGetKpis>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardGetKpisQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve recent-activity information
 * @summary GET /api/dashboard/recent-activity
 */
export const dashboardRecentActivity = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/dashboard/recent-activity`,
    method: "GET",
    signal,
  });
};

export const getDashboardRecentActivityQueryKey = () => {
  return [`/api/dashboard/recent-activity`] as const;
};

export const getDashboardRecentActivityQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardRecentActivity>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRecentActivity>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardRecentActivityQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardRecentActivity>>
  > = ({ signal }) => dashboardRecentActivity(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRecentActivity>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardRecentActivityQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardRecentActivity>>
>;
export type DashboardRecentActivityQueryError = unknown;

/**
 * @summary GET /api/dashboard/recent-activity
 */

export function useDashboardRecentActivity<
  TData = Awaited<ReturnType<typeof dashboardRecentActivity>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardRecentActivity>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardRecentActivityQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of devices with optional filtering and pagination
 * @summary Get list of devices
 */
export const devicesGetDevices = (
  params?: DevicesGetDevicesParams,
  signal?: AbortSignal,
) => {
  return customInstance<DevicesGetDevices200>({
    url: `/api/devices`,
    method: "GET",
    params,
    signal,
  });
};

export const getDevicesGetDevicesQueryKey = (
  params?: DevicesGetDevicesParams,
) => {
  return [`/api/devices`, ...(params ? [params] : [])] as const;
};

export const getDevicesGetDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesGetDevices>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: DevicesGetDevicesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof devicesGetDevices>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDevicesGetDevicesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof devicesGetDevices>>
  > = ({ signal }) => devicesGetDevices(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDevices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DevicesGetDevicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesGetDevices>>
>;
export type DevicesGetDevicesQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get list of devices
 */

export function useDevicesGetDevices<
  TData = Awaited<ReturnType<typeof devicesGetDevices>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: DevicesGetDevicesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof devicesGetDevices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDevicesGetDevicesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Register a new hearing aid device in the system
 * @summary Create a new device
 */
export const devicesCreateDevice = (
  devicesCreateDeviceBody?: DevicesCreateDeviceBody,
  signal?: AbortSignal,
) => {
  return customInstance<Device>({
    url: `/api/devices`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: devicesCreateDeviceBody,
    signal,
  });
};

export const getDevicesCreateDeviceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDevice>>,
    TError,
    { data: DevicesCreateDeviceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesCreateDevice>>,
  TError,
  { data: DevicesCreateDeviceBody },
  TContext
> => {
  const mutationKey = ["devicesCreateDevice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesCreateDevice>>,
    { data: DevicesCreateDeviceBody }
  > = (props) => {
    const { data } = props ?? {};

    return devicesCreateDevice(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesCreateDeviceMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesCreateDevice>>
>;
export type DevicesCreateDeviceMutationBody = DevicesCreateDeviceBody;
export type DevicesCreateDeviceMutationError = unknown;

/**
 * @summary Create a new device
 */
export const useDevicesCreateDevice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDevice>>,
    TError,
    { data: DevicesCreateDeviceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof devicesCreateDevice>>,
  TError,
  { data: DevicesCreateDeviceBody },
  TContext
> => {
  const mutationOptions = getDevicesCreateDeviceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a device from the system
 * @summary Delete a device
 */
export const devicesDeleteDevice = (deviceId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/devices/${deviceId}`,
    method: "DELETE",
  });
};

export const getDevicesDeleteDeviceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesDeleteDevice>>,
    TError,
    { deviceId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesDeleteDevice>>,
  TError,
  { deviceId: string },
  TContext
> => {
  const mutationKey = ["devicesDeleteDevice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesDeleteDevice>>,
    { deviceId: string }
  > = (props) => {
    const { deviceId } = props ?? {};

    return devicesDeleteDevice(deviceId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesDeleteDeviceMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesDeleteDevice>>
>;

export type DevicesDeleteDeviceMutationError = unknown;

/**
 * @summary Delete a device
 */
export const useDevicesDeleteDevice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesDeleteDevice>>,
    TError,
    { deviceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof devicesDeleteDevice>>,
  TError,
  { deviceId: string },
  TContext
> => {
  const mutationOptions = getDevicesDeleteDeviceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This endpoint is intentionally permissive for tests â€” real inventory logic
should live in a dedicated inventory table/service.
 * @summary Update device stock levels (simplified).
 */
export const devicesUpdateDeviceStock = (
  deviceId: string,
  devicesUpdateDeviceStockBody?: DevicesUpdateDeviceStockBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/devices/${deviceId}/stock-update`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: devicesUpdateDeviceStockBody,
    signal,
  });
};

export const getDevicesUpdateDeviceStockMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
    TError,
    { deviceId: string; data: DevicesUpdateDeviceStockBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
  TError,
  { deviceId: string; data: DevicesUpdateDeviceStockBody },
  TContext
> => {
  const mutationKey = ["devicesUpdateDeviceStock"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
    { deviceId: string; data: DevicesUpdateDeviceStockBody }
  > = (props) => {
    const { deviceId, data } = props ?? {};

    return devicesUpdateDeviceStock(deviceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesUpdateDeviceStockMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesUpdateDeviceStock>>
>;
export type DevicesUpdateDeviceStockMutationBody = DevicesUpdateDeviceStockBody;
export type DevicesUpdateDeviceStockMutationError = unknown;

/**
 * @summary Update device stock levels (simplified).
 */
export const useDevicesUpdateDeviceStock = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
    TError,
    { deviceId: string; data: DevicesUpdateDeviceStockBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
  TError,
  { deviceId: string; data: DevicesUpdateDeviceStockBody },
  TContext
> => {
  const mutationOptions = getDevicesUpdateDeviceStockMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve brands information
 * @summary Get available device brands
 */
export const devicesGetDeviceBrands = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/devices/brands`,
    method: "GET",
    signal,
  });
};

export const getDevicesGetDeviceBrandsQueryKey = () => {
  return [`/api/devices/brands`] as const;
};

export const getDevicesGetDeviceBrandsQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDevicesGetDeviceBrandsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof devicesGetDeviceBrands>>
  > = ({ signal }) => devicesGetDeviceBrands(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DevicesGetDeviceBrandsQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesGetDeviceBrands>>
>;
export type DevicesGetDeviceBrandsQueryError = unknown;

/**
 * @summary Get available device brands
 */

export function useDevicesGetDeviceBrands<
  TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDevicesGetDeviceBrandsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new device brand
 * @summary Create a new device brand
 */
export const devicesCreateDeviceBrand = (
  devicesCreateDeviceBrandBody: DevicesCreateDeviceBrandBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/devices/brands`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: devicesCreateDeviceBrandBody,
    signal,
  });
};

export const getDevicesCreateDeviceBrandMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
    TError,
    { data: DevicesCreateDeviceBrandBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
  TError,
  { data: DevicesCreateDeviceBrandBody },
  TContext
> => {
  const mutationKey = ["devicesCreateDeviceBrand"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
    { data: DevicesCreateDeviceBrandBody }
  > = (props) => {
    const { data } = props ?? {};

    return devicesCreateDeviceBrand(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesCreateDeviceBrandMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesCreateDeviceBrand>>
>;
export type DevicesCreateDeviceBrandMutationBody = DevicesCreateDeviceBrandBody;
export type DevicesCreateDeviceBrandMutationError = void | void | void;

/**
 * @summary Create a new device brand
 */
export const useDevicesCreateDeviceBrand = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
    TError,
    { data: DevicesCreateDeviceBrandBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
  TError,
  { data: DevicesCreateDeviceBrandBody },
  TContext
> => {
  const mutationOptions = getDevicesCreateDeviceBrandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve categories information
 * @summary Get available device categories
 */
export const devicesGetDeviceCategories = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/devices/categories`,
    method: "GET",
    signal,
  });
};

export const getDevicesGetDeviceCategoriesQueryKey = () => {
  return [`/api/devices/categories`] as const;
};

export const getDevicesGetDeviceCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDevicesGetDeviceCategoriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof devicesGetDeviceCategories>>
  > = ({ signal }) => devicesGetDeviceCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DevicesGetDeviceCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesGetDeviceCategories>>
>;
export type DevicesGetDeviceCategoriesQueryError = unknown;

/**
 * @summary Get available device categories
 */

export function useDevicesGetDeviceCategories<
  TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDevicesGetDeviceCategoriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new device category
 * @summary Create a new device category
 */
export const devicesCreateDeviceCategory = (
  devicesCreateDeviceCategoryBody: DevicesCreateDeviceCategoryBody,
  signal?: AbortSignal,
) => {
  return customInstance<DevicesCreateDeviceCategory201>({
    url: `/api/devices/categories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: devicesCreateDeviceCategoryBody,
    signal,
  });
};

export const getDevicesCreateDeviceCategoryMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
    TError,
    { data: DevicesCreateDeviceCategoryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
  TError,
  { data: DevicesCreateDeviceCategoryBody },
  TContext
> => {
  const mutationKey = ["devicesCreateDeviceCategory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
    { data: DevicesCreateDeviceCategoryBody }
  > = (props) => {
    const { data } = props ?? {};

    return devicesCreateDeviceCategory(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesCreateDeviceCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesCreateDeviceCategory>>
>;
export type DevicesCreateDeviceCategoryMutationBody =
  DevicesCreateDeviceCategoryBody;
export type DevicesCreateDeviceCategoryMutationError = void | void | void;

/**
 * @summary Create a new device category
 */
export const useDevicesCreateDeviceCategory = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
    TError,
    { data: DevicesCreateDeviceCategoryBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
  TError,
  { data: DevicesCreateDeviceCategoryBody },
  TContext
> => {
  const mutationOptions =
    getDevicesCreateDeviceCategoryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve low-stock information
 * @summary Get devices with low stock levels
 */
export const devicesGetLowStockDevices = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/devices/low-stock`,
    method: "GET",
    signal,
  });
};

export const getDevicesGetLowStockDevicesQueryKey = () => {
  return [`/api/devices/low-stock`] as const;
};

export const getDevicesGetLowStockDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDevicesGetLowStockDevicesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof devicesGetLowStockDevices>>
  > = ({ signal }) => devicesGetLowStockDevices(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DevicesGetLowStockDevicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesGetLowStockDevices>>
>;
export type DevicesGetLowStockDevicesQueryError = unknown;

/**
 * @summary Get devices with low stock levels
 */

export function useDevicesGetLowStockDevices<
  TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDevicesGetLowStockDevicesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns 200 when read+write ok, 503 when write fails, and 500 when other errors occur.
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */
export const healthCheck = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/api/health`, method: "GET", signal });
};

export const getHealthCheckQueryKey = () => {
  return [`/api/health`] as const;
};

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>;
export type HealthCheckQueryError = unknown;

/**
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of inventory items with optional filtering and pagination
 * @summary Get list of inventory items
 */
export const inventoryGetInventoryItems = (
  params?: InventoryGetInventoryItemsParams,
  signal?: AbortSignal,
) => {
  return customInstance<InventoryGetInventoryItems200>({
    url: `/api/inventory`,
    method: "GET",
    params,
    signal,
  });
};

export const getInventoryGetInventoryItemsQueryKey = (
  params?: InventoryGetInventoryItemsParams,
) => {
  return [`/api/inventory`, ...(params ? [params] : [])] as const;
};

export const getInventoryGetInventoryItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: InventoryGetInventoryItemsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetInventoryItemsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetInventoryItems>>
  > = ({ signal }) => inventoryGetInventoryItems(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetInventoryItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetInventoryItems>>
>;
export type InventoryGetInventoryItemsQueryError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Get list of inventory items
 */

export function useInventoryGetInventoryItems<
  TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: InventoryGetInventoryItemsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetInventoryItemsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add a new item to inventory with quantity and details
 * @summary Create a new inventory item
 */
export const inventoryCreateInventoryItem = (
  inventoryCreateInventoryItemBody?: InventoryCreateInventoryItemBody,
  signal?: AbortSignal,
) => {
  return customInstance<InventoryItem>({
    url: `/api/inventory`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryCreateInventoryItemBody,
    signal,
  });
};

export const getInventoryCreateInventoryItemMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
    TError,
    { data: InventoryCreateInventoryItemBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
  TError,
  { data: InventoryCreateInventoryItemBody },
  TContext
> => {
  const mutationKey = ["inventoryCreateInventoryItem"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
    { data: InventoryCreateInventoryItemBody }
  > = (props) => {
    const { data } = props ?? {};

    return inventoryCreateInventoryItem(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryCreateInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryCreateInventoryItem>>
>;
export type InventoryCreateInventoryItemMutationBody =
  InventoryCreateInventoryItemBody;
export type InventoryCreateInventoryItemMutationError = unknown;

/**
 * @summary Create a new inventory item
 */
export const useInventoryCreateInventoryItem = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
    TError,
    { data: InventoryCreateInventoryItemBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
  TError,
  { data: InventoryCreateInventoryItemBody },
  TContext
> => {
  const mutationOptions =
    getInventoryCreateInventoryItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve a single inventory item by its ID
 * @summary Get a single inventory item by ID
 */
export const inventoryGetInventoryItem = (
  itemId: string,
  signal?: AbortSignal,
) => {
  return customInstance<InventoryGetInventoryItem200>({
    url: `/api/inventory/${itemId}`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetInventoryItemQueryKey = (itemId?: string) => {
  return [`/api/inventory/${itemId}`] as const;
};

export const getInventoryGetInventoryItemQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
  TError = ErrorResponse | ErrorResponse,
>(
  itemId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetInventoryItemQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetInventoryItem>>
  > = ({ signal }) => inventoryGetInventoryItem(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetInventoryItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetInventoryItem>>
>;
export type InventoryGetInventoryItemQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get a single inventory item by ID
 */

export function useInventoryGetInventoryItem<
  TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
  TError = ErrorResponse | ErrorResponse,
>(
  itemId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetInventoryItemQueryOptions(
    itemId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Remove an item from inventory
 * @summary Delete an inventory item
 */
export const inventoryDeleteInventoryItem = (itemId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/inventory/${itemId}`,
    method: "DELETE",
  });
};

export const getInventoryDeleteInventoryItemMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationKey = ["inventoryDeleteInventoryItem"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
    { itemId: string }
  > = (props) => {
    const { itemId } = props ?? {};

    return inventoryDeleteInventoryItem(itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryDeleteInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>
>;

export type InventoryDeleteInventoryItemMutationError = unknown;

/**
 * @summary Delete an inventory item
 */
export const useInventoryDeleteInventoryItem = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationOptions =
    getInventoryDeleteInventoryItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update an inventory item
 */
export const inventoryUpdateInventoryItem = (
  itemId: string,
  inventoryItem?: InventoryItem,
) => {
  return customInstance<InventoryUpdateInventoryItem200>({
    url: `/api/inventory/${itemId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: inventoryItem,
  });
};

export const getInventoryUpdateInventoryItemMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
    TError,
    { itemId: string; data: InventoryItem },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
  TError,
  { itemId: string; data: InventoryItem },
  TContext
> => {
  const mutationKey = ["inventoryUpdateInventoryItem"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
    { itemId: string; data: InventoryItem }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return inventoryUpdateInventoryItem(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryUpdateInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>
>;
export type InventoryUpdateInventoryItemMutationBody = InventoryItem;
export type InventoryUpdateInventoryItemMutationError = unknown;

/**
 * @summary Update an inventory item
 */
export const useInventoryUpdateInventoryItem = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
    TError,
    { itemId: string; data: InventoryItem },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
  TError,
  { itemId: string; data: InventoryItem },
  TContext
> => {
  const mutationOptions =
    getInventoryUpdateInventoryItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve activity information
 * @summary Get activity log for an inventory item
 */
export const inventoryGetInventoryActivities = (
  itemId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/inventory/${itemId}/activity`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetInventoryActivitiesQueryKey = (itemId?: string) => {
  return [`/api/inventory/${itemId}/activity`] as const;
};

export const getInventoryGetInventoryActivitiesQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
  TError = unknown,
>(
  itemId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getInventoryGetInventoryActivitiesQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
  > = ({ signal }) => inventoryGetInventoryActivities(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetInventoryActivitiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
>;
export type InventoryGetInventoryActivitiesQueryError = unknown;

/**
 * @summary Get activity log for an inventory item
 */

export function useInventoryGetInventoryActivities<
  TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
  TError = unknown,
>(
  itemId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetInventoryActivitiesQueryOptions(
    itemId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new assign
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const inventoryAssignToPatient = (
  itemId: string,
  inventoryAssignToPatientBody?: InventoryAssignToPatientBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/inventory/${itemId}/assign`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryAssignToPatientBody,
    signal,
  });
};

export const getInventoryAssignToPatientMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryAssignToPatient>>,
    TError,
    { itemId: string; data: InventoryAssignToPatientBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryAssignToPatient>>,
  TError,
  { itemId: string; data: InventoryAssignToPatientBody },
  TContext
> => {
  const mutationKey = ["inventoryAssignToPatient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryAssignToPatient>>,
    { itemId: string; data: InventoryAssignToPatientBody }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return inventoryAssignToPatient(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryAssignToPatientMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryAssignToPatient>>
>;
export type InventoryAssignToPatientMutationBody = InventoryAssignToPatientBody;
export type InventoryAssignToPatientMutationError = unknown;

/**
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const useInventoryAssignToPatient = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryAssignToPatient>>,
    TError,
    { itemId: string; data: InventoryAssignToPatientBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryAssignToPatient>>,
  TError,
  { itemId: string; data: InventoryAssignToPatientBody },
  TContext
> => {
  const mutationOptions = getInventoryAssignToPatientMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new serials
 * @summary Add serial numbers to an inventory item
 */
export const inventoryAddSerialNumbers = (
  itemId: string,
  inventoryAddSerialNumbersBody?: InventoryAddSerialNumbersBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/inventory/${itemId}/serials`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryAddSerialNumbersBody,
    signal,
  });
};

export const getInventoryAddSerialNumbersMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
    TError,
    { itemId: string; data: InventoryAddSerialNumbersBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
  TError,
  { itemId: string; data: InventoryAddSerialNumbersBody },
  TContext
> => {
  const mutationKey = ["inventoryAddSerialNumbers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
    { itemId: string; data: InventoryAddSerialNumbersBody }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return inventoryAddSerialNumbers(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryAddSerialNumbersMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryAddSerialNumbers>>
>;
export type InventoryAddSerialNumbersMutationBody =
  InventoryAddSerialNumbersBody;
export type InventoryAddSerialNumbersMutationError = unknown;

/**
 * @summary Add serial numbers to an inventory item
 */
export const useInventoryAddSerialNumbers = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
    TError,
    { itemId: string; data: InventoryAddSerialNumbersBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
  TError,
  { itemId: string; data: InventoryAddSerialNumbersBody },
  TContext
> => {
  const mutationOptions = getInventoryAddSerialNumbersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve low-stock information
 * @summary Get all items with low stock levels
 */
export const inventoryGetLowStockItems = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/low-stock`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetLowStockItemsQueryKey = () => {
  return [`/api/inventory/low-stock`] as const;
};

export const getInventoryGetLowStockItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetLowStockItemsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetLowStockItems>>
  > = ({ signal }) => inventoryGetLowStockItems(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetLowStockItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetLowStockItems>>
>;
export type InventoryGetLowStockItemsQueryError = unknown;

/**
 * @summary Get all items with low stock levels
 */

export function useInventoryGetLowStockItems<
  TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetLowStockItemsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get inventory statistics including low stock alerts
 * @summary Get inventory statistics
 */
export const inventoryGetInventoryStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/stats`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetInventoryStatsQueryKey = () => {
  return [`/api/inventory/stats`] as const;
};

export const getInventoryGetInventoryStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetInventoryStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetInventoryStats>>
  > = ({ signal }) => inventoryGetInventoryStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetInventoryStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetInventoryStats>>
>;
export type InventoryGetInventoryStatsQueryError = unknown;

/**
 * @summary Get inventory statistics
 */

export function useInventoryGetInventoryStats<
  TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetInventoryStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get list of all available inventory categories
 * @summary Get all inventory categories
 */
export const inventoryGetCategories = (signal?: AbortSignal) => {
  return customInstance<InventoryGetCategories200>({
    url: `/api/inventory/categories`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetCategoriesQueryKey = () => {
  return [`/api/inventory/categories`] as const;
};

export const getInventoryGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetCategories>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategories>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetCategoriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetCategories>>
  > = ({ signal }) => inventoryGetCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategories>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetCategories>>
>;
export type InventoryGetCategoriesQueryError = ErrorResponse;

/**
 * @summary Get all inventory categories
 */

export function useInventoryGetCategories<
  TData = Awaited<ReturnType<typeof inventoryGetCategories>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategories>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new inventory category
 * @summary Create new inventory category
 */
export const inventoryCreateCategory = (
  inventoryCreateCategoryBody: InventoryCreateCategoryBody,
  signal?: AbortSignal,
) => {
  return customInstance<InventoryCreateCategory201>({
    url: `/api/inventory/categories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryCreateCategoryBody,
    signal,
  });
};

export const getInventoryCreateCategoryMutationOptions = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateCategory>>,
    TError,
    { data: InventoryCreateCategoryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryCreateCategory>>,
  TError,
  { data: InventoryCreateCategoryBody },
  TContext
> => {
  const mutationKey = ["inventoryCreateCategory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryCreateCategory>>,
    { data: InventoryCreateCategoryBody }
  > = (props) => {
    const { data } = props ?? {};

    return inventoryCreateCategory(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryCreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryCreateCategory>>
>;
export type InventoryCreateCategoryMutationBody = InventoryCreateCategoryBody;
export type InventoryCreateCategoryMutationError =
  | ErrorResponse
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Create new inventory category
 */
export const useInventoryCreateCategory = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateCategory>>,
    TError,
    { data: InventoryCreateCategoryBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryCreateCategory>>,
  TError,
  { data: InventoryCreateCategoryBody },
  TContext
> => {
  const mutationOptions = getInventoryCreateCategoryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create a new invoice for a patient
 * @summary Create a new invoice
 */
export const invoicesCreateInvoice = (
  invoicesCreateInvoiceBody: InvoicesCreateInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<InvoicesCreateInvoice201>({
    url: `/api/invoices`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesCreateInvoiceBody,
    signal,
  });
};

export const getInvoicesCreateInvoiceMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesCreateInvoice>>,
    TError,
    { data: InvoicesCreateInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesCreateInvoice>>,
  TError,
  { data: InvoicesCreateInvoiceBody },
  TContext
> => {
  const mutationKey = ["invoicesCreateInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesCreateInvoice>>,
    { data: InvoicesCreateInvoiceBody }
  > = (props) => {
    const { data } = props ?? {};

    return invoicesCreateInvoice(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesCreateInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesCreateInvoice>>
>;
export type InvoicesCreateInvoiceMutationBody = InvoicesCreateInvoiceBody;
export type InvoicesCreateInvoiceMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Create a new invoice
 */
export const useInvoicesCreateInvoice = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesCreateInvoice>>,
    TError,
    { data: InvoicesCreateInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesCreateInvoice>>,
  TError,
  { data: InvoicesCreateInvoiceBody },
  TContext
> => {
  const mutationOptions = getInvoicesCreateInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve an invoice by its ID
 * @summary Get invoice by ID
 */
export const invoicesGetInvoice = (invoiceId: string, signal?: AbortSignal) => {
  return customInstance<InvoicesGetInvoice200>({
    url: `/api/invoices/${invoiceId}`,
    method: "GET",
    signal,
  });
};

export const getInvoicesGetInvoiceQueryKey = (invoiceId?: string) => {
  return [`/api/invoices/${invoiceId}`] as const;
};

export const getInvoicesGetInvoiceQueryOptions = <
  TData = Awaited<ReturnType<typeof invoicesGetInvoice>>,
  TError = ErrorResponse | ErrorResponse,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGetInvoice>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInvoicesGetInvoiceQueryKey(invoiceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof invoicesGetInvoice>>
  > = ({ signal }) => invoicesGetInvoice(invoiceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!invoiceId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof invoicesGetInvoice>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InvoicesGetInvoiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof invoicesGetInvoice>>
>;
export type InvoicesGetInvoiceQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get invoice by ID
 */

export function useInvoicesGetInvoice<
  TData = Awaited<ReturnType<typeof invoicesGetInvoice>>,
  TError = ErrorResponse | ErrorResponse,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGetInvoice>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInvoicesGetInvoiceQueryOptions(invoiceId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete an invoice by its ID
 * @summary Delete invoice by ID
 */
export const invoicesDeleteInvoice = (invoiceId: string) => {
  return customInstance<InvoicesDeleteInvoice200>({
    url: `/api/invoices/${invoiceId}`,
    method: "DELETE",
  });
};

export const getInvoicesDeleteInvoiceMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
    TError,
    { invoiceId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
  TError,
  { invoiceId: string },
  TContext
> => {
  const mutationKey = ["invoicesDeleteInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
    { invoiceId: string }
  > = (props) => {
    const { invoiceId } = props ?? {};

    return invoicesDeleteInvoice(invoiceId);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesDeleteInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesDeleteInvoice>>
>;

export type InvoicesDeleteInvoiceMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Delete invoice by ID
 */
export const useInvoicesDeleteInvoice = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
    TError,
    { invoiceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
  TError,
  { invoiceId: string },
  TContext
> => {
  const mutationOptions = getInvoicesDeleteInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Generate and download a PDF for the specified invoice
 * @summary Generate invoice PDF
 */
export const invoicesGenerateInvoicePdf = (
  invoiceId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Blob>({
    url: `/api/invoices/${invoiceId}/pdf`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getInvoicesGenerateInvoicePdfQueryKey = (invoiceId?: string) => {
  return [`/api/invoices/${invoiceId}/pdf`] as const;
};

export const getInvoicesGenerateInvoicePdfQueryOptions = <
  TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
  TError = ErrorResponse | ErrorResponse,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInvoicesGenerateInvoicePdfQueryKey(invoiceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
  > = ({ signal }) => invoicesGenerateInvoicePdf(invoiceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!invoiceId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InvoicesGenerateInvoicePdfQueryResult = NonNullable<
  Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
>;
export type InvoicesGenerateInvoicePdfQueryError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Generate invoice PDF
 */

export function useInvoicesGenerateInvoicePdf<
  TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
  TError = ErrorResponse | ErrorResponse,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInvoicesGenerateInvoicePdfQueryOptions(
    invoiceId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Send the invoice to GÄ°B (Turkish Revenue Administration)
 * @summary Send invoice to GÄ°B
 */
export const invoicesSendToGib = (invoiceId: string, signal?: AbortSignal) => {
  return customInstance<InvoicesSendToGib200>({
    url: `/api/invoices/${invoiceId}/send-to-gib`,
    method: "POST",
    signal,
  });
};

export const getInvoicesSendToGibMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesSendToGib>>,
    TError,
    { invoiceId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesSendToGib>>,
  TError,
  { invoiceId: string },
  TContext
> => {
  const mutationKey = ["invoicesSendToGib"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesSendToGib>>,
    { invoiceId: string }
  > = (props) => {
    const { invoiceId } = props ?? {};

    return invoicesSendToGib(invoiceId);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesSendToGibMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesSendToGib>>
>;

export type InvoicesSendToGibMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Send invoice to GÄ°B
 */
export const useInvoicesSendToGib = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesSendToGib>>,
    TError,
    { invoiceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesSendToGib>>,
  TError,
  { invoiceId: string },
  TContext
> => {
  const mutationOptions = getInvoicesSendToGibMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve notifications information
 * @summary GET /api/notifications
 */
export const notificationsListNotifications = (signal?: AbortSignal) => {
  return customInstance<Notification[]>({
    url: `/api/notifications`,
    method: "GET",
    signal,
  });
};

export const getNotificationsListNotificationsQueryKey = () => {
  return [`/api/notifications`] as const;
};

export const getNotificationsListNotificationsQueryOptions = <
  TData = Awaited<ReturnType<typeof notificationsListNotifications>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof notificationsListNotifications>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getNotificationsListNotificationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsListNotifications>>
  > = ({ signal }) => notificationsListNotifications(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notificationsListNotifications>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type NotificationsListNotificationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof notificationsListNotifications>>
>;
export type NotificationsListNotificationsQueryError = unknown;

/**
 * @summary GET /api/notifications
 */

export function useNotificationsListNotifications<
  TData = Awaited<ReturnType<typeof notificationsListNotifications>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof notificationsListNotifications>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getNotificationsListNotificationsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a specific notification
 * @summary DELETE /api/notifications/{notification_id}
 */
export const notificationsDeleteNotification = (notificationId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/notifications/${notificationId}`,
    method: "DELETE",
  });
};

export const getNotificationsDeleteNotificationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsDeleteNotification>>,
    TError,
    { notificationId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsDeleteNotification>>,
  TError,
  { notificationId: string },
  TContext
> => {
  const mutationKey = ["notificationsDeleteNotification"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsDeleteNotification>>,
    { notificationId: string }
  > = (props) => {
    const { notificationId } = props ?? {};

    return notificationsDeleteNotification(notificationId);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsDeleteNotificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof notificationsDeleteNotification>>
>;

export type NotificationsDeleteNotificationMutationError = unknown;

/**
 * @summary DELETE /api/notifications/{notification_id}
 */
export const useNotificationsDeleteNotification = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsDeleteNotification>>,
    TError,
    { notificationId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof notificationsDeleteNotification>>,
  TError,
  { notificationId: string },
  TContext
> => {
  const mutationOptions =
    getNotificationsDeleteNotificationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update read information
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const notificationsMarkNotificationRead = (
  notificationId: string,
  notificationsMarkNotificationReadBody?: NotificationsMarkNotificationReadBody,
) => {
  return customInstance<void>({
    url: `/api/notifications/${notificationId}/read`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: notificationsMarkNotificationReadBody,
  });
};

export const getNotificationsMarkNotificationReadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
    TError,
    { notificationId: string; data: NotificationsMarkNotificationReadBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
  TError,
  { notificationId: string; data: NotificationsMarkNotificationReadBody },
  TContext
> => {
  const mutationKey = ["notificationsMarkNotificationRead"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
    { notificationId: string; data: NotificationsMarkNotificationReadBody }
  > = (props) => {
    const { notificationId, data } = props ?? {};

    return notificationsMarkNotificationRead(notificationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsMarkNotificationReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof notificationsMarkNotificationRead>>
>;
export type NotificationsMarkNotificationReadMutationBody =
  NotificationsMarkNotificationReadBody;
export type NotificationsMarkNotificationReadMutationError = unknown;

/**
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const useNotificationsMarkNotificationRead = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
    TError,
    { notificationId: string; data: NotificationsMarkNotificationReadBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
  TError,
  { notificationId: string; data: NotificationsMarkNotificationReadBody },
  TContext
> => {
  const mutationOptions =
    getNotificationsMarkNotificationReadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve stats information
 * @summary GET /api/notifications/stats
 */
export const notificationsNotificationStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/notifications/stats`,
    method: "GET",
    signal,
  });
};

export const getNotificationsNotificationStatsQueryKey = () => {
  return [`/api/notifications/stats`] as const;
};

export const getNotificationsNotificationStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof notificationsNotificationStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof notificationsNotificationStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getNotificationsNotificationStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsNotificationStats>>
  > = ({ signal }) => notificationsNotificationStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notificationsNotificationStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type NotificationsNotificationStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof notificationsNotificationStats>>
>;
export type NotificationsNotificationStatsQueryError = unknown;

/**
 * @summary GET /api/notifications/stats
 */

export function useNotificationsNotificationStats<
  TData = Awaited<ReturnType<typeof notificationsNotificationStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof notificationsNotificationStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getNotificationsNotificationStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new process
 * @summary POST /api/ocr/process
 */
export const sgkProcessOcr = (
  sgkProcessOcrBody?: SgkProcessOcrBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/process`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkProcessOcrBody,
    signal,
  });
};

export const getSgkProcessOcrMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    TError,
    { data: SgkProcessOcrBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkProcessOcr>>,
  TError,
  { data: SgkProcessOcrBody },
  TContext
> => {
  const mutationKey = ["sgkProcessOcr"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    { data: SgkProcessOcrBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkProcessOcr(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkProcessOcrMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkProcessOcr>>
>;
export type SgkProcessOcrMutationBody = SgkProcessOcrBody;
export type SgkProcessOcrMutationError = unknown;

/**
 * @summary POST /api/ocr/process
 */
export const useSgkProcessOcr = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    TError,
    { data: SgkProcessOcrBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkProcessOcr>>,
  TError,
  { data: SgkProcessOcrBody },
  TContext
> => {
  const mutationOptions = getSgkProcessOcrMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns CORS headers so the static Swagger UI served from a different origin (e.g. localhost:8080)
can fetch the YAML without browser CORS errors.
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */
export const serveOpenapiYaml = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/openapi.yaml`,
    method: "GET",
    signal,
  });
};

export const getServeOpenapiYamlQueryKey = () => {
  return [`/api/openapi.yaml`] as const;
};

export const getServeOpenapiYamlQueryOptions = <
  TData = Awaited<ReturnType<typeof serveOpenapiYaml>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof serveOpenapiYaml>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getServeOpenapiYamlQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof serveOpenapiYaml>>
  > = ({ signal }) => serveOpenapiYaml(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof serveOpenapiYaml>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ServeOpenapiYamlQueryResult = NonNullable<
  Awaited<ReturnType<typeof serveOpenapiYaml>>
>;
export type ServeOpenapiYamlQueryError = unknown;

/**
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */

export function useServeOpenapiYaml<
  TData = Awaited<ReturnType<typeof serveOpenapiYaml>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof serveOpenapiYaml>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getServeOpenapiYamlQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
  params?: PatientsGetPatientsParams,
  signal?: AbortSignal,
) => {
  return customInstance<PatientsGetPatients200>({
    url: `/api/patients`,
    method: "GET",
    params,
    signal,
  });
};

export const getPatientsGetPatientsQueryKey = (
  params?: PatientsGetPatientsParams,
) => {
  return [`/api/patients`, ...(params ? [params] : [])] as const;
};

export const getPatientsGetPatientsQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsGetPatients>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: PatientsGetPatientsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatients>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsGetPatients>>
  > = ({ signal }) => patientsGetPatients(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsGetPatients>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsGetPatientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsGetPatients>>
>;
export type PatientsGetPatientsQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<
  TData = Awaited<ReturnType<typeof patientsGetPatients>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: PatientsGetPatientsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatients>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsGetPatientsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
  patientsCreatePatientBody?: PatientsCreatePatientBody,
  signal?: AbortSignal,
) => {
  return customInstance<Patient>({
    url: `/api/patients`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patientsCreatePatientBody,
    signal,
  });
};

export const getPatientsCreatePatientMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsCreatePatient>>,
    TError,
    { data: PatientsCreatePatientBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientsCreatePatient>>,
  TError,
  { data: PatientsCreatePatientBody },
  TContext
> => {
  const mutationKey = ["patientsCreatePatient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientsCreatePatient>>,
    { data: PatientsCreatePatientBody }
  > = (props) => {
    const { data } = props ?? {};

    return patientsCreatePatient(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientsCreatePatientMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientsCreatePatient>>
>;
export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody;
export type PatientsCreatePatientMutationError = unknown;

/**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsCreatePatient>>,
    TError,
    { data: PatientsCreatePatientBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientsCreatePatient>>,
  TError,
  { data: PatientsCreatePatientBody },
  TContext
> => {
  const mutationOptions = getPatientsCreatePatientMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve detailed information about a specific patient
 * @summary Get a specific patient by ID
 */
export const patientsGetPatient = (patientId: string, signal?: AbortSignal) => {
  return customInstance<Patient>({
    url: `/api/patients/${patientId}`,
    method: "GET",
    signal,
  });
};

export const getPatientsGetPatientQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}`] as const;
};

export const getPatientsGetPatientQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsGetPatient>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatient>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsGetPatient>>
  > = ({ signal }) => patientsGetPatient(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsGetPatient>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsGetPatientQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsGetPatient>>
>;
export type PatientsGetPatientQueryError = unknown;

/**
 * @summary Get a specific patient by ID
 */

export function usePatientsGetPatient<
  TData = Awaited<ReturnType<typeof patientsGetPatient>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatient>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsGetPatientQueryOptions(patientId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update an existing patient's information
 * @summary Update a patient
 */
export const patientsUpdatePatient = (patientId: string, patient: Patient) => {
  return customInstance<Patient>({
    url: `/api/patients/${patientId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: patient,
  });
};

export const getPatientsUpdatePatientMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsUpdatePatient>>,
    TError,
    { patientId: string; data: Patient },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientsUpdatePatient>>,
  TError,
  { patientId: string; data: Patient },
  TContext
> => {
  const mutationKey = ["patientsUpdatePatient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientsUpdatePatient>>,
    { patientId: string; data: Patient }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return patientsUpdatePatient(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientsUpdatePatientMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientsUpdatePatient>>
>;
export type PatientsUpdatePatientMutationBody = Patient;
export type PatientsUpdatePatientMutationError = unknown;

/**
 * @summary Update a patient
 */
export const usePatientsUpdatePatient = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsUpdatePatient>>,
    TError,
    { patientId: string; data: Patient },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientsUpdatePatient>>,
  TError,
  { patientId: string; data: Patient },
  TContext
> => {
  const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (patientId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/patients/${patientId}`,
    method: "DELETE",
  });
};

export const getPatientsDeletePatientMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsDeletePatient>>,
    TError,
    { patientId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientsDeletePatient>>,
  TError,
  { patientId: string },
  TContext
> => {
  const mutationKey = ["patientsDeletePatient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientsDeletePatient>>,
    { patientId: string }
  > = (props) => {
    const { patientId } = props ?? {};

    return patientsDeletePatient(patientId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientsDeletePatientMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientsDeletePatient>>
>;

export type PatientsDeletePatientMutationError = unknown;

/**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsDeletePatient>>,
    TError,
    { patientId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientsDeletePatient>>,
  TError,
  { patientId: string },
  TContext
> => {
  const mutationOptions = getPatientsDeletePatientMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
  patientId: string,
  salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/assign-devices-extended`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesAssignDevicesExtendedBody,
    signal,
  });
};

export const getSalesAssignDevicesExtendedMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
    TError,
    { patientId: string; data: SalesAssignDevicesExtendedBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
  TError,
  { patientId: string; data: SalesAssignDevicesExtendedBody },
  TContext
> => {
  const mutationKey = ["salesAssignDevicesExtended"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
    { patientId: string; data: SalesAssignDevicesExtendedBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return salesAssignDevicesExtended(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesAssignDevicesExtendedMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesAssignDevicesExtended>>
>;
export type SalesAssignDevicesExtendedMutationBody =
  SalesAssignDevicesExtendedBody;
export type SalesAssignDevicesExtendedMutationError = unknown;

/**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
    TError,
    { patientId: string; data: SalesAssignDevicesExtendedBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
  TError,
  { patientId: string; data: SalesAssignDevicesExtendedBody },
  TContext
> => {
  const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<PatientsGetPatientDevices200>({
    url: `/api/patients/${patientId}/devices`,
    method: "GET",
    signal,
  });
};

export const getPatientsGetPatientDevicesQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/devices`] as const;
};

export const getPatientsGetPatientDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatientDevices>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsGetPatientDevices>>
  > = ({ signal }) => patientsGetPatientDevices(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsGetPatientDevices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsGetPatientDevicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsGetPatientDevices>>
>;
export type PatientsGetPatientDevicesQueryError = unknown;

/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<
  TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsGetPatientDevices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsGetPatientDevicesQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
  patientId: string,
  patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/ereceipts`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patientSubresourcesCreatePatientEreceiptBody,
    signal,
  });
};

export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
    TError,
    { patientId: string; data: PatientSubresourcesCreatePatientEreceiptBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
  TError,
  { patientId: string; data: PatientSubresourcesCreatePatientEreceiptBody },
  TContext
> => {
  const mutationKey = ["patientSubresourcesCreatePatientEreceipt"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
    { patientId: string; data: PatientSubresourcesCreatePatientEreceiptBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return patientSubresourcesCreatePatientEreceipt(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesCreatePatientEreceiptMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>
  >;
export type PatientSubresourcesCreatePatientEreceiptMutationBody =
  PatientSubresourcesCreatePatientEreceiptBody;
export type PatientSubresourcesCreatePatientEreceiptMutationError = unknown;

/**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
    TError,
    { patientId: string; data: PatientSubresourcesCreatePatientEreceiptBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
  TError,
  { patientId: string; data: PatientSubresourcesCreatePatientEreceiptBody },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
  patientId: string,
  ereceiptId: string,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`,
    method: "DELETE",
  });
};

export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
    TError,
    { patientId: string; ereceiptId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
  TError,
  { patientId: string; ereceiptId: string },
  TContext
> => {
  const mutationKey = ["patientSubresourcesDeletePatientEreceipt"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
    { patientId: string; ereceiptId: string }
  > = (props) => {
    const { patientId, ereceiptId } = props ?? {};

    return patientSubresourcesDeletePatientEreceipt(patientId, ereceiptId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesDeletePatientEreceiptMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>
  >;

export type PatientSubresourcesDeletePatientEreceiptMutationError = unknown;

/**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
    TError,
    { patientId: string; ereceiptId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
  TError,
  { patientId: string; ereceiptId: string },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
  patientId: string,
  patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/hearing-tests`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patientSubresourcesAddPatientHearingTestBody,
    signal,
  });
};

export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
    TError,
    { patientId: string; data: PatientSubresourcesAddPatientHearingTestBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
  TError,
  { patientId: string; data: PatientSubresourcesAddPatientHearingTestBody },
  TContext
> => {
  const mutationKey = ["patientSubresourcesAddPatientHearingTest"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
    { patientId: string; data: PatientSubresourcesAddPatientHearingTestBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return patientSubresourcesAddPatientHearingTest(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesAddPatientHearingTestMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>
  >;
export type PatientSubresourcesAddPatientHearingTestMutationBody =
  PatientSubresourcesAddPatientHearingTestBody;
export type PatientSubresourcesAddPatientHearingTestMutationError = unknown;

/**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
    TError,
    { patientId: string; data: PatientSubresourcesAddPatientHearingTestBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
  TError,
  { patientId: string; data: PatientSubresourcesAddPatientHearingTestBody },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
  patientId: string,
  testId: string,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/hearing-tests/${testId}`,
    method: "DELETE",
  });
};

export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
    TError,
    { patientId: string; testId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
  TError,
  { patientId: string; testId: string },
  TContext
> => {
  const mutationKey = ["patientSubresourcesDeletePatientHearingTest"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
    { patientId: string; testId: string }
  > = (props) => {
    const { patientId, testId } = props ?? {};

    return patientSubresourcesDeletePatientHearingTest(patientId, testId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesDeletePatientHearingTestMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>
  >;

export type PatientSubresourcesDeletePatientHearingTestMutationError = unknown;

/**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
    TError,
    { patientId: string; testId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
  TError,
  { patientId: string; testId: string },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
  patientId: string,
  patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/notes`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patientSubresourcesCreatePatientNoteBody,
    signal,
  });
};

export const getPatientSubresourcesCreatePatientNoteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
    TError,
    { patientId: string; data: PatientSubresourcesCreatePatientNoteBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
  TError,
  { patientId: string; data: PatientSubresourcesCreatePatientNoteBody },
  TContext
> => {
  const mutationKey = ["patientSubresourcesCreatePatientNote"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
    { patientId: string; data: PatientSubresourcesCreatePatientNoteBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return patientSubresourcesCreatePatientNote(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>
>;
export type PatientSubresourcesCreatePatientNoteMutationBody =
  PatientSubresourcesCreatePatientNoteBody;
export type PatientSubresourcesCreatePatientNoteMutationError = unknown;

/**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
    TError,
    { patientId: string; data: PatientSubresourcesCreatePatientNoteBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
  TError,
  { patientId: string; data: PatientSubresourcesCreatePatientNoteBody },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesCreatePatientNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
  patientId: string,
  noteId: string,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/notes/${noteId}`,
    method: "DELETE",
  });
};

export const getPatientSubresourcesDeletePatientNoteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
    TError,
    { patientId: string; noteId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
  TError,
  { patientId: string; noteId: string },
  TContext
> => {
  const mutationKey = ["patientSubresourcesDeletePatientNote"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
    { patientId: string; noteId: string }
  > = (props) => {
    const { patientId, noteId } = props ?? {};

    return patientSubresourcesDeletePatientNote(patientId, noteId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>
>;

export type PatientSubresourcesDeletePatientNoteMutationError = unknown;

/**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
    TError,
    { patientId: string; noteId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
  TError,
  { patientId: string; noteId: string },
  TContext
> => {
  const mutationOptions =
    getPatientSubresourcesDeletePatientNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/promissory-notes`,
    method: "GET",
    signal,
  });
};

export const getPaymentsGetPatientPromissoryNotesQueryKey = (
  patientId?: string,
) => {
  return [`/api/patients/${patientId}/promissory-notes`] as const;
};

export const getPaymentsGetPatientPromissoryNotesQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
  > = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
>;
export type PaymentsGetPatientPromissoryNotesQueryError = unknown;

/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<
  TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Sale[]>({
    url: `/api/patients/${patientId}/sales`,
    method: "GET",
    signal,
  });
};

export const getSalesGetPatientSalesQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/sales`] as const;
};

export const getSalesGetPatientSalesQueryOptions = <
  TData = Awaited<ReturnType<typeof salesGetPatientSales>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetPatientSales>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof salesGetPatientSales>>
  > = ({ signal }) => salesGetPatientSales(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof salesGetPatientSales>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SalesGetPatientSalesQueryResult = NonNullable<
  Awaited<ReturnType<typeof salesGetPatientSales>>
>;
export type SalesGetPatientSalesQueryError = unknown;

/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<
  TData = Awaited<ReturnType<typeof salesGetPatientSales>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetPatientSales>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/sgk-documents`,
    method: "GET",
    signal,
  });
};

export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/sgk-documents`] as const;
};

export const getSgkGetPatientSgkDocumentsQueryOptions = <
  TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
  > = ({ signal }) => sgkGetPatientSgkDocuments(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
>;
export type SgkGetPatientSgkDocumentsQueryError = unknown;

/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<
  TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all timeline events for a specific patient, including events from both custom data and activity logs
 * @summary Get timeline events for a patient
 */
export const timelineGetPatientTimeline = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<TimelineGetPatientTimeline200>({
    url: `/api/patients/${patientId}/timeline`,
    method: "GET",
    signal,
  });
};

export const getTimelineGetPatientTimelineQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/timeline`] as const;
};

export const getTimelineGetPatientTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
  TError = void | void,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTimelineGetPatientTimelineQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timelineGetPatientTimeline>>
  > = ({ signal }) => timelineGetPatientTimeline(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TimelineGetPatientTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof timelineGetPatientTimeline>>
>;
export type TimelineGetPatientTimelineQueryError = void | void;

/**
 * @summary Get timeline events for a patient
 */

export function useTimelineGetPatientTimeline<
  TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
  TError = void | void,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTimelineGetPatientTimelineQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new timeline event for a specific patient and logs it to both custom data and activity logs
 * @summary Add a new timeline event for a patient
 */
export const timelineAddTimelineEvent = (
  patientId: string,
  timelineAddTimelineEventBody: TimelineAddTimelineEventBody,
  signal?: AbortSignal,
) => {
  return customInstance<TimelineAddTimelineEvent201>({
    url: `/api/patients/${patientId}/timeline`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: timelineAddTimelineEventBody,
    signal,
  });
};

export const getTimelineAddTimelineEventMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
    TError,
    { patientId: string; data: TimelineAddTimelineEventBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
  TError,
  { patientId: string; data: TimelineAddTimelineEventBody },
  TContext
> => {
  const mutationKey = ["timelineAddTimelineEvent"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
    { patientId: string; data: TimelineAddTimelineEventBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return timelineAddTimelineEvent(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TimelineAddTimelineEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof timelineAddTimelineEvent>>
>;
export type TimelineAddTimelineEventMutationBody = TimelineAddTimelineEventBody;
export type TimelineAddTimelineEventMutationError = void | void | void;

/**
 * @summary Add a new timeline event for a patient
 */
export const useTimelineAddTimelineEvent = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
    TError,
    { patientId: string; data: TimelineAddTimelineEventBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
  TError,
  { patientId: string; data: TimelineAddTimelineEventBody },
  TContext
> => {
  const mutationOptions = getTimelineAddTimelineEventMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Removes a specific timeline event from a patient's timeline
 * @summary Delete a timeline event
 */
export const timelineDeleteTimelineEvent = (
  patientId: string,
  eventId: string,
) => {
  return customInstance<TimelineDeleteTimelineEvent200>({
    url: `/api/patients/${patientId}/timeline/${eventId}`,
    method: "DELETE",
  });
};

export const getTimelineDeleteTimelineEventMutationOptions = <
  TError = void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
    TError,
    { patientId: string; eventId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
  TError,
  { patientId: string; eventId: string },
  TContext
> => {
  const mutationKey = ["timelineDeleteTimelineEvent"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
    { patientId: string; eventId: string }
  > = (props) => {
    const { patientId, eventId } = props ?? {};

    return timelineDeleteTimelineEvent(patientId, eventId);
  };

  return { mutationFn, ...mutationOptions };
};

export type TimelineDeleteTimelineEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>
>;

export type TimelineDeleteTimelineEventMutationError = void | void;

/**
 * @summary Delete a timeline event
 */
export const useTimelineDeleteTimelineEvent = <
  TError = void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
    TError,
    { patientId: string; eventId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
  TError,
  { patientId: string; eventId: string },
  TContext
> => {
  const mutationOptions =
    getTimelineDeleteTimelineEventMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Alternative endpoint for adding timeline events, provides the same functionality as POST /api/patients/{patient_id}/timeline
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const timelineLogPatientActivity = (
  patientId: string,
  timelineLogPatientActivityBody: TimelineLogPatientActivityBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/activities`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: timelineLogPatientActivityBody,
    signal,
  });
};

export const getTimelineLogPatientActivityMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineLogPatientActivity>>,
    TError,
    { patientId: string; data: TimelineLogPatientActivityBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof timelineLogPatientActivity>>,
  TError,
  { patientId: string; data: TimelineLogPatientActivityBody },
  TContext
> => {
  const mutationKey = ["timelineLogPatientActivity"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timelineLogPatientActivity>>,
    { patientId: string; data: TimelineLogPatientActivityBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return timelineLogPatientActivity(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TimelineLogPatientActivityMutationResult = NonNullable<
  Awaited<ReturnType<typeof timelineLogPatientActivity>>
>;
export type TimelineLogPatientActivityMutationBody =
  TimelineLogPatientActivityBody;
export type TimelineLogPatientActivityMutationError = void | void | void;

/**
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const useTimelineLogPatientActivity = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timelineLogPatientActivity>>,
    TError,
    { patientId: string; data: TimelineLogPatientActivityBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof timelineLogPatientActivity>>,
  TError,
  { patientId: string; data: TimelineLogPatientActivityBody },
  TContext
> => {
  const mutationOptions = getTimelineLogPatientActivityMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
  patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/bulk_upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patientsBulkUploadPatientsBody,
    signal,
  });
};

export const getPatientsBulkUploadPatientsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
    TError,
    { data: PatientsBulkUploadPatientsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
  TError,
  { data: PatientsBulkUploadPatientsBody },
  TContext
> => {
  const mutationKey = ["patientsBulkUploadPatients"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
    { data: PatientsBulkUploadPatientsBody }
  > = (props) => {
    const { data } = props ?? {};

    return patientsBulkUploadPatients(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatientsBulkUploadPatientsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patientsBulkUploadPatients>>
>;
export type PatientsBulkUploadPatientsMutationBody =
  PatientsBulkUploadPatientsBody;
export type PatientsBulkUploadPatientsMutationError = unknown;

/**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
    TError,
    { data: PatientsBulkUploadPatientsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
  TError,
  { data: PatientsBulkUploadPatientsBody },
  TContext
> => {
  const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Count patients matching the given filters. Only counts patients with valid phone numbers.
Useful for SMS campaign target audience estimation.

 * @summary Count patients with optional filters for SMS campaigns
 */
export const patientsCountPatients = (
  params?: PatientsCountPatientsParams,
  signal?: AbortSignal,
) => {
  return customInstance<PatientsCountPatients200>({
    url: `/api/patients/count`,
    method: "GET",
    params,
    signal,
  });
};

export const getPatientsCountPatientsQueryKey = (
  params?: PatientsCountPatientsParams,
) => {
  return [`/api/patients/count`, ...(params ? [params] : [])] as const;
};

export const getPatientsCountPatientsQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsCountPatients>>,
  TError = unknown,
>(
  params?: PatientsCountPatientsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsCountPatients>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsCountPatientsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsCountPatients>>
  > = ({ signal }) => patientsCountPatients(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsCountPatients>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsCountPatientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsCountPatients>>
>;
export type PatientsCountPatientsQueryError = unknown;

/**
 * @summary Count patients with optional filters for SMS campaigns
 */

export function usePatientsCountPatients<
  TData = Awaited<ReturnType<typeof patientsCountPatients>>,
  TError = unknown,
>(
  params?: PatientsCountPatientsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof patientsCountPatients>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsCountPatientsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve the authenticated tenant's subscription status, plan, and expiry info.
 * @summary Get current tenant subscription
 */
export const subscriptionsGetCurrent = (signal?: AbortSignal) => {
  return customInstance<SubscriptionsGetCurrent200>({
    url: `/api/subscriptions/current`,
    method: "GET",
    signal,
  });
};

export const getSubscriptionsGetCurrentQueryKey = () => {
  return [`/api/subscriptions/current`] as const;
};

export const getSubscriptionsGetCurrentQueryOptions = <
  TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSubscriptionsGetCurrentQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof subscriptionsGetCurrent>>
  > = ({ signal }) => subscriptionsGetCurrent(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SubscriptionsGetCurrentQueryResult = NonNullable<
  Awaited<ReturnType<typeof subscriptionsGetCurrent>>
>;
export type SubscriptionsGetCurrentQueryError = unknown;

/**
 * @summary Get current tenant subscription
 */

export function useSubscriptionsGetCurrent<
  TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSubscriptionsGetCurrentQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve active add-ons that tenants can purchase as optional features.
 * @summary List active public add-ons
 */
export const addonsListActive = (signal?: AbortSignal) => {
  return customInstance<AddonsListActive200>({
    url: `/api/addons`,
    method: "GET",
    signal,
  });
};

export const getAddonsListActiveQueryKey = () => {
  return [`/api/addons`] as const;
};

export const getAddonsListActiveQueryOptions = <
  TData = Awaited<ReturnType<typeof addonsListActive>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof addonsListActive>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAddonsListActiveQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof addonsListActive>>
  > = ({ signal }) => addonsListActive(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof addonsListActive>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AddonsListActiveQueryResult = NonNullable<
  Awaited<ReturnType<typeof addonsListActive>>
>;
export type AddonsListActiveQueryError = unknown;

/**
 * @summary List active public add-ons
 */

export function useAddonsListActive<
  TData = Awaited<ReturnType<typeof addonsListActive>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof addonsListActive>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAddonsListActiveQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/patients/export`,
    method: "GET",
    signal,
  });
};

export const getPatientsExportPatientsCsvQueryKey = () => {
  return [`/api/patients/export`] as const;
};

export const getPatientsExportPatientsCsvQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsExportPatientsCsv>>
  > = ({ signal }) => patientsExportPatientsCsv(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsExportPatientsCsvQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsExportPatientsCsv>>
>;
export type PatientsExportPatientsCsvQueryError = unknown;

/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<
  TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/patients/search`,
    method: "GET",
    signal,
  });
};

export const getPatientsSearchPatientsQueryKey = () => {
  return [`/api/patients/search`] as const;
};

export const getPatientsSearchPatientsQueryOptions = <
  TData = Awaited<ReturnType<typeof patientsSearchPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof patientsSearchPatients>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof patientsSearchPatients>>
  > = ({ signal }) => patientsSearchPatients(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof patientsSearchPatients>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PatientsSearchPatientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof patientsSearchPatients>>
>;
export type PatientsSearchPatientsQueryError = unknown;

/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<
  TData = Awaited<ReturnType<typeof patientsSearchPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof patientsSearchPatients>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPatientsSearchPatientsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new pricing-preview
 * @summary POST /api/pricing-preview
 */
export const salesPricingPreview = (
  salesPricingPreviewBody?: SalesPricingPreviewBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/pricing-preview`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesPricingPreviewBody,
    signal,
  });
};

export const getSalesPricingPreviewMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesPricingPreview>>,
    TError,
    { data: SalesPricingPreviewBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesPricingPreview>>,
  TError,
  { data: SalesPricingPreviewBody },
  TContext
> => {
  const mutationKey = ["salesPricingPreview"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesPricingPreview>>,
    { data: SalesPricingPreviewBody }
  > = (props) => {
    const { data } = props ?? {};

    return salesPricingPreview(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesPricingPreviewMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesPricingPreview>>
>;
export type SalesPricingPreviewMutationBody = SalesPricingPreviewBody;
export type SalesPricingPreviewMutationError = unknown;

/**
 * @summary POST /api/pricing-preview
 */
export const useSalesPricingPreview = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesPricingPreview>>,
    TError,
    { data: SalesPricingPreviewBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesPricingPreview>>,
  TError,
  { data: SalesPricingPreviewBody },
  TContext
> => {
  const mutationOptions = getSalesPricingPreviewMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete {ps_id}
 * @summary Delete a product-supplier relationship
 */
export const suppliersDeleteProductSupplier = (psId: string) => {
  return customInstance<void>({
    url: `/api/product-suppliers/${psId}`,
    method: "DELETE",
  });
};

export const getSuppliersDeleteProductSupplierMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
    TError,
    { psId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
  TError,
  { psId: string },
  TContext
> => {
  const mutationKey = ["suppliersDeleteProductSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
    { psId: string }
  > = (props) => {
    const { psId } = props ?? {};

    return suppliersDeleteProductSupplier(psId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersDeleteProductSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>
>;

export type SuppliersDeleteProductSupplierMutationError = unknown;

/**
 * @summary Delete a product-supplier relationship
 */
export const useSuppliersDeleteProductSupplier = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
    TError,
    { psId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
  TError,
  { psId: string },
  TContext
> => {
  const mutationOptions =
    getSuppliersDeleteProductSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new suppliers
 * @summary Add a supplier to a product
 */
export const suppliersAddProductSupplier = (
  productId: string,
  suppliersAddProductSupplierBody?: SuppliersAddProductSupplierBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/products/${productId}/suppliers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: suppliersAddProductSupplierBody,
    signal,
  });
};

export const getSuppliersAddProductSupplierMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
    TError,
    { productId: string; data: SuppliersAddProductSupplierBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
  TError,
  { productId: string; data: SuppliersAddProductSupplierBody },
  TContext
> => {
  const mutationKey = ["suppliersAddProductSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
    { productId: string; data: SuppliersAddProductSupplierBody }
  > = (props) => {
    const { productId, data } = props ?? {};

    return suppliersAddProductSupplier(productId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersAddProductSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersAddProductSupplier>>
>;
export type SuppliersAddProductSupplierMutationBody =
  SuppliersAddProductSupplierBody;
export type SuppliersAddProductSupplierMutationError = unknown;

/**
 * @summary Add a supplier to a product
 */
export const useSuppliersAddProductSupplier = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
    TError,
    { productId: string; data: SuppliersAddProductSupplierBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
  TError,
  { productId: string; data: SuppliersAddProductSupplierBody },
  TContext
> => {
  const mutationOptions =
    getSuppliersAddProductSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create multiple promissory notes
 */
export const paymentsCreatePromissoryNotes = (
  paymentsCreatePromissoryNotesBody?: PaymentsCreatePromissoryNotesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/promissory-notes`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: paymentsCreatePromissoryNotesBody,
    signal,
  });
};

export const getPaymentsCreatePromissoryNotesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
    TError,
    { data: PaymentsCreatePromissoryNotesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
  TError,
  { data: PaymentsCreatePromissoryNotesBody },
  TContext
> => {
  const mutationKey = ["paymentsCreatePromissoryNotes"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
    { data: PaymentsCreatePromissoryNotesBody }
  > = (props) => {
    const { data } = props ?? {};

    return paymentsCreatePromissoryNotes(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentsCreatePromissoryNotesMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>
>;
export type PaymentsCreatePromissoryNotesMutationBody =
  PaymentsCreatePromissoryNotesBody;
export type PaymentsCreatePromissoryNotesMutationError = unknown;

/**
 * @summary Create multiple promissory notes
 */
export const usePaymentsCreatePromissoryNotes = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
    TError,
    { data: PaymentsCreatePromissoryNotesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
  TError,
  { data: PaymentsCreatePromissoryNotesBody },
  TContext
> => {
  const mutationOptions =
    getPaymentsCreatePromissoryNotesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update a promissory note
 */
export const paymentsUpdatePromissoryNote = (
  noteId: string,
  paymentsUpdatePromissoryNoteBody?: PaymentsUpdatePromissoryNoteBody,
) => {
  return customInstance<void>({
    url: `/api/promissory-notes/${noteId}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: paymentsUpdatePromissoryNoteBody,
  });
};

export const getPaymentsUpdatePromissoryNoteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
    TError,
    { noteId: string; data: PaymentsUpdatePromissoryNoteBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
  TError,
  { noteId: string; data: PaymentsUpdatePromissoryNoteBody },
  TContext
> => {
  const mutationKey = ["paymentsUpdatePromissoryNote"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
    { noteId: string; data: PaymentsUpdatePromissoryNoteBody }
  > = (props) => {
    const { noteId, data } = props ?? {};

    return paymentsUpdatePromissoryNote(noteId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentsUpdatePromissoryNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>
>;
export type PaymentsUpdatePromissoryNoteMutationBody =
  PaymentsUpdatePromissoryNoteBody;
export type PaymentsUpdatePromissoryNoteMutationError = unknown;

/**
 * @summary Update a promissory note
 */
export const usePaymentsUpdatePromissoryNote = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
    TError,
    { noteId: string; data: PaymentsUpdatePromissoryNoteBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
  TError,
  { noteId: string; data: PaymentsUpdatePromissoryNoteBody },
  TContext
> => {
  const mutationOptions =
    getPaymentsUpdatePromissoryNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const paymentsCollectPromissoryNote = (
  noteId: string,
  paymentsCollectPromissoryNoteBody?: PaymentsCollectPromissoryNoteBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/promissory-notes/${noteId}/collect`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: paymentsCollectPromissoryNoteBody,
    signal,
  });
};

export const getPaymentsCollectPromissoryNoteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
    TError,
    { noteId: string; data: PaymentsCollectPromissoryNoteBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
  TError,
  { noteId: string; data: PaymentsCollectPromissoryNoteBody },
  TContext
> => {
  const mutationKey = ["paymentsCollectPromissoryNote"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
    { noteId: string; data: PaymentsCollectPromissoryNoteBody }
  > = (props) => {
    const { noteId, data } = props ?? {};

    return paymentsCollectPromissoryNote(noteId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentsCollectPromissoryNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>
>;
export type PaymentsCollectPromissoryNoteMutationBody =
  PaymentsCollectPromissoryNoteBody;
export type PaymentsCollectPromissoryNoteMutationError = unknown;

/**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const usePaymentsCollectPromissoryNote = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
    TError,
    { noteId: string; data: PaymentsCollectPromissoryNoteBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
  TError,
  { noteId: string; data: PaymentsCollectPromissoryNoteBody },
  TContext
> => {
  const mutationOptions =
    getPaymentsCollectPromissoryNoteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new register-phone
 * @summary POST /api/register-phone
 */
export const registrationRegisterPhone = (
  registrationRegisterPhoneBody?: RegistrationRegisterPhoneBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/register-phone`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: registrationRegisterPhoneBody,
    signal,
  });
};

export const getRegistrationRegisterPhoneMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registrationRegisterPhone>>,
    TError,
    { data: RegistrationRegisterPhoneBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registrationRegisterPhone>>,
  TError,
  { data: RegistrationRegisterPhoneBody },
  TContext
> => {
  const mutationKey = ["registrationRegisterPhone"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registrationRegisterPhone>>,
    { data: RegistrationRegisterPhoneBody }
  > = (props) => {
    const { data } = props ?? {};

    return registrationRegisterPhone(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegistrationRegisterPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof registrationRegisterPhone>>
>;
export type RegistrationRegisterPhoneMutationBody =
  RegistrationRegisterPhoneBody;
export type RegistrationRegisterPhoneMutationError = unknown;

/**
 * @summary POST /api/register-phone
 */
export const useRegistrationRegisterPhone = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registrationRegisterPhone>>,
    TError,
    { data: RegistrationRegisterPhoneBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof registrationRegisterPhone>>,
  TError,
  { data: RegistrationRegisterPhoneBody },
  TContext
> => {
  const mutationOptions = getRegistrationRegisterPhoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve appointments information
 * @summary GET /api/reports/appointments
 */
export const reportsReportAppointments = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/appointments`,
    method: "GET",
    signal,
  });
};

export const getReportsReportAppointmentsQueryKey = () => {
  return [`/api/reports/appointments`] as const;
};

export const getReportsReportAppointmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportAppointments>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportAppointmentsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportAppointments>>
  > = ({ signal }) => reportsReportAppointments(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportAppointments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportAppointmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportAppointments>>
>;
export type ReportsReportAppointmentsQueryError = unknown;

/**
 * @summary GET /api/reports/appointments
 */

export function useReportsReportAppointments<
  TData = Awaited<ReturnType<typeof reportsReportAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportAppointments>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportAppointmentsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve campaigns information
 * @summary Kampanya raporu
 */
export const reportsReportCampaigns = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/campaigns`,
    method: "GET",
    signal,
  });
};

export const getReportsReportCampaignsQueryKey = () => {
  return [`/api/reports/campaigns`] as const;
};

export const getReportsReportCampaignsQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportCampaigns>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportCampaigns>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportCampaignsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportCampaigns>>
  > = ({ signal }) => reportsReportCampaigns(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportCampaigns>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportCampaignsQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportCampaigns>>
>;
export type ReportsReportCampaignsQueryError = unknown;

/**
 * @summary Kampanya raporu
 */

export function useReportsReportCampaigns<
  TData = Awaited<ReturnType<typeof reportsReportCampaigns>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportCampaigns>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportCampaignsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve financial information
 * @summary Mali rapor
 */
export const reportsReportFinancial = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/financial`,
    method: "GET",
    signal,
  });
};

export const getReportsReportFinancialQueryKey = () => {
  return [`/api/reports/financial`] as const;
};

export const getReportsReportFinancialQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportFinancial>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportFinancial>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportFinancialQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportFinancial>>
  > = ({ signal }) => reportsReportFinancial(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportFinancial>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportFinancialQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportFinancial>>
>;
export type ReportsReportFinancialQueryError = unknown;

/**
 * @summary Mali rapor
 */

export function useReportsReportFinancial<
  TData = Awaited<ReturnType<typeof reportsReportFinancial>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportFinancial>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportFinancialQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve overview information
 * @summary Genel rapor Ã¶zeti
 */
export const reportsReportOverview = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/overview`,
    method: "GET",
    signal,
  });
};

export const getReportsReportOverviewQueryKey = () => {
  return [`/api/reports/overview`] as const;
};

export const getReportsReportOverviewQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportOverview>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportOverview>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReportsReportOverviewQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportOverview>>
  > = ({ signal }) => reportsReportOverview(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportOverview>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportOverviewQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportOverview>>
>;
export type ReportsReportOverviewQueryError = unknown;

/**
 * @summary Genel rapor Ã¶zeti
 */

export function useReportsReportOverview<
  TData = Awaited<ReturnType<typeof reportsReportOverview>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportOverview>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportOverviewQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve patients information
 * @summary Hasta analizi raporu
 */
export const reportsReportPatients = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/patients`,
    method: "GET",
    signal,
  });
};

export const getReportsReportPatientsQueryKey = () => {
  return [`/api/reports/patients`] as const;
};

export const getReportsReportPatientsQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPatients>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReportsReportPatientsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportPatients>>
  > = ({ signal }) => reportsReportPatients(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPatients>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportPatientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportPatients>>
>;
export type ReportsReportPatientsQueryError = unknown;

/**
 * @summary Hasta analizi raporu
 */

export function useReportsReportPatients<
  TData = Awaited<ReturnType<typeof reportsReportPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPatients>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportPatientsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve revenue information
 * @summary GET /api/reports/revenue
 */
export const reportsReportRevenue = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/reports/revenue`,
    method: "GET",
    signal,
  });
};

export const getReportsReportRevenueQueryKey = () => {
  return [`/api/reports/revenue`] as const;
};

export const getReportsReportRevenueQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportRevenue>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportRevenue>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReportsReportRevenueQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportRevenue>>
  > = ({ signal }) => reportsReportRevenue(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportRevenue>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportRevenueQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportRevenue>>
>;
export type ReportsReportRevenueQueryError = unknown;

/**
 * @summary GET /api/reports/revenue
 */

export function useReportsReportRevenue<
  TData = Awaited<ReturnType<typeof reportsReportRevenue>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportRevenue>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportRevenueQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of all sales
 * @summary GET /api/sales
 */
export const salesListSales = (signal?: AbortSignal) => {
  return customInstance<Sale[]>({ url: `/api/sales`, method: "GET", signal });
};

export const getSalesListSalesQueryKey = () => {
  return [`/api/sales`] as const;
};

export const getSalesListSalesQueryOptions = <
  TData = Awaited<ReturnType<typeof salesListSales>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof salesListSales>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSalesListSalesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof salesListSales>>> = ({
    signal,
  }) => salesListSales(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof salesListSales>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SalesListSalesQueryResult = NonNullable<
  Awaited<ReturnType<typeof salesListSales>>
>;
export type SalesListSalesQueryError = unknown;

/**
 * @summary GET /api/sales
 */

export function useSalesListSales<
  TData = Awaited<ReturnType<typeof salesListSales>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof salesListSales>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSalesListSalesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new sale
 * @summary POST /api/sales
 */
export const salesCreateSale = (
  salesCreateSaleBody: SalesCreateSaleBody,
  signal?: AbortSignal,
) => {
  return customInstance<Sale>({
    url: `/api/sales`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesCreateSaleBody,
    signal,
  });
};

export const getSalesCreateSaleMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSale>>,
    TError,
    { data: SalesCreateSaleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesCreateSale>>,
  TError,
  { data: SalesCreateSaleBody },
  TContext
> => {
  const mutationKey = ["salesCreateSale"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesCreateSale>>,
    { data: SalesCreateSaleBody }
  > = (props) => {
    const { data } = props ?? {};

    return salesCreateSale(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesCreateSaleMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesCreateSale>>
>;
export type SalesCreateSaleMutationBody = SalesCreateSaleBody;
export type SalesCreateSaleMutationError = ErrorResponse;

/**
 * @summary POST /api/sales
 */
export const useSalesCreateSale = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSale>>,
    TError,
    { data: SalesCreateSaleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesCreateSale>>,
  TError,
  { data: SalesCreateSaleBody },
  TContext
> => {
  const mutationOptions = getSalesCreateSaleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get sale details by ID
 * @summary GET /api/sales/{sale_id}
 */
export const salesGetSale = (saleId: string, signal?: AbortSignal) => {
  return customInstance<Sale>({
    url: `/api/sales/${saleId}`,
    method: "GET",
    signal,
  });
};

export const getSalesGetSaleQueryKey = (saleId?: string) => {
  return [`/api/sales/${saleId}`] as const;
};

export const getSalesGetSaleQueryOptions = <
  TData = Awaited<ReturnType<typeof salesGetSale>>,
  TError = ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetSale>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSalesGetSaleQueryKey(saleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSale>>> = ({
    signal,
  }) => salesGetSale(saleId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!saleId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof salesGetSale>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SalesGetSaleQueryResult = NonNullable<
  Awaited<ReturnType<typeof salesGetSale>>
>;
export type SalesGetSaleQueryError = ErrorResponse;

/**
 * @summary GET /api/sales/{sale_id}
 */

export function useSalesGetSale<
  TData = Awaited<ReturnType<typeof salesGetSale>>,
  TError = ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetSale>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSalesGetSaleQueryOptions(saleId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update sale information
 * @summary PUT /api/sales/{sale_id}
 */
export const salesUpdateSale = (
  saleId: string,
  salesUpdateSaleBody: SalesUpdateSaleBody,
) => {
  return customInstance<Sale>({
    url: `/api/sales/${saleId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: salesUpdateSaleBody,
  });
};

export const getSalesUpdateSaleMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateSale>>,
    TError,
    { saleId: string; data: SalesUpdateSaleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesUpdateSale>>,
  TError,
  { saleId: string; data: SalesUpdateSaleBody },
  TContext
> => {
  const mutationKey = ["salesUpdateSale"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesUpdateSale>>,
    { saleId: string; data: SalesUpdateSaleBody }
  > = (props) => {
    const { saleId, data } = props ?? {};

    return salesUpdateSale(saleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesUpdateSaleMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesUpdateSale>>
>;
export type SalesUpdateSaleMutationBody = SalesUpdateSaleBody;
export type SalesUpdateSaleMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary PUT /api/sales/{sale_id}
 */
export const useSalesUpdateSale = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateSale>>,
    TError,
    { saleId: string; data: SalesUpdateSaleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesUpdateSale>>,
  TError,
  { saleId: string; data: SalesUpdateSaleBody },
  TContext
> => {
  const mutationOptions = getSalesUpdateSaleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a sale
 * @summary DELETE /api/sales/{sale_id}
 */
export const salesDeleteSale = (saleId: string) => {
  return customInstance<void>({
    url: `/api/sales/${saleId}`,
    method: "DELETE",
  });
};

export const getSalesDeleteSaleMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesDeleteSale>>,
    TError,
    { saleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesDeleteSale>>,
  TError,
  { saleId: string },
  TContext
> => {
  const mutationKey = ["salesDeleteSale"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesDeleteSale>>,
    { saleId: string }
  > = (props) => {
    const { saleId } = props ?? {};

    return salesDeleteSale(saleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesDeleteSaleMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesDeleteSale>>
>;

export type SalesDeleteSaleMutationError = ErrorResponse;

/**
 * @summary DELETE /api/sales/{sale_id}
 */
export const useSalesDeleteSale = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesDeleteSale>>,
    TError,
    { saleId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesDeleteSale>>,
  TError,
  { saleId: string },
  TContext
> => {
  const mutationOptions = getSalesDeleteSaleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new payment-plan
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const salesCreateSalePaymentPlan = (
  saleId: string,
  salesCreateSalePaymentPlanBody?: SalesCreateSalePaymentPlanBody,
  signal?: AbortSignal,
) => {
  return customInstance<PaymentRecord>({
    url: `/api/sales/${saleId}/payment-plan`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesCreateSalePaymentPlanBody,
    signal,
  });
};

export const getSalesCreateSalePaymentPlanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
    TError,
    { saleId: string; data: SalesCreateSalePaymentPlanBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
  TError,
  { saleId: string; data: SalesCreateSalePaymentPlanBody },
  TContext
> => {
  const mutationKey = ["salesCreateSalePaymentPlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
    { saleId: string; data: SalesCreateSalePaymentPlanBody }
  > = (props) => {
    const { saleId, data } = props ?? {};

    return salesCreateSalePaymentPlan(saleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesCreateSalePaymentPlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>
>;
export type SalesCreateSalePaymentPlanMutationBody =
  SalesCreateSalePaymentPlanBody;
export type SalesCreateSalePaymentPlanMutationError = unknown;

/**
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const useSalesCreateSalePaymentPlan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
    TError,
    { saleId: string; data: SalesCreateSalePaymentPlanBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
  TError,
  { saleId: string; data: SalesCreateSalePaymentPlanBody },
  TContext
> => {
  const mutationOptions = getSalesCreateSalePaymentPlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all promissory notes for a specific sale
 */
export const paymentsGetSalePromissoryNotes = (
  saleId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sales/${saleId}/promissory-notes`,
    method: "GET",
    signal,
  });
};

export const getPaymentsGetSalePromissoryNotesQueryKey = (saleId?: string) => {
  return [`/api/sales/${saleId}/promissory-notes`] as const;
};

export const getPaymentsGetSalePromissoryNotesQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
  TError = unknown,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPaymentsGetSalePromissoryNotesQueryKey(saleId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
  > = ({ signal }) => paymentsGetSalePromissoryNotes(saleId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!saleId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PaymentsGetSalePromissoryNotesQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
>;
export type PaymentsGetSalePromissoryNotesQueryError = unknown;

/**
 * @summary Get all promissory notes for a specific sale
 */

export function usePaymentsGetSalePromissoryNotes<
  TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
  TError = unknown,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPaymentsGetSalePromissoryNotesQueryOptions(
    saleId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create an invoice for the specified sale
 * @summary Create invoice for sale
 */
export const salesCreateSaleInvoice = (
  saleId: string,
  salesCreateSaleInvoiceBody: SalesCreateSaleInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<SalesCreateSaleInvoice201>({
    url: `/api/sales/${saleId}/invoice`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesCreateSaleInvoiceBody,
    signal,
  });
};

export const getSalesCreateSaleInvoiceMutationOptions = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
    TError,
    { saleId: string; data: SalesCreateSaleInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
  TError,
  { saleId: string; data: SalesCreateSaleInvoiceBody },
  TContext
> => {
  const mutationKey = ["salesCreateSaleInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
    { saleId: string; data: SalesCreateSaleInvoiceBody }
  > = (props) => {
    const { saleId, data } = props ?? {};

    return salesCreateSaleInvoice(saleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesCreateSaleInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesCreateSaleInvoice>>
>;
export type SalesCreateSaleInvoiceMutationBody = SalesCreateSaleInvoiceBody;
export type SalesCreateSaleInvoiceMutationError =
  | ErrorResponse
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Create invoice for sale
 */
export const useSalesCreateSaleInvoice = <
  TError = ErrorResponse | ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
    TError,
    { saleId: string; data: SalesCreateSaleInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
  TError,
  { saleId: string; data: SalesCreateSaleInvoiceBody },
  TContext
> => {
  const mutationOptions = getSalesCreateSaleInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve the invoice for the specified sale
 * @summary Get invoice for sale
 */
export const salesGetSaleInvoice = (saleId: string, signal?: AbortSignal) => {
  return customInstance<SalesGetSaleInvoice200>({
    url: `/api/sales/${saleId}/invoice`,
    method: "GET",
    signal,
  });
};

export const getSalesGetSaleInvoiceQueryKey = (saleId?: string) => {
  return [`/api/sales/${saleId}/invoice`] as const;
};

export const getSalesGetSaleInvoiceQueryOptions = <
  TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>,
  TError = ErrorResponse | ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetSaleInvoice>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSalesGetSaleInvoiceQueryKey(saleId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof salesGetSaleInvoice>>
  > = ({ signal }) => salesGetSaleInvoice(saleId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!saleId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof salesGetSaleInvoice>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SalesGetSaleInvoiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof salesGetSaleInvoice>>
>;
export type SalesGetSaleInvoiceQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get invoice for sale
 */

export function useSalesGetSaleInvoice<
  TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>,
  TError = ErrorResponse | ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGetSaleInvoice>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSalesGetSaleInvoiceQueryOptions(saleId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Generate and download a PDF for the specified sale invoice
 * @summary Generate sale invoice PDF
 */
export const salesGenerateSaleInvoicePdf = (
  saleId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Blob>({
    url: `/api/sales/${saleId}/invoice/pdf`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getSalesGenerateSaleInvoicePdfQueryKey = (saleId?: string) => {
  return [`/api/sales/${saleId}/invoice/pdf`] as const;
};

export const getSalesGenerateSaleInvoicePdfQueryOptions = <
  TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
  TError = ErrorResponse | ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSalesGenerateSaleInvoicePdfQueryKey(saleId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
  > = ({ signal }) => salesGenerateSaleInvoicePdf(saleId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!saleId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SalesGenerateSaleInvoicePdfQueryResult = NonNullable<
  Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
>;
export type SalesGenerateSaleInvoicePdfQueryError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Generate sale invoice PDF
 */

export function useSalesGenerateSaleInvoicePdf<
  TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
  TError = ErrorResponse | ErrorResponse,
>(
  saleId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSalesGenerateSaleInvoicePdfQueryOptions(
    saleId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update settings information
 * @summary Update system settings
 */
export const updateSettings = (updateSettingsBody?: UpdateSettingsBody) => {
  return customInstance<void>({
    url: `/api/settings`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateSettingsBody,
  });
};

export const getUpdateSettingsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSettings>>,
    TError,
    { data: UpdateSettingsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSettings>>,
  TError,
  { data: UpdateSettingsBody },
  TContext
> => {
  const mutationKey = ["updateSettings"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSettings>>,
    { data: UpdateSettingsBody }
  > = (props) => {
    const { data } = props ?? {};

    return updateSettings(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSettingsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSettings>>
>;
export type UpdateSettingsMutationBody = UpdateSettingsBody;
export type UpdateSettingsMutationError = unknown;

/**
 * @summary Update system settings
 */
export const useUpdateSettings = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSettings>>,
    TError,
    { data: UpdateSettingsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateSettings>>,
  TError,
  { data: UpdateSettingsBody },
  TContext
> => {
  const mutationOptions = getUpdateSettingsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
  sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/documents`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkUploadSgkDocumentBody,
    signal,
  });
};

export const getSgkUploadSgkDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
    TError,
    { data: SgkUploadSgkDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
  TError,
  { data: SgkUploadSgkDocumentBody },
  TContext
> => {
  const mutationKey = ["sgkUploadSgkDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
    { data: SgkUploadSgkDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkUploadSgkDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkUploadSgkDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkUploadSgkDocument>>
>;
export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody;
export type SgkUploadSgkDocumentMutationError = unknown;

/**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
    TError,
    { data: SgkUploadSgkDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
  TError,
  { data: SgkUploadSgkDocumentBody },
  TContext
> => {
  const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (documentId: string) => {
  return customInstance<void>({
    url: `/api/sgk/documents/${documentId}`,
    method: "DELETE",
  });
};

export const getSgkDeleteSgkDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
    TError,
    { documentId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
  TError,
  { documentId: string },
  TContext
> => {
  const mutationKey = ["sgkDeleteSgkDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
    { documentId: string }
  > = (props) => {
    const { documentId } = props ?? {};

    return sgkDeleteSgkDocument(documentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkDeleteSgkDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkDeleteSgkDocument>>
>;

export type SgkDeleteSgkDocumentMutationError = unknown;

/**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
    TError,
    { documentId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
  TError,
  { documentId: string },
  TContext
> => {
  const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve list of SMS headers
 * @summary Get SMS headers
 */
export const smsGetHeaders = (signal?: AbortSignal) => {
  return customInstance<SmsGetHeaders200>({
    url: `/api/sms/headers`,
    method: "GET",
    signal,
  });
};

export const getSmsGetHeadersQueryKey = () => {
  return [`/api/sms/headers`] as const;
};

export const getSmsGetHeadersQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetHeaders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetHeadersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetHeaders>>> = ({
    signal,
  }) => smsGetHeaders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetHeadersQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetHeaders>>
>;
export type SmsGetHeadersQueryError = unknown;

/**
 * @summary Get SMS headers
 */

export function useSmsGetHeaders<
  TData = Awaited<ReturnType<typeof smsGetHeaders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetHeaders>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetHeadersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new SMS header
 * @summary Create SMS header
 */
export const smsCreateHeader = (
  smsCreateHeaderBody: SmsCreateHeaderBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/headers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: smsCreateHeaderBody,
    signal,
  });
};

export const getSmsCreateHeaderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsCreateHeader>>,
    TError,
    { data: SmsCreateHeaderBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsCreateHeader>>,
  TError,
  { data: SmsCreateHeaderBody },
  TContext
> => {
  const mutationKey = ["smsCreateHeader"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsCreateHeader>>,
    { data: SmsCreateHeaderBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsCreateHeader(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsCreateHeaderMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsCreateHeader>>
>;
export type SmsCreateHeaderMutationBody = SmsCreateHeaderBody;
export type SmsCreateHeaderMutationError = unknown;

/**
 * @summary Create SMS header
 */
export const useSmsCreateHeader = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsCreateHeader>>,
    TError,
    { data: SmsCreateHeaderBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsCreateHeader>>,
  TError,
  { data: SmsCreateHeaderBody },
  TContext
> => {
  const mutationOptions = getSmsCreateHeaderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve list of SMS audiences
 * @summary Get SMS audiences
 */
export const smsGetAudiences = (signal?: AbortSignal) => {
  return customInstance<SmsGetAudiences200>({
    url: `/api/sms/audiences`,
    method: "GET",
    signal,
  });
};

export const getSmsGetAudiencesQueryKey = () => {
  return [`/api/sms/audiences`] as const;
};

export const getSmsGetAudiencesQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetAudiences>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetAudiencesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetAudiences>>> = ({
    signal,
  }) => smsGetAudiences(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetAudiencesQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetAudiences>>
>;
export type SmsGetAudiencesQueryError = unknown;

/**
 * @summary Get SMS audiences
 */

export function useSmsGetAudiences<
  TData = Awaited<ReturnType<typeof smsGetAudiences>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetAudiences>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetAudiencesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new SMS audience
 * @summary Create SMS audience
 */
export const smsCreateAudience = (
  smsCreateAudienceBody: SmsCreateAudienceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/audiences`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: smsCreateAudienceBody,
    signal,
  });
};

export const getSmsCreateAudienceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsCreateAudience>>,
    TError,
    { data: SmsCreateAudienceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsCreateAudience>>,
  TError,
  { data: SmsCreateAudienceBody },
  TContext
> => {
  const mutationKey = ["smsCreateAudience"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsCreateAudience>>,
    { data: SmsCreateAudienceBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsCreateAudience(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsCreateAudienceMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsCreateAudience>>
>;
export type SmsCreateAudienceMutationBody = SmsCreateAudienceBody;
export type SmsCreateAudienceMutationError = unknown;

/**
 * @summary Create SMS audience
 */
export const useSmsCreateAudience = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsCreateAudience>>,
    TError,
    { data: SmsCreateAudienceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsCreateAudience>>,
  TError,
  { data: SmsCreateAudienceBody },
  TContext
> => {
  const mutationOptions = getSmsCreateAudienceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Upload a file to create SMS audience
 * @summary Upload SMS audience file
 */
export const smsUploadAudience = (
  smsUploadAudienceBody: SmsUploadAudienceBody,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (smsUploadAudienceBody.file !== undefined) {
    formData.append(`file`, smsUploadAudienceBody.file);
  }

  return customInstance<void>({
    url: `/api/sms/audiences/upload`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getSmsUploadAudienceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadAudience>>,
    TError,
    { data: SmsUploadAudienceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsUploadAudience>>,
  TError,
  { data: SmsUploadAudienceBody },
  TContext
> => {
  const mutationKey = ["smsUploadAudience"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsUploadAudience>>,
    { data: SmsUploadAudienceBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsUploadAudience(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsUploadAudienceMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsUploadAudience>>
>;
export type SmsUploadAudienceMutationBody = SmsUploadAudienceBody;
export type SmsUploadAudienceMutationError = unknown;

/**
 * @summary Upload SMS audience file
 */
export const useSmsUploadAudience = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadAudience>>,
    TError,
    { data: SmsUploadAudienceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsUploadAudience>>,
  TError,
  { data: SmsUploadAudienceBody },
  TContext
> => {
  const mutationOptions = getSmsUploadAudienceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve SMS configuration settings
 * @summary Get SMS configuration
 */
export const smsGetConfig = (signal?: AbortSignal) => {
  return customInstance<SmsGetConfig200>({
    url: `/api/sms/config`,
    method: "GET",
    signal,
  });
};

export const getSmsGetConfigQueryKey = () => {
  return [`/api/sms/config`] as const;
};

export const getSmsGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetConfig>>> = ({
    signal,
  }) => smsGetConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetConfig>>
>;
export type SmsGetConfigQueryError = unknown;

/**
 * @summary Get SMS configuration
 */

export function useSmsGetConfig<
  TData = Awaited<ReturnType<typeof smsGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update SMS configuration settings
 * @summary Update SMS configuration
 */
export const smsUpdateConfig = (smsUpdateConfigBody: SmsUpdateConfigBody) => {
  return customInstance<void>({
    url: `/api/sms/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: smsUpdateConfigBody,
  });
};

export const getSmsUpdateConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUpdateConfig>>,
    TError,
    { data: SmsUpdateConfigBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsUpdateConfig>>,
  TError,
  { data: SmsUpdateConfigBody },
  TContext
> => {
  const mutationKey = ["smsUpdateConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsUpdateConfig>>,
    { data: SmsUpdateConfigBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsUpdateConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsUpdateConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsUpdateConfig>>
>;
export type SmsUpdateConfigMutationBody = SmsUpdateConfigBody;
export type SmsUpdateConfigMutationError = unknown;

/**
 * @summary Update SMS configuration
 */
export const useSmsUpdateConfig = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUpdateConfig>>,
    TError,
    { data: SmsUpdateConfigBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsUpdateConfig>>,
  TError,
  { data: SmsUpdateConfigBody },
  TContext
> => {
  const mutationOptions = getSmsUpdateConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve available SMS packages
 * @summary Get SMS packages
 */
export const smsGetPackages = (signal?: AbortSignal) => {
  return customInstance<SmsGetPackages200>({
    url: `/api/sms/packages`,
    method: "GET",
    signal,
  });
};

export const getSmsGetPackagesQueryKey = () => {
  return [`/api/sms/packages`] as const;
};

export const getSmsGetPackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetPackages>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetPackagesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetPackages>>> = ({
    signal,
  }) => smsGetPackages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetPackages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetPackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetPackages>>
>;
export type SmsGetPackagesQueryError = unknown;

/**
 * @summary Get SMS packages
 */

export function useSmsGetPackages<
  TData = Awaited<ReturnType<typeof smsGetPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetPackages>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetPackagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve current SMS credit balance
 * @summary Get SMS credit balance
 */
export const smsGetCredit = (signal?: AbortSignal) => {
  return customInstance<SmsGetCredit200>({
    url: `/api/sms/credit`,
    method: "GET",
    signal,
  });
};

export const getSmsGetCreditQueryKey = () => {
  return [`/api/sms/credit`] as const;
};

export const getSmsGetCreditQueryOptions = <
  TData = Awaited<ReturnType<typeof smsGetCredit>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetCredit>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsGetCreditQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetCredit>>> = ({
    signal,
  }) => smsGetCredit(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsGetCredit>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsGetCreditQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsGetCredit>>
>;
export type SmsGetCreditQueryError = unknown;

/**
 * @summary Get SMS credit balance
 */

export function useSmsGetCredit<
  TData = Awaited<ReturnType<typeof smsGetCredit>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsGetCredit>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsGetCreditQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Upload SMS-related document
 * @summary Upload SMS document
 */
export const smsUploadDocument = (
  smsUploadDocumentBody: SmsUploadDocumentBody,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (smsUploadDocumentBody.file !== undefined) {
    formData.append(`file`, smsUploadDocumentBody.file);
  }

  return customInstance<void>({
    url: `/api/sms/upload`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getSmsUploadDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    TError,
    { data: SmsUploadDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsUploadDocument>>,
  TError,
  { data: SmsUploadDocumentBody },
  TContext
> => {
  const mutationKey = ["smsUploadDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    { data: SmsUploadDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return smsUploadDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsUploadDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsUploadDocument>>
>;
export type SmsUploadDocumentMutationBody = SmsUploadDocumentBody;
export type SmsUploadDocumentMutationError = unknown;

/**
 * @summary Upload SMS document
 */
export const useSmsUploadDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocument>>,
    TError,
    { data: SmsUploadDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsUploadDocument>>,
  TError,
  { data: SmsUploadDocumentBody },
  TContext
> => {
  const mutationOptions = getSmsUploadDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Download SMS-related document
 * @summary Download SMS document
 */
export const smsDownloadDocument = (
  documentType: string,
  signal?: AbortSignal,
) => {
  return customInstance<Blob>({
    url: `/api/sms/documents/${documentType}/download`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getSmsDownloadDocumentQueryKey = (documentType?: string) => {
  return [`/api/sms/documents/${documentType}/download`] as const;
};

export const getSmsDownloadDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof smsDownloadDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsDownloadDocument>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSmsDownloadDocumentQueryKey(documentType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsDownloadDocument>>
  > = ({ signal }) => smsDownloadDocument(documentType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!documentType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof smsDownloadDocument>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsDownloadDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsDownloadDocument>>
>;
export type SmsDownloadDocumentQueryError = unknown;

/**
 * @summary Download SMS document
 */

export function useSmsDownloadDocument<
  TData = Awaited<ReturnType<typeof smsDownloadDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsDownloadDocument>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsDownloadDocumentQueryOptions(
    documentType,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete SMS-related document
 * @summary Delete SMS document
 */
export const smsDeleteDocument = (documentType: string) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}`,
    method: "DELETE",
  });
};

export const getSmsDeleteDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsDeleteDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationKey = ["smsDeleteDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    { documentType: string }
  > = (props) => {
    const { documentType } = props ?? {};

    return smsDeleteDocument(documentType);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsDeleteDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsDeleteDocument>>
>;

export type SmsDeleteDocumentMutationError = unknown;

/**
 * @summary Delete SMS document
 */
export const useSmsDeleteDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsDeleteDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsDeleteDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationOptions = getSmsDeleteDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/sms/monitoring`,
    method: "GET",
    signal,
  });
};

export const getSmsMonitoringQueryKey = () => {
  return [`/api/sms/monitoring`] as const;
};

export const getSmsMonitoringQueryOptions = <
  TData = Awaited<ReturnType<typeof smsMonitoring>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({
    signal,
  }) => smsMonitoring(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsMonitoringQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsMonitoring>>
>;
export type SmsMonitoringQueryError = unknown;

/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<
  TData = Awaited<ReturnType<typeof smsMonitoring>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof smsMonitoring>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsMonitoringQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of suppliers with optional filtering and pagination
 * @summary Get list of suppliers
 */
export const suppliersGetSuppliers = (
  params?: SuppliersGetSuppliersParams,
  signal?: AbortSignal,
) => {
  return customInstance<SuppliersGetSuppliers200>({
    url: `/api/suppliers`,
    method: "GET",
    params,
    signal,
  });
};

export const getSuppliersGetSuppliersQueryKey = (
  params?: SuppliersGetSuppliersParams,
) => {
  return [`/api/suppliers`, ...(params ? [params] : [])] as const;
};

export const getSuppliersGetSuppliersQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: SuppliersGetSuppliersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSuppliers>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuppliersGetSuppliersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersGetSuppliers>>
  > = ({ signal }) => suppliersGetSuppliers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSuppliers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersGetSuppliersQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersGetSuppliers>>
>;
export type SuppliersGetSuppliersQueryError = ErrorResponse | ErrorResponse;

/**
 * @summary Get list of suppliers
 */

export function useSuppliersGetSuppliers<
  TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>,
  TError = ErrorResponse | ErrorResponse,
>(
  params?: SuppliersGetSuppliersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSuppliers>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersGetSuppliersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Register a new supplier with contact and business information
 * @summary Create a new supplier
 */
export const suppliersCreateSupplier = (
  suppliersCreateSupplierBody?: SuppliersCreateSupplierBody,
  signal?: AbortSignal,
) => {
  return customInstance<Supplier>({
    url: `/api/suppliers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: suppliersCreateSupplierBody,
    signal,
  });
};

export const getSuppliersCreateSupplierMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersCreateSupplier>>,
    TError,
    { data: SuppliersCreateSupplierBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersCreateSupplier>>,
  TError,
  { data: SuppliersCreateSupplierBody },
  TContext
> => {
  const mutationKey = ["suppliersCreateSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersCreateSupplier>>,
    { data: SuppliersCreateSupplierBody }
  > = (props) => {
    const { data } = props ?? {};

    return suppliersCreateSupplier(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersCreateSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersCreateSupplier>>
>;
export type SuppliersCreateSupplierMutationBody = SuppliersCreateSupplierBody;
export type SuppliersCreateSupplierMutationError = unknown;

/**
 * @summary Create a new supplier
 */
export const useSuppliersCreateSupplier = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersCreateSupplier>>,
    TError,
    { data: SuppliersCreateSupplierBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersCreateSupplier>>,
  TError,
  { data: SuppliersCreateSupplierBody },
  TContext
> => {
  const mutationOptions = getSuppliersCreateSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a supplier from the system
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const suppliersDeleteSupplier = (supplierId: string) => {
  return customInstance<SuccessResponse>({
    url: `/api/suppliers/${supplierId}`,
    method: "DELETE",
  });
};

export const getSuppliersDeleteSupplierMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
    TError,
    { supplierId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
  TError,
  { supplierId: string },
  TContext
> => {
  const mutationKey = ["suppliersDeleteSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
    { supplierId: string }
  > = (props) => {
    const { supplierId } = props ?? {};

    return suppliersDeleteSupplier(supplierId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersDeleteSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersDeleteSupplier>>
>;

export type SuppliersDeleteSupplierMutationError = unknown;

/**
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const useSuppliersDeleteSupplier = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
    TError,
    { supplierId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
  TError,
  { supplierId: string },
  TContext
> => {
  const mutationOptions = getSuppliersDeleteSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update an existing supplier's information
 * @summary Update supplier details
 */
export const suppliersUpdateSupplier = (
  supplierId: string,
  suppliersCreateSupplierBody: SuppliersCreateSupplierBody,
) => {
  return customInstance<Supplier>({
    url: `/api/suppliers/${supplierId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: suppliersCreateSupplierBody,
  });
};

export const getSuppliersUpdateSupplierMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
    TError,
    { supplierId: string; data: SuppliersCreateSupplierBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
  TError,
  { supplierId: string; data: SuppliersCreateSupplierBody },
  TContext
> => {
  const mutationKey = ["suppliersUpdateSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
    { supplierId: string; data: SuppliersCreateSupplierBody }
  > = (props) => {
    const { supplierId, data } = props ?? {};

    return suppliersUpdateSupplier(supplierId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersUpdateSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersUpdateSupplier>>
>;
export type SuppliersUpdateSupplierMutationBody = SuppliersCreateSupplierBody;
export type SuppliersUpdateSupplierMutationError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Update supplier details
 */
export const useSuppliersUpdateSupplier = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
    TError,
    { supplierId: string; data: SuppliersCreateSupplierBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
  TError,
  { supplierId: string; data: SuppliersCreateSupplierBody },
  TContext
> => {
  const mutationOptions = getSuppliersUpdateSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get list of products available from a specific supplier
 * @summary Get all products for a specific supplier
 */
export const suppliersGetSupplierProducts = (
  supplierId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/suppliers/${supplierId}/products`,
    method: "GET",
    signal,
  });
};

export const getSuppliersGetSupplierProductsQueryKey = (
  supplierId?: string,
) => {
  return [`/api/suppliers/${supplierId}/products`] as const;
};

export const getSuppliersGetSupplierProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
  TError = unknown,
>(
  supplierId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSuppliersGetSupplierProductsQueryKey(supplierId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
  > = ({ signal }) => suppliersGetSupplierProducts(supplierId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!supplierId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersGetSupplierProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
>;
export type SuppliersGetSupplierProductsQueryError = unknown;

/**
 * @summary Get all products for a specific supplier
 */

export function useSuppliersGetSupplierProducts<
  TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
  TError = unknown,
>(
  supplierId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersGetSupplierProductsQueryOptions(
    supplierId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get supplier statistics including order history
 * @summary Get supplier statistics
 */
export const suppliersGetSupplierStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/suppliers/stats`,
    method: "GET",
    signal,
  });
};

export const getSuppliersGetSupplierStatsQueryKey = () => {
  return [`/api/suppliers/stats`] as const;
};

export const getSuppliersGetSupplierStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuppliersGetSupplierStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersGetSupplierStats>>
  > = ({ signal }) => suppliersGetSupplierStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersGetSupplierStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersGetSupplierStats>>
>;
export type SuppliersGetSupplierStatsQueryError = unknown;

/**
 * @summary Get supplier statistics
 */

export function useSuppliersGetSupplierStats<
  TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersGetSupplierStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new verify-registration-otp
 * @summary POST /api/verify-registration-otp
 */
export const registrationVerifyRegistrationOtp = (
  registrationVerifyRegistrationOtpBody?: RegistrationVerifyRegistrationOtpBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/verify-registration-otp`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: registrationVerifyRegistrationOtpBody,
    signal,
  });
};

export const getRegistrationVerifyRegistrationOtpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
    TError,
    { data: RegistrationVerifyRegistrationOtpBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
  TError,
  { data: RegistrationVerifyRegistrationOtpBody },
  TContext
> => {
  const mutationKey = ["registrationVerifyRegistrationOtp"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
    { data: RegistrationVerifyRegistrationOtpBody }
  > = (props) => {
    const { data } = props ?? {};

    return registrationVerifyRegistrationOtp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegistrationVerifyRegistrationOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>
>;
export type RegistrationVerifyRegistrationOtpMutationBody =
  RegistrationVerifyRegistrationOtpBody;
export type RegistrationVerifyRegistrationOtpMutationError = unknown;

/**
 * @summary POST /api/verify-registration-otp
 */
export const useRegistrationVerifyRegistrationOtp = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
    TError,
    { data: RegistrationVerifyRegistrationOtpBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
  TError,
  { data: RegistrationVerifyRegistrationOtpBody },
  TContext
> => {
  const mutationOptions =
    getRegistrationVerifyRegistrationOtpMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve a list of all users
 * @summary GET /api/users
 */
export const usersListUsers = (signal?: AbortSignal) => {
  return customInstance<User[]>({ url: `/api/users`, method: "GET", signal });
};

export const getUsersListUsersQueryKey = () => {
  return [`/api/users`] as const;
};

export const getUsersListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof usersListUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof usersListUsers>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersListUsersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersListUsers>>> = ({
    signal,
  }) => usersListUsers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersListUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersListUsers>>
>;
export type UsersListUsersQueryError = unknown;

/**
 * @summary GET /api/users
 */

export function useUsersListUsers<
  TData = Awaited<ReturnType<typeof usersListUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof usersListUsers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersListUsersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new user
 * @summary POST /api/users
 */
export const usersCreateUser = (
  usersCreateUserBody: UsersCreateUserBody,
  signal?: AbortSignal,
) => {
  return customInstance<User>({
    url: `/api/users`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: usersCreateUserBody,
    signal,
  });
};

export const getUsersCreateUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersCreateUser>>,
    TError,
    { data: UsersCreateUserBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersCreateUser>>,
  TError,
  { data: UsersCreateUserBody },
  TContext
> => {
  const mutationKey = ["usersCreateUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersCreateUser>>,
    { data: UsersCreateUserBody }
  > = (props) => {
    const { data } = props ?? {};

    return usersCreateUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersCreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersCreateUser>>
>;
export type UsersCreateUserMutationBody = UsersCreateUserBody;
export type UsersCreateUserMutationError = ErrorResponse;

/**
 * @summary POST /api/users
 */
export const useUsersCreateUser = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersCreateUser>>,
    TError,
    { data: UsersCreateUserBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersCreateUser>>,
  TError,
  { data: UsersCreateUserBody },
  TContext
> => {
  const mutationOptions = getUsersCreateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get user details by ID
 * @summary GET /api/users/{user_id}
 */
export const usersGetUser = (userId: string, signal?: AbortSignal) => {
  return customInstance<User>({
    url: `/api/users/${userId}`,
    method: "GET",
    signal,
  });
};

export const getUsersGetUserQueryKey = (userId?: string) => {
  return [`/api/users/${userId}`] as const;
};

export const getUsersGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUser>>,
  TError = ErrorResponse,
>(
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof usersGetUser>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetUserQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUser>>> = ({
    signal,
  }) => usersGetUser(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUser>>
>;
export type UsersGetUserQueryError = ErrorResponse;

/**
 * @summary GET /api/users/{user_id}
 */

export function useUsersGetUser<
  TData = Awaited<ReturnType<typeof usersGetUser>>,
  TError = ErrorResponse,
>(
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof usersGetUser>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersGetUserQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update user information
 * @summary PUT /api/users/{user_id}
 */
export const usersUpdateUser = (
  userId: string,
  usersUpdateUserBody: UsersUpdateUserBody,
) => {
  return customInstance<User>({
    url: `/api/users/${userId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: usersUpdateUserBody,
  });
};

export const getUsersUpdateUserMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateUser>>,
    TError,
    { userId: string; data: UsersUpdateUserBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdateUser>>,
  TError,
  { userId: string; data: UsersUpdateUserBody },
  TContext
> => {
  const mutationKey = ["usersUpdateUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdateUser>>,
    { userId: string; data: UsersUpdateUserBody }
  > = (props) => {
    const { userId, data } = props ?? {};

    return usersUpdateUser(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdateUser>>
>;
export type UsersUpdateUserMutationBody = UsersUpdateUserBody;
export type UsersUpdateUserMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary PUT /api/users/{user_id}
 */
export const useUsersUpdateUser = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateUser>>,
    TError,
    { userId: string; data: UsersUpdateUserBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdateUser>>,
  TError,
  { userId: string; data: UsersUpdateUserBody },
  TContext
> => {
  const mutationOptions = getUsersUpdateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a user
 * @summary DELETE /api/users/{user_id}
 */
export const usersDeleteUser = (userId: string) => {
  return customInstance<void>({
    url: `/api/users/${userId}`,
    method: "DELETE",
  });
};

export const getUsersDeleteUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteUser>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersDeleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ["usersDeleteUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDeleteUser>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return usersDeleteUser(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersDeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDeleteUser>>
>;

export type UsersDeleteUserMutationError = ErrorResponse;

/**
 * @summary DELETE /api/users/{user_id}
 */
export const useUsersDeleteUser = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteUser>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersDeleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getUsersDeleteUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get current authenticated user information
 * @summary GET /api/users/me
 */
export const usersGetCurrentUser = (signal?: AbortSignal) => {
  return customInstance<User>({ url: `/api/users/me`, method: "GET", signal });
};

export const getUsersGetCurrentUserQueryKey = () => {
  return [`/api/users/me`] as const;
};

export const getUsersGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetCurrentUser>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof usersGetCurrentUser>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetCurrentUserQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetCurrentUser>>
  > = ({ signal }) => usersGetCurrentUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetCurrentUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersGetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetCurrentUser>>
>;
export type UsersGetCurrentUserQueryError = ErrorResponse;

/**
 * @summary GET /api/users/me
 */

export function useUsersGetCurrentUser<
  TData = Awaited<ReturnType<typeof usersGetCurrentUser>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof usersGetCurrentUser>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUsersGetCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update current user profile
 */
export const usersUpdateMe = (usersUpdateMeBody: UsersUpdateMeBody) => {
  return customInstance<User>({
    url: `/api/users/me`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: usersUpdateMeBody,
  });
};

export const getUsersUpdateMeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    TError,
    { data: UsersUpdateMeBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdateMe>>,
  TError,
  { data: UsersUpdateMeBody },
  TContext
> => {
  const mutationKey = ["usersUpdateMe"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    { data: UsersUpdateMeBody }
  > = (props) => {
    const { data } = props ?? {};

    return usersUpdateMe(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateMeMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdateMe>>
>;
export type UsersUpdateMeMutationBody = UsersUpdateMeBody;
export type UsersUpdateMeMutationError = unknown;

/**
 * @summary Update current user profile
 */
export const useUsersUpdateMe = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    TError,
    { data: UsersUpdateMeBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdateMe>>,
  TError,
  { data: UsersUpdateMeBody },
  TContext
> => {
  const mutationOptions = getUsersUpdateMeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Change current user password
 */
export const usersChangePassword = (
  usersChangePasswordBody: UsersChangePasswordBody,
  signal?: AbortSignal,
) => {
  return customInstance<UsersChangePassword200>({
    url: `/api/users/me/password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: usersChangePasswordBody,
    signal,
  });
};

export const getUsersChangePasswordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersChangePassword>>,
    TError,
    { data: UsersChangePasswordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersChangePassword>>,
  TError,
  { data: UsersChangePasswordBody },
  TContext
> => {
  const mutationKey = ["usersChangePassword"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersChangePassword>>,
    { data: UsersChangePasswordBody }
  > = (props) => {
    const { data } = props ?? {};

    return usersChangePassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersChangePasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersChangePassword>>
>;
export type UsersChangePasswordMutationBody = UsersChangePasswordBody;
export type UsersChangePasswordMutationError = unknown;

/**
 * @summary Change current user password
 */
export const useUsersChangePassword = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersChangePassword>>,
    TError,
    { data: UsersChangePasswordBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersChangePassword>>,
  TError,
  { data: UsersChangePasswordBody },
  TContext
> => {
  const mutationOptions = getUsersChangePasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary List tenant users
 */
export const tenantUsersList = (signal?: AbortSignal) => {
  return customInstance<TenantUsersList200>({
    url: `/api/tenant/users`,
    method: "GET",
    signal,
  });
};

export const getTenantUsersListQueryKey = () => {
  return [`/api/tenant/users`] as const;
};

export const getTenantUsersListQueryOptions = <
  TData = Awaited<ReturnType<typeof tenantUsersList>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof tenantUsersList>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTenantUsersListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantUsersList>>> = ({
    signal,
  }) => tenantUsersList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tenantUsersList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TenantUsersListQueryResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersList>>
>;
export type TenantUsersListQueryError = unknown;

/**
 * @summary List tenant users
 */

export function useTenantUsersList<
  TData = Awaited<ReturnType<typeof tenantUsersList>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof tenantUsersList>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTenantUsersListQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Invite/Create tenant user
 */
export const tenantUsersInvite = (
  tenantUsersInviteBody: TenantUsersInviteBody,
  signal?: AbortSignal,
) => {
  return customInstance<TenantUsersInvite201>({
    url: `/api/tenant/users`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tenantUsersInviteBody,
    signal,
  });
};

export const getTenantUsersInviteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersInvite>>,
    TError,
    { data: TenantUsersInviteBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tenantUsersInvite>>,
  TError,
  { data: TenantUsersInviteBody },
  TContext
> => {
  const mutationKey = ["tenantUsersInvite"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tenantUsersInvite>>,
    { data: TenantUsersInviteBody }
  > = (props) => {
    const { data } = props ?? {};

    return tenantUsersInvite(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TenantUsersInviteMutationResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersInvite>>
>;
export type TenantUsersInviteMutationBody = TenantUsersInviteBody;
export type TenantUsersInviteMutationError = unknown;

/**
 * @summary Invite/Create tenant user
 */
export const useTenantUsersInvite = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersInvite>>,
    TError,
    { data: TenantUsersInviteBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof tenantUsersInvite>>,
  TError,
  { data: TenantUsersInviteBody },
  TContext
> => {
  const mutationOptions = getTenantUsersInviteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete tenant user
 */
export const tenantUsersDelete = (userId: string) => {
  return customInstance<TenantUsersDelete200>({
    url: `/api/tenant/users/${userId}`,
    method: "DELETE",
  });
};

export const getTenantUsersDeleteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersDelete>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tenantUsersDelete>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ["tenantUsersDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tenantUsersDelete>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return tenantUsersDelete(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type TenantUsersDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersDelete>>
>;

export type TenantUsersDeleteMutationError = unknown;

/**
 * @summary Delete tenant user
 */
export const useTenantUsersDelete = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersDelete>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof tenantUsersDelete>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getTenantUsersDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create new entities
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntities = (
  ocrExtractEntitiesBody?: OcrExtractEntitiesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/entities`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrExtractEntitiesBody,
    signal,
  });
};

export const getOcrExtractEntitiesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    TError,
    { data: OcrExtractEntitiesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractEntities>>,
  TError,
  { data: OcrExtractEntitiesBody },
  TContext
> => {
  const mutationKey = ["ocrExtractEntities"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    { data: OcrExtractEntitiesBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrExtractEntities(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractEntitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractEntities>>
>;
export type OcrExtractEntitiesMutationBody = OcrExtractEntitiesBody;
export type OcrExtractEntitiesMutationError = unknown;

/**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntities = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    TError,
    { data: OcrExtractEntitiesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractEntities>>,
  TError,
  { data: OcrExtractEntitiesBody },
  TContext
> => {
  const mutationOptions = getOcrExtractEntitiesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Extract patient name from document image using OCR
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientName = (
  ocrExtractPatientNameBody?: OcrExtractPatientNameBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/extract_patient`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrExtractPatientNameBody,
    signal,
  });
};

export const getOcrExtractPatientNameMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    TError,
    { data: OcrExtractPatientNameBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractPatientName>>,
  TError,
  { data: OcrExtractPatientNameBody },
  TContext
> => {
  const mutationKey = ["ocrExtractPatientName"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    { data: OcrExtractPatientNameBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrExtractPatientName(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractPatientNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractPatientName>>
>;
export type OcrExtractPatientNameMutationBody = OcrExtractPatientNameBody;
export type OcrExtractPatientNameMutationError = unknown;

/**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientName = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    TError,
    { data: OcrExtractPatientNameBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractPatientName>>,
  TError,
  { data: OcrExtractPatientNameBody },
  TContext
> => {
  const mutationOptions = getOcrExtractPatientNameMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Health check for OCR service availability
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheck = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/health`, method: "GET", signal });
};

export const getOcrHealthCheckQueryKey = () => {
  return [`/health`] as const;
};

export const getOcrHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof ocrHealthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOcrHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheck>>> = ({
    signal,
  }) => ocrHealthCheck(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OcrHealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof ocrHealthCheck>>
>;
export type OcrHealthCheckQueryError = unknown;

/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheck<
  TData = Awaited<ReturnType<typeof ocrHealthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOcrHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Initialize OCR service database and create required tables
 * @summary Initialize database and create tables
 */
export const ocrInitDatabase = (
  ocrInitDatabaseBody?: OcrInitDatabaseBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrInitDatabaseBody,
    signal,
  });
};

export const getOcrInitDatabaseMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    TError,
    { data: OcrInitDatabaseBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitDatabase>>,
  TError,
  { data: OcrInitDatabaseBody },
  TContext
> => {
  const mutationKey = ["ocrInitDatabase"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    { data: OcrInitDatabaseBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrInitDatabase(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitDatabaseMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitDatabase>>
>;
export type OcrInitDatabaseMutationBody = OcrInitDatabaseBody;
export type OcrInitDatabaseMutationError = unknown;

/**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabase = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    TError,
    { data: OcrInitDatabaseBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitDatabase>>,
  TError,
  { data: OcrInitDatabaseBody },
  TContext
> => {
  const mutationOptions = getOcrInitDatabaseMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Initialize NLP/OCR processing service
 * @summary Initialize NLP/OCR service
 */
export const ocrInitializeNlpEndpoint = (
  ocrInitializeNlpEndpointBody?: OcrInitializeNlpEndpointBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/initialize`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrInitializeNlpEndpointBody,
    signal,
  });
};

export const getOcrInitializeNlpEndpointMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    TError,
    { data: OcrInitializeNlpEndpointBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
  TError,
  { data: OcrInitializeNlpEndpointBody },
  TContext
> => {
  const mutationKey = ["ocrInitializeNlpEndpoint"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    { data: OcrInitializeNlpEndpointBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrInitializeNlpEndpoint(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitializeNlpEndpointMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>
>;
export type OcrInitializeNlpEndpointMutationBody = OcrInitializeNlpEndpointBody;
export type OcrInitializeNlpEndpointMutationError = unknown;

/**
 * @summary Initialize NLP/OCR service
 */
export const useOcrInitializeNlpEndpoint = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    TError,
    { data: OcrInitializeNlpEndpointBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
  TError,
  { data: OcrInitializeNlpEndpointBody },
  TContext
> => {
  const mutationOptions = getOcrInitializeNlpEndpointMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Process document using OCR to extract text and data
 * @summary Process document with OCR
 */
export const ocrProcessDocument = (
  ocrProcessDocumentBody?: OcrProcessDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/process`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrProcessDocumentBody,
    signal,
  });
};

export const getOcrProcessDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrProcessDocument>>,
    TError,
    { data: OcrProcessDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrProcessDocument>>,
  TError,
  { data: OcrProcessDocumentBody },
  TContext
> => {
  const mutationKey = ["ocrProcessDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrProcessDocument>>,
    { data: OcrProcessDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrProcessDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrProcessDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrProcessDocument>>
>;
export type OcrProcessDocumentMutationBody = OcrProcessDocumentBody;
export type OcrProcessDocumentMutationError = unknown;

/**
 * @summary Process document with OCR
 */
export const useOcrProcessDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrProcessDocument>>,
    TError,
    { data: OcrProcessDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrProcessDocument>>,
  TError,
  { data: OcrProcessDocumentBody },
  TContext
> => {
  const mutationOptions = getOcrProcessDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Calculate similarity between documents using OCR text analysis
 * @summary Calculate similarity between two images using OCR text
 */
export const ocrCalculateSimilarity = (
  ocrCalculateSimilarityBody?: OcrCalculateSimilarityBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/similarity`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrCalculateSimilarityBody,
    signal,
  });
};

export const getOcrCalculateSimilarityMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    TError,
    { data: OcrCalculateSimilarityBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
  TError,
  { data: OcrCalculateSimilarityBody },
  TContext
> => {
  const mutationKey = ["ocrCalculateSimilarity"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    { data: OcrCalculateSimilarityBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrCalculateSimilarity(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrCalculateSimilarityMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>
>;
export type OcrCalculateSimilarityMutationBody = OcrCalculateSimilarityBody;
export type OcrCalculateSimilarityMutationError = unknown;

/**
 * @summary Calculate similarity between two images using OCR text
 */
export const useOcrCalculateSimilarity = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    TError,
    { data: OcrCalculateSimilarityBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
  TError,
  { data: OcrCalculateSimilarityBody },
  TContext
> => {
  const mutationOptions = getOcrCalculateSimilarityMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This helps local development: visit http://<backend-host>:<port>/swagger.html so the
Swagger UI and `/api/openapi.yaml` are on the same origin and no CORS overrides are needed.
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */
export const serveSwaggerUi = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/swagger.html`, method: "GET", signal });
};

export const getServeSwaggerUiQueryKey = () => {
  return [`/swagger.html`] as const;
};

export const getServeSwaggerUiQueryOptions = <
  TData = Awaited<ReturnType<typeof serveSwaggerUi>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof serveSwaggerUi>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getServeSwaggerUiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof serveSwaggerUi>>> = ({
    signal,
  }) => serveSwaggerUi(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof serveSwaggerUi>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ServeSwaggerUiQueryResult = NonNullable<
  Awaited<ReturnType<typeof serveSwaggerUi>>
>;
export type ServeSwaggerUiQueryError = unknown;

/**
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */

export function useServeSwaggerUi<
  TData = Awaited<ReturnType<typeof serveSwaggerUi>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof serveSwaggerUi>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getServeSwaggerUiQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve purchase invoices for the specified supplier
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */
export const suppliersGetSupplierInvoices = (
  supplierId: string,
  params?: SuppliersGetSupplierInvoicesParams,
  signal?: AbortSignal,
) => {
  return customInstance<SuppliersGetSupplierInvoices200>({
    url: `/api/suppliers/${supplierId}/invoices`,
    method: "GET",
    params,
    signal,
  });
};

export const getSuppliersGetSupplierInvoicesQueryKey = (
  supplierId?: string,
  params?: SuppliersGetSupplierInvoicesParams,
) => {
  return [
    `/api/suppliers/${supplierId}/invoices`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSuppliersGetSupplierInvoicesQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
  TError = ErrorResponse | ErrorResponse,
>(
  supplierId: string,
  params?: SuppliersGetSupplierInvoicesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSuppliersGetSupplierInvoicesQueryKey(supplierId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
  > = ({ signal }) => suppliersGetSupplierInvoices(supplierId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!supplierId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersGetSupplierInvoicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
>;
export type SuppliersGetSupplierInvoicesQueryError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */

export function useSuppliersGetSupplierInvoices<
  TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
  TError = ErrorResponse | ErrorResponse,
>(
  supplierId: string,
  params?: SuppliersGetSupplierInvoicesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersGetSupplierInvoicesQueryOptions(
    supplierId,
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a list of suggested suppliers based on incoming invoices
 * @summary Get suggested suppliers (pending approval)
 */
export const suppliersGetSuggestedSuppliers = (signal?: AbortSignal) => {
  return customInstance<SuppliersGetSuggestedSuppliers200>({
    url: `/api/suppliers/suggested`,
    method: "GET",
    signal,
  });
};

export const getSuppliersGetSuggestedSuppliersQueryKey = () => {
  return [`/api/suppliers/suggested`] as const;
};

export const getSuppliersGetSuggestedSuppliersQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuppliersGetSuggestedSuppliersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
  > = ({ signal }) => suppliersGetSuggestedSuppliers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersGetSuggestedSuppliersQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
>;
export type SuppliersGetSuggestedSuppliersQueryError = ErrorResponse;

/**
 * @summary Get suggested suppliers (pending approval)
 */

export function useSuppliersGetSuggestedSuppliers<
  TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
  TError = ErrorResponse,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersGetSuggestedSuppliersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Accept a suggested supplier and create or link to a supplier by tax number
 * @summary Accept suggested supplier and create/link supplier record
 */
export const suppliersAcceptSuggestedSupplier = (
  suggestedId: string,
  signal?: AbortSignal,
) => {
  return customInstance<
    SuppliersAcceptSuggestedSupplier200 | SuppliersAcceptSuggestedSupplier201
  >({
    url: `/api/suppliers/suggested/${suggestedId}/accept`,
    method: "POST",
    signal,
  });
};

export const getSuppliersAcceptSuggestedSupplierMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
    TError,
    { suggestedId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
  TError,
  { suggestedId: string },
  TContext
> => {
  const mutationKey = ["suppliersAcceptSuggestedSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
    { suggestedId: string }
  > = (props) => {
    const { suggestedId } = props ?? {};

    return suppliersAcceptSuggestedSupplier(suggestedId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersAcceptSuggestedSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>
>;

export type SuppliersAcceptSuggestedSupplierMutationError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Accept suggested supplier and create/link supplier record
 */
export const useSuppliersAcceptSuggestedSupplier = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
    TError,
    { suggestedId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
  TError,
  { suggestedId: string },
  TContext
> => {
  const mutationOptions =
    getSuppliersAcceptSuggestedSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reject and mark a suggested supplier as rejected
 * @summary Reject a suggested supplier
 */
export const suppliersRejectSuggestedSupplier = (suggestedId: string) => {
  return customInstance<SuppliersRejectSuggestedSupplier200>({
    url: `/api/suppliers/suggested/${suggestedId}`,
    method: "DELETE",
  });
};

export const getSuppliersRejectSuggestedSupplierMutationOptions = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
    TError,
    { suggestedId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
  TError,
  { suggestedId: string },
  TContext
> => {
  const mutationKey = ["suppliersRejectSuggestedSupplier"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
    { suggestedId: string }
  > = (props) => {
    const { suggestedId } = props ?? {};

    return suppliersRejectSuggestedSupplier(suggestedId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersRejectSuggestedSupplierMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>
>;

export type SuppliersRejectSuggestedSupplierMutationError =
  | ErrorResponse
  | ErrorResponse;

/**
 * @summary Reject a suggested supplier
 */
export const useSuppliersRejectSuggestedSupplier = <
  TError = ErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
    TError,
    { suggestedId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
  TError,
  { suggestedId: string },
  TContext
> => {
  const mutationOptions =
    getSuppliersRejectSuggestedSupplierMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Trigger invoice synchronization from integrator to local database
 * @summary Sync invoices from BirFatura provider
 */
export const birfaturaSyncInvoices = (
  birfaturaSyncInvoicesBody?: BirfaturaSyncInvoicesBody,
  signal?: AbortSignal,
) => {
  return customInstance<BirfaturaSyncInvoices200>({
    url: `/api/birfatura/sync-invoices`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaSyncInvoicesBody,
    signal,
  });
};

export const getBirfaturaSyncInvoicesMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
    TError,
    { data: BirfaturaSyncInvoicesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
  TError,
  { data: BirfaturaSyncInvoicesBody },
  TContext
> => {
  const mutationKey = ["birfaturaSyncInvoices"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
    { data: BirfaturaSyncInvoicesBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaSyncInvoices(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaSyncInvoicesMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaSyncInvoices>>
>;
export type BirfaturaSyncInvoicesMutationBody = BirfaturaSyncInvoicesBody;
export type BirfaturaSyncInvoicesMutationError = ErrorResponse;

/**
 * @summary Sync invoices from BirFatura provider
 */
export const useBirfaturaSyncInvoices = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
    TError,
    { data: BirfaturaSyncInvoicesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
  TError,
  { data: BirfaturaSyncInvoicesBody },
  TContext
> => {
  const mutationOptions = getBirfaturaSyncInvoicesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/EFatura/sendBasicInvoice
 */
export const birfaturaBpSendBasicInvoice = (
  birfaturaBpSendBasicInvoiceBody?: BirfaturaBpSendBasicInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/EFatura/sendBasicInvoice`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpSendBasicInvoiceBody,
    signal,
  });
};

export const getBirfaturaBpSendBasicInvoiceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
    TError,
    { data: BirfaturaBpSendBasicInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
  TError,
  { data: BirfaturaBpSendBasicInvoiceBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpSendBasicInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
    { data: BirfaturaBpSendBasicInvoiceBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpSendBasicInvoice(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpSendBasicInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>
>;
export type BirfaturaBpSendBasicInvoiceMutationBody =
  BirfaturaBpSendBasicInvoiceBody;
export type BirfaturaBpSendBasicInvoiceMutationError = unknown;

/**
 * @summary POST /api/EFatura/sendBasicInvoice
 */
export const useBirfaturaBpSendBasicInvoice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
    TError,
    { data: BirfaturaBpSendBasicInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
  TError,
  { data: BirfaturaBpSendBasicInvoiceBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpSendBasicInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/EFatura/sendDocument
 */
export const birfaturaBpSendDocument = (
  birfaturaBpSendDocumentBody?: BirfaturaBpSendDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/EFatura/sendDocument`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpSendDocumentBody,
    signal,
  });
};

export const getBirfaturaBpSendDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
    TError,
    { data: BirfaturaBpSendDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
  TError,
  { data: BirfaturaBpSendDocumentBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpSendDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
    { data: BirfaturaBpSendDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpSendDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpSendDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpSendDocument>>
>;
export type BirfaturaBpSendDocumentMutationBody = BirfaturaBpSendDocumentBody;
export type BirfaturaBpSendDocumentMutationError = unknown;

/**
 * @summary POST /api/EFatura/sendDocument
 */
export const useBirfaturaBpSendDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
    TError,
    { data: BirfaturaBpSendDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
  TError,
  { data: BirfaturaBpSendDocumentBody },
  TContext
> => {
  const mutationOptions = getBirfaturaBpSendDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * In mock mode, returns document from local inbox by UUID.
 * @summary Proxy for Birfatura DocumentDownloadByUUID.
 */
export const birfaturaBpOutDocumentDownloadByUuid = (
  birfaturaBpOutDocumentDownloadByUuidBody?: BirfaturaBpOutDocumentDownloadByUuidBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/DocumentDownloadByUUID`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutDocumentDownloadByUuidBody,
    signal,
  });
};

export const getBirfaturaBpOutDocumentDownloadByUuidMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
    TError,
    { data: BirfaturaBpOutDocumentDownloadByUuidBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
  TError,
  { data: BirfaturaBpOutDocumentDownloadByUuidBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutDocumentDownloadByUuid"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
    { data: BirfaturaBpOutDocumentDownloadByUuidBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutDocumentDownloadByUuid(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutDocumentDownloadByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>
>;
export type BirfaturaBpOutDocumentDownloadByUuidMutationBody =
  BirfaturaBpOutDocumentDownloadByUuidBody;
export type BirfaturaBpOutDocumentDownloadByUuidMutationError = unknown;

/**
 * @summary Proxy for Birfatura DocumentDownloadByUUID.
 */
export const useBirfaturaBpOutDocumentDownloadByUuid = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
    TError,
    { data: BirfaturaBpOutDocumentDownloadByUuidBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
  TError,
  { data: BirfaturaBpOutDocumentDownloadByUuidBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutDocumentDownloadByUuidMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * In mock mode, reads from local inbox directory and returns parsed invoice list.
 * @summary Proxy for Birfatura GetInBoxDocuments.
 */
export const birfaturaBpOutGetInboxDocuments = (
  birfaturaBpOutGetInboxDocumentsBody?: BirfaturaBpOutGetInboxDocumentsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/GetInBoxDocuments`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutGetInboxDocumentsBody,
    signal,
  });
};

export const getBirfaturaBpOutGetInboxDocumentsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
    TError,
    { data: BirfaturaBpOutGetInboxDocumentsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
  TError,
  { data: BirfaturaBpOutGetInboxDocumentsBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutGetInboxDocuments"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
    { data: BirfaturaBpOutGetInboxDocumentsBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutGetInboxDocuments(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutGetInboxDocumentsMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>
>;
export type BirfaturaBpOutGetInboxDocumentsMutationBody =
  BirfaturaBpOutGetInboxDocumentsBody;
export type BirfaturaBpOutGetInboxDocumentsMutationError = unknown;

/**
 * @summary Proxy for Birfatura GetInBoxDocuments.
 */
export const useBirfaturaBpOutGetInboxDocuments = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
    TError,
    { data: BirfaturaBpOutGetInboxDocumentsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
  TError,
  { data: BirfaturaBpOutGetInboxDocumentsBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutGetInboxDocumentsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * In mock mode, returns invoice list with jsonData (XML content).
 * @summary Proxy for Birfatura GetInBoxDocumentsWithDetail.
 */
export const birfaturaBpOutGetInboxDocumentsWithDetail = (
  birfaturaBpOutGetInboxDocumentsWithDetailBody?: BirfaturaBpOutGetInboxDocumentsWithDetailBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/GetInBoxDocumentsWithDetail`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutGetInboxDocumentsWithDetailBody,
    signal,
  });
};

export const getBirfaturaBpOutGetInboxDocumentsWithDetailMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
    TError,
    { data: BirfaturaBpOutGetInboxDocumentsWithDetailBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
  TError,
  { data: BirfaturaBpOutGetInboxDocumentsWithDetailBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutGetInboxDocumentsWithDetail"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
    { data: BirfaturaBpOutGetInboxDocumentsWithDetailBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutGetInboxDocumentsWithDetail(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>
  >;
export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationBody =
  BirfaturaBpOutGetInboxDocumentsWithDetailBody;
export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationError = unknown;

/**
 * @summary Proxy for Birfatura GetInBoxDocumentsWithDetail.
 */
export const useBirfaturaBpOutGetInboxDocumentsWithDetail = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
    TError,
    { data: BirfaturaBpOutGetInboxDocumentsWithDetailBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
  TError,
  { data: BirfaturaBpOutGetInboxDocumentsWithDetailBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutGetInboxDocumentsWithDetailMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * In mock mode, generates PDF from provided XML.
 * @summary Proxy for Birfatura PreviewDocumentReturnPDF.
 */
export const birfaturaBpOutPreviewDocumentReturnPdf = (
  birfaturaBpOutPreviewDocumentReturnPdfBody?: BirfaturaBpOutPreviewDocumentReturnPdfBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/PreviewDocumentReturnPDF`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutPreviewDocumentReturnPdfBody,
    signal,
  });
};

export const getBirfaturaBpOutPreviewDocumentReturnPdfMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
    TError,
    { data: BirfaturaBpOutPreviewDocumentReturnPdfBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
  TError,
  { data: BirfaturaBpOutPreviewDocumentReturnPdfBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutPreviewDocumentReturnPdf"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
    { data: BirfaturaBpOutPreviewDocumentReturnPdfBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutPreviewDocumentReturnPdf(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutPreviewDocumentReturnPdfMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>
>;
export type BirfaturaBpOutPreviewDocumentReturnPdfMutationBody =
  BirfaturaBpOutPreviewDocumentReturnPdfBody;
export type BirfaturaBpOutPreviewDocumentReturnPdfMutationError = unknown;

/**
 * @summary Proxy for Birfatura PreviewDocumentReturnPDF.
 */
export const useBirfaturaBpOutPreviewDocumentReturnPdf = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
    TError,
    { data: BirfaturaBpOutPreviewDocumentReturnPdfBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
  TError,
  { data: BirfaturaBpOutPreviewDocumentReturnPdfBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutPreviewDocumentReturnPdfMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * and writes the XML to `instance/birfatura_inbox/` with a provided `filename` or timestamped name.
 * @summary Simple inbox simulator endpoint: accepts JSON with `xml` or `documentBase64` (or raw body)
 */
export const birfaturaBpOutReceiveDocument = (
  birfaturaBpOutReceiveDocumentBody?: BirfaturaBpOutReceiveDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/ReceiveDocument`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutReceiveDocumentBody,
    signal,
  });
};

export const getBirfaturaBpOutReceiveDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
    TError,
    { data: BirfaturaBpOutReceiveDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
  TError,
  { data: BirfaturaBpOutReceiveDocumentBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutReceiveDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
    { data: BirfaturaBpOutReceiveDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutReceiveDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutReceiveDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>
>;
export type BirfaturaBpOutReceiveDocumentMutationBody =
  BirfaturaBpOutReceiveDocumentBody;
export type BirfaturaBpOutReceiveDocumentMutationError = unknown;

/**
 * @summary Simple inbox simulator endpoint: accepts JSON with `xml` or `documentBase64` (or raw body)
 */
export const useBirfaturaBpOutReceiveDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
    TError,
    { data: BirfaturaBpOutReceiveDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
  TError,
  { data: BirfaturaBpOutReceiveDocumentBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutReceiveDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/OutEBelgeV2/SendBasicInvoiceFromModel
 */
export const birfaturaBpOutSendBasicInvoiceFromModel = (
  birfaturaBpOutSendBasicInvoiceFromModelBody?: BirfaturaBpOutSendBasicInvoiceFromModelBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/SendBasicInvoiceFromModel`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutSendBasicInvoiceFromModelBody,
    signal,
  });
};

export const getBirfaturaBpOutSendBasicInvoiceFromModelMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
    TError,
    { data: BirfaturaBpOutSendBasicInvoiceFromModelBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
  TError,
  { data: BirfaturaBpOutSendBasicInvoiceFromModelBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutSendBasicInvoiceFromModel"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
    { data: BirfaturaBpOutSendBasicInvoiceFromModelBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutSendBasicInvoiceFromModel(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutSendBasicInvoiceFromModelMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>
>;
export type BirfaturaBpOutSendBasicInvoiceFromModelMutationBody =
  BirfaturaBpOutSendBasicInvoiceFromModelBody;
export type BirfaturaBpOutSendBasicInvoiceFromModelMutationError = unknown;

/**
 * @summary POST /api/OutEBelgeV2/SendBasicInvoiceFromModel
 */
export const useBirfaturaBpOutSendBasicInvoiceFromModel = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
    TError,
    { data: BirfaturaBpOutSendBasicInvoiceFromModelBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
  TError,
  { data: BirfaturaBpOutSendBasicInvoiceFromModelBody },
  TContext
> => {
  const mutationOptions =
    getBirfaturaBpOutSendBasicInvoiceFromModelMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/OutEBelgeV2/SendDocument
 */
export const birfaturaBpOutSendDocument = (
  birfaturaBpOutSendDocumentBody?: BirfaturaBpOutSendDocumentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/OutEBelgeV2/SendDocument`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: birfaturaBpOutSendDocumentBody,
    signal,
  });
};

export const getBirfaturaBpOutSendDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
    TError,
    { data: BirfaturaBpOutSendDocumentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
  TError,
  { data: BirfaturaBpOutSendDocumentBody },
  TContext
> => {
  const mutationKey = ["birfaturaBpOutSendDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
    { data: BirfaturaBpOutSendDocumentBody }
  > = (props) => {
    const { data } = props ?? {};

    return birfaturaBpOutSendDocument(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BirfaturaBpOutSendDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>
>;
export type BirfaturaBpOutSendDocumentMutationBody =
  BirfaturaBpOutSendDocumentBody;
export type BirfaturaBpOutSendDocumentMutationError = unknown;

/**
 * @summary POST /api/OutEBelgeV2/SendDocument
 */
export const useBirfaturaBpOutSendDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
    TError,
    { data: BirfaturaBpOutSendDocumentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
  TError,
  { data: BirfaturaBpOutSendDocumentBody },
  TContext
> => {
  const mutationOptions = getBirfaturaBpOutSendDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Updates the read status of a document
 * @summary Update document read status
 */
export const postApiOutEBelgeV2UpdateUnreadedStatus = (
  updateUnreadedStatusRequestData: UpdateUnreadedStatusRequestData,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseString>({
    url: `/api/OutEBelgeV2/UpdateUnreadedStatus`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateUnreadedStatusRequestData,
    signal,
  });
};

export const getPostApiOutEBelgeV2UpdateUnreadedStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
    TError,
    { data: UpdateUnreadedStatusRequestData },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
  TError,
  { data: UpdateUnreadedStatusRequestData },
  TContext
> => {
  const mutationKey = ["postApiOutEBelgeV2UpdateUnreadedStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
    { data: UpdateUnreadedStatusRequestData }
  > = (props) => {
    const { data } = props ?? {};

    return postApiOutEBelgeV2UpdateUnreadedStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>
>;
export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationBody =
  UpdateUnreadedStatusRequestData;
export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationError = unknown;

/**
 * @summary Update document read status
 */
export const usePostApiOutEBelgeV2UpdateUnreadedStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
    TError,
    { data: UpdateUnreadedStatusRequestData },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
  TError,
  { data: UpdateUnreadedStatusRequestData },
  TContext
> => {
  const mutationOptions =
    getPostApiOutEBelgeV2UpdateUnreadedStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Sends an answer (KABUL, RED, IPTAL) for an incoming document
 * @summary Send document answer (accept/reject/cancel)
 */
export const postApiOutEBelgeV2SendDocumentAnswer = (
  sendDocumentAnswerRequestData: SendDocumentAnswerRequestData,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseSendDocumentAnswerResponse>({
    url: `/api/OutEBelgeV2/SendDocumentAnswer`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sendDocumentAnswerRequestData,
    signal,
  });
};

export const getPostApiOutEBelgeV2SendDocumentAnswerMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
    TError,
    { data: SendDocumentAnswerRequestData },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
  TError,
  { data: SendDocumentAnswerRequestData },
  TContext
> => {
  const mutationKey = ["postApiOutEBelgeV2SendDocumentAnswer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
    { data: SendDocumentAnswerRequestData }
  > = (props) => {
    const { data } = props ?? {};

    return postApiOutEBelgeV2SendDocumentAnswer(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiOutEBelgeV2SendDocumentAnswerMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>
>;
export type PostApiOutEBelgeV2SendDocumentAnswerMutationBody =
  SendDocumentAnswerRequestData;
export type PostApiOutEBelgeV2SendDocumentAnswerMutationError = unknown;

/**
 * @summary Send document answer (accept/reject/cancel)
 */
export const usePostApiOutEBelgeV2SendDocumentAnswer = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
    TError,
    { data: SendDocumentAnswerRequestData },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
  TError,
  { data: SendDocumentAnswerRequestData },
  TContext
> => {
  const mutationOptions =
    getPostApiOutEBelgeV2SendDocumentAnswerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Activity Logs
 */
export const activityLogsGetActivityLogs = (
  params?: ActivityLogsGetActivityLogsParams,
  signal?: AbortSignal,
) => {
  return customInstance<ActivityLogsGetActivityLogs200>({
    url: `/api/activity-logs`,
    method: "GET",
    params,
    signal,
  });
};

export const getActivityLogsGetActivityLogsQueryKey = (
  params?: ActivityLogsGetActivityLogsParams,
) => {
  return [`/api/activity-logs`, ...(params ? [params] : [])] as const;
};

export const getActivityLogsGetActivityLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
  TError = unknown,
>(
  params?: ActivityLogsGetActivityLogsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getActivityLogsGetActivityLogsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsGetActivityLogs>>
  > = ({ signal }) => activityLogsGetActivityLogs(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsGetActivityLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsGetActivityLogs>>
>;
export type ActivityLogsGetActivityLogsQueryError = unknown;

/**
 * @summary Get Activity Logs
 */

export function useActivityLogsGetActivityLogs<
  TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
  TError = unknown,
>(
  params?: ActivityLogsGetActivityLogsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getActivityLogsGetActivityLogsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get available filter options for activity logs
 */
export const activityLogsGetFilterOptions = (signal?: AbortSignal) => {
  return customInstance<ActivityLogsGetFilterOptions200>({
    url: `/api/activity-logs/filter-options`,
    method: "GET",
    signal,
  });
};

export const getActivityLogsGetFilterOptionsQueryKey = () => {
  return [`/api/activity-logs/filter-options`] as const;
};

export const getActivityLogsGetFilterOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getActivityLogsGetFilterOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsGetFilterOptions>>
  > = ({ signal }) => activityLogsGetFilterOptions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsGetFilterOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsGetFilterOptions>>
>;
export type ActivityLogsGetFilterOptionsQueryError = unknown;

/**
 * @summary Get available filter options for activity logs
 */

export function useActivityLogsGetFilterOptions<
  TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getActivityLogsGetFilterOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a single activity log entry with full details
 */
export const activityLogsGetActivityLogDetail = (
  logId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/activity-logs/${logId}`,
    method: "GET",
    signal,
  });
};

export const getActivityLogsGetActivityLogDetailQueryKey = (logId?: string) => {
  return [`/api/activity-logs/${logId}`] as const;
};

export const getActivityLogsGetActivityLogDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
  TError = unknown,
>(
  logId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getActivityLogsGetActivityLogDetailQueryKey(logId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>
  > = ({ signal }) => activityLogsGetActivityLogDetail(logId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsGetActivityLogDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>
>;
export type ActivityLogsGetActivityLogDetailQueryError = unknown;

/**
 * @summary Get a single activity log entry with full details
 */

export function useActivityLogsGetActivityLogDetail<
  TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
  TError = unknown,
>(
  logId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getActivityLogsGetActivityLogDetailQueryOptions(
    logId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Query params:
page: int - Page number (default 1)
page_size: int - Items per page (default 20, max 100)
tenant_id: str - Filter by tenant
branch_id: str - Filter by branch
user_id: str - Filter by user
role: str - Filter by role
action: str - Filter by exact action
action_type: str - Filter by action prefix (e.g., "patient", "invoice")
date_from: str - ISO date string
date_to: str - ISO date string
critical_only: bool - Only show critical actions
search: str - Search in message, action, entity_id
Returns:
{
success: true,
data: {
logs: [...],
meta: { total, page, pageSize, totalPages }
}
}
 * @summary Get all activity logs for platform admin.
 */
export const activityLogsAdminGetActivityLogs = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/activity-logs`,
    method: "GET",
    signal,
  });
};

export const getActivityLogsAdminGetActivityLogsQueryKey = () => {
  return [`/api/admin/activity-logs`] as const;
};

export const getActivityLogsAdminGetActivityLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getActivityLogsAdminGetActivityLogsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>
  > = ({ signal }) => activityLogsAdminGetActivityLogs(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsAdminGetActivityLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>
>;
export type ActivityLogsAdminGetActivityLogsQueryError = unknown;

/**
 * @summary Get all activity logs for platform admin.
 */

export function useActivityLogsAdminGetActivityLogs<
  TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getActivityLogsAdminGetActivityLogsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get filter options for admin panel activity logs
 */
export const activityLogsAdminGetFilterOptions = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/activity-logs/filter-options`,
    method: "GET",
    signal,
  });
};

export const getActivityLogsAdminGetFilterOptionsQueryKey = () => {
  return [`/api/admin/activity-logs/filter-options`] as const;
};

export const getActivityLogsAdminGetFilterOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getActivityLogsAdminGetFilterOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>
  > = ({ signal }) => activityLogsAdminGetFilterOptions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsAdminGetFilterOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>
>;
export type ActivityLogsAdminGetFilterOptionsQueryError = unknown;

/**
 * @summary Get filter options for admin panel activity logs
 */

export function useActivityLogsAdminGetFilterOptions<
  TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getActivityLogsAdminGetFilterOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns action counts, top users, etc.
 * @summary Get activity statistics for platform admin.
 */
export const activityLogsAdminGetActivityStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/activity-logs/stats`,
    method: "GET",
    signal,
  });
};

export const getActivityLogsAdminGetActivityStatsQueryKey = () => {
  return [`/api/admin/activity-logs/stats`] as const;
};

export const getActivityLogsAdminGetActivityStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getActivityLogsAdminGetActivityStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>
  > = ({ signal }) => activityLogsAdminGetActivityStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ActivityLogsAdminGetActivityStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>
>;
export type ActivityLogsAdminGetActivityStatsQueryError = unknown;

/**
 * @summary Get activity statistics for platform admin.
 */

export function useActivityLogsAdminGetActivityStats<
  TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getActivityLogsAdminGetActivityStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new add-on
 */
export const adminAddonsCreateAddon = (
  adminAddonsCreateAddonBody?: AdminAddonsCreateAddonBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/addons`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminAddonsCreateAddonBody,
    signal,
  });
};

export const getAdminAddonsCreateAddonMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
    TError,
    { data: AdminAddonsCreateAddonBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
  TError,
  { data: AdminAddonsCreateAddonBody },
  TContext
> => {
  const mutationKey = ["adminAddonsCreateAddon"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
    { data: AdminAddonsCreateAddonBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminAddonsCreateAddon(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminAddonsCreateAddonMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminAddonsCreateAddon>>
>;
export type AdminAddonsCreateAddonMutationBody = AdminAddonsCreateAddonBody;
export type AdminAddonsCreateAddonMutationError = unknown;

/**
 * @summary Create a new add-on
 */
export const useAdminAddonsCreateAddon = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
    TError,
    { data: AdminAddonsCreateAddonBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
  TError,
  { data: AdminAddonsCreateAddonBody },
  TContext
> => {
  const mutationOptions = getAdminAddonsCreateAddonMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete add-on (soft delete by setting is_active=False)
 */
export const adminAddonsDeleteAddon = (addonId: string) => {
  return customInstance<void>({
    url: `/api/admin/addons/${addonId}`,
    method: "DELETE",
  });
};

export const getAdminAddonsDeleteAddonMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
    TError,
    { addonId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
  TError,
  { addonId: string },
  TContext
> => {
  const mutationKey = ["adminAddonsDeleteAddon"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
    { addonId: string }
  > = (props) => {
    const { addonId } = props ?? {};

    return adminAddonsDeleteAddon(addonId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminAddonsDeleteAddonMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminAddonsDeleteAddon>>
>;

export type AdminAddonsDeleteAddonMutationError = unknown;

/**
 * @summary Delete add-on (soft delete by setting is_active=False)
 */
export const useAdminAddonsDeleteAddon = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
    TError,
    { addonId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
  TError,
  { addonId: string },
  TContext
> => {
  const mutationOptions = getAdminAddonsDeleteAddonMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Admin kullanÄ±cÄ±larÄ± rolleriyle birlikte listele
 */
export const adminRolesGetAdminUsersWithRoles = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/admin-users`,
    method: "GET",
    signal,
  });
};

export const getAdminRolesGetAdminUsersWithRolesQueryKey = () => {
  return [`/api/admin/admin-users`] as const;
};

export const getAdminRolesGetAdminUsersWithRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminRolesGetAdminUsersWithRolesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>
  > = ({ signal }) => adminRolesGetAdminUsersWithRoles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminRolesGetAdminUsersWithRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>
>;
export type AdminRolesGetAdminUsersWithRolesQueryError = unknown;

/**
 * @summary Admin kullanÄ±cÄ±larÄ± rolleriyle birlikte listele
 */

export function useAdminRolesGetAdminUsersWithRoles<
  TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminRolesGetAdminUsersWithRolesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Admin kullanÄ±cÄ± detayÄ±
 */
export const adminRolesGetAdminUserDetail = (
  userId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/admin-users/${userId}`,
    method: "GET",
    signal,
  });
};

export const getAdminRolesGetAdminUserDetailQueryKey = (userId?: string) => {
  return [`/api/admin/admin-users/${userId}`] as const;
};

export const getAdminRolesGetAdminUserDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminRolesGetAdminUserDetailQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>
  > = ({ signal }) => adminRolesGetAdminUserDetail(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminRolesGetAdminUserDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>
>;
export type AdminRolesGetAdminUserDetailQueryError = unknown;

/**
 * @summary Admin kullanÄ±cÄ± detayÄ±
 */

export function useAdminRolesGetAdminUserDetail<
  TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminRolesGetAdminUserDetailQueryOptions(
    userId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Body:
role_ids: list[str] - Rol ID'leri
Not: admin@x-ear.com kullanÄ±cÄ±sÄ±ndan SuperAdmin rolÃ¼ kaldÄ±rÄ±lamaz
 * @summary KullanÄ±cÄ±ya rol ata
 */
export const adminRolesUpdateAdminUserRoles = (
  userId: string,
  adminRolesUpdateAdminUserRolesBody?: AdminRolesUpdateAdminUserRolesBody,
) => {
  return customInstance<void>({
    url: `/api/admin/admin-users/${userId}/roles`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminRolesUpdateAdminUserRolesBody,
  });
};

export const getAdminRolesUpdateAdminUserRolesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
    TError,
    { userId: string; data: AdminRolesUpdateAdminUserRolesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
  TError,
  { userId: string; data: AdminRolesUpdateAdminUserRolesBody },
  TContext
> => {
  const mutationKey = ["adminRolesUpdateAdminUserRoles"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
    { userId: string; data: AdminRolesUpdateAdminUserRolesBody }
  > = (props) => {
    const { userId, data } = props ?? {};

    return adminRolesUpdateAdminUserRoles(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminRolesUpdateAdminUserRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>
>;
export type AdminRolesUpdateAdminUserRolesMutationBody =
  AdminRolesUpdateAdminUserRolesBody;
export type AdminRolesUpdateAdminUserRolesMutationError = unknown;

/**
 * @summary KullanÄ±cÄ±ya rol ata
 */
export const useAdminRolesUpdateAdminUserRoles = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
    TError,
    { userId: string; data: AdminRolesUpdateAdminUserRolesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
  TError,
  { userId: string; data: AdminRolesUpdateAdminUserRolesBody },
  TContext
> => {
  const mutationOptions =
    getAdminRolesUpdateAdminUserRolesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get admin analytics data
 */
export const adminAnalyticsGetAdminAnalytics = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/analytics`,
    method: "GET",
    signal,
  });
};

export const getAdminAnalyticsGetAdminAnalyticsQueryKey = () => {
  return [`/api/admin/analytics`] as const;
};

export const getAdminAnalyticsGetAdminAnalyticsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminAnalyticsGetAdminAnalyticsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>
  > = ({ signal }) => adminAnalyticsGetAdminAnalytics(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminAnalyticsGetAdminAnalyticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>
>;
export type AdminAnalyticsGetAdminAnalyticsQueryError = unknown;

/**
 * @summary Get admin analytics data
 */

export function useAdminAnalyticsGetAdminAnalytics<
  TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminAnalyticsGetAdminAnalyticsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new API key
 */
export const adminApiKeysCreateApiKey = (
  adminApiKeysCreateApiKeyBody?: AdminApiKeysCreateApiKeyBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/api-keys`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminApiKeysCreateApiKeyBody,
    signal,
  });
};

export const getAdminApiKeysCreateApiKeyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
    TError,
    { data: AdminApiKeysCreateApiKeyBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
  TError,
  { data: AdminApiKeysCreateApiKeyBody },
  TContext
> => {
  const mutationKey = ["adminApiKeysCreateApiKey"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
    { data: AdminApiKeysCreateApiKeyBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminApiKeysCreateApiKey(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminApiKeysCreateApiKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>
>;
export type AdminApiKeysCreateApiKeyMutationBody = AdminApiKeysCreateApiKeyBody;
export type AdminApiKeysCreateApiKeyMutationError = unknown;

/**
 * @summary Create a new API key
 */
export const useAdminApiKeysCreateApiKey = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
    TError,
    { data: AdminApiKeysCreateApiKeyBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
  TError,
  { data: AdminApiKeysCreateApiKeyBody },
  TContext
> => {
  const mutationOptions = getAdminApiKeysCreateApiKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Initialize API Key table
 */
export const adminApiKeysInitDb = (
  adminApiKeysInitDbBody?: AdminApiKeysInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/api-keys/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminApiKeysInitDbBody,
    signal,
  });
};

export const getAdminApiKeysInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysInitDb>>,
    TError,
    { data: AdminApiKeysInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminApiKeysInitDb>>,
  TError,
  { data: AdminApiKeysInitDbBody },
  TContext
> => {
  const mutationKey = ["adminApiKeysInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminApiKeysInitDb>>,
    { data: AdminApiKeysInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminApiKeysInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminApiKeysInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminApiKeysInitDb>>
>;
export type AdminApiKeysInitDbMutationBody = AdminApiKeysInitDbBody;
export type AdminApiKeysInitDbMutationError = unknown;

/**
 * @summary Initialize API Key table
 */
export const useAdminApiKeysInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysInitDb>>,
    TError,
    { data: AdminApiKeysInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminApiKeysInitDb>>,
  TError,
  { data: AdminApiKeysInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminApiKeysInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Revoke (delete) an API key
 */
export const adminApiKeysRevokeApiKey = (keyId: string) => {
  return customInstance<void>({
    url: `/api/admin/api-keys/${keyId}`,
    method: "DELETE",
  });
};

export const getAdminApiKeysRevokeApiKeyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
    TError,
    { keyId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
  TError,
  { keyId: string },
  TContext
> => {
  const mutationKey = ["adminApiKeysRevokeApiKey"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
    { keyId: string }
  > = (props) => {
    const { keyId } = props ?? {};

    return adminApiKeysRevokeApiKey(keyId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminApiKeysRevokeApiKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>
>;

export type AdminApiKeysRevokeApiKeyMutationError = unknown;

/**
 * @summary Revoke (delete) an API key
 */
export const useAdminApiKeysRevokeApiKey = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
    TError,
    { keyId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
  TError,
  { keyId: string },
  TContext
> => {
  const mutationOptions = getAdminApiKeysRevokeApiKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get list of ALL appointments from ALL tenants
 */
export const adminAppointmentsGetAllAppointments = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/appointments`,
    method: "GET",
    signal,
  });
};

export const getAdminAppointmentsGetAllAppointmentsQueryKey = () => {
  return [`/api/admin/appointments`] as const;
};

export const getAdminAppointmentsGetAllAppointmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminAppointmentsGetAllAppointmentsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>
  > = ({ signal }) => adminAppointmentsGetAllAppointments(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminAppointmentsGetAllAppointmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>
>;
export type AdminAppointmentsGetAllAppointmentsQueryError = unknown;

/**
 * @summary Get list of ALL appointments from ALL tenants
 */

export function useAdminAppointmentsGetAllAppointments<
  TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getAdminAppointmentsGetAllAppointmentsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Admin login endpoint
 */
export const adminAdminLogin = (
  adminAdminLoginBody?: AdminAdminLoginBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminAdminLoginBody,
    signal,
  });
};

export const getAdminAdminLoginMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAdminLogin>>,
    TError,
    { data: AdminAdminLoginBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminAdminLogin>>,
  TError,
  { data: AdminAdminLoginBody },
  TContext
> => {
  const mutationKey = ["adminAdminLogin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminAdminLogin>>,
    { data: AdminAdminLoginBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminAdminLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminAdminLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminAdminLogin>>
>;
export type AdminAdminLoginMutationBody = AdminAdminLoginBody;
export type AdminAdminLoginMutationError = unknown;

/**
 * @summary Admin login endpoint
 */
export const useAdminAdminLogin = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminAdminLogin>>,
    TError,
    { data: AdminAdminLoginBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminAdminLogin>>,
  TError,
  { data: AdminAdminLoginBody },
  TContext
> => {
  const mutationOptions = getAdminAdminLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get invoices with BirFatura status
 */
export const adminBirfaturaGetInvoices = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/birfatura/invoices`,
    method: "GET",
    signal,
  });
};

export const getAdminBirfaturaGetInvoicesQueryKey = () => {
  return [`/api/admin/birfatura/invoices`] as const;
};

export const getAdminBirfaturaGetInvoicesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminBirfaturaGetInvoicesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>
  > = ({ signal }) => adminBirfaturaGetInvoices(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminBirfaturaGetInvoicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>
>;
export type AdminBirfaturaGetInvoicesQueryError = unknown;

/**
 * @summary Get invoices with BirFatura status
 */

export function useAdminBirfaturaGetInvoices<
  TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminBirfaturaGetInvoicesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get BirFatura related logs
 */
export const adminBirfaturaGetLogs = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/birfatura/logs`,
    method: "GET",
    signal,
  });
};

export const getAdminBirfaturaGetLogsQueryKey = () => {
  return [`/api/admin/birfatura/logs`] as const;
};

export const getAdminBirfaturaGetLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminBirfaturaGetLogsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminBirfaturaGetLogs>>
  > = ({ signal }) => adminBirfaturaGetLogs(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminBirfaturaGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminBirfaturaGetLogs>>
>;
export type AdminBirfaturaGetLogsQueryError = unknown;

/**
 * @summary Get BirFatura related logs
 */

export function useAdminBirfaturaGetLogs<
  TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminBirfaturaGetLogsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get BirFatura statistics
 */
export const adminBirfaturaGetStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/birfatura/stats`,
    method: "GET",
    signal,
  });
};

export const getAdminBirfaturaGetStatsQueryKey = () => {
  return [`/api/admin/birfatura/stats`] as const;
};

export const getAdminBirfaturaGetStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminBirfaturaGetStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminBirfaturaGetStats>>
  > = ({ signal }) => adminBirfaturaGetStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminBirfaturaGetStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminBirfaturaGetStats>>
>;
export type AdminBirfaturaGetStatsQueryError = unknown;

/**
 * @summary Get BirFatura statistics
 */

export function useAdminBirfaturaGetStats<
  TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminBirfaturaGetStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get dashboard metrics
 */
export const adminDashboardGetDashboardMetrics = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/dashboard/metrics`,
    method: "GET",
    signal,
  });
};

export const getAdminDashboardGetDashboardMetricsQueryKey = () => {
  return [`/api/admin/dashboard/metrics`] as const;
};

export const getAdminDashboardGetDashboardMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminDashboardGetDashboardMetricsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>
  > = ({ signal }) => adminDashboardGetDashboardMetrics(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminDashboardGetDashboardMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>
>;
export type AdminDashboardGetDashboardMetricsQueryError = unknown;

/**
 * @summary Get dashboard metrics
 */

export function useAdminDashboardGetDashboardMetrics<
  TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getAdminDashboardGetDashboardMetricsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Only available to admin@x-ear.com user.
 * @summary Get all available roles for debugging.
 */
export const adminDebugAvailableRoles = (signal?: AbortSignal) => {
  return customInstance<AdminDebugAvailableRoles200>({
    url: `/api/admin/debug/available-roles`,
    method: "GET",
    signal,
  });
};

export const getAdminDebugAvailableRolesQueryKey = () => {
  return [`/api/admin/debug/available-roles`] as const;
};

export const getAdminDebugAvailableRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminDebugAvailableRolesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminDebugAvailableRoles>>
  > = ({ signal }) => adminDebugAvailableRoles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminDebugAvailableRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminDebugAvailableRoles>>
>;
export type AdminDebugAvailableRolesQueryError = unknown;

/**
 * @summary Get all available roles for debugging.
 */

export function useAdminDebugAvailableRoles<
  TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminDebugAvailableRolesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Only available to admin@x-ear.com user.
 * @summary Get permissions for a specific page based on the effective role.
 */
export const adminDebugPagePermissions = (
  pageKey: string,
  signal?: AbortSignal,
) => {
  return customInstance<AdminDebugPagePermissions200>({
    url: `/api/admin/debug/page-permissions/${pageKey}`,
    method: "GET",
    signal,
  });
};

export const getAdminDebugPagePermissionsQueryKey = (pageKey?: string) => {
  return [`/api/admin/debug/page-permissions/${pageKey}`] as const;
};

export const getAdminDebugPagePermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>,
  TError = unknown,
>(
  pageKey: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminDebugPagePermissions>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminDebugPagePermissionsQueryKey(pageKey);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminDebugPagePermissions>>
  > = ({ signal }) => adminDebugPagePermissions(pageKey, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!pageKey,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof adminDebugPagePermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminDebugPagePermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminDebugPagePermissions>>
>;
export type AdminDebugPagePermissionsQueryError = unknown;

/**
 * @summary Get permissions for a specific page based on the effective role.
 */

export function useAdminDebugPagePermissions<
  TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>,
  TError = unknown,
>(
  pageKey: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminDebugPagePermissions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminDebugPagePermissionsQueryOptions(
    pageKey,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Only available to admin@x-ear.com user.
Returns a new JWT with the selected role's permissions.
 * @summary Switch to a different role for debugging purposes.
 */
export const adminDebugSwitchRole = (
  adminDebugSwitchRoleBody: AdminDebugSwitchRoleBody,
  signal?: AbortSignal,
) => {
  return customInstance<AdminDebugSwitchRole200>({
    url: `/api/admin/debug/switch-role`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminDebugSwitchRoleBody,
    signal,
  });
};

export const getAdminDebugSwitchRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminDebugSwitchRole>>,
    TError,
    { data: AdminDebugSwitchRoleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminDebugSwitchRole>>,
  TError,
  { data: AdminDebugSwitchRoleBody },
  TContext
> => {
  const mutationKey = ["adminDebugSwitchRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminDebugSwitchRole>>,
    { data: AdminDebugSwitchRoleBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminDebugSwitchRole(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminDebugSwitchRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminDebugSwitchRole>>
>;
export type AdminDebugSwitchRoleMutationBody = AdminDebugSwitchRoleBody;
export type AdminDebugSwitchRoleMutationError = unknown;

/**
 * @summary Switch to a different role for debugging purposes.
 */
export const useAdminDebugSwitchRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminDebugSwitchRole>>,
    TError,
    { data: AdminDebugSwitchRoleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminDebugSwitchRole>>,
  TError,
  { data: AdminDebugSwitchRoleBody },
  TContext
> => {
  const mutationOptions = getAdminDebugSwitchRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Authorization: user must have `settings.update` or `features.toggle`.
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const adminPatchFeatures = () => {
  return customInstance<void>({ url: `/api/admin/features`, method: "PATCH" });
};

export const getAdminPatchFeaturesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPatchFeatures>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminPatchFeatures>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["adminPatchFeatures"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminPatchFeatures>>,
    void
  > = () => {
    return adminPatchFeatures();
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminPatchFeaturesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminPatchFeatures>>
>;

export type AdminPatchFeaturesMutationError = unknown;

/**
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const useAdminPatchFeatures = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPatchFeatures>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminPatchFeatures>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAdminPatchFeaturesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update BirFatura integration configuration
 */
export const adminIntegrationsUpdateBirfaturaConfig = (
  adminIntegrationsUpdateBirfaturaConfigBody?: AdminIntegrationsUpdateBirfaturaConfigBody,
) => {
  return customInstance<void>({
    url: `/api/admin/integrations/birfatura/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminIntegrationsUpdateBirfaturaConfigBody,
  });
};

export const getAdminIntegrationsUpdateBirfaturaConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
    TError,
    { data: AdminIntegrationsUpdateBirfaturaConfigBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
  TError,
  { data: AdminIntegrationsUpdateBirfaturaConfigBody },
  TContext
> => {
  const mutationKey = ["adminIntegrationsUpdateBirfaturaConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
    { data: AdminIntegrationsUpdateBirfaturaConfigBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminIntegrationsUpdateBirfaturaConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminIntegrationsUpdateBirfaturaConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>
>;
export type AdminIntegrationsUpdateBirfaturaConfigMutationBody =
  AdminIntegrationsUpdateBirfaturaConfigBody;
export type AdminIntegrationsUpdateBirfaturaConfigMutationError = unknown;

/**
 * @summary Update BirFatura integration configuration
 */
export const useAdminIntegrationsUpdateBirfaturaConfig = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
    TError,
    { data: AdminIntegrationsUpdateBirfaturaConfigBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
  TError,
  { data: AdminIntegrationsUpdateBirfaturaConfigBody },
  TContext
> => {
  const mutationOptions =
    getAdminIntegrationsUpdateBirfaturaConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Initialize integration config tables
 */
export const adminIntegrationsInitDb = (
  adminIntegrationsInitDbBody?: AdminIntegrationsInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/integrations/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminIntegrationsInitDbBody,
    signal,
  });
};

export const getAdminIntegrationsInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
    TError,
    { data: AdminIntegrationsInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
  TError,
  { data: AdminIntegrationsInitDbBody },
  TContext
> => {
  const mutationKey = ["adminIntegrationsInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
    { data: AdminIntegrationsInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminIntegrationsInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminIntegrationsInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminIntegrationsInitDb>>
>;
export type AdminIntegrationsInitDbMutationBody = AdminIntegrationsInitDbBody;
export type AdminIntegrationsInitDbMutationError = unknown;

/**
 * @summary Initialize integration config tables
 */
export const useAdminIntegrationsInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
    TError,
    { data: AdminIntegrationsInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
  TError,
  { data: AdminIntegrationsInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminIntegrationsInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update VatanSMS integration configuration
 */
export const adminIntegrationsUpdateVatanSmsConfig = (
  adminIntegrationsUpdateVatanSmsConfigBody?: AdminIntegrationsUpdateVatanSmsConfigBody,
) => {
  return customInstance<void>({
    url: `/api/admin/integrations/vatan-sms/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminIntegrationsUpdateVatanSmsConfigBody,
  });
};

export const getAdminIntegrationsUpdateVatanSmsConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
    TError,
    { data: AdminIntegrationsUpdateVatanSmsConfigBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
  TError,
  { data: AdminIntegrationsUpdateVatanSmsConfigBody },
  TContext
> => {
  const mutationKey = ["adminIntegrationsUpdateVatanSmsConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
    { data: AdminIntegrationsUpdateVatanSmsConfigBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminIntegrationsUpdateVatanSmsConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminIntegrationsUpdateVatanSmsConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>
>;
export type AdminIntegrationsUpdateVatanSmsConfigMutationBody =
  AdminIntegrationsUpdateVatanSmsConfigBody;
export type AdminIntegrationsUpdateVatanSmsConfigMutationError = unknown;

/**
 * @summary Update VatanSMS integration configuration
 */
export const useAdminIntegrationsUpdateVatanSmsConfig = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
    TError,
    { data: AdminIntegrationsUpdateVatanSmsConfigBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
  TError,
  { data: AdminIntegrationsUpdateVatanSmsConfigBody },
  TContext
> => {
  const mutationOptions =
    getAdminIntegrationsUpdateVatanSmsConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get list of ALL devices/inventory from ALL tenants
 */
export const adminInventoryGetAllInventory = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/inventory`,
    method: "GET",
    signal,
  });
};

export const getAdminInventoryGetAllInventoryQueryKey = () => {
  return [`/api/admin/inventory`] as const;
};

export const getAdminInventoryGetAllInventoryQueryOptions = <
  TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminInventoryGetAllInventoryQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminInventoryGetAllInventory>>
  > = ({ signal }) => adminInventoryGetAllInventory(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminInventoryGetAllInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminInventoryGetAllInventory>>
>;
export type AdminInventoryGetAllInventoryQueryError = unknown;

/**
 * @summary Get list of ALL devices/inventory from ALL tenants
 */

export function useAdminInventoryGetAllInventory<
  TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminInventoryGetAllInventoryQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary POST /api/admin/invoices
 */
export const adminInvoicesCreateAdminInvoice = (
  adminInvoicesCreateAdminInvoiceBody?: AdminInvoicesCreateAdminInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/invoices`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminInvoicesCreateAdminInvoiceBody,
    signal,
  });
};

export const getAdminInvoicesCreateAdminInvoiceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
    TError,
    { data: AdminInvoicesCreateAdminInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
  TError,
  { data: AdminInvoicesCreateAdminInvoiceBody },
  TContext
> => {
  const mutationKey = ["adminInvoicesCreateAdminInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
    { data: AdminInvoicesCreateAdminInvoiceBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminInvoicesCreateAdminInvoice(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminInvoicesCreateAdminInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>
>;
export type AdminInvoicesCreateAdminInvoiceMutationBody =
  AdminInvoicesCreateAdminInvoiceBody;
export type AdminInvoicesCreateAdminInvoiceMutationError = unknown;

/**
 * @summary POST /api/admin/invoices
 */
export const useAdminInvoicesCreateAdminInvoice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
    TError,
    { data: AdminInvoicesCreateAdminInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
  TError,
  { data: AdminInvoicesCreateAdminInvoiceBody },
  TContext
> => {
  const mutationOptions =
    getAdminInvoicesCreateAdminInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary GET /api/admin/invoices/{id}
 */
export const adminInvoicesGetAdminInvoice = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/invoices/${id}`,
    method: "GET",
    signal,
  });
};

export const getAdminInvoicesGetAdminInvoiceQueryKey = (id?: string) => {
  return [`/api/admin/invoices/${id}`] as const;
};

export const getAdminInvoicesGetAdminInvoiceQueryOptions = <
  TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminInvoicesGetAdminInvoiceQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>
  > = ({ signal }) => adminInvoicesGetAdminInvoice(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminInvoicesGetAdminInvoiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>
>;
export type AdminInvoicesGetAdminInvoiceQueryError = unknown;

/**
 * @summary GET /api/admin/invoices/{id}
 */

export function useAdminInvoicesGetAdminInvoice<
  TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminInvoicesGetAdminInvoiceQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary POST /api/admin/invoices/{id}/payment
 */
export const adminInvoicesRecordPayment = (
  id: string,
  adminInvoicesRecordPaymentBody?: AdminInvoicesRecordPaymentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/invoices/${id}/payment`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminInvoicesRecordPaymentBody,
    signal,
  });
};

export const getAdminInvoicesRecordPaymentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
    TError,
    { id: string; data: AdminInvoicesRecordPaymentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
  TError,
  { id: string; data: AdminInvoicesRecordPaymentBody },
  TContext
> => {
  const mutationKey = ["adminInvoicesRecordPayment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
    { id: string; data: AdminInvoicesRecordPaymentBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminInvoicesRecordPayment(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminInvoicesRecordPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminInvoicesRecordPayment>>
>;
export type AdminInvoicesRecordPaymentMutationBody =
  AdminInvoicesRecordPaymentBody;
export type AdminInvoicesRecordPaymentMutationError = unknown;

/**
 * @summary POST /api/admin/invoices/{id}/payment
 */
export const useAdminInvoicesRecordPayment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
    TError,
    { id: string; data: AdminInvoicesRecordPaymentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
  TError,
  { id: string; data: AdminInvoicesRecordPaymentBody },
  TContext
> => {
  const mutationOptions = getAdminInvoicesRecordPaymentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary GET /api/admin/invoices/{id}/pdf
 */
export const adminInvoicesGetInvoicePdf = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/invoices/${id}/pdf`,
    method: "GET",
    signal,
  });
};

export const getAdminInvoicesGetInvoicePdfQueryKey = (id?: string) => {
  return [`/api/admin/invoices/${id}/pdf`] as const;
};

export const getAdminInvoicesGetInvoicePdfQueryOptions = <
  TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminInvoicesGetInvoicePdfQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>
  > = ({ signal }) => adminInvoicesGetInvoicePdf(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminInvoicesGetInvoicePdfQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>
>;
export type AdminInvoicesGetInvoicePdfQueryError = unknown;

/**
 * @summary GET /api/admin/invoices/{id}/pdf
 */

export function useAdminInvoicesGetInvoicePdf<
  TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminInvoicesGetInvoicePdfQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initialize Marketplace tables
 */
export const adminMarketplacesInitDb = (
  adminMarketplacesInitDbBody?: AdminMarketplacesInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/marketplaces/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminMarketplacesInitDbBody,
    signal,
  });
};

export const getAdminMarketplacesInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
    TError,
    { data: AdminMarketplacesInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
  TError,
  { data: AdminMarketplacesInitDbBody },
  TContext
> => {
  const mutationKey = ["adminMarketplacesInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
    { data: AdminMarketplacesInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminMarketplacesInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminMarketplacesInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminMarketplacesInitDb>>
>;
export type AdminMarketplacesInitDbMutationBody = AdminMarketplacesInitDbBody;
export type AdminMarketplacesInitDbMutationError = unknown;

/**
 * @summary Initialize Marketplace tables
 */
export const useAdminMarketplacesInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
    TError,
    { data: AdminMarketplacesInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
  TError,
  { data: AdminMarketplacesInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminMarketplacesInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new marketplace integration
 */
export const adminMarketplacesCreateIntegration = (
  adminMarketplacesCreateIntegrationBody?: AdminMarketplacesCreateIntegrationBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/marketplaces/integrations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminMarketplacesCreateIntegrationBody,
    signal,
  });
};

export const getAdminMarketplacesCreateIntegrationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
    TError,
    { data: AdminMarketplacesCreateIntegrationBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
  TError,
  { data: AdminMarketplacesCreateIntegrationBody },
  TContext
> => {
  const mutationKey = ["adminMarketplacesCreateIntegration"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
    { data: AdminMarketplacesCreateIntegrationBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminMarketplacesCreateIntegration(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminMarketplacesCreateIntegrationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>
>;
export type AdminMarketplacesCreateIntegrationMutationBody =
  AdminMarketplacesCreateIntegrationBody;
export type AdminMarketplacesCreateIntegrationMutationError = unknown;

/**
 * @summary Create a new marketplace integration
 */
export const useAdminMarketplacesCreateIntegration = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
    TError,
    { data: AdminMarketplacesCreateIntegrationBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
  TError,
  { data: AdminMarketplacesCreateIntegrationBody },
  TContext
> => {
  const mutationOptions =
    getAdminMarketplacesCreateIntegrationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Trigger sync for an integration (Mock)
 */
export const adminMarketplacesSyncIntegration = (
  id: string,
  adminMarketplacesSyncIntegrationBody?: AdminMarketplacesSyncIntegrationBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/marketplaces/integrations/${id}/sync`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminMarketplacesSyncIntegrationBody,
    signal,
  });
};

export const getAdminMarketplacesSyncIntegrationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
    TError,
    { id: string; data: AdminMarketplacesSyncIntegrationBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
  TError,
  { id: string; data: AdminMarketplacesSyncIntegrationBody },
  TContext
> => {
  const mutationKey = ["adminMarketplacesSyncIntegration"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
    { id: string; data: AdminMarketplacesSyncIntegrationBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminMarketplacesSyncIntegration(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminMarketplacesSyncIntegrationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>
>;
export type AdminMarketplacesSyncIntegrationMutationBody =
  AdminMarketplacesSyncIntegrationBody;
export type AdminMarketplacesSyncIntegrationMutationError = unknown;

/**
 * @summary Trigger sync for an integration (Mock)
 */
export const useAdminMarketplacesSyncIntegration = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
    TError,
    { id: string; data: AdminMarketplacesSyncIntegrationBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
  TError,
  { id: string; data: AdminMarketplacesSyncIntegrationBody },
  TContext
> => {
  const mutationOptions =
    getAdminMarketplacesSyncIntegrationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Frontend iÃ§in - sidebar, buton gizleme vb.
 * @summary Mevcut admin kullanÄ±cÄ±sÄ±nÄ±n izinlerini dÃ¶ndÃ¼rÃ¼r.
 */
export const adminRolesGetMyAdminPermissions = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/my-permissions`,
    method: "GET",
    signal,
  });
};

export const getAdminRolesGetMyAdminPermissionsQueryKey = () => {
  return [`/api/admin/my-permissions`] as const;
};

export const getAdminRolesGetMyAdminPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminRolesGetMyAdminPermissionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>
  > = ({ signal }) => adminRolesGetMyAdminPermissions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminRolesGetMyAdminPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>
>;
export type AdminRolesGetMyAdminPermissionsQueryError = unknown;

/**
 * @summary Mevcut admin kullanÄ±cÄ±sÄ±nÄ±n izinlerini dÃ¶ndÃ¼rÃ¼r.
 */

export function useAdminRolesGetMyAdminPermissions<
  TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminRolesGetMyAdminPermissionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get list of notifications
 */
export const adminNotificationsGetNotifications = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/notifications`,
    method: "GET",
    signal,
  });
};

export const getAdminNotificationsGetNotificationsQueryKey = () => {
  return [`/api/admin/notifications`] as const;
};

export const getAdminNotificationsGetNotificationsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminNotificationsGetNotificationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminNotificationsGetNotifications>>
  > = ({ signal }) => adminNotificationsGetNotifications(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminNotificationsGetNotificationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminNotificationsGetNotifications>>
>;
export type AdminNotificationsGetNotificationsQueryError = unknown;

/**
 * @summary Get list of notifications
 */

export function useAdminNotificationsGetNotifications<
  TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getAdminNotificationsGetNotificationsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initialize notification tables
 */
export const adminNotificationsInitDb = (
  adminNotificationsInitDbBody?: AdminNotificationsInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/notifications/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminNotificationsInitDbBody,
    signal,
  });
};

export const getAdminNotificationsInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsInitDb>>,
    TError,
    { data: AdminNotificationsInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminNotificationsInitDb>>,
  TError,
  { data: AdminNotificationsInitDbBody },
  TContext
> => {
  const mutationKey = ["adminNotificationsInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminNotificationsInitDb>>,
    { data: AdminNotificationsInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminNotificationsInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminNotificationsInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminNotificationsInitDb>>
>;
export type AdminNotificationsInitDbMutationBody = AdminNotificationsInitDbBody;
export type AdminNotificationsInitDbMutationError = unknown;

/**
 * @summary Initialize notification tables
 */
export const useAdminNotificationsInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsInitDb>>,
    TError,
    { data: AdminNotificationsInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminNotificationsInitDb>>,
  TError,
  { data: AdminNotificationsInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminNotificationsInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Send a notification to tenants
 */
export const adminNotificationsSendNotification = (
  adminNotificationsSendNotificationBody?: AdminNotificationsSendNotificationBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/notifications/send`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminNotificationsSendNotificationBody,
    signal,
  });
};

export const getAdminNotificationsSendNotificationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
    TError,
    { data: AdminNotificationsSendNotificationBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
  TError,
  { data: AdminNotificationsSendNotificationBody },
  TContext
> => {
  const mutationKey = ["adminNotificationsSendNotification"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
    { data: AdminNotificationsSendNotificationBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminNotificationsSendNotification(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminNotificationsSendNotificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminNotificationsSendNotification>>
>;
export type AdminNotificationsSendNotificationMutationBody =
  AdminNotificationsSendNotificationBody;
export type AdminNotificationsSendNotificationMutationError = unknown;

/**
 * @summary Send a notification to tenants
 */
export const useAdminNotificationsSendNotification = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
    TError,
    { data: AdminNotificationsSendNotificationBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
  TError,
  { data: AdminNotificationsSendNotificationBody },
  TContext
> => {
  const mutationOptions =
    getAdminNotificationsSendNotificationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new notification template
 */
export const adminNotificationsCreateTemplate = (
  adminNotificationsCreateTemplateBody?: AdminNotificationsCreateTemplateBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/notifications/templates`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminNotificationsCreateTemplateBody,
    signal,
  });
};

export const getAdminNotificationsCreateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
    TError,
    { data: AdminNotificationsCreateTemplateBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
  TError,
  { data: AdminNotificationsCreateTemplateBody },
  TContext
> => {
  const mutationKey = ["adminNotificationsCreateTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
    { data: AdminNotificationsCreateTemplateBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminNotificationsCreateTemplate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminNotificationsCreateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>
>;
export type AdminNotificationsCreateTemplateMutationBody =
  AdminNotificationsCreateTemplateBody;
export type AdminNotificationsCreateTemplateMutationError = unknown;

/**
 * @summary Create a new notification template
 */
export const useAdminNotificationsCreateTemplate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
    TError,
    { data: AdminNotificationsCreateTemplateBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
  TError,
  { data: AdminNotificationsCreateTemplateBody },
  TContext
> => {
  const mutationOptions =
    getAdminNotificationsCreateTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete a notification template
 */
export const adminNotificationsDeleteTemplate = (templateId: string) => {
  return customInstance<void>({
    url: `/api/admin/notifications/templates/${templateId}`,
    method: "DELETE",
  });
};

export const getAdminNotificationsDeleteTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ["adminNotificationsDeleteTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return adminNotificationsDeleteTemplate(templateId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminNotificationsDeleteTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>
>;

export type AdminNotificationsDeleteTemplateMutationError = unknown;

/**
 * @summary Delete a notification template
 */
export const useAdminNotificationsDeleteTemplate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions =
    getAdminNotificationsDeleteTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get list of ALL patients from ALL tenants
 */
export const adminPatientsGetAllPatients = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/patients`,
    method: "GET",
    signal,
  });
};

export const getAdminPatientsGetAllPatientsQueryKey = () => {
  return [`/api/admin/patients`] as const;
};

export const getAdminPatientsGetAllPatientsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminPatientsGetAllPatientsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminPatientsGetAllPatients>>
  > = ({ signal }) => adminPatientsGetAllPatients(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminPatientsGetAllPatientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminPatientsGetAllPatients>>
>;
export type AdminPatientsGetAllPatientsQueryError = unknown;

/**
 * @summary Get list of ALL patients from ALL tenants
 */

export function useAdminPatientsGetAllPatients<
  TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminPatientsGetAllPatientsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Query params:
category: str - Kategoriye gÃ¶re filtrele
 * @summary TÃ¼m izinleri listele
 */
export const adminRolesGetAdminPermissions = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/permissions`,
    method: "GET",
    signal,
  });
};

export const getAdminRolesGetAdminPermissionsQueryKey = () => {
  return [`/api/admin/permissions`] as const;
};

export const getAdminRolesGetAdminPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminRolesGetAdminPermissionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>
  > = ({ signal }) => adminRolesGetAdminPermissions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminRolesGetAdminPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>
>;
export type AdminRolesGetAdminPermissionsQueryError = unknown;

/**
 * @summary TÃ¼m izinleri listele
 */

export function useAdminRolesGetAdminPermissions<
  TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminRolesGetAdminPermissionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Belirli bir endpoint iÃ§in gerekli permission'Ä± dÃ¶ndÃ¼rÃ¼r.
 */
export const permissionAdminCheckEndpointPermission = (
  endpointPath: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/permissions/check/${endpointPath}`,
    method: "GET",
    signal,
  });
};

export const getPermissionAdminCheckEndpointPermissionQueryKey = (
  endpointPath?: string,
) => {
  return [`/api/admin/permissions/check/${endpointPath}`] as const;
};

export const getPermissionAdminCheckEndpointPermissionQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
  TError = unknown,
>(
  endpointPath: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPermissionAdminCheckEndpointPermissionQueryKey(endpointPath);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>
  > = ({ signal }) =>
    permissionAdminCheckEndpointPermission(endpointPath, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!endpointPath,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionAdminCheckEndpointPermissionQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>
>;
export type PermissionAdminCheckEndpointPermissionQueryError = unknown;

/**
 * @summary Belirli bir endpoint iÃ§in gerekli permission'Ä± dÃ¶ndÃ¼rÃ¼r.
 */

export function usePermissionAdminCheckEndpointPermission<
  TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
  TError = unknown,
>(
  endpointPath: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionAdminCheckEndpointPermissionQueryOptions(
    endpointPath,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Permission coverage raporunu dÃ¶ndÃ¼rÃ¼r.
 */
export const permissionAdminGetPermissionCoverage = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/permissions/coverage`,
    method: "GET",
    signal,
  });
};

export const getPermissionAdminGetPermissionCoverageQueryKey = () => {
  return [`/api/admin/permissions/coverage`] as const;
};

export const getPermissionAdminGetPermissionCoverageQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPermissionAdminGetPermissionCoverageQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>
  > = ({ signal }) => permissionAdminGetPermissionCoverage(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionAdminGetPermissionCoverageQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>
>;
export type PermissionAdminGetPermissionCoverageQueryError = unknown;

/**
 * @summary Permission coverage raporunu dÃ¶ndÃ¼rÃ¼r.
 */

export function usePermissionAdminGetPermissionCoverage<
  TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getPermissionAdminGetPermissionCoverageQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TÃ¼m endpoint-permission mapping'ini dÃ¶ndÃ¼rÃ¼r.
 */
export const permissionAdminGetPermissionMap = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/permissions/map`,
    method: "GET",
    signal,
  });
};

export const getPermissionAdminGetPermissionMapQueryKey = () => {
  return [`/api/admin/permissions/map`] as const;
};

export const getPermissionAdminGetPermissionMapQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPermissionAdminGetPermissionMapQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>
  > = ({ signal }) => permissionAdminGetPermissionMap(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionAdminGetPermissionMapQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>
>;
export type PermissionAdminGetPermissionMapQueryError = unknown;

/**
 * @summary TÃ¼m endpoint-permission mapping'ini dÃ¶ndÃ¼rÃ¼r.
 */

export function usePermissionAdminGetPermissionMap<
  TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionAdminGetPermissionMapQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new plan
 */
export const adminPlansCreatePlan = (
  adminPlansCreatePlanBody?: AdminPlansCreatePlanBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/plans`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminPlansCreatePlanBody,
    signal,
  });
};

export const getAdminPlansCreatePlanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPlansCreatePlan>>,
    TError,
    { data: AdminPlansCreatePlanBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminPlansCreatePlan>>,
  TError,
  { data: AdminPlansCreatePlanBody },
  TContext
> => {
  const mutationKey = ["adminPlansCreatePlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminPlansCreatePlan>>,
    { data: AdminPlansCreatePlanBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminPlansCreatePlan(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminPlansCreatePlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminPlansCreatePlan>>
>;
export type AdminPlansCreatePlanMutationBody = AdminPlansCreatePlanBody;
export type AdminPlansCreatePlanMutationError = unknown;

/**
 * @summary Create a new plan
 */
export const useAdminPlansCreatePlan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPlansCreatePlan>>,
    TError,
    { data: AdminPlansCreatePlanBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminPlansCreatePlan>>,
  TError,
  { data: AdminPlansCreatePlanBody },
  TContext
> => {
  const mutationOptions = getAdminPlansCreatePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete plan (soft delete by setting is_active=False)
 */
export const adminPlansDeletePlan = (planId: string) => {
  return customInstance<void>({
    url: `/api/admin/plans/${planId}`,
    method: "DELETE",
  });
};

export const getAdminPlansDeletePlanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPlansDeletePlan>>,
    TError,
    { planId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminPlansDeletePlan>>,
  TError,
  { planId: string },
  TContext
> => {
  const mutationKey = ["adminPlansDeletePlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminPlansDeletePlan>>,
    { planId: string }
  > = (props) => {
    const { planId } = props ?? {};

    return adminPlansDeletePlan(planId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminPlansDeletePlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminPlansDeletePlan>>
>;

export type AdminPlansDeletePlanMutationError = unknown;

/**
 * @summary Delete plan (soft delete by setting is_active=False)
 */
export const useAdminPlansDeletePlan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminPlansDeletePlan>>,
    TError,
    { planId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminPlansDeletePlan>>,
  TError,
  { planId: string },
  TContext
> => {
  const mutationOptions = getAdminPlansDeletePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Initialize Production Orders table
 */
export const adminProductionInitDb = (
  adminProductionInitDbBody?: AdminProductionInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/production/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminProductionInitDbBody,
    signal,
  });
};

export const getAdminProductionInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminProductionInitDb>>,
    TError,
    { data: AdminProductionInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminProductionInitDb>>,
  TError,
  { data: AdminProductionInitDbBody },
  TContext
> => {
  const mutationKey = ["adminProductionInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminProductionInitDb>>,
    { data: AdminProductionInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminProductionInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminProductionInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminProductionInitDb>>
>;
export type AdminProductionInitDbMutationBody = AdminProductionInitDbBody;
export type AdminProductionInitDbMutationError = unknown;

/**
 * @summary Initialize Production Orders table
 */
export const useAdminProductionInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminProductionInitDb>>,
    TError,
    { data: AdminProductionInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminProductionInitDb>>,
  TError,
  { data: AdminProductionInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminProductionInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get production orders
 */
export const adminProductionGetOrders = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/production/orders`,
    method: "GET",
    signal,
  });
};

export const getAdminProductionGetOrdersQueryKey = () => {
  return [`/api/admin/production/orders`] as const;
};

export const getAdminProductionGetOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminProductionGetOrders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminProductionGetOrders>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminProductionGetOrdersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminProductionGetOrders>>
  > = ({ signal }) => adminProductionGetOrders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminProductionGetOrders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminProductionGetOrdersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminProductionGetOrders>>
>;
export type AdminProductionGetOrdersQueryError = unknown;

/**
 * @summary Get production orders
 */

export function useAdminProductionGetOrders<
  TData = Awaited<ReturnType<typeof adminProductionGetOrders>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminProductionGetOrders>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminProductionGetOrdersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update order status
 */
export const adminProductionUpdateOrderStatus = (
  id: string,
  adminProductionUpdateOrderStatusBody?: AdminProductionUpdateOrderStatusBody,
) => {
  return customInstance<void>({
    url: `/api/admin/production/orders/${id}/status`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminProductionUpdateOrderStatusBody,
  });
};

export const getAdminProductionUpdateOrderStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
    TError,
    { id: string; data: AdminProductionUpdateOrderStatusBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
  TError,
  { id: string; data: AdminProductionUpdateOrderStatusBody },
  TContext
> => {
  const mutationKey = ["adminProductionUpdateOrderStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
    { id: string; data: AdminProductionUpdateOrderStatusBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminProductionUpdateOrderStatus(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminProductionUpdateOrderStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>
>;
export type AdminProductionUpdateOrderStatusMutationBody =
  AdminProductionUpdateOrderStatusBody;
export type AdminProductionUpdateOrderStatusMutationError = unknown;

/**
 * @summary Update order status
 */
export const useAdminProductionUpdateOrderStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
    TError,
    { id: string; data: AdminProductionUpdateOrderStatusBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
  TError,
  { id: string; data: AdminProductionUpdateOrderStatusBody },
  TContext
> => {
  const mutationOptions =
    getAdminProductionUpdateOrderStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Body:
name: str - Rol adÄ± (unique)
description: str - AÃ§Ä±klama
permissions: list[str] - Ä°zin kodlarÄ±
 * @summary Yeni rol oluÅŸtur
 */
export const adminRolesCreateAdminRole = (
  adminRolesCreateAdminRoleBody?: AdminRolesCreateAdminRoleBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/roles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminRolesCreateAdminRoleBody,
    signal,
  });
};

export const getAdminRolesCreateAdminRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
    TError,
    { data: AdminRolesCreateAdminRoleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
  TError,
  { data: AdminRolesCreateAdminRoleBody },
  TContext
> => {
  const mutationKey = ["adminRolesCreateAdminRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
    { data: AdminRolesCreateAdminRoleBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminRolesCreateAdminRole(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminRolesCreateAdminRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesCreateAdminRole>>
>;
export type AdminRolesCreateAdminRoleMutationBody =
  AdminRolesCreateAdminRoleBody;
export type AdminRolesCreateAdminRoleMutationError = unknown;

/**
 * @summary Yeni rol oluÅŸtur
 */
export const useAdminRolesCreateAdminRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
    TError,
    { data: AdminRolesCreateAdminRoleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
  TError,
  { data: AdminRolesCreateAdminRoleBody },
  TContext
> => {
  const mutationOptions = getAdminRolesCreateAdminRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Not: System role'ler silinemez
 * @summary Rol sil
 */
export const adminRolesDeleteAdminRole = (roleId: string) => {
  return customInstance<void>({
    url: `/api/admin/roles/${roleId}`,
    method: "DELETE",
  });
};

export const getAdminRolesDeleteAdminRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
    TError,
    { roleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationKey = ["adminRolesDeleteAdminRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
    { roleId: string }
  > = (props) => {
    const { roleId } = props ?? {};

    return adminRolesDeleteAdminRole(roleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminRolesDeleteAdminRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>
>;

export type AdminRolesDeleteAdminRoleMutationError = unknown;

/**
 * @summary Rol sil
 */
export const useAdminRolesDeleteAdminRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
    TError,
    { roleId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationOptions = getAdminRolesDeleteAdminRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Body:
permissions: list[str] - Ä°zin kodlarÄ±
Not: SuperAdmin rolÃ¼nÃ¼n izinleri deÄŸiÅŸtirilemez
 * @summary Rol izinlerini gÃ¼ncelle
 */
export const adminRolesUpdateAdminRolePermissions = (
  roleId: string,
  adminRolesUpdateAdminRolePermissionsBody?: AdminRolesUpdateAdminRolePermissionsBody,
) => {
  return customInstance<void>({
    url: `/api/admin/roles/${roleId}/permissions`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminRolesUpdateAdminRolePermissionsBody,
  });
};

export const getAdminRolesUpdateAdminRolePermissionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
    TError,
    { roleId: string; data: AdminRolesUpdateAdminRolePermissionsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
  TError,
  { roleId: string; data: AdminRolesUpdateAdminRolePermissionsBody },
  TContext
> => {
  const mutationKey = ["adminRolesUpdateAdminRolePermissions"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
    { roleId: string; data: AdminRolesUpdateAdminRolePermissionsBody }
  > = (props) => {
    const { roleId, data } = props ?? {};

    return adminRolesUpdateAdminRolePermissions(roleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminRolesUpdateAdminRolePermissionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>
>;
export type AdminRolesUpdateAdminRolePermissionsMutationBody =
  AdminRolesUpdateAdminRolePermissionsBody;
export type AdminRolesUpdateAdminRolePermissionsMutationError = unknown;

/**
 * @summary Rol izinlerini gÃ¼ncelle
 */
export const useAdminRolesUpdateAdminRolePermissions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
    TError,
    { roleId: string; data: AdminRolesUpdateAdminRolePermissionsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
  TError,
  { roleId: string; data: AdminRolesUpdateAdminRolePermissionsBody },
  TContext
> => {
  const mutationOptions =
    getAdminRolesUpdateAdminRolePermissionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get scan queue items
 */
export const adminScanQueueGetScanQueue = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/scan-queue`,
    method: "GET",
    signal,
  });
};

export const getAdminScanQueueGetScanQueueQueryKey = () => {
  return [`/api/admin/scan-queue`] as const;
};

export const getAdminScanQueueGetScanQueueQueryOptions = <
  TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminScanQueueGetScanQueueQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>
  > = ({ signal }) => adminScanQueueGetScanQueue(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminScanQueueGetScanQueueQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>
>;
export type AdminScanQueueGetScanQueueQueryError = unknown;

/**
 * @summary Get scan queue items
 */

export function useAdminScanQueueGetScanQueue<
  TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminScanQueueGetScanQueueQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initialize Scan Queue table
 */
export const adminScanQueueInitDb = (
  adminScanQueueInitDbBody?: AdminScanQueueInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/scan-queue/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminScanQueueInitDbBody,
    signal,
  });
};

export const getAdminScanQueueInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminScanQueueInitDb>>,
    TError,
    { data: AdminScanQueueInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminScanQueueInitDb>>,
  TError,
  { data: AdminScanQueueInitDbBody },
  TContext
> => {
  const mutationKey = ["adminScanQueueInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminScanQueueInitDb>>,
    { data: AdminScanQueueInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminScanQueueInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminScanQueueInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminScanQueueInitDb>>
>;
export type AdminScanQueueInitDbMutationBody = AdminScanQueueInitDbBody;
export type AdminScanQueueInitDbMutationError = unknown;

/**
 * @summary Initialize Scan Queue table
 */
export const useAdminScanQueueInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminScanQueueInitDb>>,
    TError,
    { data: AdminScanQueueInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminScanQueueInitDb>>,
  TError,
  { data: AdminScanQueueInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminScanQueueInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Retry a failed scan
 */
export const adminScanQueueRetryScan = (
  id: string,
  adminScanQueueRetryScanBody?: AdminScanQueueRetryScanBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/scan-queue/${id}/retry`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminScanQueueRetryScanBody,
    signal,
  });
};

export const getAdminScanQueueRetryScanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
    TError,
    { id: string; data: AdminScanQueueRetryScanBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
  TError,
  { id: string; data: AdminScanQueueRetryScanBody },
  TContext
> => {
  const mutationKey = ["adminScanQueueRetryScan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
    { id: string; data: AdminScanQueueRetryScanBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminScanQueueRetryScan(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminScanQueueRetryScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminScanQueueRetryScan>>
>;
export type AdminScanQueueRetryScanMutationBody = AdminScanQueueRetryScanBody;
export type AdminScanQueueRetryScanMutationError = unknown;

/**
 * @summary Retry a failed scan
 */
export const useAdminScanQueueRetryScan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
    TError,
    { id: string; data: AdminScanQueueRetryScanBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
  TError,
  { id: string; data: AdminScanQueueRetryScanBody },
  TContext
> => {
  const mutationOptions = getAdminScanQueueRetryScanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update system settings
 */
export const adminSettingsUpdateSettings = (
  adminSettingsUpdateSettingsBody?: AdminSettingsUpdateSettingsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/settings`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminSettingsUpdateSettingsBody,
    signal,
  });
};

export const getAdminSettingsUpdateSettingsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
    TError,
    { data: AdminSettingsUpdateSettingsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
  TError,
  { data: AdminSettingsUpdateSettingsBody },
  TContext
> => {
  const mutationKey = ["adminSettingsUpdateSettings"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
    { data: AdminSettingsUpdateSettingsBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminSettingsUpdateSettings(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSettingsUpdateSettingsMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSettingsUpdateSettings>>
>;
export type AdminSettingsUpdateSettingsMutationBody =
  AdminSettingsUpdateSettingsBody;
export type AdminSettingsUpdateSettingsMutationError = unknown;

/**
 * @summary Update system settings
 */
export const useAdminSettingsUpdateSettings = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
    TError,
    { data: AdminSettingsUpdateSettingsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
  TError,
  { data: AdminSettingsUpdateSettingsBody },
  TContext
> => {
  const mutationOptions =
    getAdminSettingsUpdateSettingsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Trigger database backup (Mock)
 */
export const adminSettingsTriggerBackup = (
  adminSettingsTriggerBackupBody?: AdminSettingsTriggerBackupBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/settings/backup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminSettingsTriggerBackupBody,
    signal,
  });
};

export const getAdminSettingsTriggerBackupMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
    TError,
    { data: AdminSettingsTriggerBackupBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
  TError,
  { data: AdminSettingsTriggerBackupBody },
  TContext
> => {
  const mutationKey = ["adminSettingsTriggerBackup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
    { data: AdminSettingsTriggerBackupBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminSettingsTriggerBackup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSettingsTriggerBackupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSettingsTriggerBackup>>
>;
export type AdminSettingsTriggerBackupMutationBody =
  AdminSettingsTriggerBackupBody;
export type AdminSettingsTriggerBackupMutationError = unknown;

/**
 * @summary Trigger database backup (Mock)
 */
export const useAdminSettingsTriggerBackup = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
    TError,
    { data: AdminSettingsTriggerBackupBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
  TError,
  { data: AdminSettingsTriggerBackupBody },
  TContext
> => {
  const mutationOptions = getAdminSettingsTriggerBackupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Clear system cache (Mock)
 */
export const adminSettingsClearCache = (
  adminSettingsClearCacheBody?: AdminSettingsClearCacheBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/settings/cache/clear`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminSettingsClearCacheBody,
    signal,
  });
};

export const getAdminSettingsClearCacheMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsClearCache>>,
    TError,
    { data: AdminSettingsClearCacheBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSettingsClearCache>>,
  TError,
  { data: AdminSettingsClearCacheBody },
  TContext
> => {
  const mutationKey = ["adminSettingsClearCache"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSettingsClearCache>>,
    { data: AdminSettingsClearCacheBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminSettingsClearCache(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSettingsClearCacheMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSettingsClearCache>>
>;
export type AdminSettingsClearCacheMutationBody = AdminSettingsClearCacheBody;
export type AdminSettingsClearCacheMutationError = unknown;

/**
 * @summary Clear system cache (Mock)
 */
export const useAdminSettingsClearCache = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsClearCache>>,
    TError,
    { data: AdminSettingsClearCacheBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSettingsClearCache>>,
  TError,
  { data: AdminSettingsClearCacheBody },
  TContext
> => {
  const mutationOptions = getAdminSettingsClearCacheMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Initialize System Settings table
 */
export const adminSettingsInitDb = (
  adminSettingsInitDbBody?: AdminSettingsInitDbBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/settings/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminSettingsInitDbBody,
    signal,
  });
};

export const getAdminSettingsInitDbMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsInitDb>>,
    TError,
    { data: AdminSettingsInitDbBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSettingsInitDb>>,
  TError,
  { data: AdminSettingsInitDbBody },
  TContext
> => {
  const mutationKey = ["adminSettingsInitDb"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSettingsInitDb>>,
    { data: AdminSettingsInitDbBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminSettingsInitDb(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSettingsInitDbMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSettingsInitDb>>
>;
export type AdminSettingsInitDbMutationBody = AdminSettingsInitDbBody;
export type AdminSettingsInitDbMutationError = unknown;

/**
 * @summary Initialize System Settings table
 */
export const useAdminSettingsInitDb = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSettingsInitDb>>,
    TError,
    { data: AdminSettingsInitDbBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSettingsInitDb>>,
  TError,
  { data: AdminSettingsInitDbBody },
  TContext
> => {
  const mutationOptions = getAdminSettingsInitDbMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Admin List SMS Headers
 */
export const adminSmsGetHeaders = (
  params?: AdminSmsGetHeadersParams,
  signal?: AbortSignal,
) => {
  return customInstance<AdminSmsGetHeaders200>({
    url: `/api/admin/sms/headers`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminSmsGetHeadersQueryKey = (
  params?: AdminSmsGetHeadersParams,
) => {
  return [`/api/admin/sms/headers`, ...(params ? [params] : [])] as const;
};

export const getAdminSmsGetHeadersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>,
  TError = unknown,
>(
  params?: AdminSmsGetHeadersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminSmsGetHeaders>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminSmsGetHeadersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminSmsGetHeaders>>
  > = ({ signal }) => adminSmsGetHeaders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminSmsGetHeaders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminSmsGetHeadersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminSmsGetHeaders>>
>;
export type AdminSmsGetHeadersQueryError = unknown;

/**
 * @summary Admin List SMS Headers
 */

export function useAdminSmsGetHeaders<
  TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>,
  TError = unknown,
>(
  params?: AdminSmsGetHeadersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof adminSmsGetHeaders>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminSmsGetHeadersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Admin Update SMS Header Status
 */
export const adminSmsUpdateHeaderStatus = (
  headerId: string,
  adminSmsUpdateHeaderStatusBody: AdminSmsUpdateHeaderStatusBody,
) => {
  return customInstance<SMSHeaderRequest>({
    url: `/api/admin/sms/headers/${headerId}/status`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminSmsUpdateHeaderStatusBody,
  });
};

export const getAdminSmsUpdateHeaderStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
    TError,
    { headerId: string; data: AdminSmsUpdateHeaderStatusBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
  TError,
  { headerId: string; data: AdminSmsUpdateHeaderStatusBody },
  TContext
> => {
  const mutationKey = ["adminSmsUpdateHeaderStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
    { headerId: string; data: AdminSmsUpdateHeaderStatusBody }
  > = (props) => {
    const { headerId, data } = props ?? {};

    return adminSmsUpdateHeaderStatus(headerId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSmsUpdateHeaderStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>
>;
export type AdminSmsUpdateHeaderStatusMutationBody =
  AdminSmsUpdateHeaderStatusBody;
export type AdminSmsUpdateHeaderStatusMutationError = unknown;

/**
 * @summary Admin Update SMS Header Status
 */
export const useAdminSmsUpdateHeaderStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
    TError,
    { headerId: string; data: AdminSmsUpdateHeaderStatusBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
  TError,
  { headerId: string; data: AdminSmsUpdateHeaderStatusBody },
  TContext
> => {
  const mutationOptions = getAdminSmsUpdateHeaderStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Admin List SMS Packages
 */
export const adminSmsGetPackages = (signal?: AbortSignal) => {
  return customInstance<AdminSmsGetPackages200>({
    url: `/api/admin/sms/packages`,
    method: "GET",
    signal,
  });
};

export const getAdminSmsGetPackagesQueryKey = () => {
  return [`/api/admin/sms/packages`] as const;
};

export const getAdminSmsGetPackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminSmsGetPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminSmsGetPackages>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminSmsGetPackagesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminSmsGetPackages>>
  > = ({ signal }) => adminSmsGetPackages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminSmsGetPackages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminSmsGetPackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminSmsGetPackages>>
>;
export type AdminSmsGetPackagesQueryError = unknown;

/**
 * @summary Admin List SMS Packages
 */

export function useAdminSmsGetPackages<
  TData = Awaited<ReturnType<typeof adminSmsGetPackages>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminSmsGetPackages>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminSmsGetPackagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Admin Create SMS Package
 */
export const adminSmsCreatePackage = (
  adminSmsCreatePackageBody: AdminSmsCreatePackageBody,
  signal?: AbortSignal,
) => {
  return customInstance<SMSPackage>({
    url: `/api/admin/sms/packages`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminSmsCreatePackageBody,
    signal,
  });
};

export const getAdminSmsCreatePackageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsCreatePackage>>,
    TError,
    { data: AdminSmsCreatePackageBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSmsCreatePackage>>,
  TError,
  { data: AdminSmsCreatePackageBody },
  TContext
> => {
  const mutationKey = ["adminSmsCreatePackage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSmsCreatePackage>>,
    { data: AdminSmsCreatePackageBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminSmsCreatePackage(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSmsCreatePackageMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSmsCreatePackage>>
>;
export type AdminSmsCreatePackageMutationBody = AdminSmsCreatePackageBody;
export type AdminSmsCreatePackageMutationError = unknown;

/**
 * @summary Admin Create SMS Package
 */
export const useAdminSmsCreatePackage = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsCreatePackage>>,
    TError,
    { data: AdminSmsCreatePackageBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSmsCreatePackage>>,
  TError,
  { data: AdminSmsCreatePackageBody },
  TContext
> => {
  const mutationOptions = getAdminSmsCreatePackageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Admin Update SMS Package
 */
export const adminSmsUpdatePackage = (
  pkgId: string,
  adminSmsUpdatePackageBody: AdminSmsUpdatePackageBody,
) => {
  return customInstance<SMSPackage>({
    url: `/api/admin/sms/packages/${pkgId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminSmsUpdatePackageBody,
  });
};

export const getAdminSmsUpdatePackageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
    TError,
    { pkgId: string; data: AdminSmsUpdatePackageBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
  TError,
  { pkgId: string; data: AdminSmsUpdatePackageBody },
  TContext
> => {
  const mutationKey = ["adminSmsUpdatePackage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
    { pkgId: string; data: AdminSmsUpdatePackageBody }
  > = (props) => {
    const { pkgId, data } = props ?? {};

    return adminSmsUpdatePackage(pkgId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSmsUpdatePackageMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSmsUpdatePackage>>
>;
export type AdminSmsUpdatePackageMutationBody = AdminSmsUpdatePackageBody;
export type AdminSmsUpdatePackageMutationError = unknown;

/**
 * @summary Admin Update SMS Package
 */
export const useAdminSmsUpdatePackage = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
    TError,
    { pkgId: string; data: AdminSmsUpdatePackageBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
  TError,
  { pkgId: string; data: AdminSmsUpdatePackageBody },
  TContext
> => {
  const mutationOptions = getAdminSmsUpdatePackageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create tenant
 */
export const adminTenantsCreateTenant = (
  adminTenantsCreateTenantBody?: AdminTenantsCreateTenantBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsCreateTenantBody,
    signal,
  });
};

export const getAdminTenantsCreateTenantMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
    TError,
    { data: AdminTenantsCreateTenantBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
  TError,
  { data: AdminTenantsCreateTenantBody },
  TContext
> => {
  const mutationKey = ["adminTenantsCreateTenant"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
    { data: AdminTenantsCreateTenantBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminTenantsCreateTenant(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsCreateTenantMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsCreateTenant>>
>;
export type AdminTenantsCreateTenantMutationBody = AdminTenantsCreateTenantBody;
export type AdminTenantsCreateTenantMutationError = unknown;

/**
 * @summary Create tenant
 */
export const useAdminTenantsCreateTenant = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
    TError,
    { data: AdminTenantsCreateTenantBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
  TError,
  { data: AdminTenantsCreateTenantBody },
  TContext
> => {
  const mutationOptions = getAdminTenantsCreateTenantMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete tenant (soft delete)
 */
export const adminTenantsDeleteTenant = (tenantId: string) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}`,
    method: "DELETE",
  });
};

export const getAdminTenantsDeleteTenantMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
    TError,
    { tenantId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationKey = ["adminTenantsDeleteTenant"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
    { tenantId: string }
  > = (props) => {
    const { tenantId } = props ?? {};

    return adminTenantsDeleteTenant(tenantId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsDeleteTenantMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsDeleteTenant>>
>;

export type AdminTenantsDeleteTenantMutationError = unknown;

/**
 * @summary Delete tenant (soft delete)
 */
export const useAdminTenantsDeleteTenant = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
    TError,
    { tenantId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationOptions = getAdminTenantsDeleteTenantMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Add addon to tenant (Admin override)
 */
export const adminTenantsAddTenantAddon = (
  tenantId: string,
  adminTenantsAddTenantAddonBody?: AdminTenantsAddTenantAddonBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}/addons`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsAddTenantAddonBody,
    signal,
  });
};

export const getAdminTenantsAddTenantAddonMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
    TError,
    { tenantId: string; data: AdminTenantsAddTenantAddonBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
  TError,
  { tenantId: string; data: AdminTenantsAddTenantAddonBody },
  TContext
> => {
  const mutationKey = ["adminTenantsAddTenantAddon"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
    { tenantId: string; data: AdminTenantsAddTenantAddonBody }
  > = (props) => {
    const { tenantId, data } = props ?? {};

    return adminTenantsAddTenantAddon(tenantId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsAddTenantAddonMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>
>;
export type AdminTenantsAddTenantAddonMutationBody =
  AdminTenantsAddTenantAddonBody;
export type AdminTenantsAddTenantAddonMutationError = unknown;

/**
 * @summary Add addon to tenant (Admin override)
 */
export const useAdminTenantsAddTenantAddon = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
    TError,
    { tenantId: string; data: AdminTenantsAddTenantAddonBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
  TError,
  { tenantId: string; data: AdminTenantsAddTenantAddonBody },
  TContext
> => {
  const mutationOptions = getAdminTenantsAddTenantAddonMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update tenant status
 */
export const adminTenantsUpdateTenantStatus = (
  tenantId: string,
  adminTenantsUpdateTenantStatusBody?: AdminTenantsUpdateTenantStatusBody,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}/status`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsUpdateTenantStatusBody,
  });
};

export const getAdminTenantsUpdateTenantStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
    TError,
    { tenantId: string; data: AdminTenantsUpdateTenantStatusBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
  TError,
  { tenantId: string; data: AdminTenantsUpdateTenantStatusBody },
  TContext
> => {
  const mutationKey = ["adminTenantsUpdateTenantStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
    { tenantId: string; data: AdminTenantsUpdateTenantStatusBody }
  > = (props) => {
    const { tenantId, data } = props ?? {};

    return adminTenantsUpdateTenantStatus(tenantId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsUpdateTenantStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>
>;
export type AdminTenantsUpdateTenantStatusMutationBody =
  AdminTenantsUpdateTenantStatusBody;
export type AdminTenantsUpdateTenantStatusMutationError = unknown;

/**
 * @summary Update tenant status
 */
export const useAdminTenantsUpdateTenantStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
    TError,
    { tenantId: string; data: AdminTenantsUpdateTenantStatusBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
  TError,
  { tenantId: string; data: AdminTenantsUpdateTenantStatusBody },
  TContext
> => {
  const mutationOptions =
    getAdminTenantsUpdateTenantStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Subscribe tenant to a plan (Admin override)
 */
export const adminTenantsSubscribeTenant = (
  tenantId: string,
  adminTenantsSubscribeTenantBody?: AdminTenantsSubscribeTenantBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}/subscribe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsSubscribeTenantBody,
    signal,
  });
};

export const getAdminTenantsSubscribeTenantMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
    TError,
    { tenantId: string; data: AdminTenantsSubscribeTenantBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
  TError,
  { tenantId: string; data: AdminTenantsSubscribeTenantBody },
  TContext
> => {
  const mutationKey = ["adminTenantsSubscribeTenant"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
    { tenantId: string; data: AdminTenantsSubscribeTenantBody }
  > = (props) => {
    const { tenantId, data } = props ?? {};

    return adminTenantsSubscribeTenant(tenantId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsSubscribeTenantMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>
>;
export type AdminTenantsSubscribeTenantMutationBody =
  AdminTenantsSubscribeTenantBody;
export type AdminTenantsSubscribeTenantMutationError = unknown;

/**
 * @summary Subscribe tenant to a plan (Admin override)
 */
export const useAdminTenantsSubscribeTenant = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
    TError,
    { tenantId: string; data: AdminTenantsSubscribeTenantBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
  TError,
  { tenantId: string; data: AdminTenantsSubscribeTenantBody },
  TContext
> => {
  const mutationOptions =
    getAdminTenantsSubscribeTenantMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a user for a specific tenant
 */
export const adminTenantsCreateTenantUser = (
  tenantId: string,
  adminTenantsCreateTenantUserBody?: AdminTenantsCreateTenantUserBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}/users`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsCreateTenantUserBody,
    signal,
  });
};

export const getAdminTenantsCreateTenantUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
    TError,
    { tenantId: string; data: AdminTenantsCreateTenantUserBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
  TError,
  { tenantId: string; data: AdminTenantsCreateTenantUserBody },
  TContext
> => {
  const mutationKey = ["adminTenantsCreateTenantUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
    { tenantId: string; data: AdminTenantsCreateTenantUserBody }
  > = (props) => {
    const { tenantId, data } = props ?? {};

    return adminTenantsCreateTenantUser(tenantId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsCreateTenantUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>
>;
export type AdminTenantsCreateTenantUserMutationBody =
  AdminTenantsCreateTenantUserBody;
export type AdminTenantsCreateTenantUserMutationError = unknown;

/**
 * @summary Create a user for a specific tenant
 */
export const useAdminTenantsCreateTenantUser = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
    TError,
    { tenantId: string; data: AdminTenantsCreateTenantUserBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
  TError,
  { tenantId: string; data: AdminTenantsCreateTenantUserBody },
  TContext
> => {
  const mutationOptions =
    getAdminTenantsCreateTenantUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update a tenant user
 */
export const adminTenantsUpdateTenantUser = (
  tenantId: string,
  userId: string,
  adminTenantsUpdateTenantUserBody?: AdminTenantsUpdateTenantUserBody,
) => {
  return customInstance<void>({
    url: `/api/admin/tenants/${tenantId}/users/${userId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminTenantsUpdateTenantUserBody,
  });
};

export const getAdminTenantsUpdateTenantUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
    TError,
    {
      tenantId: string;
      userId: string;
      data: AdminTenantsUpdateTenantUserBody;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
  TError,
  { tenantId: string; userId: string; data: AdminTenantsUpdateTenantUserBody },
  TContext
> => {
  const mutationKey = ["adminTenantsUpdateTenantUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
    { tenantId: string; userId: string; data: AdminTenantsUpdateTenantUserBody }
  > = (props) => {
    const { tenantId, userId, data } = props ?? {};

    return adminTenantsUpdateTenantUser(tenantId, userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTenantsUpdateTenantUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>
>;
export type AdminTenantsUpdateTenantUserMutationBody =
  AdminTenantsUpdateTenantUserBody;
export type AdminTenantsUpdateTenantUserMutationError = unknown;

/**
 * @summary Update a tenant user
 */
export const useAdminTenantsUpdateTenantUser = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
    TError,
    {
      tenantId: string;
      userId: string;
      data: AdminTenantsUpdateTenantUserBody;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
  TError,
  { tenantId: string; userId: string; data: AdminTenantsUpdateTenantUserBody },
  TContext
> => {
  const mutationOptions =
    getAdminTenantsUpdateTenantUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/admin/tickets
 */
export const adminTicketsCreateAdminTicket = (
  adminTicketsCreateAdminTicketBody?: AdminTicketsCreateAdminTicketBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tickets`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminTicketsCreateAdminTicketBody,
    signal,
  });
};

export const getAdminTicketsCreateAdminTicketMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
    TError,
    { data: AdminTicketsCreateAdminTicketBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
  TError,
  { data: AdminTicketsCreateAdminTicketBody },
  TContext
> => {
  const mutationKey = ["adminTicketsCreateAdminTicket"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
    { data: AdminTicketsCreateAdminTicketBody }
  > = (props) => {
    const { data } = props ?? {};

    return adminTicketsCreateAdminTicket(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTicketsCreateAdminTicketMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>
>;
export type AdminTicketsCreateAdminTicketMutationBody =
  AdminTicketsCreateAdminTicketBody;
export type AdminTicketsCreateAdminTicketMutationError = unknown;

/**
 * @summary POST /api/admin/tickets
 */
export const useAdminTicketsCreateAdminTicket = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
    TError,
    { data: AdminTicketsCreateAdminTicketBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
  TError,
  { data: AdminTicketsCreateAdminTicketBody },
  TContext
> => {
  const mutationOptions =
    getAdminTicketsCreateAdminTicketMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary PUT /api/admin/tickets/{id}
 */
export const adminTicketsUpdateAdminTicket = (
  id: string,
  adminTicketsUpdateAdminTicketBody?: AdminTicketsUpdateAdminTicketBody,
) => {
  return customInstance<void>({
    url: `/api/admin/tickets/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminTicketsUpdateAdminTicketBody,
  });
};

export const getAdminTicketsUpdateAdminTicketMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
    TError,
    { id: string; data: AdminTicketsUpdateAdminTicketBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
  TError,
  { id: string; data: AdminTicketsUpdateAdminTicketBody },
  TContext
> => {
  const mutationKey = ["adminTicketsUpdateAdminTicket"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
    { id: string; data: AdminTicketsUpdateAdminTicketBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminTicketsUpdateAdminTicket(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTicketsUpdateAdminTicketMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>
>;
export type AdminTicketsUpdateAdminTicketMutationBody =
  AdminTicketsUpdateAdminTicketBody;
export type AdminTicketsUpdateAdminTicketMutationError = unknown;

/**
 * @summary PUT /api/admin/tickets/{id}
 */
export const useAdminTicketsUpdateAdminTicket = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
    TError,
    { id: string; data: AdminTicketsUpdateAdminTicketBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
  TError,
  { id: string; data: AdminTicketsUpdateAdminTicketBody },
  TContext
> => {
  const mutationOptions =
    getAdminTicketsUpdateAdminTicketMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update support ticket (placeholder)
 */
export const adminUpdateAdminTicket = (
  ticketId: string,
  adminUpdateAdminTicketBody?: AdminUpdateAdminTicketBody,
) => {
  return customInstance<void>({
    url: `/api/admin/tickets/${ticketId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminUpdateAdminTicketBody,
  });
};

export const getAdminUpdateAdminTicketMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
    TError,
    { ticketId: string; data: AdminUpdateAdminTicketBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
  TError,
  { ticketId: string; data: AdminUpdateAdminTicketBody },
  TContext
> => {
  const mutationKey = ["adminUpdateAdminTicket"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
    { ticketId: string; data: AdminUpdateAdminTicketBody }
  > = (props) => {
    const { ticketId, data } = props ?? {};

    return adminUpdateAdminTicket(ticketId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUpdateAdminTicketMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUpdateAdminTicket>>
>;
export type AdminUpdateAdminTicketMutationBody = AdminUpdateAdminTicketBody;
export type AdminUpdateAdminTicketMutationError = unknown;

/**
 * @summary Update support ticket (placeholder)
 */
export const useAdminUpdateAdminTicket = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
    TError,
    { ticketId: string; data: AdminUpdateAdminTicketBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
  TError,
  { ticketId: string; data: AdminUpdateAdminTicketBody },
  TContext
> => {
  const mutationOptions = getAdminUpdateAdminTicketMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create response for support ticket (placeholder)
 */
export const adminCreateTicketResponse = (
  ticketId: string,
  adminCreateTicketResponseBody?: AdminCreateTicketResponseBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/admin/tickets/${ticketId}/responses`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminCreateTicketResponseBody,
    signal,
  });
};

export const getAdminCreateTicketResponseMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminCreateTicketResponse>>,
    TError,
    { ticketId: string; data: AdminCreateTicketResponseBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminCreateTicketResponse>>,
  TError,
  { ticketId: string; data: AdminCreateTicketResponseBody },
  TContext
> => {
  const mutationKey = ["adminCreateTicketResponse"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminCreateTicketResponse>>,
    { ticketId: string; data: AdminCreateTicketResponseBody }
  > = (props) => {
    const { ticketId, data } = props ?? {};

    return adminCreateTicketResponse(ticketId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminCreateTicketResponseMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminCreateTicketResponse>>
>;
export type AdminCreateTicketResponseMutationBody =
  AdminCreateTicketResponseBody;
export type AdminCreateTicketResponseMutationError = unknown;

/**
 * @summary Create response for support ticket (placeholder)
 */
export const useAdminCreateTicketResponse = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminCreateTicketResponse>>,
    TError,
    { ticketId: string; data: AdminCreateTicketResponseBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminCreateTicketResponse>>,
  TError,
  { ticketId: string; data: AdminCreateTicketResponseBody },
  TContext
> => {
  const mutationOptions = getAdminCreateTicketResponseMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get list of admin users
 */
export const adminGetAdminUsers = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/users`,
    method: "GET",
    signal,
  });
};

export const getAdminGetAdminUsersQueryKey = () => {
  return [`/api/admin/users`] as const;
};

export const getAdminGetAdminUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminGetAdminUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAdminUsers>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminGetAdminUsersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminGetAdminUsers>>
  > = ({ signal }) => adminGetAdminUsers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAdminUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminGetAdminUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminGetAdminUsers>>
>;
export type AdminGetAdminUsersQueryError = unknown;

/**
 * @summary Get list of admin users
 */

export function useAdminGetAdminUsers<
  TData = Awaited<ReturnType<typeof adminGetAdminUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAdminUsers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminGetAdminUsersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get list of ALL users from ALL tenants
 */
export const adminGetAllTenantUsers = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/admin/users/all`,
    method: "GET",
    signal,
  });
};

export const getAdminGetAllTenantUsersQueryKey = () => {
  return [`/api/admin/users/all`] as const;
};

export const getAdminGetAllTenantUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminGetAllTenantUsersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminGetAllTenantUsers>>
  > = ({ signal }) => adminGetAllTenantUsers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AdminGetAllTenantUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminGetAllTenantUsers>>
>;
export type AdminGetAllTenantUsersQueryError = unknown;

/**
 * @summary Get list of ALL users from ALL tenants
 */

export function useAdminGetAllTenantUsers<
  TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAdminGetAllTenantUsersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update any tenant user (Admin Panel)
 */
export const adminUpdateAnyTenantUser = (
  userId: string,
  adminUpdateAnyTenantUserBody?: AdminUpdateAnyTenantUserBody,
) => {
  return customInstance<void>({
    url: `/api/admin/users/all/${userId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminUpdateAnyTenantUserBody,
  });
};

export const getAdminUpdateAnyTenantUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
    TError,
    { userId: string; data: AdminUpdateAnyTenantUserBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
  TError,
  { userId: string; data: AdminUpdateAnyTenantUserBody },
  TContext
> => {
  const mutationKey = ["adminUpdateAnyTenantUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
    { userId: string; data: AdminUpdateAnyTenantUserBody }
  > = (props) => {
    const { userId, data } = props ?? {};

    return adminUpdateAnyTenantUser(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUpdateAnyTenantUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>
>;
export type AdminUpdateAnyTenantUserMutationBody = AdminUpdateAnyTenantUserBody;
export type AdminUpdateAnyTenantUserMutationError = unknown;

/**
 * @summary Update any tenant user (Admin Panel)
 */
export const useAdminUpdateAnyTenantUser = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
    TError,
    { userId: string; data: AdminUpdateAnyTenantUserBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
  TError,
  { userId: string; data: AdminUpdateAnyTenantUserBody },
  TContext
> => {
  const mutationOptions = getAdminUpdateAnyTenantUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/auth/forgot-password
 */
export const authForgotPassword = (
  authForgotPasswordBody?: AuthForgotPasswordBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/auth/forgot-password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authForgotPasswordBody,
    signal,
  });
};

export const getAuthForgotPasswordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: AuthForgotPasswordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: AuthForgotPasswordBody },
  TContext
> => {
  const mutationKey = ["authForgotPassword"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authForgotPassword>>,
    { data: AuthForgotPasswordBody }
  > = (props) => {
    const { data } = props ?? {};

    return authForgotPassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authForgotPassword>>
>;
export type AuthForgotPasswordMutationBody = AuthForgotPasswordBody;
export type AuthForgotPasswordMutationError = unknown;

/**
 * @summary POST /api/auth/forgot-password
 */
export const useAuthForgotPassword = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: AuthForgotPasswordBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: AuthForgotPasswordBody },
  TContext
> => {
  const mutationOptions = getAuthForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/auth/login
 */
export const authLogin = (
  authLoginBody?: AuthLoginBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authLoginBody,
    signal,
  });
};

export const getAuthLoginMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: AuthLoginBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: AuthLoginBody },
  TContext
> => {
  const mutationKey = ["authLogin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogin>>,
    { data: AuthLoginBody }
  > = (props) => {
    const { data } = props ?? {};

    return authLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogin>>
>;
export type AuthLoginMutationBody = AuthLoginBody;
export type AuthLoginMutationError = unknown;

/**
 * @summary POST /api/auth/login
 */
export const useAuthLogin = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: AuthLoginBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: AuthLoginBody },
  TContext
> => {
  const mutationOptions = getAuthLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Refresh access token using refresh token
 */
export const authRefresh = (
  authRefreshBody?: AuthRefreshBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/auth/refresh`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authRefreshBody,
    signal,
  });
};

export const getAuthRefreshMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefresh>>,
    TError,
    { data: AuthRefreshBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRefresh>>,
  TError,
  { data: AuthRefreshBody },
  TContext
> => {
  const mutationKey = ["authRefresh"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefresh>>,
    { data: AuthRefreshBody }
  > = (props) => {
    const { data } = props ?? {};

    return authRefresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefresh>>
>;
export type AuthRefreshMutationBody = AuthRefreshBody;
export type AuthRefreshMutationError = unknown;

/**
 * @summary Refresh access token using refresh token
 */
export const useAuthRefresh = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefresh>>,
    TError,
    { data: AuthRefreshBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authRefresh>>,
  TError,
  { data: AuthRefreshBody },
  TContext
> => {
  const mutationOptions = getAuthRefreshMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Send OTP to the user's phone number (requires pre-auth token)
 */
export const authSendVerificationOtp = (
  authSendVerificationOtpBody?: AuthSendVerificationOtpBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/auth/send-verification-otp`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authSendVerificationOtpBody,
    signal,
  });
};

export const getAuthSendVerificationOtpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authSendVerificationOtp>>,
    TError,
    { data: AuthSendVerificationOtpBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authSendVerificationOtp>>,
  TError,
  { data: AuthSendVerificationOtpBody },
  TContext
> => {
  const mutationKey = ["authSendVerificationOtp"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authSendVerificationOtp>>,
    { data: AuthSendVerificationOtpBody }
  > = (props) => {
    const { data } = props ?? {};

    return authSendVerificationOtp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthSendVerificationOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof authSendVerificationOtp>>
>;
export type AuthSendVerificationOtpMutationBody = AuthSendVerificationOtpBody;
export type AuthSendVerificationOtpMutationError = unknown;

/**
 * @summary Send OTP to the user's phone number (requires pre-auth token)
 */
export const useAuthSendVerificationOtp = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authSendVerificationOtp>>,
    TError,
    { data: AuthSendVerificationOtpBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authSendVerificationOtp>>,
  TError,
  { data: AuthSendVerificationOtpBody },
  TContext
> => {
  const mutationOptions = getAuthSendVerificationOtpMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/auth/verify-otp
 */
export const authVerifyOtp = (
  authVerifyOtpBody?: AuthVerifyOtpBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/auth/verify-otp`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authVerifyOtpBody,
    signal,
  });
};

export const getAuthVerifyOtpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyOtp>>,
    TError,
    { data: AuthVerifyOtpBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authVerifyOtp>>,
  TError,
  { data: AuthVerifyOtpBody },
  TContext
> => {
  const mutationKey = ["authVerifyOtp"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authVerifyOtp>>,
    { data: AuthVerifyOtpBody }
  > = (props) => {
    const { data } = props ?? {};

    return authVerifyOtp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthVerifyOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof authVerifyOtp>>
>;
export type AuthVerifyOtpMutationBody = AuthVerifyOtpBody;
export type AuthVerifyOtpMutationError = unknown;

/**
 * @summary POST /api/auth/verify-otp
 */
export const useAuthVerifyOtp = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyOtp>>,
    TError,
    { data: AuthVerifyOtpBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authVerifyOtp>>,
  TError,
  { data: AuthVerifyOtpBody },
  TContext
> => {
  const mutationOptions = getAuthVerifyOtpMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Query params:
- name: filename in the inbox directory (required)
- format: 'xml' (default) or 'pdf'
 * @summary Return raw XML or rendered PDF for a given inbox filename.
 */
export const birfaturaBpBirfaturaInboxFile = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/birfatura/inbox/file`,
    method: "GET",
    signal,
  });
};

export const getBirfaturaBpBirfaturaInboxFileQueryKey = () => {
  return [`/api/birfatura/inbox/file`] as const;
};

export const getBirfaturaBpBirfaturaInboxFileQueryOptions = <
  TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBirfaturaBpBirfaturaInboxFileQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>
  > = ({ signal }) => birfaturaBpBirfaturaInboxFile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type BirfaturaBpBirfaturaInboxFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>
>;
export type BirfaturaBpBirfaturaInboxFileQueryError = unknown;

/**
 * @summary Return raw XML or rendered PDF for a given inbox filename.
 */

export function useBirfaturaBpBirfaturaInboxFile<
  TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getBirfaturaBpBirfaturaInboxFileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List files saved in the birfatura_inbox directory.
 */
export const birfaturaBpBirfaturaInboxList = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/birfatura/inbox/list`,
    method: "GET",
    signal,
  });
};

export const getBirfaturaBpBirfaturaInboxListQueryKey = () => {
  return [`/api/birfatura/inbox/list`] as const;
};

export const getBirfaturaBpBirfaturaInboxListQueryOptions = <
  TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBirfaturaBpBirfaturaInboxListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>
  > = ({ signal }) => birfaturaBpBirfaturaInboxList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type BirfaturaBpBirfaturaInboxListQueryResult = NonNullable<
  Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>
>;
export type BirfaturaBpBirfaturaInboxListQueryError = unknown;

/**
 * @summary List files saved in the birfatura_inbox directory.
 */

export function useBirfaturaBpBirfaturaInboxList<
  TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getBirfaturaBpBirfaturaInboxListQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DELETE /api/branches/{branch_id}
 */
export const branchesDeleteBranch = (branchId: string) => {
  return customInstance<void>({
    url: `/api/branches/${branchId}`,
    method: "DELETE",
  });
};

export const getBranchesDeleteBranchMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof branchesDeleteBranch>>,
    TError,
    { branchId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof branchesDeleteBranch>>,
  TError,
  { branchId: string },
  TContext
> => {
  const mutationKey = ["branchesDeleteBranch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof branchesDeleteBranch>>,
    { branchId: string }
  > = (props) => {
    const { branchId } = props ?? {};

    return branchesDeleteBranch(branchId);
  };

  return { mutationFn, ...mutationOptions };
};

export type BranchesDeleteBranchMutationResult = NonNullable<
  Awaited<ReturnType<typeof branchesDeleteBranch>>
>;

export type BranchesDeleteBranchMutationError = unknown;

/**
 * @summary DELETE /api/branches/{branch_id}
 */
export const useBranchesDeleteBranch = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof branchesDeleteBranch>>,
    TError,
    { branchId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof branchesDeleteBranch>>,
  TError,
  { branchId: string },
  TContext
> => {
  const mutationOptions = getBranchesDeleteBranchMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const cashRecordsCreateCashRecord = (
  cashRecordsCreateCashRecordBody?: CashRecordsCreateCashRecordBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/cash-records`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: cashRecordsCreateCashRecordBody,
    signal,
  });
};

export const getCashRecordsCreateCashRecordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
    TError,
    { data: CashRecordsCreateCashRecordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
  TError,
  { data: CashRecordsCreateCashRecordBody },
  TContext
> => {
  const mutationKey = ["cashRecordsCreateCashRecord"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
    { data: CashRecordsCreateCashRecordBody }
  > = (props) => {
    const { data } = props ?? {};

    return cashRecordsCreateCashRecord(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CashRecordsCreateCashRecordMutationResult = NonNullable<
  Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>
>;
export type CashRecordsCreateCashRecordMutationBody =
  CashRecordsCreateCashRecordBody;
export type CashRecordsCreateCashRecordMutationError = unknown;

/**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const useCashRecordsCreateCashRecord = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
    TError,
    { data: CashRecordsCreateCashRecordBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
  TError,
  { data: CashRecordsCreateCashRecordBody },
  TContext
> => {
  const mutationOptions =
    getCashRecordsCreateCashRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete a cash record by ID.
 */
export const cashRecordsDeleteCashRecord = (recordId: string) => {
  return customInstance<void>({
    url: `/api/cash-records/${recordId}`,
    method: "DELETE",
  });
};

export const getCashRecordsDeleteCashRecordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
    TError,
    { recordId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
  TError,
  { recordId: string },
  TContext
> => {
  const mutationKey = ["cashRecordsDeleteCashRecord"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
    { recordId: string }
  > = (props) => {
    const { recordId } = props ?? {};

    return cashRecordsDeleteCashRecord(recordId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CashRecordsDeleteCashRecordMutationResult = NonNullable<
  Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>
>;

export type CashRecordsDeleteCashRecordMutationError = unknown;

/**
 * @summary Delete a cash record by ID.
 */
export const useCashRecordsDeleteCashRecord = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
    TError,
    { recordId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
  TError,
  { recordId: string },
  TContext
> => {
  const mutationOptions =
    getCashRecordsDeleteCashRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Mock endpoint to confirm a payment (simulating a webhook or successful callback).
 */
export const checkoutConfirmPayment = (
  checkoutConfirmPaymentBody?: CheckoutConfirmPaymentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/checkout/confirm`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: checkoutConfirmPaymentBody,
    signal,
  });
};

export const getCheckoutConfirmPaymentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutConfirmPayment>>,
    TError,
    { data: CheckoutConfirmPaymentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkoutConfirmPayment>>,
  TError,
  { data: CheckoutConfirmPaymentBody },
  TContext
> => {
  const mutationKey = ["checkoutConfirmPayment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkoutConfirmPayment>>,
    { data: CheckoutConfirmPaymentBody }
  > = (props) => {
    const { data } = props ?? {};

    return checkoutConfirmPayment(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckoutConfirmPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkoutConfirmPayment>>
>;
export type CheckoutConfirmPaymentMutationBody = CheckoutConfirmPaymentBody;
export type CheckoutConfirmPaymentMutationError = unknown;

/**
 * @summary Mock endpoint to confirm a payment (simulating a webhook or successful callback).
 */
export const useCheckoutConfirmPayment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutConfirmPayment>>,
    TError,
    { data: CheckoutConfirmPaymentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof checkoutConfirmPayment>>,
  TError,
  { data: CheckoutConfirmPaymentBody },
  TContext
> => {
  const mutationOptions = getCheckoutConfirmPaymentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * In a real scenario, this would create a Stripe Checkout Session.
For now, it simulates the process and returns a success URL or mock payment data.
 * @summary Initiates a checkout session for a plan purchase.
 */
export const checkoutCreateCheckoutSession = (
  checkoutCreateCheckoutSessionBody?: CheckoutCreateCheckoutSessionBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/checkout/session`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: checkoutCreateCheckoutSessionBody,
    signal,
  });
};

export const getCheckoutCreateCheckoutSessionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
    TError,
    { data: CheckoutCreateCheckoutSessionBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
  TError,
  { data: CheckoutCreateCheckoutSessionBody },
  TContext
> => {
  const mutationKey = ["checkoutCreateCheckoutSession"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
    { data: CheckoutCreateCheckoutSessionBody }
  > = (props) => {
    const { data } = props ?? {};

    return checkoutCreateCheckoutSession(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckoutCreateCheckoutSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>
>;
export type CheckoutCreateCheckoutSessionMutationBody =
  CheckoutCreateCheckoutSessionBody;
export type CheckoutCreateCheckoutSessionMutationError = unknown;

/**
 * @summary Initiates a checkout session for a plan purchase.
 */
export const useCheckoutCreateCheckoutSession = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
    TError,
    { data: CheckoutCreateCheckoutSessionBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
  TError,
  { data: CheckoutCreateCheckoutSessionBody },
  TContext
> => {
  const mutationOptions =
    getCheckoutCreateCheckoutSessionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a manual communication history entry
 */
export const communicationsCreateCommunicationHistory = (
  communicationsCreateCommunicationHistoryBody?: CommunicationsCreateCommunicationHistoryBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/communications/history`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: communicationsCreateCommunicationHistoryBody,
    signal,
  });
};

export const getCommunicationsCreateCommunicationHistoryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
    TError,
    { data: CommunicationsCreateCommunicationHistoryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
  TError,
  { data: CommunicationsCreateCommunicationHistoryBody },
  TContext
> => {
  const mutationKey = ["communicationsCreateCommunicationHistory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
    { data: CommunicationsCreateCommunicationHistoryBody }
  > = (props) => {
    const { data } = props ?? {};

    return communicationsCreateCommunicationHistory(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsCreateCommunicationHistoryMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>
  >;
export type CommunicationsCreateCommunicationHistoryMutationBody =
  CommunicationsCreateCommunicationHistoryBody;
export type CommunicationsCreateCommunicationHistoryMutationError = unknown;

/**
 * @summary Create a manual communication history entry
 */
export const useCommunicationsCreateCommunicationHistory = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
    TError,
    { data: CommunicationsCreateCommunicationHistoryBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
  TError,
  { data: CommunicationsCreateCommunicationHistoryBody },
  TContext
> => {
  const mutationOptions =
    getCommunicationsCreateCommunicationHistoryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Send Email message
 */
export const communicationsSendEmail = (
  communicationsSendEmailBody?: CommunicationsSendEmailBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/communications/messages/send-email`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: communicationsSendEmailBody,
    signal,
  });
};

export const getCommunicationsSendEmailMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsSendEmail>>,
    TError,
    { data: CommunicationsSendEmailBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsSendEmail>>,
  TError,
  { data: CommunicationsSendEmailBody },
  TContext
> => {
  const mutationKey = ["communicationsSendEmail"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsSendEmail>>,
    { data: CommunicationsSendEmailBody }
  > = (props) => {
    const { data } = props ?? {};

    return communicationsSendEmail(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsSendEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof communicationsSendEmail>>
>;
export type CommunicationsSendEmailMutationBody = CommunicationsSendEmailBody;
export type CommunicationsSendEmailMutationError = unknown;

/**
 * @summary Send Email message
 */
export const useCommunicationsSendEmail = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsSendEmail>>,
    TError,
    { data: CommunicationsSendEmailBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsSendEmail>>,
  TError,
  { data: CommunicationsSendEmailBody },
  TContext
> => {
  const mutationOptions = getCommunicationsSendEmailMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Send SMS message
 */
export const communicationsSendSms = (
  communicationsSendSmsBody?: CommunicationsSendSmsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/communications/messages/send-sms`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: communicationsSendSmsBody,
    signal,
  });
};

export const getCommunicationsSendSmsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsSendSms>>,
    TError,
    { data: CommunicationsSendSmsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof communicationsSendSms>>,
  TError,
  { data: CommunicationsSendSmsBody },
  TContext
> => {
  const mutationKey = ["communicationsSendSms"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof communicationsSendSms>>,
    { data: CommunicationsSendSmsBody }
  > = (props) => {
    const { data } = props ?? {};

    return communicationsSendSms(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommunicationsSendSmsMutationResult = NonNullable<
  Awaited<ReturnType<typeof communicationsSendSms>>
>;
export type CommunicationsSendSmsMutationBody = CommunicationsSendSmsBody;
export type CommunicationsSendSmsMutationError = unknown;

/**
 * @summary Send SMS message
 */
export const useCommunicationsSendSms = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof communicationsSendSms>>,
    TError,
    { data: CommunicationsSendSmsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof communicationsSendSms>>,
  TError,
  { data: CommunicationsSendSmsBody },
  TContext
> => {
  const mutationOptions = getCommunicationsSendSmsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get communication statistics
 */
export const communicationsCommunicationStats = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/communications/stats`,
    method: "GET",
    signal,
  });
};

export const getCommunicationsCommunicationStatsQueryKey = () => {
  return [`/api/communications/stats`] as const;
};

export const getCommunicationsCommunicationStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof communicationsCommunicationStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCommunicationsCommunicationStatsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof communicationsCommunicationStats>>
  > = ({ signal }) => communicationsCommunicationStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof communicationsCommunicationStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommunicationsCommunicationStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof communicationsCommunicationStats>>
>;
export type CommunicationsCommunicationStatsQueryError = unknown;

/**
 * @summary Get communication statistics
 */

export function useCommunicationsCommunicationStats<
  TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof communicationsCommunicationStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommunicationsCommunicationStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GET /api/config
 */
export const configGetConfig = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/api/config`, method: "GET", signal });
};

export const getConfigGetConfigQueryKey = () => {
  return [`/api/config`] as const;
};

export const getConfigGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof configGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof configGetConfig>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConfigGetConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof configGetConfig>>> = ({
    signal,
  }) => configGetConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof configGetConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ConfigGetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof configGetConfig>>
>;
export type ConfigGetConfigQueryError = unknown;

/**
 * @summary GET /api/config
 */

export function useConfigGetConfig<
  TData = Awaited<ReturnType<typeof configGetConfig>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof configGetConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getConfigGetConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GET /api/dashboard/charts/patient-distribution
 */
export const dashboardPatientDistribution = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/dashboard/charts/patient-distribution`,
    method: "GET",
    signal,
  });
};

export const getDashboardPatientDistributionQueryKey = () => {
  return [`/api/dashboard/charts/patient-distribution`] as const;
};

export const getDashboardPatientDistributionQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientDistribution>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardPatientDistributionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardPatientDistribution>>
  > = ({ signal }) => dashboardPatientDistribution(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientDistribution>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DashboardPatientDistributionQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardPatientDistribution>>
>;
export type DashboardPatientDistributionQueryError = unknown;

/**
 * @summary GET /api/dashboard/charts/patient-distribution
 */

export function useDashboardPatientDistribution<
  TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof dashboardPatientDistribution>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDashboardPatientDistributionQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a device assignment (e.g., cancel, update serial numbers, pricing)
 */
export const salesUpdateDeviceAssignment = (assignmentId: string) => {
  return customInstance<void>({
    url: `/api/device-assignments/${assignmentId}`,
    method: "PATCH",
  });
};

export const getSalesUpdateDeviceAssignmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
    TError,
    { assignmentId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
  TError,
  { assignmentId: string },
  TContext
> => {
  const mutationKey = ["salesUpdateDeviceAssignment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
    { assignmentId: string }
  > = (props) => {
    const { assignmentId } = props ?? {};

    return salesUpdateDeviceAssignment(assignmentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesUpdateDeviceAssignmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>
>;

export type SalesUpdateDeviceAssignmentMutationError = unknown;

/**
 * @summary Update a device assignment (e.g., cancel, update serial numbers, pricing)
 */
export const useSalesUpdateDeviceAssignment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
    TError,
    { assignmentId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
  TError,
  { assignmentId: string },
  TContext
> => {
  const mutationOptions =
    getSalesUpdateDeviceAssignmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new brand
 */
export const inventoryCreateBrand = (
  inventoryCreateBrandBody?: InventoryCreateBrandBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/inventory/brands`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryCreateBrandBody,
    signal,
  });
};

export const getInventoryCreateBrandMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateBrand>>,
    TError,
    { data: InventoryCreateBrandBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryCreateBrand>>,
  TError,
  { data: InventoryCreateBrandBody },
  TContext
> => {
  const mutationKey = ["inventoryCreateBrand"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryCreateBrand>>,
    { data: InventoryCreateBrandBody }
  > = (props) => {
    const { data } = props ?? {};

    return inventoryCreateBrand(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryCreateBrandMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryCreateBrand>>
>;
export type InventoryCreateBrandMutationBody = InventoryCreateBrandBody;
export type InventoryCreateBrandMutationError = unknown;

/**
 * @summary Create a new brand
 */
export const useInventoryCreateBrand = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryCreateBrand>>,
    TError,
    { data: InventoryCreateBrandBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryCreateBrand>>,
  TError,
  { data: InventoryCreateBrandBody },
  TContext
> => {
  const mutationOptions = getInventoryCreateBrandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all available product brands with counts and categories
 */
export const inventoryGetBrandsOld = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/brands_old`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetBrandsOldQueryKey = () => {
  return [`/api/inventory/brands_old`] as const;
};

export const getInventoryGetBrandsOldQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInventoryGetBrandsOldQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetBrandsOld>>
  > = ({ signal }) => inventoryGetBrandsOld(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetBrandsOldQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetBrandsOld>>
>;
export type InventoryGetBrandsOldQueryError = unknown;

/**
 * @summary Get all available product brands with counts and categories
 */

export function useInventoryGetBrandsOld<
  TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetBrandsOldQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Bulk upload inventory items from CSV/XLSX. Returns {created, updated, errors}.
 */
export const inventoryBulkUploadInventory = (
  inventoryBulkUploadInventoryBody?: InventoryBulkUploadInventoryBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/inventory/bulk_upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inventoryBulkUploadInventoryBody,
    signal,
  });
};

export const getInventoryBulkUploadInventoryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
    TError,
    { data: InventoryBulkUploadInventoryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
  TError,
  { data: InventoryBulkUploadInventoryBody },
  TContext
> => {
  const mutationKey = ["inventoryBulkUploadInventory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
    { data: InventoryBulkUploadInventoryBody }
  > = (props) => {
    const { data } = props ?? {};

    return inventoryBulkUploadInventory(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InventoryBulkUploadInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof inventoryBulkUploadInventory>>
>;
export type InventoryBulkUploadInventoryMutationBody =
  InventoryBulkUploadInventoryBody;
export type InventoryBulkUploadInventoryMutationError = unknown;

/**
 * @summary Bulk upload inventory items from CSV/XLSX. Returns {created, updated, errors}.
 */
export const useInventoryBulkUploadInventory = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
    TError,
    { data: InventoryBulkUploadInventoryBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
  TError,
  { data: InventoryBulkUploadInventoryBody },
  TContext
> => {
  const mutationOptions =
    getInventoryBulkUploadInventoryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all available product categories with counts
 */
export const inventoryGetCategoriesOld = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/categories_old`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetCategoriesOldQueryKey = () => {
  return [`/api/inventory/categories_old`] as const;
};

export const getInventoryGetCategoriesOldQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryGetCategoriesOldQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetCategoriesOld>>
  > = ({ signal }) => inventoryGetCategoriesOld(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetCategoriesOldQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetCategoriesOld>>
>;
export type InventoryGetCategoriesOldQueryError = unknown;

/**
 * @summary Get all available product categories with counts
 */

export function useInventoryGetCategoriesOld<
  TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetCategoriesOldQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all available product features with counts
 */
export const inventoryGetFeatures = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/features`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetFeaturesQueryKey = () => {
  return [`/api/inventory/features`] as const;
};

export const getInventoryGetFeaturesQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetFeatures>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetFeatures>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInventoryGetFeaturesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetFeatures>>
  > = ({ signal }) => inventoryGetFeatures(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetFeatures>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetFeaturesQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetFeatures>>
>;
export type InventoryGetFeaturesQueryError = unknown;

/**
 * @summary Get all available product features with counts
 */

export function useInventoryGetFeatures<
  TData = Awaited<ReturnType<typeof inventoryGetFeatures>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetFeatures>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetFeaturesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Advanced product search with comprehensive filtering
 */
export const inventoryAdvancedSearch = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/search`,
    method: "GET",
    signal,
  });
};

export const getInventoryAdvancedSearchQueryKey = () => {
  return [`/api/inventory/search`] as const;
};

export const getInventoryAdvancedSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInventoryAdvancedSearchQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryAdvancedSearch>>
  > = ({ signal }) => inventoryAdvancedSearch(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryAdvancedSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryAdvancedSearch>>
>;
export type InventoryAdvancedSearchQueryError = unknown;

/**
 * @summary Advanced product search with comprehensive filtering
 */

export function useInventoryAdvancedSearch<
  TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryAdvancedSearchQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all available unit types for inventory items
 */
export const inventoryGetUnits = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/inventory/units`,
    method: "GET",
    signal,
  });
};

export const getInventoryGetUnitsQueryKey = () => {
  return [`/api/inventory/units`] as const;
};

export const getInventoryGetUnitsQueryOptions = <
  TData = Awaited<ReturnType<typeof inventoryGetUnits>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetUnits>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInventoryGetUnitsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inventoryGetUnits>>
  > = ({ signal }) => inventoryGetUnits(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetUnits>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InventoryGetUnitsQueryResult = NonNullable<
  Awaited<ReturnType<typeof inventoryGetUnits>>
>;
export type InventoryGetUnitsQueryError = unknown;

/**
 * @summary Get all available unit types for inventory items
 */

export function useInventoryGetUnits<
  TData = Awaited<ReturnType<typeof inventoryGetUnits>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof inventoryGetUnits>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInventoryGetUnitsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Generate multiple invoices at once
 */
export const invoicesBatchGenerateInvoices = (
  invoicesBatchGenerateInvoicesBody?: InvoicesBatchGenerateInvoicesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/batch-generate`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesBatchGenerateInvoicesBody,
    signal,
  });
};

export const getInvoicesBatchGenerateInvoicesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
    TError,
    { data: InvoicesBatchGenerateInvoicesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
  TError,
  { data: InvoicesBatchGenerateInvoicesBody },
  TContext
> => {
  const mutationKey = ["invoicesBatchGenerateInvoices"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
    { data: InvoicesBatchGenerateInvoicesBody }
  > = (props) => {
    const { data } = props ?? {};

    return invoicesBatchGenerateInvoices(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesBatchGenerateInvoicesMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>
>;
export type InvoicesBatchGenerateInvoicesMutationBody =
  InvoicesBatchGenerateInvoicesBody;
export type InvoicesBatchGenerateInvoicesMutationError = unknown;

/**
 * @summary Generate multiple invoices at once
 */
export const useInvoicesBatchGenerateInvoices = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
    TError,
    { data: InvoicesBatchGenerateInvoicesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
  TError,
  { data: InvoicesBatchGenerateInvoicesBody },
  TContext
> => {
  const mutationOptions =
    getInvoicesBatchGenerateInvoicesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Bulk upload invoices from CSV/XLSX. Returns {created, updated, errors}.
 */
export const invoicesBulkUploadInvoices = (
  invoicesBulkUploadInvoicesBody?: InvoicesBulkUploadInvoicesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/bulk_upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesBulkUploadInvoicesBody,
    signal,
  });
};

export const getInvoicesBulkUploadInvoicesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
    TError,
    { data: InvoicesBulkUploadInvoicesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
  TError,
  { data: InvoicesBulkUploadInvoicesBody },
  TContext
> => {
  const mutationKey = ["invoicesBulkUploadInvoices"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
    { data: InvoicesBulkUploadInvoicesBody }
  > = (props) => {
    const { data } = props ?? {};

    return invoicesBulkUploadInvoices(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesBulkUploadInvoicesMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>
>;
export type InvoicesBulkUploadInvoicesMutationBody =
  InvoicesBulkUploadInvoicesBody;
export type InvoicesBulkUploadInvoicesMutationError = unknown;

/**
 * @summary Bulk upload invoices from CSV/XLSX. Returns {created, updated, errors}.
 */
export const useInvoicesBulkUploadInvoices = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
    TError,
    { data: InvoicesBulkUploadInvoicesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
  TError,
  { data: InvoicesBulkUploadInvoicesBody },
  TContext
> => {
  const mutationOptions = getInvoicesBulkUploadInvoicesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Add invoices to print queue
 */
export const invoicesAddToPrintQueue = (
  invoicesAddToPrintQueueBody?: InvoicesAddToPrintQueueBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/print-queue`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesAddToPrintQueueBody,
    signal,
  });
};

export const getInvoicesAddToPrintQueueMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
    TError,
    { data: InvoicesAddToPrintQueueBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
  TError,
  { data: InvoicesAddToPrintQueueBody },
  TContext
> => {
  const mutationKey = ["invoicesAddToPrintQueue"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
    { data: InvoicesAddToPrintQueueBody }
  > = (props) => {
    const { data } = props ?? {};

    return invoicesAddToPrintQueue(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesAddToPrintQueueMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesAddToPrintQueue>>
>;
export type InvoicesAddToPrintQueueMutationBody = InvoicesAddToPrintQueueBody;
export type InvoicesAddToPrintQueueMutationError = unknown;

/**
 * @summary Add invoices to print queue
 */
export const useInvoicesAddToPrintQueue = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
    TError,
    { data: InvoicesAddToPrintQueueBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
  TError,
  { data: InvoicesAddToPrintQueueBody },
  TContext
> => {
  const mutationOptions = getInvoicesAddToPrintQueueMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a custom invoice template
 */
export const invoicesCreateInvoiceTemplate = (
  invoicesCreateInvoiceTemplateBody?: InvoicesCreateInvoiceTemplateBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/templates`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesCreateInvoiceTemplateBody,
    signal,
  });
};

export const getInvoicesCreateInvoiceTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
    TError,
    { data: InvoicesCreateInvoiceTemplateBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
  TError,
  { data: InvoicesCreateInvoiceTemplateBody },
  TContext
> => {
  const mutationKey = ["invoicesCreateInvoiceTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
    { data: InvoicesCreateInvoiceTemplateBody }
  > = (props) => {
    const { data } = props ?? {};

    return invoicesCreateInvoiceTemplate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesCreateInvoiceTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>
>;
export type InvoicesCreateInvoiceTemplateMutationBody =
  InvoicesCreateInvoiceTemplateBody;
export type InvoicesCreateInvoiceTemplateMutationError = unknown;

/**
 * @summary Create a custom invoice template
 */
export const useInvoicesCreateInvoiceTemplate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
    TError,
    { data: InvoicesCreateInvoiceTemplateBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
  TError,
  { data: InvoicesCreateInvoiceTemplateBody },
  TContext
> => {
  const mutationOptions =
    getInvoicesCreateInvoiceTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/invoices/{invoice_id}/copy
 */
export const invoicesActionsCopyInvoice = (
  invoiceId: string,
  invoicesActionsCopyInvoiceBody?: InvoicesActionsCopyInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/copy`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesActionsCopyInvoiceBody,
    signal,
  });
};

export const getInvoicesActionsCopyInvoiceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
    TError,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
  TError,
  { invoiceId: string; data: InvoicesActionsCopyInvoiceBody },
  TContext
> => {
  const mutationKey = ["invoicesActionsCopyInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return invoicesActionsCopyInvoice(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesActionsCopyInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>
>;
export type InvoicesActionsCopyInvoiceMutationBody =
  InvoicesActionsCopyInvoiceBody;
export type InvoicesActionsCopyInvoiceMutationError = unknown;

/**
 * @summary POST /api/invoices/{invoice_id}/copy
 */
export const useInvoicesActionsCopyInvoice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
    TError,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
  TError,
  { invoiceId: string; data: InvoicesActionsCopyInvoiceBody },
  TContext
> => {
  const mutationOptions = getInvoicesActionsCopyInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/invoices/{invoice_id}/copy-cancel
 */
export const invoicesActionsCopyInvoiceCancel = (
  invoiceId: string,
  invoicesActionsCopyInvoiceCancelBody?: InvoicesActionsCopyInvoiceCancelBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/copy-cancel`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesActionsCopyInvoiceCancelBody,
    signal,
  });
};

export const getInvoicesActionsCopyInvoiceCancelMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
    TError,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceCancelBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
  TError,
  { invoiceId: string; data: InvoicesActionsCopyInvoiceCancelBody },
  TContext
> => {
  const mutationKey = ["invoicesActionsCopyInvoiceCancel"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceCancelBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return invoicesActionsCopyInvoiceCancel(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesActionsCopyInvoiceCancelMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>
>;
export type InvoicesActionsCopyInvoiceCancelMutationBody =
  InvoicesActionsCopyInvoiceCancelBody;
export type InvoicesActionsCopyInvoiceCancelMutationError = unknown;

/**
 * @summary POST /api/invoices/{invoice_id}/copy-cancel
 */
export const useInvoicesActionsCopyInvoiceCancel = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
    TError,
    { invoiceId: string; data: InvoicesActionsCopyInvoiceCancelBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
  TError,
  { invoiceId: string; data: InvoicesActionsCopyInvoiceCancelBody },
  TContext
> => {
  const mutationOptions =
    getInvoicesActionsCopyInvoiceCancelMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/invoices/{invoice_id}/issue
 */
export const invoicesActionsIssueInvoice = (
  invoiceId: string,
  invoicesActionsIssueInvoiceBody?: InvoicesActionsIssueInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/issue`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesActionsIssueInvoiceBody,
    signal,
  });
};

export const getInvoicesActionsIssueInvoiceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
    TError,
    { invoiceId: string; data: InvoicesActionsIssueInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
  TError,
  { invoiceId: string; data: InvoicesActionsIssueInvoiceBody },
  TContext
> => {
  const mutationKey = ["invoicesActionsIssueInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
    { invoiceId: string; data: InvoicesActionsIssueInvoiceBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return invoicesActionsIssueInvoice(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesActionsIssueInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>
>;
export type InvoicesActionsIssueInvoiceMutationBody =
  InvoicesActionsIssueInvoiceBody;
export type InvoicesActionsIssueInvoiceMutationError = unknown;

/**
 * @summary POST /api/invoices/{invoice_id}/issue
 */
export const useInvoicesActionsIssueInvoice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
    TError,
    { invoiceId: string; data: InvoicesActionsIssueInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
  TError,
  { invoiceId: string; data: InvoicesActionsIssueInvoiceBody },
  TContext
> => {
  const mutationOptions =
    getInvoicesActionsIssueInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary GET /api/invoices/{invoice_id}/shipping-pdf
 */
export const invoicesActionsServeShippingPdf = (
  invoiceId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/shipping-pdf`,
    method: "GET",
    signal,
  });
};

export const getInvoicesActionsServeShippingPdfQueryKey = (
  invoiceId?: string,
) => {
  return [`/api/invoices/${invoiceId}/shipping-pdf`] as const;
};

export const getInvoicesActionsServeShippingPdfQueryOptions = <
  TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
  TError = unknown,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getInvoicesActionsServeShippingPdfQueryKey(invoiceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>
  > = ({ signal }) => invoicesActionsServeShippingPdf(invoiceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!invoiceId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InvoicesActionsServeShippingPdfQueryResult = NonNullable<
  Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>
>;
export type InvoicesActionsServeShippingPdfQueryError = unknown;

/**
 * @summary GET /api/invoices/{invoice_id}/shipping-pdf
 */

export function useInvoicesActionsServeShippingPdf<
  TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
  TError = unknown,
>(
  invoiceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInvoicesActionsServeShippingPdfQueryOptions(
    invoiceId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Called to check if GÄ°B has approved/rejected the invoice and fetch PDF if available.
 * @summary Update invoice status from Birfatura.
 */
export const invoicesUpdateInvoiceGibStatus = (
  invoiceId: string,
  invoicesUpdateInvoiceGibStatusBody?: InvoicesUpdateInvoiceGibStatusBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/update-gib-status`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesUpdateInvoiceGibStatusBody,
    signal,
  });
};

export const getInvoicesUpdateInvoiceGibStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
    TError,
    { invoiceId: string; data: InvoicesUpdateInvoiceGibStatusBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
  TError,
  { invoiceId: string; data: InvoicesUpdateInvoiceGibStatusBody },
  TContext
> => {
  const mutationKey = ["invoicesUpdateInvoiceGibStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
    { invoiceId: string; data: InvoicesUpdateInvoiceGibStatusBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return invoicesUpdateInvoiceGibStatus(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesUpdateInvoiceGibStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>
>;
export type InvoicesUpdateInvoiceGibStatusMutationBody =
  InvoicesUpdateInvoiceGibStatusBody;
export type InvoicesUpdateInvoiceGibStatusMutationError = unknown;

/**
 * @summary Update invoice status from Birfatura.
 */
export const useInvoicesUpdateInvoiceGibStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
    TError,
    { invoiceId: string; data: InvoicesUpdateInvoiceGibStatusBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
  TError,
  { invoiceId: string; data: InvoicesUpdateInvoiceGibStatusBody },
  TContext
> => {
  const mutationOptions =
    getInvoicesUpdateInvoiceGibStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Upload an XML (e.g., from birfatura) and save it for this invoice.
 */
export const invoicesUploadInvoiceXml = (
  invoiceId: string,
  invoicesUploadInvoiceXmlBody?: InvoicesUploadInvoiceXmlBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/invoices/${invoiceId}/xml`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: invoicesUploadInvoiceXmlBody,
    signal,
  });
};

export const getInvoicesUploadInvoiceXmlMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
    TError,
    { invoiceId: string; data: InvoicesUploadInvoiceXmlBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
  TError,
  { invoiceId: string; data: InvoicesUploadInvoiceXmlBody },
  TContext
> => {
  const mutationKey = ["invoicesUploadInvoiceXml"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
    { invoiceId: string; data: InvoicesUploadInvoiceXmlBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return invoicesUploadInvoiceXml(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InvoicesUploadInvoiceXmlMutationResult = NonNullable<
  Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>
>;
export type InvoicesUploadInvoiceXmlMutationBody = InvoicesUploadInvoiceXmlBody;
export type InvoicesUploadInvoiceXmlMutationError = unknown;

/**
 * @summary Upload an XML (e.g., from birfatura) and save it for this invoice.
 */
export const useInvoicesUploadInvoiceXml = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
    TError,
    { invoiceId: string; data: InvoicesUploadInvoiceXmlBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
  TError,
  { invoiceId: string; data: InvoicesUploadInvoiceXmlBody },
  TContext
> => {
  const mutationOptions = getInvoicesUploadInvoiceXmlMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary PUT /api/notifications/settings
 */
export const notificationsSetUserNotificationSettings = (
  notificationsSetUserNotificationSettingsBody?: NotificationsSetUserNotificationSettingsBody,
) => {
  return customInstance<void>({
    url: `/api/notifications/settings`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: notificationsSetUserNotificationSettingsBody,
  });
};

export const getNotificationsSetUserNotificationSettingsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
    TError,
    { data: NotificationsSetUserNotificationSettingsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
  TError,
  { data: NotificationsSetUserNotificationSettingsBody },
  TContext
> => {
  const mutationKey = ["notificationsSetUserNotificationSettings"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
    { data: NotificationsSetUserNotificationSettingsBody }
  > = (props) => {
    const { data } = props ?? {};

    return notificationsSetUserNotificationSettings(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsSetUserNotificationSettingsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>
  >;
export type NotificationsSetUserNotificationSettingsMutationBody =
  NotificationsSetUserNotificationSettingsBody;
export type NotificationsSetUserNotificationSettingsMutationError = unknown;

/**
 * @summary PUT /api/notifications/settings
 */
export const useNotificationsSetUserNotificationSettings = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
    TError,
    { data: NotificationsSetUserNotificationSettingsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
  TError,
  { data: NotificationsSetUserNotificationSettingsBody },
  TContext
> => {
  const mutationOptions =
    getNotificationsSetUserNotificationSettingsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Request JSON: { "text": "..." }
Returns: { hf_ner: [...], spacy_entities: [...], tokens: [...] }
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const ocrDebugNer = (
  ocrDebugNerBody?: OcrDebugNerBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/debug_ner`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrDebugNerBody,
    signal,
  });
};

export const getOcrDebugNerMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    TError,
    { data: OcrDebugNerBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrDebugNer>>,
  TError,
  { data: OcrDebugNerBody },
  TContext
> => {
  const mutationKey = ["ocrDebugNer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    { data: OcrDebugNerBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrDebugNer(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrDebugNerMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrDebugNer>>
>;
export type OcrDebugNerMutationBody = OcrDebugNerBody;
export type OcrDebugNerMutationError = unknown;

/**
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const useOcrDebugNer = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    TError,
    { data: OcrDebugNerBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrDebugNer>>,
  TError,
  { data: OcrDebugNerBody },
  TContext
> => {
  const mutationOptions = getOcrDebugNerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntitiesV2 = (
  ocrExtractEntitiesV2Body?: OcrExtractEntitiesV2Body,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/entities`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrExtractEntitiesV2Body,
    signal,
  });
};

export const getOcrExtractEntitiesV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
    TError,
    { data: OcrExtractEntitiesV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
  TError,
  { data: OcrExtractEntitiesV2Body },
  TContext
> => {
  const mutationKey = ["ocrExtractEntitiesV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
    { data: OcrExtractEntitiesV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return ocrExtractEntitiesV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractEntitiesV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractEntitiesV2>>
>;
export type OcrExtractEntitiesV2MutationBody = OcrExtractEntitiesV2Body;
export type OcrExtractEntitiesV2MutationError = unknown;

/**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntitiesV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
    TError,
    { data: OcrExtractEntitiesV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
  TError,
  { data: OcrExtractEntitiesV2Body },
  TContext
> => {
  const mutationOptions = getOcrExtractEntitiesV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientNameV2 = (
  ocrExtractPatientNameV2Body?: OcrExtractPatientNameV2Body,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/extract_patient`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrExtractPatientNameV2Body,
    signal,
  });
};

export const getOcrExtractPatientNameV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
    TError,
    { data: OcrExtractPatientNameV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
  TError,
  { data: OcrExtractPatientNameV2Body },
  TContext
> => {
  const mutationKey = ["ocrExtractPatientNameV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
    { data: OcrExtractPatientNameV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return ocrExtractPatientNameV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractPatientNameV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractPatientNameV2>>
>;
export type OcrExtractPatientNameV2MutationBody = OcrExtractPatientNameV2Body;
export type OcrExtractPatientNameV2MutationError = unknown;

/**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientNameV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
    TError,
    { data: OcrExtractPatientNameV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
  TError,
  { data: OcrExtractPatientNameV2Body },
  TContext
> => {
  const mutationOptions = getOcrExtractPatientNameV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheckApi = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/health`,
    method: "GET",
    signal,
  });
};

export const getOcrHealthCheckApiQueryKey = () => {
  return [`/api/ocr/health`] as const;
};

export const getOcrHealthCheckApiQueryOptions = <
  TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheckApi>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOcrHealthCheckApiQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof ocrHealthCheckApi>>
  > = ({ signal }) => ocrHealthCheckApi(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheckApi>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OcrHealthCheckApiQueryResult = NonNullable<
  Awaited<ReturnType<typeof ocrHealthCheckApi>>
>;
export type OcrHealthCheckApiQueryError = unknown;

/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheckApi<
  TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheckApi>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOcrHealthCheckApiQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initialize database and create tables
 */
export const ocrInitDatabaseV2 = (
  ocrInitDatabaseV2Body?: OcrInitDatabaseV2Body,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/init-db`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrInitDatabaseV2Body,
    signal,
  });
};

export const getOcrInitDatabaseV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
    TError,
    { data: OcrInitDatabaseV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
  TError,
  { data: OcrInitDatabaseV2Body },
  TContext
> => {
  const mutationKey = ["ocrInitDatabaseV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
    { data: OcrInitDatabaseV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return ocrInitDatabaseV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitDatabaseV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitDatabaseV2>>
>;
export type OcrInitDatabaseV2MutationBody = OcrInitDatabaseV2Body;
export type OcrInitDatabaseV2MutationError = unknown;

/**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabaseV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
    TError,
    { data: OcrInitDatabaseV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
  TError,
  { data: OcrInitDatabaseV2Body },
  TContext
> => {
  const mutationOptions = getOcrInitDatabaseV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Starts model initialization in a background thread so the HTTP request
can return quickly and heavy imports/downloads happen asynchronously.
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const ocrInitializeNlpEndpointV2 = (
  ocrInitializeNlpEndpointV2Body?: OcrInitializeNlpEndpointV2Body,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/initialize`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrInitializeNlpEndpointV2Body,
    signal,
  });
};

export const getOcrInitializeNlpEndpointV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
    TError,
    { data: OcrInitializeNlpEndpointV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
  TError,
  { data: OcrInitializeNlpEndpointV2Body },
  TContext
> => {
  const mutationKey = ["ocrInitializeNlpEndpointV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
    { data: OcrInitializeNlpEndpointV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return ocrInitializeNlpEndpointV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitializeNlpEndpointV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>
>;
export type OcrInitializeNlpEndpointV2MutationBody =
  OcrInitializeNlpEndpointV2Body;
export type OcrInitializeNlpEndpointV2MutationError = unknown;

/**
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const useOcrInitializeNlpEndpointV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
    TError,
    { data: OcrInitializeNlpEndpointV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
  TError,
  { data: OcrInitializeNlpEndpointV2Body },
  TContext
> => {
  const mutationOptions = getOcrInitializeNlpEndpointV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new OCR job
 */
export const ocrCreateJob = (
  ocrCreateJobBody?: OcrCreateJobBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/jobs`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrCreateJobBody,
    signal,
  });
};

export const getOcrCreateJobMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    TError,
    { data: OcrCreateJobBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrCreateJob>>,
  TError,
  { data: OcrCreateJobBody },
  TContext
> => {
  const mutationKey = ["ocrCreateJob"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    { data: OcrCreateJobBody }
  > = (props) => {
    const { data } = props ?? {};

    return ocrCreateJob(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrCreateJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrCreateJob>>
>;
export type OcrCreateJobMutationBody = OcrCreateJobBody;
export type OcrCreateJobMutationError = unknown;

/**
 * @summary Create a new OCR job
 */
export const useOcrCreateJob = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    TError,
    { data: OcrCreateJobBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrCreateJob>>,
  TError,
  { data: OcrCreateJobBody },
  TContext
> => {
  const mutationOptions = getOcrCreateJobMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Accepts either {'image_path1':..., 'image_path2':...} or {'text1':..., 'text2':...}
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const ocrCalculateSimilarityV2 = (
  ocrCalculateSimilarityV2Body?: OcrCalculateSimilarityV2Body,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/ocr/similarity`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ocrCalculateSimilarityV2Body,
    signal,
  });
};

export const getOcrCalculateSimilarityV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
    TError,
    { data: OcrCalculateSimilarityV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
  TError,
  { data: OcrCalculateSimilarityV2Body },
  TContext
> => {
  const mutationKey = ["ocrCalculateSimilarityV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
    { data: OcrCalculateSimilarityV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return ocrCalculateSimilarityV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrCalculateSimilarityV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>
>;
export type OcrCalculateSimilarityV2MutationBody = OcrCalculateSimilarityV2Body;
export type OcrCalculateSimilarityV2MutationError = unknown;

/**
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const useOcrCalculateSimilarityV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
    TError,
    { data: OcrCalculateSimilarityV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
  TError,
  { data: OcrCalculateSimilarityV2Body },
  TContext
> => {
  const mutationOptions = getOcrCalculateSimilarityV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all invoices for a patient
 */
export const invoicesGetPatientInvoices = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/invoices`,
    method: "GET",
    signal,
  });
};

export const getInvoicesGetPatientInvoicesQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/invoices`] as const;
};

export const getInvoicesGetPatientInvoicesQueryOptions = <
  TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getInvoicesGetPatientInvoicesQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
  > = ({ signal }) => invoicesGetPatientInvoices(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InvoicesGetPatientInvoicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
>;
export type InvoicesGetPatientInvoicesQueryError = unknown;

/**
 * @summary Get all invoices for a patient
 */

export function useInvoicesGetPatientInvoices<
  TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInvoicesGetPatientInvoicesQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all payment records for a patient
 */
export const paymentsGetPatientPaymentRecords = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/payment-records`,
    method: "GET",
    signal,
  });
};

export const getPaymentsGetPatientPaymentRecordsQueryKey = (
  patientId?: string,
) => {
  return [`/api/patients/${patientId}/payment-records`] as const;
};

export const getPaymentsGetPatientPaymentRecordsQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentsGetPatientPaymentRecordsQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
  > = ({ signal }) => paymentsGetPatientPaymentRecords(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PaymentsGetPatientPaymentRecordsQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
>;
export type PaymentsGetPatientPaymentRecordsQueryError = unknown;

/**
 * @summary Get all payment records for a patient
 */

export function usePaymentsGetPatientPaymentRecords<
  TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPaymentsGetPatientPaymentRecordsQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new product sale from inventory
 */
export const salesCreateProductSale = (
  patientId: string,
  salesCreateProductSaleBody?: SalesCreateProductSaleBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/product-sales`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesCreateProductSaleBody,
    signal,
  });
};

export const getSalesCreateProductSaleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateProductSale>>,
    TError,
    { patientId: string; data: SalesCreateProductSaleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesCreateProductSale>>,
  TError,
  { patientId: string; data: SalesCreateProductSaleBody },
  TContext
> => {
  const mutationKey = ["salesCreateProductSale"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesCreateProductSale>>,
    { patientId: string; data: SalesCreateProductSaleBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return salesCreateProductSale(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesCreateProductSaleMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesCreateProductSale>>
>;
export type SalesCreateProductSaleMutationBody = SalesCreateProductSaleBody;
export type SalesCreateProductSaleMutationError = unknown;

/**
 * @summary Create a new product sale from inventory
 */
export const useSalesCreateProductSale = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateProductSale>>,
    TError,
    { patientId: string; data: SalesCreateProductSaleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesCreateProductSale>>,
  TError,
  { patientId: string; data: SalesCreateProductSaleBody },
  TContext
> => {
  const mutationOptions = getSalesCreateProductSaleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all proformas for a patient
 */
export const proformasGetPatientProformas = (
  patientId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/proformas`,
    method: "GET",
    signal,
  });
};

export const getProformasGetPatientProformasQueryKey = (patientId?: string) => {
  return [`/api/patients/${patientId}/proformas`] as const;
};

export const getProformasGetPatientProformasQueryOptions = <
  TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof proformasGetPatientProformas>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getProformasGetPatientProformasQueryKey(patientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof proformasGetPatientProformas>>
  > = ({ signal }) => proformasGetPatientProformas(patientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!patientId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof proformasGetPatientProformas>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ProformasGetPatientProformasQueryResult = NonNullable<
  Awaited<ReturnType<typeof proformasGetPatientProformas>>
>;
export type ProformasGetPatientProformasQueryError = unknown;

/**
 * @summary Get all proformas for a patient
 */

export function useProformasGetPatientProformas<
  TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>,
  TError = unknown,
>(
  patientId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof proformasGetPatientProformas>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProformasGetPatientProformasQueryOptions(
    patientId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const replacementsCreatePatientReplacement = (
  patientId: string,
  replacementsCreatePatientReplacementBody?: ReplacementsCreatePatientReplacementBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/replacements`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: replacementsCreatePatientReplacementBody,
    signal,
  });
};

export const getReplacementsCreatePatientReplacementMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
    TError,
    { patientId: string; data: ReplacementsCreatePatientReplacementBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
  TError,
  { patientId: string; data: ReplacementsCreatePatientReplacementBody },
  TContext
> => {
  const mutationKey = ["replacementsCreatePatientReplacement"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
    { patientId: string; data: ReplacementsCreatePatientReplacementBody }
  > = (props) => {
    const { patientId, data } = props ?? {};

    return replacementsCreatePatientReplacement(patientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReplacementsCreatePatientReplacementMutationResult = NonNullable<
  Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>
>;
export type ReplacementsCreatePatientReplacementMutationBody =
  ReplacementsCreatePatientReplacementBody;
export type ReplacementsCreatePatientReplacementMutationError = unknown;

/**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const useReplacementsCreatePatientReplacement = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
    TError,
    { patientId: string; data: ReplacementsCreatePatientReplacementBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
  TError,
  { patientId: string; data: ReplacementsCreatePatientReplacementBody },
  TContext
> => {
  const mutationOptions =
    getReplacementsCreatePatientReplacementMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Expected payload: { "status": "cancelled", "total_amount": 1000.0, "paid_amount": 500.0, "notes": "Updated notes" }
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const salesUpdateSalePartial = (patientId: string, saleId: string) => {
  return customInstance<void>({
    url: `/api/patients/${patientId}/sales/${saleId}`,
    method: "PATCH",
  });
};

export const getSalesUpdateSalePartialMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateSalePartial>>,
    TError,
    { patientId: string; saleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesUpdateSalePartial>>,
  TError,
  { patientId: string; saleId: string },
  TContext
> => {
  const mutationKey = ["salesUpdateSalePartial"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesUpdateSalePartial>>,
    { patientId: string; saleId: string }
  > = (props) => {
    const { patientId, saleId } = props ?? {};

    return salesUpdateSalePartial(patientId, saleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesUpdateSalePartialMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesUpdateSalePartial>>
>;

export type SalesUpdateSalePartialMutationError = unknown;

/**
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const useSalesUpdateSalePartial = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesUpdateSalePartial>>,
    TError,
    { patientId: string; saleId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesUpdateSalePartial>>,
  TError,
  { patientId: string; saleId: string },
  TContext
> => {
  const mutationOptions = getSalesUpdateSalePartialMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new payment record
 */
export const paymentsCreatePaymentRecord = (
  paymentsCreatePaymentRecordBody?: PaymentsCreatePaymentRecordBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/payment-records`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: paymentsCreatePaymentRecordBody,
    signal,
  });
};

export const getPaymentsCreatePaymentRecordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
    TError,
    { data: PaymentsCreatePaymentRecordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
  TError,
  { data: PaymentsCreatePaymentRecordBody },
  TContext
> => {
  const mutationKey = ["paymentsCreatePaymentRecord"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
    { data: PaymentsCreatePaymentRecordBody }
  > = (props) => {
    const { data } = props ?? {};

    return paymentsCreatePaymentRecord(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentsCreatePaymentRecordMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>
>;
export type PaymentsCreatePaymentRecordMutationBody =
  PaymentsCreatePaymentRecordBody;
export type PaymentsCreatePaymentRecordMutationError = unknown;

/**
 * @summary Create a new payment record
 */
export const usePaymentsCreatePaymentRecord = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
    TError,
    { data: PaymentsCreatePaymentRecordBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
  TError,
  { data: PaymentsCreatePaymentRecordBody },
  TContext
> => {
  const mutationOptions =
    getPaymentsCreatePaymentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update a payment record
 */
export const paymentsUpdatePaymentRecord = (recordId: string) => {
  return customInstance<void>({
    url: `/api/payment-records/${recordId}`,
    method: "PATCH",
  });
};

export const getPaymentsUpdatePaymentRecordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
    TError,
    { recordId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
  TError,
  { recordId: string },
  TContext
> => {
  const mutationKey = ["paymentsUpdatePaymentRecord"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
    { recordId: string }
  > = (props) => {
    const { recordId } = props ?? {};

    return paymentsUpdatePaymentRecord(recordId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentsUpdatePaymentRecordMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>
>;

export type PaymentsUpdatePaymentRecordMutationError = unknown;

/**
 * @summary Update a payment record
 */
export const usePaymentsUpdatePaymentRecord = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
    TError,
    { recordId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
  TError,
  { recordId: string },
  TContext
> => {
  const mutationOptions =
    getPaymentsUpdatePaymentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary List all permissions grouped by category
 */
export const permissionsListPermissions = (signal?: AbortSignal) => {
  return customInstance<PermissionsListPermissions200>({
    url: `/api/permissions`,
    method: "GET",
    signal,
  });
};

export const getPermissionsListPermissionsQueryKey = () => {
  return [`/api/permissions`] as const;
};

export const getPermissionsListPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionsListPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionsListPermissions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPermissionsListPermissionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionsListPermissions>>
  > = ({ signal }) => permissionsListPermissions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsListPermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionsListPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionsListPermissions>>
>;
export type PermissionsListPermissionsQueryError = unknown;

/**
 * @summary List all permissions grouped by category
 */

export function usePermissionsListPermissions<
  TData = Awaited<ReturnType<typeof permissionsListPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionsListPermissions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionsListPermissionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary POST /api/permissions
 */
export const permissionsCreatePermission = (
  permissionsCreatePermissionBody?: PermissionsCreatePermissionBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/permissions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: permissionsCreatePermissionBody,
    signal,
  });
};

export const getPermissionsCreatePermissionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof permissionsCreatePermission>>,
    TError,
    { data: PermissionsCreatePermissionBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof permissionsCreatePermission>>,
  TError,
  { data: PermissionsCreatePermissionBody },
  TContext
> => {
  const mutationKey = ["permissionsCreatePermission"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof permissionsCreatePermission>>,
    { data: PermissionsCreatePermissionBody }
  > = (props) => {
    const { data } = props ?? {};

    return permissionsCreatePermission(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PermissionsCreatePermissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof permissionsCreatePermission>>
>;
export type PermissionsCreatePermissionMutationBody =
  PermissionsCreatePermissionBody;
export type PermissionsCreatePermissionMutationError = unknown;

/**
 * @summary POST /api/permissions
 */
export const usePermissionsCreatePermission = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof permissionsCreatePermission>>,
    TError,
    { data: PermissionsCreatePermissionBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof permissionsCreatePermission>>,
  TError,
  { data: PermissionsCreatePermissionBody },
  TContext
> => {
  const mutationOptions =
    getPermissionsCreatePermissionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get current user's permissions based on their role
 */
export const permissionsGetMyPermissions = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/permissions/my`,
    method: "GET",
    signal,
  });
};

export const getPermissionsGetMyPermissionsQueryKey = () => {
  return [`/api/permissions/my`] as const;
};

export const getPermissionsGetMyPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPermissionsGetMyPermissionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionsGetMyPermissions>>
  > = ({ signal }) => permissionsGetMyPermissions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionsGetMyPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionsGetMyPermissions>>
>;
export type PermissionsGetMyPermissionsQueryError = unknown;

/**
 * @summary Get current user's permissions based on their role
 */

export function usePermissionsGetMyPermissions<
  TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionsGetMyPermissionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get permissions for a specific role
 */
export const permissionsGetRolePermissions = (
  roleName: string,
  signal?: AbortSignal,
) => {
  return customInstance<PermissionsGetRolePermissions200>({
    url: `/api/permissions/role/${roleName}`,
    method: "GET",
    signal,
  });
};

export const getPermissionsGetRolePermissionsQueryKey = (roleName?: string) => {
  return [`/api/permissions/role/${roleName}`] as const;
};

export const getPermissionsGetRolePermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
  TError = unknown,
>(
  roleName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPermissionsGetRolePermissionsQueryKey(roleName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionsGetRolePermissions>>
  > = ({ signal }) => permissionsGetRolePermissions(roleName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!roleName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PermissionsGetRolePermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionsGetRolePermissions>>
>;
export type PermissionsGetRolePermissionsQueryError = unknown;

/**
 * @summary Get permissions for a specific role
 */

export function usePermissionsGetRolePermissions<
  TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
  TError = unknown,
>(
  roleName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPermissionsGetRolePermissionsQueryOptions(
    roleName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update permissions for a role (bulk update)
 */
export const permissionsUpdateRolePermissions = (
  roleName: string,
  permissionsUpdateRolePermissionsBody?: PermissionsUpdateRolePermissionsBody,
) => {
  return customInstance<void>({
    url: `/api/permissions/role/${roleName}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: permissionsUpdateRolePermissionsBody,
  });
};

export const getPermissionsUpdateRolePermissionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
    TError,
    { roleName: string; data: PermissionsUpdateRolePermissionsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
  TError,
  { roleName: string; data: PermissionsUpdateRolePermissionsBody },
  TContext
> => {
  const mutationKey = ["permissionsUpdateRolePermissions"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
    { roleName: string; data: PermissionsUpdateRolePermissionsBody }
  > = (props) => {
    const { roleName, data } = props ?? {};

    return permissionsUpdateRolePermissions(roleName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PermissionsUpdateRolePermissionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>
>;
export type PermissionsUpdateRolePermissionsMutationBody =
  PermissionsUpdateRolePermissionsBody;
export type PermissionsUpdateRolePermissionsMutationError = unknown;

/**
 * @summary Update permissions for a role (bulk update)
 */
export const usePermissionsUpdateRolePermissions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
    TError,
    { roleName: string; data: PermissionsUpdateRolePermissionsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
  TError,
  { roleName: string; data: PermissionsUpdateRolePermissionsBody },
  TContext
> => {
  const mutationOptions =
    getPermissionsUpdateRolePermissionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new plan (Super Admin only)
 */
export const plansCreatePlan = (
  plansCreatePlanBody?: PlansCreatePlanBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/plans`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: plansCreatePlanBody,
    signal,
  });
};

export const getPlansCreatePlanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof plansCreatePlan>>,
    TError,
    { data: PlansCreatePlanBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof plansCreatePlan>>,
  TError,
  { data: PlansCreatePlanBody },
  TContext
> => {
  const mutationKey = ["plansCreatePlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof plansCreatePlan>>,
    { data: PlansCreatePlanBody }
  > = (props) => {
    const { data } = props ?? {};

    return plansCreatePlan(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlansCreatePlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof plansCreatePlan>>
>;
export type PlansCreatePlanMutationBody = PlansCreatePlanBody;
export type PlansCreatePlanMutationError = unknown;

/**
 * @summary Create a new plan (Super Admin only)
 */
export const usePlansCreatePlan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof plansCreatePlan>>,
    TError,
    { data: PlansCreatePlanBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof plansCreatePlan>>,
  TError,
  { data: PlansCreatePlanBody },
  TContext
> => {
  const mutationOptions = getPlansCreatePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all plans for admin (including inactive/private)
 */
export const plansGetAdminPlans = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/plans/admin`,
    method: "GET",
    signal,
  });
};

export const getPlansGetAdminPlansQueryKey = () => {
  return [`/api/plans/admin`] as const;
};

export const getPlansGetAdminPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof plansGetAdminPlans>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof plansGetAdminPlans>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlansGetAdminPlansQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof plansGetAdminPlans>>
  > = ({ signal }) => plansGetAdminPlans(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof plansGetAdminPlans>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PlansGetAdminPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof plansGetAdminPlans>>
>;
export type PlansGetAdminPlansQueryError = unknown;

/**
 * @summary Get all plans for admin (including inactive/private)
 */

export function usePlansGetAdminPlans<
  TData = Awaited<ReturnType<typeof plansGetAdminPlans>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof plansGetAdminPlans>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPlansGetAdminPlansQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a plan (Super Admin only)
 */
export const plansUpdatePlan = (
  planId: string,
  plansUpdatePlanBody?: PlansUpdatePlanBody,
) => {
  return customInstance<void>({
    url: `/api/plans/${planId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: plansUpdatePlanBody,
  });
};

export const getPlansUpdatePlanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof plansUpdatePlan>>,
    TError,
    { planId: string; data: PlansUpdatePlanBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof plansUpdatePlan>>,
  TError,
  { planId: string; data: PlansUpdatePlanBody },
  TContext
> => {
  const mutationKey = ["plansUpdatePlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof plansUpdatePlan>>,
    { planId: string; data: PlansUpdatePlanBody }
  > = (props) => {
    const { planId, data } = props ?? {};

    return plansUpdatePlan(planId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlansUpdatePlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof plansUpdatePlan>>
>;
export type PlansUpdatePlanMutationBody = PlansUpdatePlanBody;
export type PlansUpdatePlanMutationError = unknown;

/**
 * @summary Update a plan (Super Admin only)
 */
export const usePlansUpdatePlan = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof plansUpdatePlan>>,
    TError,
    { planId: string; data: PlansUpdatePlanBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof plansUpdatePlan>>,
  TError,
  { planId: string; data: PlansUpdatePlanBody },
  TContext
> => {
  const mutationOptions = getPlansUpdatePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new proforma
 */
export const proformasCreateProforma = (
  proformasCreateProformaBody?: ProformasCreateProformaBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/proformas`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: proformasCreateProformaBody,
    signal,
  });
};

export const getProformasCreateProformaMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof proformasCreateProforma>>,
    TError,
    { data: ProformasCreateProformaBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof proformasCreateProforma>>,
  TError,
  { data: ProformasCreateProformaBody },
  TContext
> => {
  const mutationKey = ["proformasCreateProforma"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof proformasCreateProforma>>,
    { data: ProformasCreateProformaBody }
  > = (props) => {
    const { data } = props ?? {};

    return proformasCreateProforma(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProformasCreateProformaMutationResult = NonNullable<
  Awaited<ReturnType<typeof proformasCreateProforma>>
>;
export type ProformasCreateProformaMutationBody = ProformasCreateProformaBody;
export type ProformasCreateProformaMutationError = unknown;

/**
 * @summary Create a new proforma
 */
export const useProformasCreateProforma = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof proformasCreateProforma>>,
    TError,
    { data: ProformasCreateProformaBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof proformasCreateProforma>>,
  TError,
  { data: ProformasCreateProformaBody },
  TContext
> => {
  const mutationOptions = getProformasCreateProformaMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get a specific proforma
 */
export const proformasGetProforma = (
  proformaId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/proformas/${proformaId}`,
    method: "GET",
    signal,
  });
};

export const getProformasGetProformaQueryKey = (proformaId?: string) => {
  return [`/api/proformas/${proformaId}`] as const;
};

export const getProformasGetProformaQueryOptions = <
  TData = Awaited<ReturnType<typeof proformasGetProforma>>,
  TError = unknown,
>(
  proformaId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof proformasGetProforma>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getProformasGetProformaQueryKey(proformaId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof proformasGetProforma>>
  > = ({ signal }) => proformasGetProforma(proformaId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!proformaId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof proformasGetProforma>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ProformasGetProformaQueryResult = NonNullable<
  Awaited<ReturnType<typeof proformasGetProforma>>
>;
export type ProformasGetProformaQueryError = unknown;

/**
 * @summary Get a specific proforma
 */

export function useProformasGetProforma<
  TData = Awaited<ReturnType<typeof proformasGetProforma>>,
  TError = unknown,
>(
  proformaId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof proformasGetProforma>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getProformasGetProformaQueryOptions(proformaId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const proformasConvertProformaToSale = (
  proformaId: string,
  proformasConvertProformaToSaleBody?: ProformasConvertProformaToSaleBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/proformas/${proformaId}/convert`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: proformasConvertProformaToSaleBody,
    signal,
  });
};

export const getProformasConvertProformaToSaleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
    TError,
    { proformaId: string; data: ProformasConvertProformaToSaleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
  TError,
  { proformaId: string; data: ProformasConvertProformaToSaleBody },
  TContext
> => {
  const mutationKey = ["proformasConvertProformaToSale"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
    { proformaId: string; data: ProformasConvertProformaToSaleBody }
  > = (props) => {
    const { proformaId, data } = props ?? {};

    return proformasConvertProformaToSale(proformaId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProformasConvertProformaToSaleMutationResult = NonNullable<
  Awaited<ReturnType<typeof proformasConvertProformaToSale>>
>;
export type ProformasConvertProformaToSaleMutationBody =
  ProformasConvertProformaToSaleBody;
export type ProformasConvertProformaToSaleMutationError = unknown;

/**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const useProformasConvertProformaToSale = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
    TError,
    { proformaId: string; data: ProformasConvertProformaToSaleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
  TError,
  { proformaId: string; data: ProformasConvertProformaToSaleBody },
  TContext
> => {
  const mutationOptions =
    getProformasConvertProformaToSaleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary GET /api/replacements/{replacement_id}
 */
export const replacementsGetReplacement = (
  replacementId: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/replacements/${replacementId}`,
    method: "GET",
    signal,
  });
};

export const getReplacementsGetReplacementQueryKey = (
  replacementId?: string,
) => {
  return [`/api/replacements/${replacementId}`] as const;
};

export const getReplacementsGetReplacementQueryOptions = <
  TData = Awaited<ReturnType<typeof replacementsGetReplacement>>,
  TError = unknown,
>(
  replacementId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof replacementsGetReplacement>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getReplacementsGetReplacementQueryKey(replacementId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof replacementsGetReplacement>>
  > = ({ signal }) => replacementsGetReplacement(replacementId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!replacementId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof replacementsGetReplacement>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReplacementsGetReplacementQueryResult = NonNullable<
  Awaited<ReturnType<typeof replacementsGetReplacement>>
>;
export type ReplacementsGetReplacementQueryError = unknown;

/**
 * @summary GET /api/replacements/{replacement_id}
 */

export function useReplacementsGetReplacement<
  TData = Awaited<ReturnType<typeof replacementsGetReplacement>>,
  TError = unknown,
>(
  replacementId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof replacementsGetReplacement>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReplacementsGetReplacementQueryOptions(
    replacementId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * This implementation stores invoice metadata on the Replacement row (legacy-compatible).
 * @summary Create a supplier return invoice record linked to a replacement.
 */
export const replacementsCreateReturnInvoice = (
  replacementId: string,
  replacementsCreateReturnInvoiceBody?: ReplacementsCreateReturnInvoiceBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/replacements/${replacementId}/invoice`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: replacementsCreateReturnInvoiceBody,
    signal,
  });
};

export const getReplacementsCreateReturnInvoiceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
    TError,
    { replacementId: string; data: ReplacementsCreateReturnInvoiceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
  TError,
  { replacementId: string; data: ReplacementsCreateReturnInvoiceBody },
  TContext
> => {
  const mutationKey = ["replacementsCreateReturnInvoice"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
    { replacementId: string; data: ReplacementsCreateReturnInvoiceBody }
  > = (props) => {
    const { replacementId, data } = props ?? {};

    return replacementsCreateReturnInvoice(replacementId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReplacementsCreateReturnInvoiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>
>;
export type ReplacementsCreateReturnInvoiceMutationBody =
  ReplacementsCreateReturnInvoiceBody;
export type ReplacementsCreateReturnInvoiceMutationError = unknown;

/**
 * @summary Create a supplier return invoice record linked to a replacement.
 */
export const useReplacementsCreateReturnInvoice = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
    TError,
    { replacementId: string; data: ReplacementsCreateReturnInvoiceBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
  TError,
  { replacementId: string; data: ReplacementsCreateReturnInvoiceBody },
  TContext
> => {
  const mutationOptions =
    getReplacementsCreateReturnInvoiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary PATCH /api/replacements/{replacement_id}/status
 */
export const replacementsPatchReplacementStatus = (replacementId: string) => {
  return customInstance<void>({
    url: `/api/replacements/${replacementId}/status`,
    method: "PATCH",
  });
};

export const getReplacementsPatchReplacementStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
    TError,
    { replacementId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
  TError,
  { replacementId: string },
  TContext
> => {
  const mutationKey = ["replacementsPatchReplacementStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
    { replacementId: string }
  > = (props) => {
    const { replacementId } = props ?? {};

    return replacementsPatchReplacementStatus(replacementId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReplacementsPatchReplacementStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>
>;

export type ReplacementsPatchReplacementStatusMutationError = unknown;

/**
 * @summary PATCH /api/replacements/{replacement_id}/status
 */
export const useReplacementsPatchReplacementStatus = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
    TError,
    { replacementId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
  TError,
  { replacementId: string },
  TContext
> => {
  const mutationOptions =
    getReplacementsPatchReplacementStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Kasa Ã¶zeti raporu - tahsilatlar (Sales tabanlÄ±)
 */
export const reportsReportCashflowSummary = (
  params?: ReportsReportCashflowSummaryParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/reports/cashflow-summary`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportsReportCashflowSummaryQueryKey = (
  params?: ReportsReportCashflowSummaryParams,
) => {
  return [
    `/api/reports/cashflow-summary`,
    ...(params ? [params] : []),
  ] as const;
};

export const getReportsReportCashflowSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
  TError = unknown,
>(
  params?: ReportsReportCashflowSummaryParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportCashflowSummaryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportCashflowSummary>>
  > = ({ signal }) => reportsReportCashflowSummary(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportCashflowSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportCashflowSummary>>
>;
export type ReportsReportCashflowSummaryQueryError = unknown;

/**
 * @summary Kasa Ã¶zeti raporu - tahsilatlar (Sales tabanlÄ±)
 */

export function useReportsReportCashflowSummary<
  TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
  TError = unknown,
>(
  params?: ReportsReportCashflowSummaryParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportCashflowSummaryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Senet raporlarÄ± - aylÄ±k sayÄ±, gelir ve Ã¶zet
 */
export const reportsReportPromissoryNotes = (
  params?: ReportsReportPromissoryNotesParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/reports/promissory-notes`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportsReportPromissoryNotesQueryKey = (
  params?: ReportsReportPromissoryNotesParams,
) => {
  return [
    `/api/reports/promissory-notes`,
    ...(params ? [params] : []),
  ] as const;
};

export const getReportsReportPromissoryNotesQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportPromissoryNotesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportPromissoryNotes>>
  > = ({ signal }) => reportsReportPromissoryNotes(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportPromissoryNotesQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportPromissoryNotes>>
>;
export type ReportsReportPromissoryNotesQueryError = unknown;

/**
 * @summary Senet raporlarÄ± - aylÄ±k sayÄ±, gelir ve Ã¶zet
 */

export function useReportsReportPromissoryNotes<
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportPromissoryNotesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Hasta bazlÄ± senet Ã¶zeti - hangi hastanÄ±n kaÃ§ senedi kalmÄ±ÅŸ
 */
export const reportsReportPromissoryNotesByPatient = (
  params?: ReportsReportPromissoryNotesByPatientParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/reports/promissory-notes/by-patient`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportsReportPromissoryNotesByPatientQueryKey = (
  params?: ReportsReportPromissoryNotesByPatientParams,
) => {
  return [
    `/api/reports/promissory-notes/by-patient`,
    ...(params ? [params] : []),
  ] as const;
};

export const getReportsReportPromissoryNotesByPatientQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesByPatientParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getReportsReportPromissoryNotesByPatientQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>
  > = ({ signal }) => reportsReportPromissoryNotesByPatient(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportPromissoryNotesByPatientQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>
>;
export type ReportsReportPromissoryNotesByPatientQueryError = unknown;

/**
 * @summary Hasta bazlÄ± senet Ã¶zeti - hangi hastanÄ±n kaÃ§ senedi kalmÄ±ÅŸ
 */

export function useReportsReportPromissoryNotesByPatient<
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesByPatientParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportPromissoryNotesByPatientQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Toplu senet listesi - modal iÃ§in
 */
export const reportsReportPromissoryNotesList = (
  params?: ReportsReportPromissoryNotesListParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/reports/promissory-notes/list`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportsReportPromissoryNotesListQueryKey = (
  params?: ReportsReportPromissoryNotesListParams,
) => {
  return [
    `/api/reports/promissory-notes/list`,
    ...(params ? [params] : []),
  ] as const;
};

export const getReportsReportPromissoryNotesListQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getReportsReportPromissoryNotesListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>
  > = ({ signal }) => reportsReportPromissoryNotesList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportPromissoryNotesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>
>;
export type ReportsReportPromissoryNotesListQueryError = unknown;

/**
 * @summary Toplu senet listesi - modal iÃ§in
 */

export function useReportsReportPromissoryNotesList<
  TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
  TError = unknown,
>(
  params?: ReportsReportPromissoryNotesListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportPromissoryNotesListQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Kalan Ã¶demeler raporu - hangi hastanÄ±n ne kadar Ã¶demesi kalmÄ±ÅŸ
 */
export const reportsReportRemainingPayments = (
  params?: ReportsReportRemainingPaymentsParams,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/reports/remaining-payments`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportsReportRemainingPaymentsQueryKey = (
  params?: ReportsReportRemainingPaymentsParams,
) => {
  return [
    `/api/reports/remaining-payments`,
    ...(params ? [params] : []),
  ] as const;
};

export const getReportsReportRemainingPaymentsQueryOptions = <
  TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
  TError = unknown,
>(
  params?: ReportsReportRemainingPaymentsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportsReportRemainingPaymentsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportsReportRemainingPayments>>
  > = ({ signal }) => reportsReportRemainingPayments(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ReportsReportRemainingPaymentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportsReportRemainingPayments>>
>;
export type ReportsReportRemainingPaymentsQueryError = unknown;

/**
 * @summary Kalan Ã¶demeler raporu - hangi hastanÄ±n ne kadar Ã¶demesi kalmÄ±ÅŸ
 */

export function useReportsReportRemainingPayments<
  TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
  TError = unknown,
>(
  params?: ReportsReportRemainingPaymentsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getReportsReportRemainingPaymentsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Here we mark gib_sent and update replacement status. Actual EFatura/GÄ°B integration should be added server-side.
 * @summary Mark return invoice as sent to GIB. In legacy flow GÄ°B send triggers replacement completion and stock effects.
 */
export const replacementsSendInvoiceToGib = (
  invoiceId: string,
  replacementsSendInvoiceToGibBody?: ReplacementsSendInvoiceToGibBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/return-invoices/${invoiceId}/send-to-gib`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: replacementsSendInvoiceToGibBody,
    signal,
  });
};

export const getReplacementsSendInvoiceToGibMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
    TError,
    { invoiceId: string; data: ReplacementsSendInvoiceToGibBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
  TError,
  { invoiceId: string; data: ReplacementsSendInvoiceToGibBody },
  TContext
> => {
  const mutationKey = ["replacementsSendInvoiceToGib"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
    { invoiceId: string; data: ReplacementsSendInvoiceToGibBody }
  > = (props) => {
    const { invoiceId, data } = props ?? {};

    return replacementsSendInvoiceToGib(invoiceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReplacementsSendInvoiceToGibMutationResult = NonNullable<
  Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>
>;
export type ReplacementsSendInvoiceToGibMutationBody =
  ReplacementsSendInvoiceToGibBody;
export type ReplacementsSendInvoiceToGibMutationError = unknown;

/**
 * @summary Mark return invoice as sent to GIB. In legacy flow GÄ°B send triggers replacement completion and stock effects.
 */
export const useReplacementsSendInvoiceToGib = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
    TError,
    { invoiceId: string; data: ReplacementsSendInvoiceToGibBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
  TError,
  { invoiceId: string; data: ReplacementsSendInvoiceToGibBody },
  TContext
> => {
  const mutationOptions =
    getReplacementsSendInvoiceToGibMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/roles
 */
export const rolesCreateRole = (
  rolesCreateRoleBody?: RolesCreateRoleBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/roles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: rolesCreateRoleBody,
    signal,
  });
};

export const getRolesCreateRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesCreateRole>>,
    TError,
    { data: RolesCreateRoleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rolesCreateRole>>,
  TError,
  { data: RolesCreateRoleBody },
  TContext
> => {
  const mutationKey = ["rolesCreateRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rolesCreateRole>>,
    { data: RolesCreateRoleBody }
  > = (props) => {
    const { data } = props ?? {};

    return rolesCreateRole(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RolesCreateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof rolesCreateRole>>
>;
export type RolesCreateRoleMutationBody = RolesCreateRoleBody;
export type RolesCreateRoleMutationError = unknown;

/**
 * @summary POST /api/roles
 */
export const useRolesCreateRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesCreateRole>>,
    TError,
    { data: RolesCreateRoleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof rolesCreateRole>>,
  TError,
  { data: RolesCreateRoleBody },
  TContext
> => {
  const mutationOptions = getRolesCreateRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary DELETE /api/roles/{role_id}
 */
export const rolesDeleteRole = (roleId: string) => {
  return customInstance<void>({
    url: `/api/roles/${roleId}`,
    method: "DELETE",
  });
};

export const getRolesDeleteRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesDeleteRole>>,
    TError,
    { roleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rolesDeleteRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationKey = ["rolesDeleteRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rolesDeleteRole>>,
    { roleId: string }
  > = (props) => {
    const { roleId } = props ?? {};

    return rolesDeleteRole(roleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RolesDeleteRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof rolesDeleteRole>>
>;

export type RolesDeleteRoleMutationError = unknown;

/**
 * @summary DELETE /api/roles/{role_id}
 */
export const useRolesDeleteRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesDeleteRole>>,
    TError,
    { roleId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof rolesDeleteRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationOptions = getRolesDeleteRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const rolesAddPermissionToRole = (
  roleId: string,
  rolesAddPermissionToRoleBody?: RolesAddPermissionToRoleBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/roles/${roleId}/permissions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: rolesAddPermissionToRoleBody,
    signal,
  });
};

export const getRolesAddPermissionToRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
    TError,
    { roleId: string; data: RolesAddPermissionToRoleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
  TError,
  { roleId: string; data: RolesAddPermissionToRoleBody },
  TContext
> => {
  const mutationKey = ["rolesAddPermissionToRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
    { roleId: string; data: RolesAddPermissionToRoleBody }
  > = (props) => {
    const { roleId, data } = props ?? {};

    return rolesAddPermissionToRole(roleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RolesAddPermissionToRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof rolesAddPermissionToRole>>
>;
export type RolesAddPermissionToRoleMutationBody = RolesAddPermissionToRoleBody;
export type RolesAddPermissionToRoleMutationError = unknown;

/**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const useRolesAddPermissionToRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
    TError,
    { roleId: string; data: RolesAddPermissionToRoleBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
  TError,
  { roleId: string; data: RolesAddPermissionToRoleBody },
  TContext
> => {
  const mutationOptions = getRolesAddPermissionToRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const rolesRemovePermissionFromRole = (
  roleId: string,
  permissionId: string,
) => {
  return customInstance<void>({
    url: `/api/roles/${roleId}/permissions/${permissionId}`,
    method: "DELETE",
  });
};

export const getRolesRemovePermissionFromRoleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
    TError,
    { roleId: string; permissionId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
  TError,
  { roleId: string; permissionId: string },
  TContext
> => {
  const mutationKey = ["rolesRemovePermissionFromRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
    { roleId: string; permissionId: string }
  > = (props) => {
    const { roleId, permissionId } = props ?? {};

    return rolesRemovePermissionFromRole(roleId, permissionId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RolesRemovePermissionFromRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>
>;

export type RolesRemovePermissionFromRoleMutationError = unknown;

/**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const useRolesRemovePermissionFromRole = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
    TError,
    { roleId: string; permissionId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
  TError,
  { roleId: string; permissionId: string },
  TContext
> => {
  const mutationOptions =
    getRolesRemovePermissionFromRoleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a sales log entry for cashflow.html page
 */
export const salesCreateSalesLog = (
  salesCreateSalesLogBody?: SalesCreateSalesLogBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sales/logs`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesCreateSalesLogBody,
    signal,
  });
};

export const getSalesCreateSalesLogMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSalesLog>>,
    TError,
    { data: SalesCreateSalesLogBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesCreateSalesLog>>,
  TError,
  { data: SalesCreateSalesLogBody },
  TContext
> => {
  const mutationKey = ["salesCreateSalesLog"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesCreateSalesLog>>,
    { data: SalesCreateSalesLogBody }
  > = (props) => {
    const { data } = props ?? {};

    return salesCreateSalesLog(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesCreateSalesLogMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesCreateSalesLog>>
>;
export type SalesCreateSalesLogMutationBody = SalesCreateSalesLogBody;
export type SalesCreateSalesLogMutationError = unknown;

/**
 * @summary Create a sales log entry for cashflow.html page
 */
export const useSalesCreateSalesLog = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesCreateSalesLog>>,
    TError,
    { data: SalesCreateSalesLogBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesCreateSalesLog>>,
  TError,
  { data: SalesCreateSalesLogBody },
  TContext
> => {
  const mutationOptions = getSalesCreateSalesLogMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ä°steÄŸe baÄŸlÄ± filtreler: body veya query iÃ§inde `patientId`, `saleId`, `limit`.
 * @summary SatÄ±ÅŸ kayÄ±tlarÄ±nÄ±n SGK ve hasta Ã¶deme tutarlarÄ±nÄ± yeniden hesaplarken kalÄ±cÄ± olarak gÃ¼nceller.
 */
export const salesRecalcSales = (
  salesRecalcSalesBody?: SalesRecalcSalesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sales/recalc`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesRecalcSalesBody,
    signal,
  });
};

export const getSalesRecalcSalesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesRecalcSales>>,
    TError,
    { data: SalesRecalcSalesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesRecalcSales>>,
  TError,
  { data: SalesRecalcSalesBody },
  TContext
> => {
  const mutationKey = ["salesRecalcSales"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesRecalcSales>>,
    { data: SalesRecalcSalesBody }
  > = (props) => {
    const { data } = props ?? {};

    return salesRecalcSales(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesRecalcSalesMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesRecalcSales>>
>;
export type SalesRecalcSalesMutationBody = SalesRecalcSalesBody;
export type SalesRecalcSalesMutationError = unknown;

/**
 * @summary SatÄ±ÅŸ kayÄ±tlarÄ±nÄ±n SGK ve hasta Ã¶deme tutarlarÄ±nÄ± yeniden hesaplarken kalÄ±cÄ± olarak gÃ¼nceller.
 */
export const useSalesRecalcSales = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesRecalcSales>>,
    TError,
    { data: SalesRecalcSalesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesRecalcSales>>,
  TError,
  { data: SalesRecalcSalesBody },
  TContext
> => {
  const mutationOptions = getSalesRecalcSalesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Pay a specific installment
 */
export const salesPayInstallment = (
  saleId: string,
  installmentId: string,
  salesPayInstallmentBody?: SalesPayInstallmentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sales/${saleId}/installments/${installmentId}/pay`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesPayInstallmentBody,
    signal,
  });
};

export const getSalesPayInstallmentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesPayInstallment>>,
    TError,
    { saleId: string; installmentId: string; data: SalesPayInstallmentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesPayInstallment>>,
  TError,
  { saleId: string; installmentId: string; data: SalesPayInstallmentBody },
  TContext
> => {
  const mutationKey = ["salesPayInstallment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesPayInstallment>>,
    { saleId: string; installmentId: string; data: SalesPayInstallmentBody }
  > = (props) => {
    const { saleId, installmentId, data } = props ?? {};

    return salesPayInstallment(saleId, installmentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesPayInstallmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesPayInstallment>>
>;
export type SalesPayInstallmentMutationBody = SalesPayInstallmentBody;
export type SalesPayInstallmentMutationError = unknown;

/**
 * @summary Pay a specific installment
 */
export const useSalesPayInstallment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesPayInstallment>>,
    TError,
    { saleId: string; installmentId: string; data: SalesPayInstallmentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesPayInstallment>>,
  TError,
  { saleId: string; installmentId: string; data: SalesPayInstallmentBody },
  TContext
> => {
  const mutationOptions = getSalesPayInstallmentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Record a new payment for a sale
 */
export const salesRecordSalePayment = (
  saleId: string,
  salesRecordSalePaymentBody?: SalesRecordSalePaymentBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sales/${saleId}/payments`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: salesRecordSalePaymentBody,
    signal,
  });
};

export const getSalesRecordSalePaymentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesRecordSalePayment>>,
    TError,
    { saleId: string; data: SalesRecordSalePaymentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof salesRecordSalePayment>>,
  TError,
  { saleId: string; data: SalesRecordSalePaymentBody },
  TContext
> => {
  const mutationKey = ["salesRecordSalePayment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof salesRecordSalePayment>>,
    { saleId: string; data: SalesRecordSalePaymentBody }
  > = (props) => {
    const { saleId, data } = props ?? {};

    return salesRecordSalePayment(saleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SalesRecordSalePaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof salesRecordSalePayment>>
>;
export type SalesRecordSalePaymentMutationBody = SalesRecordSalePaymentBody;
export type SalesRecordSalePaymentMutationError = unknown;

/**
 * @summary Record a new payment for a sale
 */
export const useSalesRecordSalePayment = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof salesRecordSalePayment>>,
    TError,
    { saleId: string; data: SalesRecordSalePaymentBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof salesRecordSalePayment>>,
  TError,
  { saleId: string; data: SalesRecordSalePaymentBody },
  TContext
> => {
  const mutationOptions = getSalesRecordSalePaymentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get pricing settings specifically
 */
export const getPricingSettings = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/settings/pricing`,
    method: "GET",
    signal,
  });
};

export const getGetPricingSettingsQueryKey = () => {
  return [`/api/settings/pricing`] as const;
};

export const getGetPricingSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPricingSettings>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getPricingSettings>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPricingSettingsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPricingSettings>>
  > = ({ signal }) => getPricingSettings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPricingSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPricingSettingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPricingSettings>>
>;
export type GetPricingSettingsQueryError = unknown;

/**
 * @summary Get pricing settings specifically
 */

export function useGetPricingSettings<
  TData = Awaited<ReturnType<typeof getPricingSettings>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getPricingSettings>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPricingSettingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary E-reÃ§ete sorgulama endpoint'i
 */
export const sgkQueryEReceipt = (
  sgkQueryEReceiptBody?: SgkQueryEReceiptBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/e-receipt/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkQueryEReceiptBody,
    signal,
  });
};

export const getSgkQueryEReceiptMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkQueryEReceipt>>,
    TError,
    { data: SgkQueryEReceiptBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkQueryEReceipt>>,
  TError,
  { data: SgkQueryEReceiptBody },
  TContext
> => {
  const mutationKey = ["sgkQueryEReceipt"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkQueryEReceipt>>,
    { data: SgkQueryEReceiptBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkQueryEReceipt(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkQueryEReceiptMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkQueryEReceipt>>
>;
export type SgkQueryEReceiptMutationBody = SgkQueryEReceiptBody;
export type SgkQueryEReceiptMutationError = unknown;

/**
 * @summary E-reÃ§ete sorgulama endpoint'i
 */
export const useSgkQueryEReceipt = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkQueryEReceipt>>,
    TError,
    { data: SgkQueryEReceiptBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkQueryEReceipt>>,
  TError,
  { data: SgkQueryEReceiptBody },
  TContext
> => {
  const mutationOptions = getSgkQueryEReceiptMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary SGK hasta haklarÄ± sorgulama endpoint'i
 */
export const sgkQueryPatientRights = (
  sgkQueryPatientRightsBody?: SgkQueryPatientRightsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/patient-rights/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkQueryPatientRightsBody,
    signal,
  });
};

export const getSgkQueryPatientRightsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkQueryPatientRights>>,
    TError,
    { data: SgkQueryPatientRightsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkQueryPatientRights>>,
  TError,
  { data: SgkQueryPatientRightsBody },
  TContext
> => {
  const mutationKey = ["sgkQueryPatientRights"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkQueryPatientRights>>,
    { data: SgkQueryPatientRightsBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkQueryPatientRights(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkQueryPatientRightsMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkQueryPatientRights>>
>;
export type SgkQueryPatientRightsMutationBody = SgkQueryPatientRightsBody;
export type SgkQueryPatientRightsMutationError = unknown;

/**
 * @summary SGK hasta haklarÄ± sorgulama endpoint'i
 */
export const useSgkQueryPatientRights = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkQueryPatientRights>>,
    TError,
    { data: SgkQueryPatientRightsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkQueryPatientRights>>,
  TError,
  { data: SgkQueryPatientRightsBody },
  TContext
> => {
  const mutationOptions = getSgkQueryPatientRightsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const sgkSeedTestPatients = (
  sgkSeedTestPatientsBody?: SgkSeedTestPatientsBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/seed-test-patients`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkSeedTestPatientsBody,
    signal,
  });
};

export const getSgkSeedTestPatientsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkSeedTestPatients>>,
    TError,
    { data: SgkSeedTestPatientsBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkSeedTestPatients>>,
  TError,
  { data: SgkSeedTestPatientsBody },
  TContext
> => {
  const mutationKey = ["sgkSeedTestPatients"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkSeedTestPatients>>,
    { data: SgkSeedTestPatientsBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkSeedTestPatients(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkSeedTestPatientsMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkSeedTestPatients>>
>;
export type SgkSeedTestPatientsMutationBody = SgkSeedTestPatientsBody;
export type SgkSeedTestPatientsMutationError = unknown;

/**
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const useSgkSeedTestPatients = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkSeedTestPatients>>,
    TError,
    { data: SgkSeedTestPatientsBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkSeedTestPatients>>,
  TError,
  { data: SgkSeedTestPatientsBody },
  TContext
> => {
  const mutationOptions = getSgkSeedTestPatientsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Saves files to a secure temporary path, runs OCR (worker-first) with auto_crop=True
and returns per-file OCR results including patient_info.
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const sgkUploadAndProcessFiles = (
  sgkUploadAndProcessFilesBody?: SgkUploadAndProcessFilesBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkUploadAndProcessFilesBody,
    signal,
  });
};

export const getSgkUploadAndProcessFilesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
    TError,
    { data: SgkUploadAndProcessFilesBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
  TError,
  { data: SgkUploadAndProcessFilesBody },
  TContext
> => {
  const mutationKey = ["sgkUploadAndProcessFiles"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
    { data: SgkUploadAndProcessFilesBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkUploadAndProcessFiles(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkUploadAndProcessFilesMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>
>;
export type SgkUploadAndProcessFilesMutationBody = SgkUploadAndProcessFilesBody;
export type SgkUploadAndProcessFilesMutationError = unknown;

/**
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const useSgkUploadAndProcessFiles = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
    TError,
    { data: SgkUploadAndProcessFilesBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
  TError,
  { data: SgkUploadAndProcessFilesBody },
  TContext
> => {
  const mutationOptions = getSgkUploadAndProcessFilesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary SGK workflow oluÅŸturma endpoint'i
 */
export const sgkCreateSgkWorkflow = (
  sgkCreateSgkWorkflowBody?: SgkCreateSgkWorkflowBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sgk/workflow/create`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sgkCreateSgkWorkflowBody,
    signal,
  });
};

export const getSgkCreateSgkWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
    TError,
    { data: SgkCreateSgkWorkflowBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
  TError,
  { data: SgkCreateSgkWorkflowBody },
  TContext
> => {
  const mutationKey = ["sgkCreateSgkWorkflow"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
    { data: SgkCreateSgkWorkflowBody }
  > = (props) => {
    const { data } = props ?? {};

    return sgkCreateSgkWorkflow(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkCreateSgkWorkflowMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>
>;
export type SgkCreateSgkWorkflowMutationBody = SgkCreateSgkWorkflowBody;
export type SgkCreateSgkWorkflowMutationError = unknown;

/**
 * @summary SGK workflow oluÅŸturma endpoint'i
 */
export const useSgkCreateSgkWorkflow = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
    TError,
    { data: SgkCreateSgkWorkflowBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
  TError,
  { data: SgkCreateSgkWorkflowBody },
  TContext
> => {
  const mutationOptions = getSgkCreateSgkWorkflowMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary SGK workflow detaylarÄ± endpoint'i
 */
export const sgkGetSgkWorkflow = (workflowId: string, signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/sgk/workflow/${workflowId}`,
    method: "GET",
    signal,
  });
};

export const getSgkGetSgkWorkflowQueryKey = (workflowId?: string) => {
  return [`/api/sgk/workflow/${workflowId}`] as const;
};

export const getSgkGetSgkWorkflowQueryOptions = <
  TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
  TError = unknown,
>(
  workflowId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSgkGetSgkWorkflowQueryKey(workflowId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
  > = ({ signal }) => sgkGetSgkWorkflow(workflowId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!workflowId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SgkGetSgkWorkflowQueryResult = NonNullable<
  Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
>;
export type SgkGetSgkWorkflowQueryError = unknown;

/**
 * @summary SGK workflow detaylarÄ± endpoint'i
 */

export function useSgkGetSgkWorkflow<
  TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
  TError = unknown,
>(
  workflowId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSgkGetSgkWorkflowQueryOptions(workflowId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary SGK workflow gÃ¼ncelleme endpoint'i
 */
export const sgkUpdateSgkWorkflow = (
  workflowId: string,
  sgkUpdateSgkWorkflowBody?: SgkUpdateSgkWorkflowBody,
) => {
  return customInstance<void>({
    url: `/api/sgk/workflow/${workflowId}/update`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: sgkUpdateSgkWorkflowBody,
  });
};

export const getSgkUpdateSgkWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
    TError,
    { workflowId: string; data: SgkUpdateSgkWorkflowBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
  TError,
  { workflowId: string; data: SgkUpdateSgkWorkflowBody },
  TContext
> => {
  const mutationKey = ["sgkUpdateSgkWorkflow"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
    { workflowId: string; data: SgkUpdateSgkWorkflowBody }
  > = (props) => {
    const { workflowId, data } = props ?? {};

    return sgkUpdateSgkWorkflow(workflowId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkUpdateSgkWorkflowMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>
>;
export type SgkUpdateSgkWorkflowMutationBody = SgkUpdateSgkWorkflowBody;
export type SgkUpdateSgkWorkflowMutationError = unknown;

/**
 * @summary SGK workflow gÃ¼ncelleme endpoint'i
 */
export const useSgkUpdateSgkWorkflow = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
    TError,
    { workflowId: string; data: SgkUpdateSgkWorkflowBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
  TError,
  { workflowId: string; data: SgkUpdateSgkWorkflowBody },
  TContext
> => {
  const mutationOptions = getSgkUpdateSgkWorkflowMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Upload SMS Document to S3
 */
export const smsUploadDocumentV2 = (
  smsUploadDocumentV2Body: SmsUploadDocumentV2Body,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`file`, smsUploadDocumentV2Body.file);
  formData.append(`documentType`, smsUploadDocumentV2Body.documentType);

  return customInstance<SmsUploadDocumentV2200>({
    url: `/api/sms/documents/upload`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getSmsUploadDocumentV2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocumentV2>>,
    TError,
    { data: SmsUploadDocumentV2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsUploadDocumentV2>>,
  TError,
  { data: SmsUploadDocumentV2Body },
  TContext
> => {
  const mutationKey = ["smsUploadDocumentV2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsUploadDocumentV2>>,
    { data: SmsUploadDocumentV2Body }
  > = (props) => {
    const { data } = props ?? {};

    return smsUploadDocumentV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsUploadDocumentV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof smsUploadDocumentV2>>
>;
export type SmsUploadDocumentV2MutationBody = SmsUploadDocumentV2Body;
export type SmsUploadDocumentV2MutationError = unknown;

/**
 * @summary Upload SMS Document to S3
 */
export const useSmsUploadDocumentV2 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsUploadDocumentV2>>,
    TError,
    { data: SmsUploadDocumentV2Body },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsUploadDocumentV2>>,
  TError,
  { data: SmsUploadDocumentV2Body },
  TContext
> => {
  const mutationOptions = getSmsUploadDocumentV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete an uploaded document
 */
export const smsIntegrationDeleteSmsDocument = (documentType: string) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}`,
    method: "DELETE",
  });
};

export const getSmsIntegrationDeleteSmsDocumentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationKey = ["smsIntegrationDeleteSmsDocument"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    { documentType: string }
  > = (props) => {
    const { documentType } = props ?? {};

    return smsIntegrationDeleteSmsDocument(documentType);
  };

  return { mutationFn, ...mutationOptions };
};

export type SmsIntegrationDeleteSmsDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>
>;

export type SmsIntegrationDeleteSmsDocumentMutationError = unknown;

/**
 * @summary Delete an uploaded document
 */
export const useSmsIntegrationDeleteSmsDocument = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
    TError,
    { documentType: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
  TError,
  { documentType: string },
  TContext
> => {
  const mutationOptions =
    getSmsIntegrationDeleteSmsDocumentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Generate presigned URL for document download
 */
export const smsIntegrationDownloadSmsDocument = (
  documentType: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/sms/documents/${documentType}/download`,
    method: "GET",
    signal,
  });
};

export const getSmsIntegrationDownloadSmsDocumentQueryKey = (
  documentType?: string,
) => {
  return [`/api/sms/documents/${documentType}/download`] as const;
};

export const getSmsIntegrationDownloadSmsDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSmsIntegrationDownloadSmsDocumentQueryKey(documentType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
  > = ({ signal }) => smsIntegrationDownloadSmsDocument(documentType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!documentType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SmsIntegrationDownloadSmsDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
>;
export type SmsIntegrationDownloadSmsDocumentQueryError = unknown;

/**
 * @summary Generate presigned URL for document download
 */

export function useSmsIntegrationDownloadSmsDocument<
  TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
  TError = unknown,
>(
  documentType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSmsIntegrationDownloadSmsDocumentQueryOptions(
    documentType,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Register new tenant and subscribe (Public)
 */
export const subscriptionsRegisterAndSubscribe = (
  subscriptionsRegisterAndSubscribeBody?: SubscriptionsRegisterAndSubscribeBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/subscriptions/register-and-subscribe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: subscriptionsRegisterAndSubscribeBody,
    signal,
  });
};

export const getSubscriptionsRegisterAndSubscribeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
    TError,
    { data: SubscriptionsRegisterAndSubscribeBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
  TError,
  { data: SubscriptionsRegisterAndSubscribeBody },
  TContext
> => {
  const mutationKey = ["subscriptionsRegisterAndSubscribe"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
    { data: SubscriptionsRegisterAndSubscribeBody }
  > = (props) => {
    const { data } = props ?? {};

    return subscriptionsRegisterAndSubscribe(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SubscriptionsRegisterAndSubscribeMutationResult = NonNullable<
  Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>
>;
export type SubscriptionsRegisterAndSubscribeMutationBody =
  SubscriptionsRegisterAndSubscribeBody;
export type SubscriptionsRegisterAndSubscribeMutationError = unknown;

/**
 * @summary Register new tenant and subscribe (Public)
 */
export const useSubscriptionsRegisterAndSubscribe = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
    TError,
    { data: SubscriptionsRegisterAndSubscribeBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
  TError,
  { data: SubscriptionsRegisterAndSubscribeBody },
  TContext
> => {
  const mutationOptions =
    getSubscriptionsRegisterAndSubscribeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Subscribe to a plan (Mock Payment)
 */
export const subscriptionsSubscribe = (
  subscriptionsSubscribeBody?: SubscriptionsSubscribeBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/subscriptions/subscribe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: subscriptionsSubscribeBody,
    signal,
  });
};

export const getSubscriptionsSubscribeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof subscriptionsSubscribe>>,
    TError,
    { data: SubscriptionsSubscribeBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof subscriptionsSubscribe>>,
  TError,
  { data: SubscriptionsSubscribeBody },
  TContext
> => {
  const mutationKey = ["subscriptionsSubscribe"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof subscriptionsSubscribe>>,
    { data: SubscriptionsSubscribeBody }
  > = (props) => {
    const { data } = props ?? {};

    return subscriptionsSubscribe(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SubscriptionsSubscribeMutationResult = NonNullable<
  Awaited<ReturnType<typeof subscriptionsSubscribe>>
>;
export type SubscriptionsSubscribeMutationBody = SubscriptionsSubscribeBody;
export type SubscriptionsSubscribeMutationError = unknown;

/**
 * @summary Subscribe to a plan (Mock Payment)
 */
export const useSubscriptionsSubscribe = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof subscriptionsSubscribe>>,
    TError,
    { data: SubscriptionsSubscribeBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof subscriptionsSubscribe>>,
  TError,
  { data: SubscriptionsSubscribeBody },
  TContext
> => {
  const mutationOptions = getSubscriptionsSubscribeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Bulk upload suppliers via CSV/XLSX file. Returns summary {created, updated, errors}.
 */
export const suppliersBulkUploadSuppliers = (
  suppliersBulkUploadSuppliersBody?: SuppliersBulkUploadSuppliersBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/suppliers/bulk_upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: suppliersBulkUploadSuppliersBody,
    signal,
  });
};

export const getSuppliersBulkUploadSuppliersMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
    TError,
    { data: SuppliersBulkUploadSuppliersBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
  TError,
  { data: SuppliersBulkUploadSuppliersBody },
  TContext
> => {
  const mutationKey = ["suppliersBulkUploadSuppliers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
    { data: SuppliersBulkUploadSuppliersBody }
  > = (props) => {
    const { data } = props ?? {};

    return suppliersBulkUploadSuppliers(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuppliersBulkUploadSuppliersMutationResult = NonNullable<
  Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>
>;
export type SuppliersBulkUploadSuppliersMutationBody =
  SuppliersBulkUploadSuppliersBody;
export type SuppliersBulkUploadSuppliersMutationError = unknown;

/**
 * @summary Bulk upload suppliers via CSV/XLSX file. Returns summary {created, updated, errors}.
 */
export const useSuppliersBulkUploadSuppliers = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
    TError,
    { data: SuppliersBulkUploadSuppliersBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
  TError,
  { data: SuppliersBulkUploadSuppliersBody },
  TContext
> => {
  const mutationOptions =
    getSuppliersBulkUploadSuppliersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Fast supplier search for autocomplete
 */
export const suppliersSearchSuppliers = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/suppliers/search`,
    method: "GET",
    signal,
  });
};

export const getSuppliersSearchSuppliersQueryKey = () => {
  return [`/api/suppliers/search`] as const;
};

export const getSuppliersSearchSuppliersQueryOptions = <
  TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuppliersSearchSuppliersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suppliersSearchSuppliers>>
  > = ({ signal }) => suppliersSearchSuppliers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SuppliersSearchSuppliersQueryResult = NonNullable<
  Awaited<ReturnType<typeof suppliersSearchSuppliers>>
>;
export type SuppliersSearchSuppliersQueryError = unknown;

/**
 * @summary Fast supplier search for autocomplete
 */

export function useSuppliersSearchSuppliers<
  TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSuppliersSearchSuppliersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * These are needed for PDF generation and preview.
 * @summary Serve tenant assets (logo, stamp, signature) publicly.
 */
export const tenantUsersServeTenantAsset = (
  tenantId: string,
  filename: string,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/tenant/assets/${tenantId}/${filename}`,
    method: "GET",
    signal,
  });
};

export const getTenantUsersServeTenantAssetQueryKey = (
  tenantId?: string,
  filename?: string,
) => {
  return [`/api/tenant/assets/${tenantId}/${filename}`] as const;
};

export const getTenantUsersServeTenantAssetQueryOptions = <
  TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
  TError = unknown,
>(
  tenantId: string,
  filename: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTenantUsersServeTenantAssetQueryKey(tenantId, filename);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>
  > = ({ signal }) => tenantUsersServeTenantAsset(tenantId, filename, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(tenantId && filename),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TenantUsersServeTenantAssetQueryResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>
>;
export type TenantUsersServeTenantAssetQueryError = unknown;

/**
 * @summary Serve tenant assets (logo, stamp, signature) publicly.
 */

export function useTenantUsersServeTenantAsset<
  TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
  TError = unknown,
>(
  tenantId: string,
  filename: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTenantUsersServeTenantAssetQueryOptions(
    tenantId,
    filename,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Only tenant_admin can update company info.
 * @summary Update the current tenant's company information.
 */
export const tenantUsersUpdateTenantCompany = (
  tenantUsersUpdateTenantCompanyBody?: TenantUsersUpdateTenantCompanyBody,
) => {
  return customInstance<void>({
    url: `/api/tenant/company`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: tenantUsersUpdateTenantCompanyBody,
  });
};

export const getTenantUsersUpdateTenantCompanyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
    TError,
    { data: TenantUsersUpdateTenantCompanyBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
  TError,
  { data: TenantUsersUpdateTenantCompanyBody },
  TContext
> => {
  const mutationKey = ["tenantUsersUpdateTenantCompany"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
    { data: TenantUsersUpdateTenantCompanyBody }
  > = (props) => {
    const { data } = props ?? {};

    return tenantUsersUpdateTenantCompany(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TenantUsersUpdateTenantCompanyMutationResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>
>;
export type TenantUsersUpdateTenantCompanyMutationBody =
  TenantUsersUpdateTenantCompanyBody;
export type TenantUsersUpdateTenantCompanyMutationError = unknown;

/**
 * @summary Update the current tenant's company information.
 */
export const useTenantUsersUpdateTenantCompany = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
    TError,
    { data: TenantUsersUpdateTenantCompanyBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
  TError,
  { data: TenantUsersUpdateTenantCompanyBody },
  TContext
> => {
  const mutationOptions =
    getTenantUsersUpdateTenantCompanyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete a company asset (logo, stamp, or signature).
 */
export const tenantUsersDeleteTenantAsset = (assetType: string) => {
  return customInstance<void>({
    url: `/api/tenant/company/upload/${assetType}`,
    method: "DELETE",
  });
};

export const getTenantUsersDeleteTenantAssetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
    TError,
    { assetType: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
  TError,
  { assetType: string },
  TContext
> => {
  const mutationKey = ["tenantUsersDeleteTenantAsset"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
    { assetType: string }
  > = (props) => {
    const { assetType } = props ?? {};

    return tenantUsersDeleteTenantAsset(assetType);
  };

  return { mutationFn, ...mutationOptions };
};

export type TenantUsersDeleteTenantAssetMutationResult = NonNullable<
  Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>
>;

export type TenantUsersDeleteTenantAssetMutationError = unknown;

/**
 * @summary Delete a company asset (logo, stamp, or signature).
 */
export const useTenantUsersDeleteTenantAsset = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
    TError,
    { assetType: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
  TError,
  { assetType: string },
  TContext
> => {
  const mutationOptions =
    getTenantUsersDeleteTenantAssetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Åžu kaynak tÃ¼rlerini birleÅŸtirir:
- Sales (satÄ±ÅŸlar)
- PaymentRecords (Ã¶deme kayÄ±tlarÄ±)
- Cash Records (nakit kayÄ±tlarÄ±)
Query parametreleri:
- limit: maksimum kayÄ±t sayÄ±sÄ± (varsayÄ±lan: 200)
- start_date, end_date: tarih filtreleri (ISO format)
- record_type: kayÄ±t tÃ¼rÃ¼ filtresi (sale, payment, cash)
- patient_id: hasta ID filtresi
- status: durum filtresi (paid, pending, partial)
 * @summary BirleÅŸik cash records endpoint'i - tÃ¼m finansal kayÄ±tlarÄ± tek yerden dÃ¶ndÃ¼rÃ¼r.
 */
export const unifiedCashGetUnifiedCashRecords = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/unified-cash-records`,
    method: "GET",
    signal,
  });
};

export const getUnifiedCashGetUnifiedCashRecordsQueryKey = () => {
  return [`/api/unified-cash-records`] as const;
};

export const getUnifiedCashGetUnifiedCashRecordsQueryOptions = <
  TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUnifiedCashGetUnifiedCashRecordsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
  > = ({ signal }) => unifiedCashGetUnifiedCashRecords(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UnifiedCashGetUnifiedCashRecordsQueryResult = NonNullable<
  Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
>;
export type UnifiedCashGetUnifiedCashRecordsQueryError = unknown;

/**
 * @summary BirleÅŸik cash records endpoint'i - tÃ¼m finansal kayÄ±tlarÄ± tek yerden dÃ¶ndÃ¼rÃ¼r.
 */

export function useUnifiedCashGetUnifiedCashRecords<
  TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUnifiedCashGetUnifiedCashRecordsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Query parametreleri:
- period: Ã¶zet dÃ¶nemi (today, week, month, year)
- start_date, end_date: Ã¶zel tarih aralÄ±ÄŸÄ±
 * @summary Finansal Ã¶zet bilgileri dÃ¶ndÃ¼rÃ¼r.
 */
export const unifiedCashGetCashSummary = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/unified-cash-records/summary`,
    method: "GET",
    signal,
  });
};

export const getUnifiedCashGetCashSummaryQueryKey = () => {
  return [`/api/unified-cash-records/summary`] as const;
};

export const getUnifiedCashGetCashSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUnifiedCashGetCashSummaryQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
  > = ({ signal }) => unifiedCashGetCashSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UnifiedCashGetCashSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
>;
export type UnifiedCashGetCashSummaryQueryError = unknown;

/**
 * @summary Finansal Ã¶zet bilgileri dÃ¶ndÃ¼rÃ¼r.
 */

export function useUnifiedCashGetCashSummary<
  TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUnifiedCashGetCashSummaryQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Query Params:
key (str): S3 key of the file to delete
 * @summary Delete a file
 */
export const uploadDeleteFile = () => {
  return customInstance<void>({ url: `/api/upload/files`, method: "DELETE" });
};

export const getUploadDeleteFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadDeleteFile>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadDeleteFile>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["uploadDeleteFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadDeleteFile>>,
    void
  > = () => {
    return uploadDeleteFile();
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadDeleteFile>>
>;

export type UploadDeleteFileMutationError = unknown;

/**
 * @summary Delete a file
 */
export const useUploadDeleteFile = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadDeleteFile>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uploadDeleteFile>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getUploadDeleteFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Request Body:
filename (str): Original filename
folder (str): Target folder (e.g., 'sms_documents', 'invoices')
content_type (str): File content type (optional)
Returns:
JSON: {
'url': str,
'fields': dict,
'key': str
}
 * @summary Get a presigned URL for direct S3 upload
 */
export const uploadGetPresignedUploadUrl = (
  uploadGetPresignedUploadUrlBody?: UploadGetPresignedUploadUrlBody,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/api/upload/presigned`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: uploadGetPresignedUploadUrlBody,
    signal,
  });
};

export const getUploadGetPresignedUploadUrlMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
    TError,
    { data: UploadGetPresignedUploadUrlBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
  TError,
  { data: UploadGetPresignedUploadUrlBody },
  TContext
> => {
  const mutationKey = ["uploadGetPresignedUploadUrl"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
    { data: UploadGetPresignedUploadUrlBody }
  > = (props) => {
    const { data } = props ?? {};

    return uploadGetPresignedUploadUrl(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadGetPresignedUploadUrlMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>
>;
export type UploadGetPresignedUploadUrlMutationBody =
  UploadGetPresignedUploadUrlBody;
export type UploadGetPresignedUploadUrlMutationError = unknown;

/**
 * @summary Get a presigned URL for direct S3 upload
 */
export const useUploadGetPresignedUploadUrl = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
    TError,
    { data: UploadGetPresignedUploadUrlBody },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
  TError,
  { data: UploadGetPresignedUploadUrlBody },
  TContext
> => {
  const mutationOptions =
    getUploadGetPresignedUploadUrlMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary GET /metrics
 */
export const metrics = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/metrics`, method: "GET", signal });
};

export const getMetricsQueryKey = () => {
  return [`/metrics`] as const;
};

export const getMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof metrics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMetricsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metrics>>> = ({
    signal,
  }) => metrics(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof metrics>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metrics>>
>;
export type MetricsQueryError = unknown;

/**
 * @summary GET /metrics
 */

export function useMetrics<
  TData = Awaited<ReturnType<typeof metrics>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMetricsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
