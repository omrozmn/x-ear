/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  ActivityLogsGetActivityLogs200,
  ActivityLogsGetActivityLogsParams,
  ActivityLogsGetFilterOptions200,
  AddonsListActive200,
  AdminAddonsCreateAddonBody,
  AdminAdminLoginBody,
  AdminApiKeysCreateApiKeyBody,
  AdminApiKeysInitDbBody,
  AdminCreateTicketResponseBody,
  AdminDebugAvailableRoles200,
  AdminDebugPagePermissions200,
  AdminDebugSwitchRole200,
  AdminDebugSwitchRoleBody,
  AdminIntegrationsInitDbBody,
  AdminIntegrationsUpdateBirfaturaConfigBody,
  AdminIntegrationsUpdateVatanSmsConfigBody,
  AdminInvoicesCreateAdminInvoiceBody,
  AdminInvoicesRecordPaymentBody,
  AdminMarketplacesCreateIntegrationBody,
  AdminMarketplacesInitDbBody,
  AdminMarketplacesSyncIntegrationBody,
  AdminNotificationsCreateTemplateBody,
  AdminNotificationsInitDbBody,
  AdminNotificationsSendNotificationBody,
  AdminPlansCreatePlanBody,
  AdminProductionInitDbBody,
  AdminProductionUpdateOrderStatusBody,
  AdminRolesCreateAdminRoleBody,
  AdminRolesUpdateAdminRolePermissionsBody,
  AdminRolesUpdateAdminUserRolesBody,
  AdminScanQueueInitDbBody,
  AdminScanQueueRetryScanBody,
  AdminSettingsClearCacheBody,
  AdminSettingsInitDbBody,
  AdminSettingsTriggerBackupBody,
  AdminSettingsUpdateSettingsBody,
  AdminSmsCreatePackageBody,
  AdminSmsGetHeaders200,
  AdminSmsGetHeadersParams,
  AdminSmsGetPackages200,
  AdminSmsUpdateHeaderStatusBody,
  AdminSmsUpdatePackageBody,
  AdminTenantsAddTenantAddonBody,
  AdminTenantsCreateTenantBody,
  AdminTenantsCreateTenantUserBody,
  AdminTenantsSubscribeTenantBody,
  AdminTenantsUpdateTenantStatusBody,
  AdminTenantsUpdateTenantUserBody,
  AdminTicketsCreateAdminTicketBody,
  AdminTicketsUpdateAdminTicketBody,
  AdminUpdateAdminTicketBody,
  AdminUpdateAnyTenantUserBody,
  ApiResponseSendDocumentAnswerResponse,
  ApiResponseString,
  AppointmentsCancelAppointmentBody,
  AppointmentsCompleteAppointmentBody,
  AppointmentsCreateAppointment201,
  AppointmentsCreateAppointmentBody,
  AppointmentsGetAppointmentsParams,
  AppointmentsListAppointments200,
  AppointmentsRescheduleAppointmentBody,
  AuthForgotPasswordBody,
  AuthLoginBody,
  AuthRefreshBody,
  AuthSendVerificationOtpBody,
  AuthVerifyOtpBody,
  AutomationTriggerBackupBody,
  AutomationTriggerSgkProcessingBody,
  BirfaturaBpOutDocumentDownloadByUuidBody,
  BirfaturaBpOutGetInboxDocumentsBody,
  BirfaturaBpOutGetInboxDocumentsWithDetailBody,
  BirfaturaBpOutPreviewDocumentReturnPdfBody,
  BirfaturaBpOutReceiveDocumentBody,
  BirfaturaBpOutSendBasicInvoiceFromModelBody,
  BirfaturaBpOutSendDocumentBody,
  BirfaturaBpSendBasicInvoiceBody,
  BirfaturaBpSendDocumentBody,
  BirfaturaSyncInvoices200,
  BirfaturaSyncInvoicesBody,
  BranchesGetBranches200,
  Campaign,
  CampaignsCreateCampaignBody,
  CampaignsGetCampaigns200,
  CampaignsGetCampaignsParams,
  CampaignsSendCampaignBody,
  CashRecordsCreateCashRecordBody,
  CheckoutConfirmPaymentBody,
  CheckoutCreateCheckoutSessionBody,
  CommissionCalculationRequest,
  CommissionCalculationResponse,
  CommissionRatesResponse,
  CommunicationTemplateCreate,
  CommunicationTemplateUpdate,
  CommunicationsCreateCommunicationHistoryBody,
  CommunicationsCreateTemplate201,
  CommunicationsDeleteTemplate200,
  CommunicationsGetTemplate200,
  CommunicationsListMessages200,
  CommunicationsListMessagesParams,
  CommunicationsListTemplates200,
  CommunicationsListTemplatesParams,
  CommunicationsSendEmailBody,
  CommunicationsSendSmsBody,
  CommunicationsUpdateTemplate200,
  DashboardGetDashboardData200,
  Device,
  DevicesCreateDeviceBody,
  DevicesCreateDeviceBrandBody,
  DevicesCreateDeviceCategory201,
  DevicesCreateDeviceCategoryBody,
  DevicesGetDevices200,
  DevicesGetDevicesParams,
  DevicesUpdateDeviceStockBody,
  ErrorResponse,
  GetPaytrConfig200,
  GetPosTransactions200,
  GetPosTransactionsParams,
  GetSystemCommissionRates200,
  GetTenantCommissionRates200,
  InstallmentOptionsRequest,
  InstallmentOptionsResponse,
  InventoryAddSerialNumbersBody,
  InventoryAssignToPatientBody,
  InventoryBulkUploadInventoryBody,
  InventoryCreateBrandBody,
  InventoryCreateCategory201,
  InventoryCreateCategoryBody,
  InventoryCreateInventoryItemBody,
  InventoryGetCategories200,
  InventoryGetInventoryItem200,
  InventoryGetInventoryItems200,
  InventoryGetInventoryItemsParams,
  InventoryItem,
  InventoryUpdateInventoryItem200,
  InvoicesActionsCopyInvoiceBody,
  InvoicesActionsCopyInvoiceCancelBody,
  InvoicesActionsIssueInvoiceBody,
  InvoicesAddToPrintQueueBody,
  InvoicesBatchGenerateInvoicesBody,
  InvoicesBulkUploadInvoicesBody,
  InvoicesCreateInvoice201,
  InvoicesCreateInvoiceBody,
  InvoicesCreateInvoiceTemplateBody,
  InvoicesDeleteInvoice200,
  InvoicesGetInvoice200,
  InvoicesSendToGib200,
  InvoicesUpdateInvoiceGibStatusBody,
  InvoicesUploadInvoiceXmlBody,
  Notification,
  NotificationsMarkNotificationReadBody,
  NotificationsSetUserNotificationSettingsBody,
  OcrCalculateSimilarityBody,
  OcrCalculateSimilarityV2Body,
  OcrCreateJobBody,
  OcrDebugNerBody,
  OcrExtractEntitiesBody,
  OcrExtractEntitiesV2Body,
  OcrExtractPatientNameBody,
  OcrExtractPatientNameV2Body,
  OcrInitDatabaseBody,
  OcrInitDatabaseV2Body,
  OcrInitializeNlpEndpointBody,
  OcrInitializeNlpEndpointV2Body,
  OcrProcessDocumentBody,
  Patient,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesCreatePatientNoteBody,
  PatientsBulkUploadPatientsBody,
  PatientsCountPatients200,
  PatientsCountPatientsParams,
  PatientsCreatePatientBody,
  PatientsGetPatientDevices200,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  PayTRInitiateRequest,
  PayTRInitiateResponse,
  PaymentRecord,
  PaymentsCollectPromissoryNoteBody,
  PaymentsCreatePaymentRecordBody,
  PaymentsCreatePromissoryNotesBody,
  PaymentsUpdatePromissoryNoteBody,
  PaytrCallbackBody,
  PermissionsCreatePermissionBody,
  PermissionsGetRolePermissions200,
  PermissionsListPermissions200,
  PermissionsUpdateRolePermissionsBody,
  PlansCreatePlanBody,
  PlansUpdatePlanBody,
  ProformasConvertProformaToSaleBody,
  ProformasCreateProformaBody,
  RegistrationRegisterPhoneBody,
  RegistrationVerifyRegistrationOtpBody,
  ReplacementsCreatePatientReplacementBody,
  ReplacementsCreateReturnInvoiceBody,
  ReplacementsSendInvoiceToGibBody,
  ReportPosMovements200,
  ReportPosMovementsParams,
  ReportsReportCashflowSummaryParams,
  ReportsReportPromissoryNotesByPatientParams,
  ReportsReportPromissoryNotesListParams,
  ReportsReportPromissoryNotesParams,
  ReportsReportRemainingPaymentsParams,
  RolesAddPermissionToRoleBody,
  RolesCreateRoleBody,
  SMSHeaderRequest,
  SMSPackage,
  Sale,
  SalesAssignDevicesExtendedBody,
  SalesCreateProductSaleBody,
  SalesCreateSaleBody,
  SalesCreateSaleInvoice201,
  SalesCreateSaleInvoiceBody,
  SalesCreateSalePaymentPlanBody,
  SalesCreateSalesLogBody,
  SalesGetSaleInvoice200,
  SalesPayInstallmentBody,
  SalesPricingPreviewBody,
  SalesRecalcSalesBody,
  SalesRecordSalePaymentBody,
  SalesUpdateSaleBody,
  SendDocumentAnswerRequestData,
  SgkCreateSgkWorkflowBody,
  SgkProcessOcrBody,
  SgkQueryEReceiptBody,
  SgkQueryPatientRightsBody,
  SgkSeedTestPatientsBody,
  SgkUpdateSgkWorkflowBody,
  SgkUploadAndProcessFilesBody,
  SgkUploadSgkDocumentBody,
  SmsCreateAudienceBody,
  SmsCreateHeaderBody,
  SmsGetAudiences200,
  SmsGetConfig200,
  SmsGetCredit200,
  SmsGetHeaders200,
  SmsGetPackages200,
  SmsUpdateConfigBody,
  SmsUploadAudienceBody,
  SmsUploadDocumentBody,
  SmsUploadDocumentV2200,
  SmsUploadDocumentV2Body,
  SubscriptionsGetCurrent200,
  SubscriptionsRegisterAndSubscribeBody,
  SubscriptionsSubscribeBody,
  SuccessResponse,
  Supplier,
  SuppliersAcceptSuggestedSupplier200,
  SuppliersAcceptSuggestedSupplier201,
  SuppliersAddProductSupplierBody,
  SuppliersBulkUploadSuppliersBody,
  SuppliersCreateSupplierBody,
  SuppliersGetSuggestedSuppliers200,
  SuppliersGetSupplierInvoices200,
  SuppliersGetSupplierInvoicesParams,
  SuppliersGetSuppliers200,
  SuppliersGetSuppliersParams,
  SuppliersRejectSuggestedSupplier200,
  TenantUsersDelete200,
  TenantUsersInvite201,
  TenantUsersInviteBody,
  TenantUsersList200,
  TenantUsersUpdateTenantCompanyBody,
  TimelineAddTimelineEvent201,
  TimelineAddTimelineEventBody,
  TimelineDeleteTimelineEvent200,
  TimelineGetPatientTimeline200,
  TimelineLogPatientActivityBody,
  UpdatePaytrConfig200,
  UpdatePaytrConfigBody,
  UpdateSettingsBody,
  UpdateSystemCommissionRates200,
  UpdateSystemCommissionRatesBody,
  UpdateTenantCommissionRates200,
  UpdateTenantCommissionRatesBody,
  UpdateUnreadedStatusRequestData,
  UploadGetPresignedUploadUrlBody,
  User,
  UsersChangePassword200,
  UsersChangePasswordBody,
  UsersCreateUserBody,
  UsersUpdateMeBody,
  UsersUpdateUserBody
} from './schemas';

/**
 * @summary Get list of appointments
 */
export const appointmentsGetAppointments = (
    params?: AppointmentsGetAppointmentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/appointments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getAppointmentsGetAppointmentsQueryKey = (params?: AppointmentsGetAppointmentsParams,) => {
    return [
    `/api/appointments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAppointmentsGetAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAppointmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAppointments>>> = ({ signal }) => appointmentsGetAppointments(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAppointments>>>
export type AppointmentsGetAppointmentsQueryError = AxiosError<unknown>


export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params: undefined |  AppointmentsGetAppointmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of appointments
 */

export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = AxiosError<unknown>>(
 params?: AppointmentsGetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAppointmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new appointment
 */
export const appointmentsCreateAppointment = (
    appointmentsCreateAppointmentBody: AppointmentsCreateAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppointmentsCreateAppointment201>> => {
    
    
    return axios.post(
      `/api/appointments`,
      appointmentsCreateAppointmentBody,options
    );
  }



export const getAppointmentsCreateAppointmentMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCreateAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, {data: AppointmentsCreateAppointmentBody}> = (props) => {
          const {data} = props ?? {};

          return  appointmentsCreateAppointment(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCreateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCreateAppointment>>>
    export type AppointmentsCreateAppointmentMutationBody = AppointmentsCreateAppointmentBody
    export type AppointmentsCreateAppointmentMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new appointment
 */
export const useAppointmentsCreateAppointment = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
        TError,
        {data: AppointmentsCreateAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCreateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of communication messages (SMS and Email)
 */
export const communicationsListMessages = (
    params?: CommunicationsListMessagesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsListMessages200>> => {
    
    
    return axios.get(
      `/api/communications/messages`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getCommunicationsListMessagesQueryKey = (params?: CommunicationsListMessagesParams,) => {
    return [
    `/api/communications/messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCommunicationsListMessagesQueryOptions = <TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsListMessagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsListMessages>>> = ({ signal }) => communicationsListMessages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsListMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsListMessages>>>
export type CommunicationsListMessagesQueryError = AxiosError<ErrorResponse>


export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  CommunicationsListMessagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListMessages>>,
          TError,
          Awaited<ReturnType<typeof communicationsListMessages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListMessages>>,
          TError,
          Awaited<ReturnType<typeof communicationsListMessages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of communication messages (SMS and Email)
 */

export function useCommunicationsListMessages<TData = Awaited<ReturnType<typeof communicationsListMessages>>, TError = AxiosError<ErrorResponse>>(
 params?: CommunicationsListMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListMessages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsListMessagesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get list of communication templates
 */
export const communicationsListTemplates = (
    params?: CommunicationsListTemplatesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsListTemplates200>> => {
    
    
    return axios.get(
      `/api/communications/templates`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getCommunicationsListTemplatesQueryKey = (params?: CommunicationsListTemplatesParams,) => {
    return [
    `/api/communications/templates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCommunicationsListTemplatesQueryOptions = <TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsListTemplatesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsListTemplates>>> = ({ signal }) => communicationsListTemplates(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsListTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsListTemplates>>>
export type CommunicationsListTemplatesQueryError = AxiosError<unknown>


export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params: undefined |  CommunicationsListTemplatesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of communication templates
 */

export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = AxiosError<unknown>>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsListTemplatesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new communication template
 */
export const communicationsCreateTemplate = (
    communicationTemplateCreate: CommunicationTemplateCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsCreateTemplate201>> => {
    
    
    return axios.post(
      `/api/communications/templates`,
      communicationTemplateCreate,options
    );
  }



export const getCommunicationsCreateTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext> => {

const mutationKey = ['communicationsCreateTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsCreateTemplate>>, {data: CommunicationTemplateCreate}> = (props) => {
          const {data} = props ?? {};

          return  communicationsCreateTemplate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsCreateTemplate>>>
    export type CommunicationsCreateTemplateMutationBody = CommunicationTemplateCreate
    export type CommunicationsCreateTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Create a new communication template
 */
export const useCommunicationsCreateTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsCreateTemplate>>,
        TError,
        {data: CommunicationTemplateCreate},
        TContext
      > => {

      const mutationOptions = getCommunicationsCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific communication template
 */
export const communicationsGetTemplate = (
    templateId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsGetTemplate200>> => {
    
    
    return axios.get(
      `/api/communications/templates/${templateId}`,options
    );
  }




export const getCommunicationsGetTemplateQueryKey = (templateId?: string,) => {
    return [
    `/api/communications/templates/${templateId}`
    ] as const;
    }

    
export const getCommunicationsGetTemplateQueryOptions = <TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsGetTemplateQueryKey(templateId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsGetTemplate>>> = ({ signal }) => communicationsGetTemplate(templateId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(templateId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsGetTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsGetTemplate>>>
export type CommunicationsGetTemplateQueryError = AxiosError<unknown>


export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific communication template
 */

export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = AxiosError<unknown>>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsGetTemplateQueryOptions(templateId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update a communication template
 */
export const communicationsUpdateTemplate = (
    templateId: string,
    communicationTemplateUpdate: CommunicationTemplateUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsUpdateTemplate200>> => {
    
    
    return axios.put(
      `/api/communications/templates/${templateId}`,
      communicationTemplateUpdate,options
    );
  }



export const getCommunicationsUpdateTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext> => {

const mutationKey = ['communicationsUpdateTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, {templateId: string;data: CommunicationTemplateUpdate}> = (props) => {
          const {templateId,data} = props ?? {};

          return  communicationsUpdateTemplate(templateId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsUpdateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsUpdateTemplate>>>
    export type CommunicationsUpdateTemplateMutationBody = CommunicationTemplateUpdate
    export type CommunicationsUpdateTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Update a communication template
 */
export const useCommunicationsUpdateTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
        TError,
        {templateId: string;data: CommunicationTemplateUpdate},
        TContext
      > => {

      const mutationOptions = getCommunicationsUpdateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a communication template
 */
export const communicationsDeleteTemplate = (
    templateId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommunicationsDeleteTemplate200>> => {
    
    
    return axios.delete(
      `/api/communications/templates/${templateId}`,options
    );
  }



export const getCommunicationsDeleteTemplateMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext> => {

const mutationKey = ['communicationsDeleteTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, {templateId: string}> = (props) => {
          const {templateId} = props ?? {};

          return  communicationsDeleteTemplate(templateId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsDeleteTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsDeleteTemplate>>>
    
    export type CommunicationsDeleteTemplateMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete a communication template
 */
export const useCommunicationsDeleteTemplate = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
        TError,
        {templateId: string},
        TContext
      > => {

      const mutationOptions = getCommunicationsDeleteTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete an existing appointment by its unique identifier
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const appointmentsDeleteAppointment = (
    appointmentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/appointments/${appointmentId}`,options
    );
  }



export const getAppointmentsDeleteAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['appointmentsDeleteAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  appointmentsDeleteAppointment(appointmentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsDeleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>>
    
    export type AppointmentsDeleteAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const useAppointmentsDeleteAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getAppointmentsDeleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Cancel an appointment and optionally provide cancellation reason
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const appointmentsCancelAppointment = (
    appointmentId: string,
    appointmentsCancelAppointmentBody?: AppointmentsCancelAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/cancel`,
      appointmentsCancelAppointmentBody,options
    );
  }



export const getAppointmentsCancelAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCancelAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, {appointmentId: string;data: AppointmentsCancelAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCancelAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCancelAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCancelAppointment>>>
    export type AppointmentsCancelAppointmentMutationBody = AppointmentsCancelAppointmentBody
    export type AppointmentsCancelAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const useAppointmentsCancelAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCancelAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCancelAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Mark an appointment as completed and add completion notes
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const appointmentsCompleteAppointment = (
    appointmentId: string,
    appointmentsCompleteAppointmentBody?: AppointmentsCompleteAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/complete`,
      appointmentsCompleteAppointmentBody,options
    );
  }



export const getAppointmentsCompleteAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCompleteAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, {appointmentId: string;data: AppointmentsCompleteAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCompleteAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCompleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>>
    export type AppointmentsCompleteAppointmentMutationBody = AppointmentsCompleteAppointmentBody
    export type AppointmentsCompleteAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const useAppointmentsCompleteAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCompleteAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCompleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reschedule an existing appointment to a new date and time
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const appointmentsRescheduleAppointment = (
    appointmentId: string,
    appointmentsRescheduleAppointmentBody?: AppointmentsRescheduleAppointmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/appointments/${appointmentId}/reschedule`,
      appointmentsRescheduleAppointmentBody,options
    );
  }



export const getAppointmentsRescheduleAppointmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsRescheduleAppointment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, {appointmentId: string;data: AppointmentsRescheduleAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsRescheduleAppointment(appointmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsRescheduleAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>>
    export type AppointmentsRescheduleAppointmentMutationBody = AppointmentsRescheduleAppointmentBody
    export type AppointmentsRescheduleAppointmentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const useAppointmentsRescheduleAppointment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsRescheduleAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsRescheduleAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get available appointment slots for scheduling
 * @summary GET /api/appointments/availability
 */
export const appointmentsGetAvailability = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/appointments/availability`,options
    );
  }




export const getAppointmentsGetAvailabilityQueryKey = () => {
    return [
    `/api/appointments/availability`
    ] as const;
    }

    
export const getAppointmentsGetAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAvailabilityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAvailability>>> = ({ signal }) => appointmentsGetAvailability({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAvailability>>>
export type AppointmentsGetAvailabilityQueryError = AxiosError<unknown>


export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/availability
 */

export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAvailabilityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of appointments with optional filtering
 * @summary GET /api/appointments/list
 */
export const appointmentsListAppointments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppointmentsListAppointments200>> => {
    
    
    return axios.get(
      `/api/appointments/list`,options
    );
  }




export const getAppointmentsListAppointmentsQueryKey = () => {
    return [
    `/api/appointments/list`
    ] as const;
    }

    
export const getAppointmentsListAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsListAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsListAppointments>>> = ({ signal }) => appointmentsListAppointments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsListAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsListAppointments>>>
export type AppointmentsListAppointmentsQueryError = AxiosError<unknown>


export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/list
 */

export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsListAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Trigger automated system backup process
 * @summary Trigger system backup
 */
export const automationTriggerBackup = (
    automationTriggerBackupBody?: AutomationTriggerBackupBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/automation/backup`,
      automationTriggerBackupBody,options
    );
  }



export const getAutomationTriggerBackupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext> => {

const mutationKey = ['automationTriggerBackup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerBackup>>, {data: AutomationTriggerBackupBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerBackup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerBackupMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerBackup>>>
    export type AutomationTriggerBackupMutationBody = AutomationTriggerBackupBody
    export type AutomationTriggerBackupMutationError = AxiosError<unknown>

    /**
 * @summary Trigger system backup
 */
export const useAutomationTriggerBackup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerBackup>>,
        TError,
        {data: AutomationTriggerBackupBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerBackupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve logs from automated processes and tasks
 * @summary Get automation logs
 */
export const automationGetAutomationLogs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/automation/logs`,options
    );
  }




export const getAutomationGetAutomationLogsQueryKey = () => {
    return [
    `/api/automation/logs`
    ] as const;
    }

    
export const getAutomationGetAutomationLogsQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationLogs>>> = ({ signal }) => automationGetAutomationLogs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationLogsQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationLogs>>>
export type AutomationGetAutomationLogsQueryError = AxiosError<unknown>


export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation logs
 */

export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Trigger automated SGK document processing workflow
 * @summary Trigger SGK document processing
 */
export const automationTriggerSgkProcessing = (
    automationTriggerSgkProcessingBody?: AutomationTriggerSgkProcessingBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/automation/sgk/process`,
      automationTriggerSgkProcessingBody,options
    );
  }



export const getAutomationTriggerSgkProcessingMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext> => {

const mutationKey = ['automationTriggerSgkProcessing'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, {data: AutomationTriggerSgkProcessingBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerSgkProcessing(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerSgkProcessingMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>>
    export type AutomationTriggerSgkProcessingMutationBody = AutomationTriggerSgkProcessingBody
    export type AutomationTriggerSgkProcessingMutationError = AxiosError<unknown>

    /**
 * @summary Trigger SGK document processing
 */
export const useAutomationTriggerSgkProcessing = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
        TError,
        {data: AutomationTriggerSgkProcessingBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerSgkProcessingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve status information
 * @summary Get automation system status
 */
export const automationGetAutomationStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/automation/status`,options
    );
  }




export const getAutomationGetAutomationStatusQueryKey = () => {
    return [
    `/api/automation/status`
    ] as const;
    }

    
export const getAutomationGetAutomationStatusQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationStatus>>> = ({ signal }) => automationGetAutomationStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationStatus>>>
export type AutomationGetAutomationStatusQueryError = AxiosError<unknown>


export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation system status
 */

export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve list of branches for the current tenant
 * @summary Get all branches for current tenant
 */
export const branchesGetBranches = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BranchesGetBranches200>> => {
    
    
    return axios.get(
      `/api/branches`,options
    );
  }




export const getBranchesGetBranchesQueryKey = () => {
    return [
    `/api/branches`
    ] as const;
    }

    
export const getBranchesGetBranchesQueryOptions = <TData = Awaited<ReturnType<typeof branchesGetBranches>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBranchesGetBranchesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof branchesGetBranches>>> = ({ signal }) => branchesGetBranches({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type BranchesGetBranchesQueryResult = NonNullable<Awaited<ReturnType<typeof branchesGetBranches>>>
export type BranchesGetBranchesQueryError = AxiosError<unknown>


export function useBranchesGetBranches<TData = Awaited<ReturnType<typeof branchesGetBranches>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof branchesGetBranches>>,
          TError,
          Awaited<ReturnType<typeof branchesGetBranches>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBranchesGetBranches<TData = Awaited<ReturnType<typeof branchesGetBranches>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof branchesGetBranches>>,
          TError,
          Awaited<ReturnType<typeof branchesGetBranches>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBranchesGetBranches<TData = Awaited<ReturnType<typeof branchesGetBranches>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all branches for current tenant
 */

export function useBranchesGetBranches<TData = Awaited<ReturnType<typeof branchesGetBranches>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof branchesGetBranches>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getBranchesGetBranchesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of marketing campaigns
 * @summary List all campaigns
 */
export const campaignsGetCampaigns = (
    params?: CampaignsGetCampaignsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CampaignsGetCampaigns200>> => {
    
    
    return axios.get(
      `/api/campaigns`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getCampaignsGetCampaignsQueryKey = (params?: CampaignsGetCampaignsParams,) => {
    return [
    `/api/campaigns`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCampaignsGetCampaignsQueryOptions = <TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError = AxiosError<unknown>>(params?: CampaignsGetCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCampaignsGetCampaignsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof campaignsGetCampaigns>>> = ({ signal }) => campaignsGetCampaigns(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CampaignsGetCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof campaignsGetCampaigns>>>
export type CampaignsGetCampaignsQueryError = AxiosError<unknown>


export function useCampaignsGetCampaigns<TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError = AxiosError<unknown>>(
 params: undefined |  CampaignsGetCampaignsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof campaignsGetCampaigns>>,
          TError,
          Awaited<ReturnType<typeof campaignsGetCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCampaignsGetCampaigns<TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError = AxiosError<unknown>>(
 params?: CampaignsGetCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof campaignsGetCampaigns>>,
          TError,
          Awaited<ReturnType<typeof campaignsGetCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCampaignsGetCampaigns<TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError = AxiosError<unknown>>(
 params?: CampaignsGetCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all campaigns
 */

export function useCampaignsGetCampaigns<TData = Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError = AxiosError<unknown>>(
 params?: CampaignsGetCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof campaignsGetCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCampaignsGetCampaignsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new marketing campaign with target audience and content
 * @summary POST /api/campaigns
 */
export const campaignsCreateCampaign = (
    campaignsCreateCampaignBody?: CampaignsCreateCampaignBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Campaign>> => {
    
    
    return axios.post(
      `/api/campaigns`,
      campaignsCreateCampaignBody,options
    );
  }



export const getCampaignsCreateCampaignMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext> => {

const mutationKey = ['campaignsCreateCampaign'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof campaignsCreateCampaign>>, {data: CampaignsCreateCampaignBody}> = (props) => {
          const {data} = props ?? {};

          return  campaignsCreateCampaign(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CampaignsCreateCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof campaignsCreateCampaign>>>
    export type CampaignsCreateCampaignMutationBody = CampaignsCreateCampaignBody
    export type CampaignsCreateCampaignMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/campaigns
 */
export const useCampaignsCreateCampaign = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsCreateCampaign>>, TError,{data: CampaignsCreateCampaignBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof campaignsCreateCampaign>>,
        TError,
        {data: CampaignsCreateCampaignBody},
        TContext
      > => {

      const mutationOptions = getCampaignsCreateCampaignMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve dashboard overview data including statistics and recent activities
 * @summary Get dashboard data
 */
export const dashboardGetDashboardData = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DashboardGetDashboardData200>> => {
    
    
    return axios.get(
      `/api/dashboard`,options
    );
  }




export const getDashboardGetDashboardDataQueryKey = () => {
    return [
    `/api/dashboard`
    ] as const;
    }

    
export const getDashboardGetDashboardDataQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetDashboardDataQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetDashboardData>>> = ({ signal }) => dashboardGetDashboardData({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetDashboardDataQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetDashboardData>>>
export type DashboardGetDashboardDataQueryError = AxiosError<ErrorResponse>


export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboardData>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboardData>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboardData>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboardData>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get dashboard data
 */

export function useDashboardGetDashboardData<TData = Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboardData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetDashboardDataQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new send
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const campaignsSendCampaign = (
    campaignId: string,
    campaignsSendCampaignBody?: CampaignsSendCampaignBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/campaigns/${campaignId}/send`,
      campaignsSendCampaignBody,options
    );
  }



export const getCampaignsSendCampaignMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext> => {

const mutationKey = ['campaignsSendCampaign'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof campaignsSendCampaign>>, {campaignId: string;data: CampaignsSendCampaignBody}> = (props) => {
          const {campaignId,data} = props ?? {};

          return  campaignsSendCampaign(campaignId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CampaignsSendCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof campaignsSendCampaign>>>
    export type CampaignsSendCampaignMutationBody = CampaignsSendCampaignBody
    export type CampaignsSendCampaignMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export const useCampaignsSendCampaign = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof campaignsSendCampaign>>, TError,{campaignId: string;data: CampaignsSendCampaignBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof campaignsSendCampaign>>,
        TError,
        {campaignId: string;data: CampaignsSendCampaignBody},
        TContext
      > => {

      const mutationOptions = getCampaignsSendCampaignMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve turnstile information
 * @summary GET /api/config/turnstile
 */
export const registrationGetTurnstileConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/config/turnstile`,options
    );
  }




export const getRegistrationGetTurnstileConfigQueryKey = () => {
    return [
    `/api/config/turnstile`
    ] as const;
    }

    
export const getRegistrationGetTurnstileConfigQueryOptions = <TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRegistrationGetTurnstileConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>> = ({ signal }) => registrationGetTurnstileConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type RegistrationGetTurnstileConfigQueryResult = NonNullable<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>>
export type RegistrationGetTurnstileConfigQueryError = AxiosError<unknown>


export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/config/turnstile
 */

export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRegistrationGetTurnstileConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve patient-trends information
 * @summary GET /api/dashboard/charts/patient-trends
 */
export const dashboardPatientTrends = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/charts/patient-trends`,options
    );
  }




export const getDashboardPatientTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/patient-trends`
    ] as const;
    }

    
export const getDashboardPatientTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardPatientTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardPatientTrends>>> = ({ signal }) => dashboardPatientTrends({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardPatientTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardPatientTrends>>>
export type DashboardPatientTrendsQueryError = AxiosError<unknown>


export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/patient-trends
 */

export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardPatientTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve revenue-trends information
 * @summary GET /api/dashboard/charts/revenue-trends
 */
export const dashboardRevenueTrends = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/charts/revenue-trends`,options
    );
  }




export const getDashboardRevenueTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/revenue-trends`
    ] as const;
    }

    
export const getDashboardRevenueTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRevenueTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRevenueTrends>>> = ({ signal }) => dashboardRevenueTrends({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRevenueTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRevenueTrends>>>
export type DashboardRevenueTrendsQueryError = AxiosError<unknown>


export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/revenue-trends
 */

export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRevenueTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve kpis information
 * @summary GET /api/dashboard/kpis
 */
export const dashboardGetKpis = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/kpis`,options
    );
  }




export const getDashboardGetKpisQueryKey = () => {
    return [
    `/api/dashboard/kpis`
    ] as const;
    }

    
export const getDashboardGetKpisQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetKpisQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetKpis>>> = ({ signal }) => dashboardGetKpis({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetKpisQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetKpis>>>
export type DashboardGetKpisQueryError = AxiosError<unknown>


export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/kpis
 */

export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetKpisQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve recent-activity information
 * @summary GET /api/dashboard/recent-activity
 */
export const dashboardRecentActivity = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/recent-activity`,options
    );
  }




export const getDashboardRecentActivityQueryKey = () => {
    return [
    `/api/dashboard/recent-activity`
    ] as const;
    }

    
export const getDashboardRecentActivityQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRecentActivityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRecentActivity>>> = ({ signal }) => dashboardRecentActivity({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRecentActivityQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRecentActivity>>>
export type DashboardRecentActivityQueryError = AxiosError<unknown>


export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/recent-activity
 */

export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRecentActivityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of devices with optional filtering and pagination
 * @summary Get list of devices
 */
export const devicesGetDevices = (
    params?: DevicesGetDevicesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DevicesGetDevices200>> => {
    
    
    return axios.get(
      `/api/devices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getDevicesGetDevicesQueryKey = (params?: DevicesGetDevicesParams,) => {
    return [
    `/api/devices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getDevicesGetDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDevicesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDevices>>> = ({ signal }) => devicesGetDevices(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDevices>>>
export type DevicesGetDevicesQueryError = AxiosError<ErrorResponse>


export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  DevicesGetDevicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of devices
 */

export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = AxiosError<ErrorResponse>>(
 params?: DevicesGetDevicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDevicesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new hearing aid device in the system
 * @summary Create a new device
 */
export const devicesCreateDevice = (
    devicesCreateDeviceBody?: DevicesCreateDeviceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Device>> => {
    
    
    return axios.post(
      `/api/devices`,
      devicesCreateDeviceBody,options
    );
  }



export const getDevicesCreateDeviceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext> => {

const mutationKey = ['devicesCreateDevice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDevice>>, {data: DevicesCreateDeviceBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDevice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDevice>>>
    export type DevicesCreateDeviceMutationBody = DevicesCreateDeviceBody
    export type DevicesCreateDeviceMutationError = AxiosError<unknown>

    /**
 * @summary Create a new device
 */
export const useDevicesCreateDevice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDevice>>,
        TError,
        {data: DevicesCreateDeviceBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a device from the system
 * @summary Delete a device
 */
export const devicesDeleteDevice = (
    deviceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/devices/${deviceId}`,options
    );
  }



export const getDevicesDeleteDeviceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext> => {

const mutationKey = ['devicesDeleteDevice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesDeleteDevice>>, {deviceId: string}> = (props) => {
          const {deviceId} = props ?? {};

          return  devicesDeleteDevice(deviceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesDeleteDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesDeleteDevice>>>
    
    export type DevicesDeleteDeviceMutationError = AxiosError<unknown>

    /**
 * @summary Delete a device
 */
export const useDevicesDeleteDevice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesDeleteDevice>>,
        TError,
        {deviceId: string},
        TContext
      > => {

      const mutationOptions = getDevicesDeleteDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally permissive for tests ‚Äî real inventory logic
should live in a dedicated inventory table/service.
 * @summary Update device stock levels (simplified).
 */
export const devicesUpdateDeviceStock = (
    deviceId: string,
    devicesUpdateDeviceStockBody?: DevicesUpdateDeviceStockBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/devices/${deviceId}/stock-update`,
      devicesUpdateDeviceStockBody,options
    );
  }



export const getDevicesUpdateDeviceStockMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext> => {

const mutationKey = ['devicesUpdateDeviceStock'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, {deviceId: string;data: DevicesUpdateDeviceStockBody}> = (props) => {
          const {deviceId,data} = props ?? {};

          return  devicesUpdateDeviceStock(deviceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesUpdateDeviceStockMutationResult = NonNullable<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>>
    export type DevicesUpdateDeviceStockMutationBody = DevicesUpdateDeviceStockBody
    export type DevicesUpdateDeviceStockMutationError = AxiosError<unknown>

    /**
 * @summary Update device stock levels (simplified).
 */
export const useDevicesUpdateDeviceStock = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
        TError,
        {deviceId: string;data: DevicesUpdateDeviceStockBody},
        TContext
      > => {

      const mutationOptions = getDevicesUpdateDeviceStockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve brands information
 * @summary Get available device brands
 */
export const devicesGetDeviceBrands = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/brands`,options
    );
  }




export const getDevicesGetDeviceBrandsQueryKey = () => {
    return [
    `/api/devices/brands`
    ] as const;
    }

    
export const getDevicesGetDeviceBrandsQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceBrands>>> = ({ signal }) => devicesGetDeviceBrands({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceBrands>>>
export type DevicesGetDeviceBrandsQueryError = AxiosError<unknown>


export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device brands
 */

export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new device brand
 * @summary Create a new device brand
 */
export const devicesCreateDeviceBrand = (
    devicesCreateDeviceBrandBody: DevicesCreateDeviceBrandBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/devices/brands`,
      devicesCreateDeviceBrandBody,options
    );
  }



export const getDevicesCreateDeviceBrandMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext> => {

const mutationKey = ['devicesCreateDeviceBrand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, {data: DevicesCreateDeviceBrandBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDeviceBrand(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceBrandMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>>
    export type DevicesCreateDeviceBrandMutationBody = DevicesCreateDeviceBrandBody
    export type DevicesCreateDeviceBrandMutationError = AxiosError<void>

    /**
 * @summary Create a new device brand
 */
export const useDevicesCreateDeviceBrand = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceBrand>>, TError,{data: DevicesCreateDeviceBrandBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDeviceBrand>>,
        TError,
        {data: DevicesCreateDeviceBrandBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceBrandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve categories information
 * @summary Get available device categories
 */
export const devicesGetDeviceCategories = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/categories`,options
    );
  }




export const getDevicesGetDeviceCategoriesQueryKey = () => {
    return [
    `/api/devices/categories`
    ] as const;
    }

    
export const getDevicesGetDeviceCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceCategories>>> = ({ signal }) => devicesGetDeviceCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceCategories>>>
export type DevicesGetDeviceCategoriesQueryError = AxiosError<unknown>


export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device categories
 */

export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new device category
 * @summary Create a new device category
 */
export const devicesCreateDeviceCategory = (
    devicesCreateDeviceCategoryBody: DevicesCreateDeviceCategoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DevicesCreateDeviceCategory201>> => {
    
    
    return axios.post(
      `/api/devices/categories`,
      devicesCreateDeviceCategoryBody,options
    );
  }



export const getDevicesCreateDeviceCategoryMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext> => {

const mutationKey = ['devicesCreateDeviceCategory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, {data: DevicesCreateDeviceCategoryBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDeviceCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>>
    export type DevicesCreateDeviceCategoryMutationBody = DevicesCreateDeviceCategoryBody
    export type DevicesCreateDeviceCategoryMutationError = AxiosError<void>

    /**
 * @summary Create a new device category
 */
export const useDevicesCreateDeviceCategory = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDeviceCategory>>, TError,{data: DevicesCreateDeviceCategoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDeviceCategory>>,
        TError,
        {data: DevicesCreateDeviceCategoryBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve low-stock information
 * @summary Get devices with low stock levels
 */
export const devicesGetLowStockDevices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/devices/low-stock`,options
    );
  }




export const getDevicesGetLowStockDevicesQueryKey = () => {
    return [
    `/api/devices/low-stock`
    ] as const;
    }

    
export const getDevicesGetLowStockDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetLowStockDevicesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetLowStockDevices>>> = ({ signal }) => devicesGetLowStockDevices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetLowStockDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetLowStockDevices>>>
export type DevicesGetLowStockDevicesQueryError = AxiosError<unknown>


export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get devices with low stock levels
 */

export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetLowStockDevicesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns 200 when read+write ok, 503 when write fails, and 500 when other errors occur.
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */
export const healthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/health`,options
    );
  }




export const getHealthCheckQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = AxiosError<unknown>


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of inventory items with optional filtering and pagination
 * @summary Get list of inventory items
 */
export const inventoryGetInventoryItems = (
    params?: InventoryGetInventoryItemsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetInventoryItems200>> => {
    
    
    return axios.get(
      `/api/inventory`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getInventoryGetInventoryItemsQueryKey = (params?: InventoryGetInventoryItemsParams,) => {
    return [
    `/api/inventory`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInventoryGetInventoryItemsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryItemsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryItems>>> = ({ signal }) => inventoryGetInventoryItems(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryItemsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryItems>>>
export type InventoryGetInventoryItemsQueryError = AxiosError<ErrorResponse>


export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  InventoryGetInventoryItemsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of inventory items
 */

export function useInventoryGetInventoryItems<TData = Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError = AxiosError<ErrorResponse>>(
 params?: InventoryGetInventoryItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryItemsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new item to inventory with quantity and details
 * @summary Create a new inventory item
 */
export const inventoryCreateInventoryItem = (
    inventoryCreateInventoryItemBody?: InventoryCreateInventoryItemBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryItem>> => {
    
    
    return axios.post(
      `/api/inventory`,
      inventoryCreateInventoryItemBody,options
    );
  }



export const getInventoryCreateInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext> => {

const mutationKey = ['inventoryCreateInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, {data: InventoryCreateInventoryItemBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateInventoryItem(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>>
    export type InventoryCreateInventoryItemMutationBody = InventoryCreateInventoryItemBody
    export type InventoryCreateInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Create a new inventory item
 */
export const useInventoryCreateInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateInventoryItem>>, TError,{data: InventoryCreateInventoryItemBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateInventoryItem>>,
        TError,
        {data: InventoryCreateInventoryItemBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a single inventory item by its ID
 * @summary Get a single inventory item by ID
 */
export const inventoryGetInventoryItem = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetInventoryItem200>> => {
    
    
    return axios.get(
      `/api/inventory/${itemId}`,options
    );
  }




export const getInventoryGetInventoryItemQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}`
    ] as const;
    }

    
export const getInventoryGetInventoryItemQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryItemQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryItem>>> = ({ signal }) => inventoryGetInventoryItem(itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryItemQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryItem>>>
export type InventoryGetInventoryItemQueryError = AxiosError<ErrorResponse>


export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a single inventory item by ID
 */

export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = AxiosError<ErrorResponse>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryItemQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Remove an item from inventory
 * @summary Delete an inventory item
 */
export const inventoryDeleteInventoryItem = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/inventory/${itemId}`,options
    );
  }



export const getInventoryDeleteInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['inventoryDeleteInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  inventoryDeleteInventoryItem(itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryDeleteInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>>
    
    export type InventoryDeleteInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Delete an inventory item
 */
export const useInventoryDeleteInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getInventoryDeleteInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update an inventory item
 */
export const inventoryUpdateInventoryItem = (
    itemId: string,
    inventoryItem?: InventoryItem, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryUpdateInventoryItem200>> => {
    
    
    return axios.put(
      `/api/inventory/${itemId}`,
      inventoryItem,options
    );
  }



export const getInventoryUpdateInventoryItemMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext> => {

const mutationKey = ['inventoryUpdateInventoryItem'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, {itemId: string;data: InventoryItem}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryUpdateInventoryItem(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryUpdateInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>>
    export type InventoryUpdateInventoryItemMutationBody = InventoryItem
    export type InventoryUpdateInventoryItemMutationError = AxiosError<unknown>

    /**
 * @summary Update an inventory item
 */
export const useInventoryUpdateInventoryItem = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryItem}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
        TError,
        {itemId: string;data: InventoryItem},
        TContext
      > => {

      const mutationOptions = getInventoryUpdateInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve activity information
 * @summary Get activity log for an inventory item
 */
export const inventoryGetInventoryActivities = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/${itemId}/activity`,options
    );
  }




export const getInventoryGetInventoryActivitiesQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}/activity`
    ] as const;
    }

    
export const getInventoryGetInventoryActivitiesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryActivitiesQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>> = ({ signal }) => inventoryGetInventoryActivities(itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryActivitiesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>>
export type InventoryGetInventoryActivitiesQueryError = AxiosError<unknown>


export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get activity log for an inventory item
 */

export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = AxiosError<unknown>>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryActivitiesQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new assign
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const inventoryAssignToPatient = (
    itemId: string,
    inventoryAssignToPatientBody?: InventoryAssignToPatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/${itemId}/assign`,
      inventoryAssignToPatientBody,options
    );
  }



export const getInventoryAssignToPatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext> => {

const mutationKey = ['inventoryAssignToPatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAssignToPatient>>, {itemId: string;data: InventoryAssignToPatientBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAssignToPatient(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAssignToPatientMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAssignToPatient>>>
    export type InventoryAssignToPatientMutationBody = InventoryAssignToPatientBody
    export type InventoryAssignToPatientMutationError = AxiosError<unknown>

    /**
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const useInventoryAssignToPatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAssignToPatient>>,
        TError,
        {itemId: string;data: InventoryAssignToPatientBody},
        TContext
      > => {

      const mutationOptions = getInventoryAssignToPatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new serials
 * @summary Add serial numbers to an inventory item
 */
export const inventoryAddSerialNumbers = (
    itemId: string,
    inventoryAddSerialNumbersBody?: InventoryAddSerialNumbersBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/${itemId}/serials`,
      inventoryAddSerialNumbersBody,options
    );
  }



export const getInventoryAddSerialNumbersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext> => {

const mutationKey = ['inventoryAddSerialNumbers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, {itemId: string;data: InventoryAddSerialNumbersBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAddSerialNumbers(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAddSerialNumbersMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>>
    export type InventoryAddSerialNumbersMutationBody = InventoryAddSerialNumbersBody
    export type InventoryAddSerialNumbersMutationError = AxiosError<unknown>

    /**
 * @summary Add serial numbers to an inventory item
 */
export const useInventoryAddSerialNumbers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
        TError,
        {itemId: string;data: InventoryAddSerialNumbersBody},
        TContext
      > => {

      const mutationOptions = getInventoryAddSerialNumbersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve low-stock information
 * @summary Get all items with low stock levels
 */
export const inventoryGetLowStockItems = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/low-stock`,options
    );
  }




export const getInventoryGetLowStockItemsQueryKey = () => {
    return [
    `/api/inventory/low-stock`
    ] as const;
    }

    
export const getInventoryGetLowStockItemsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetLowStockItemsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetLowStockItems>>> = ({ signal }) => inventoryGetLowStockItems({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetLowStockItemsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetLowStockItems>>>
export type InventoryGetLowStockItemsQueryError = AxiosError<unknown>


export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all items with low stock levels
 */

export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetLowStockItemsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get inventory statistics including low stock alerts
 * @summary Get inventory statistics
 */
export const inventoryGetInventoryStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/stats`,options
    );
  }




export const getInventoryGetInventoryStatsQueryKey = () => {
    return [
    `/api/inventory/stats`
    ] as const;
    }

    
export const getInventoryGetInventoryStatsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryStats>>> = ({ signal }) => inventoryGetInventoryStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryStatsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryStats>>>
export type InventoryGetInventoryStatsQueryError = AxiosError<unknown>


export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get inventory statistics
 */

export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get list of all available inventory categories
 * @summary Get all inventory categories
 */
export const inventoryGetCategories = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryGetCategories200>> => {
    
    
    return axios.get(
      `/api/inventory/categories`,options
    );
  }




export const getInventoryGetCategoriesQueryKey = () => {
    return [
    `/api/inventory/categories`
    ] as const;
    }

    
export const getInventoryGetCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetCategories>>> = ({ signal }) => inventoryGetCategories({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetCategories>>>
export type InventoryGetCategoriesQueryError = AxiosError<ErrorResponse>


export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all inventory categories
 */

export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new inventory category
 * @summary Create new inventory category
 */
export const inventoryCreateCategory = (
    inventoryCreateCategoryBody: InventoryCreateCategoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InventoryCreateCategory201>> => {
    
    
    return axios.post(
      `/api/inventory/categories`,
      inventoryCreateCategoryBody,options
    );
  }



export const getInventoryCreateCategoryMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext> => {

const mutationKey = ['inventoryCreateCategory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateCategory>>, {data: InventoryCreateCategoryBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateCategory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateCategory>>>
    export type InventoryCreateCategoryMutationBody = InventoryCreateCategoryBody
    export type InventoryCreateCategoryMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create new inventory category
 */
export const useInventoryCreateCategory = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateCategory>>, TError,{data: InventoryCreateCategoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateCategory>>,
        TError,
        {data: InventoryCreateCategoryBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new invoice for a patient
 * @summary Create a new invoice
 */
export const invoicesCreateInvoice = (
    invoicesCreateInvoiceBody: InvoicesCreateInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesCreateInvoice201>> => {
    
    
    return axios.post(
      `/api/invoices`,
      invoicesCreateInvoiceBody,options
    );
  }



export const getInvoicesCreateInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext> => {

const mutationKey = ['invoicesCreateInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateInvoice>>, {data: InvoicesCreateInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateInvoice>>>
    export type InvoicesCreateInvoiceMutationBody = InvoicesCreateInvoiceBody
    export type InvoicesCreateInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create a new invoice
 */
export const useInvoicesCreateInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateInvoice>>,
        TError,
        {data: InvoicesCreateInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve an invoice by its ID
 * @summary Get invoice by ID
 */
export const invoicesGetInvoice = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesGetInvoice200>> => {
    
    
    return axios.get(
      `/api/invoices/${invoiceId}`,options
    );
  }




export const getInvoicesGetInvoiceQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}`
    ] as const;
    }

    
export const getInvoicesGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetInvoiceQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetInvoice>>> = ({ signal }) => invoicesGetInvoice(invoiceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetInvoice>>>
export type InvoicesGetInvoiceQueryError = AxiosError<ErrorResponse>


export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice by ID
 */

export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetInvoiceQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete an invoice by its ID
 * @summary Delete invoice by ID
 */
export const invoicesDeleteInvoice = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesDeleteInvoice200>> => {
    
    
    return axios.delete(
      `/api/invoices/${invoiceId}`,options
    );
  }



export const getInvoicesDeleteInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesDeleteInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesDeleteInvoice(invoiceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesDeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesDeleteInvoice>>>
    
    export type InvoicesDeleteInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete invoice by ID
 */
export const useInvoicesDeleteInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate and download a PDF for the specified invoice
 * @summary Generate invoice PDF
 */
export const invoicesGenerateInvoicePdf = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/invoices/${invoiceId}/pdf`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getInvoicesGenerateInvoicePdfQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}/pdf`
    ] as const;
    }

    
export const getInvoicesGenerateInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGenerateInvoicePdfQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>> = ({ signal }) => invoicesGenerateInvoicePdf(invoiceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGenerateInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>>
export type InvoicesGenerateInvoicePdfQueryError = AxiosError<ErrorResponse>


export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate invoice PDF
 */

export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGenerateInvoicePdfQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Send the invoice to Gƒ∞B (Turkish Revenue Administration)
 * @summary Send invoice to Gƒ∞B
 */
export const invoicesSendToGib = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InvoicesSendToGib200>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/send-to-gib`,undefined,options
    );
  }



export const getInvoicesSendToGibMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesSendToGib'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesSendToGib>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesSendToGib(invoiceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesSendToGibMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesSendToGib>>>
    
    export type InvoicesSendToGibMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Send invoice to Gƒ∞B
 */
export const useInvoicesSendToGib = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesSendToGib>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesSendToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve notifications information
 * @summary GET /api/notifications
 */
export const notificationsListNotifications = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Notification[]>> => {
    
    
    return axios.get(
      `/api/notifications`,options
    );
  }




export const getNotificationsListNotificationsQueryKey = () => {
    return [
    `/api/notifications`
    ] as const;
    }

    
export const getNotificationsListNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationsListNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationsListNotifications>>> = ({ signal }) => notificationsListNotifications({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationsListNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationsListNotifications>>>
export type NotificationsListNotificationsQueryError = AxiosError<unknown>


export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsListNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsListNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsListNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsListNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/notifications
 */

export function useNotificationsListNotifications<TData = Awaited<ReturnType<typeof notificationsListNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsListNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationsListNotificationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a specific notification
 * @summary DELETE /api/notifications/{notification_id}
 */
export const notificationsDeleteNotification = (
    notificationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/notifications/${notificationId}`,options
    );
  }



export const getNotificationsDeleteNotificationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext> => {

const mutationKey = ['notificationsDeleteNotification'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsDeleteNotification>>, {notificationId: string}> = (props) => {
          const {notificationId} = props ?? {};

          return  notificationsDeleteNotification(notificationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsDeleteNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsDeleteNotification>>>
    
    export type NotificationsDeleteNotificationMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/notifications/{notification_id}
 */
export const useNotificationsDeleteNotification = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsDeleteNotification>>,
        TError,
        {notificationId: string},
        TContext
      > => {

      const mutationOptions = getNotificationsDeleteNotificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update read information
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const notificationsMarkNotificationRead = (
    notificationId: string,
    notificationsMarkNotificationReadBody?: NotificationsMarkNotificationReadBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/notifications/${notificationId}/read`,
      notificationsMarkNotificationReadBody,options
    );
  }



export const getNotificationsMarkNotificationReadMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext> => {

const mutationKey = ['notificationsMarkNotificationRead'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, {notificationId: string;data: NotificationsMarkNotificationReadBody}> = (props) => {
          const {notificationId,data} = props ?? {};

          return  notificationsMarkNotificationRead(notificationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsMarkNotificationReadMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>>
    export type NotificationsMarkNotificationReadMutationBody = NotificationsMarkNotificationReadBody
    export type NotificationsMarkNotificationReadMutationError = AxiosError<unknown>

    /**
 * @summary PUT /api/notifications/{notification_id}/read
 */
export const useNotificationsMarkNotificationRead = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsMarkNotificationRead>>, TError,{notificationId: string;data: NotificationsMarkNotificationReadBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsMarkNotificationRead>>,
        TError,
        {notificationId: string;data: NotificationsMarkNotificationReadBody},
        TContext
      > => {

      const mutationOptions = getNotificationsMarkNotificationReadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve stats information
 * @summary GET /api/notifications/stats
 */
export const notificationsNotificationStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/notifications/stats`,options
    );
  }




export const getNotificationsNotificationStatsQueryKey = () => {
    return [
    `/api/notifications/stats`
    ] as const;
    }

    
export const getNotificationsNotificationStatsQueryOptions = <TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationsNotificationStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationsNotificationStats>>> = ({ signal }) => notificationsNotificationStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationsNotificationStatsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationsNotificationStats>>>
export type NotificationsNotificationStatsQueryError = AxiosError<unknown>


export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsNotificationStats>>,
          TError,
          Awaited<ReturnType<typeof notificationsNotificationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsNotificationStats>>,
          TError,
          Awaited<ReturnType<typeof notificationsNotificationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/notifications/stats
 */

export function useNotificationsNotificationStats<TData = Awaited<ReturnType<typeof notificationsNotificationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsNotificationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationsNotificationStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new process
 * @summary POST /api/ocr/process
 */
export const sgkProcessOcr = (
    sgkProcessOcrBody?: SgkProcessOcrBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/process`,
      sgkProcessOcrBody,options
    );
  }



export const getSgkProcessOcrMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext> => {

const mutationKey = ['sgkProcessOcr'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkProcessOcr>>, {data: SgkProcessOcrBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkProcessOcr(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkProcessOcrMutationResult = NonNullable<Awaited<ReturnType<typeof sgkProcessOcr>>>
    export type SgkProcessOcrMutationBody = SgkProcessOcrBody
    export type SgkProcessOcrMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/ocr/process
 */
export const useSgkProcessOcr = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkProcessOcr>>,
        TError,
        {data: SgkProcessOcrBody},
        TContext
      > => {

      const mutationOptions = getSgkProcessOcrMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns CORS headers so the static Swagger UI served from a different origin (e.g. localhost:8080)
can fetch the YAML without browser CORS errors.
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */
export const serveOpenapiYaml = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/openapi.yaml`,options
    );
  }




export const getServeOpenapiYamlQueryKey = () => {
    return [
    `/api/openapi.yaml`
    ] as const;
    }

    
export const getServeOpenapiYamlQueryOptions = <TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeOpenapiYamlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveOpenapiYaml>>> = ({ signal }) => serveOpenapiYaml({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeOpenapiYamlQueryResult = NonNullable<Awaited<ReturnType<typeof serveOpenapiYaml>>>
export type ServeOpenapiYamlQueryError = AxiosError<unknown>


export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */

export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeOpenapiYamlQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
    params?: PatientsGetPatientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatients200>> => {
    
    
    return axios.get(
      `/api/patients`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getPatientsGetPatientsQueryKey = (params?: PatientsGetPatientsParams,) => {
    return [
    `/api/patients`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsGetPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatients>>> = ({ signal }) => patientsGetPatients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatients>>>
export type PatientsGetPatientsQueryError = AxiosError<ErrorResponse>


export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  PatientsGetPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.post(
      `/api/patients`,
      patientsCreatePatientBody,options
    );
  }



export const getPatientsCreatePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve detailed information about a specific patient
 * @summary Get a specific patient by ID
 */
export const patientsGetPatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}`,options
    );
  }




export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = AxiosError<unknown>


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific patient by ID
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing patient's information
 * @summary Update a patient
 */
export const patientsUpdatePatient = (
    patientId: string,
    patient: Patient, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.put(
      `/api/patients/${patientId}`,
      patient,options
    );
  }



export const getPatientsUpdatePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: Patient}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = Patient
    export type PatientsUpdatePatientMutationError = AxiosError<unknown>

    /**
 * @summary Update a patient
 */
export const usePatientsUpdatePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: Patient},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}`,options
    );
  }



export const getPatientsDeletePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/assign-devices-extended`,
      salesAssignDevicesExtendedBody,options
    );
  }



export const getSalesAssignDevicesExtendedMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatientDevices200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/devices`,options
    );
  }




export const getPatientsGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientsGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientDevices>>> = ({ signal }) => patientsGetPatientDevices(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientDevices>>>
export type PatientsGetPatientDevicesQueryError = AxiosError<unknown>


export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/ereceipts`,
      patientSubresourcesCreatePatientEreceiptBody,options
    );
  }



export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/ereceipts/${ereceiptId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/hearing-tests`,
      patientSubresourcesAddPatientHearingTestBody,options
    );
  }



export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/hearing-tests/${testId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
    patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/notes`,
      patientSubresourcesCreatePatientNoteBody,options
    );
  }



export const getPatientSubresourcesCreatePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, {patientId: string;data: PatientSubresourcesCreatePatientNoteBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientNote(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>>
    export type PatientSubresourcesCreatePatientNoteMutationBody = PatientSubresourcesCreatePatientNoteBody
    export type PatientSubresourcesCreatePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
    patientId: string,
    noteId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/notes/${noteId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  patientSubresourcesDeletePatientNote(patientId,noteId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>>
    
    export type PatientSubresourcesDeletePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/promissory-notes`,options
    );
  }




export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = AxiosError<unknown>


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale[]>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sales`,options
    );
  }




export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = AxiosError<unknown>


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sgk-documents`,options
    );
  }




export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = AxiosError<unknown>


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieves all timeline events for a specific patient, including events from both custom data and activity logs
 * @summary Get timeline events for a patient
 */
export const timelineGetPatientTimeline = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineGetPatientTimeline200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/timeline`,options
    );
  }




export const getTimelineGetPatientTimelineQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/timeline`
    ] as const;
    }

    
export const getTimelineGetPatientTimelineQueryOptions = <TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineGetPatientTimelineQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineGetPatientTimeline>>> = ({ signal }) => timelineGetPatientTimeline(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineGetPatientTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof timelineGetPatientTimeline>>>
export type TimelineGetPatientTimelineQueryError = AxiosError<void>


export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get timeline events for a patient
 */

export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = AxiosError<void>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineGetPatientTimelineQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Creates a new timeline event for a specific patient and logs it to both custom data and activity logs
 * @summary Add a new timeline event for a patient
 */
export const timelineAddTimelineEvent = (
    patientId: string,
    timelineAddTimelineEventBody: TimelineAddTimelineEventBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineAddTimelineEvent201>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/timeline`,
      timelineAddTimelineEventBody,options
    );
  }



export const getTimelineAddTimelineEventMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext> => {

const mutationKey = ['timelineAddTimelineEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, {patientId: string;data: TimelineAddTimelineEventBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineAddTimelineEvent(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineAddTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineAddTimelineEvent>>>
    export type TimelineAddTimelineEventMutationBody = TimelineAddTimelineEventBody
    export type TimelineAddTimelineEventMutationError = AxiosError<void>

    /**
 * @summary Add a new timeline event for a patient
 */
export const useTimelineAddTimelineEvent = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
        TError,
        {patientId: string;data: TimelineAddTimelineEventBody},
        TContext
      > => {

      const mutationOptions = getTimelineAddTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Removes a specific timeline event from a patient's timeline
 * @summary Delete a timeline event
 */
export const timelineDeleteTimelineEvent = (
    patientId: string,
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TimelineDeleteTimelineEvent200>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/timeline/${eventId}`,options
    );
  }



export const getTimelineDeleteTimelineEventMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext> => {

const mutationKey = ['timelineDeleteTimelineEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, {patientId: string;eventId: string}> = (props) => {
          const {patientId,eventId} = props ?? {};

          return  timelineDeleteTimelineEvent(patientId,eventId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineDeleteTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>>
    
    export type TimelineDeleteTimelineEventMutationError = AxiosError<void>

    /**
 * @summary Delete a timeline event
 */
export const useTimelineDeleteTimelineEvent = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
        TError,
        {patientId: string;eventId: string},
        TContext
      > => {

      const mutationOptions = getTimelineDeleteTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Alternative endpoint for adding timeline events, provides the same functionality as POST /api/patients/{patient_id}/timeline
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const timelineLogPatientActivity = (
    patientId: string,
    timelineLogPatientActivityBody: TimelineLogPatientActivityBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/activities`,
      timelineLogPatientActivityBody,options
    );
  }



export const getTimelineLogPatientActivityMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext> => {

const mutationKey = ['timelineLogPatientActivity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineLogPatientActivity>>, {patientId: string;data: TimelineLogPatientActivityBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineLogPatientActivity(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineLogPatientActivityMutationResult = NonNullable<Awaited<ReturnType<typeof timelineLogPatientActivity>>>
    export type TimelineLogPatientActivityMutationBody = TimelineLogPatientActivityBody
    export type TimelineLogPatientActivityMutationError = AxiosError<void>

    /**
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const useTimelineLogPatientActivity = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineLogPatientActivity>>,
        TError,
        {patientId: string;data: TimelineLogPatientActivityBody},
        TContext
      > => {

      const mutationOptions = getTimelineLogPatientActivityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/bulk_upload`,
      patientsBulkUploadPatientsBody,options
    );
  }



export const getPatientsBulkUploadPatientsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = AxiosError<unknown>

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Count patients matching the given filters. Only counts patients with valid phone numbers.
Useful for SMS campaign target audience estimation.

 * @summary Count patients with optional filters for SMS campaigns
 */
export const patientsCountPatients = (
    params?: PatientsCountPatientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsCountPatients200>> => {
    
    
    return axios.get(
      `/api/patients/count`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getPatientsCountPatientsQueryKey = (params?: PatientsCountPatientsParams,) => {
    return [
    `/api/patients/count`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsCountPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsCountPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsCountPatients>>> = ({ signal }) => patientsCountPatients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsCountPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsCountPatients>>>
export type PatientsCountPatientsQueryError = AxiosError<unknown>


export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params: undefined |  PatientsCountPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Count patients with optional filters for SMS campaigns
 */

export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsCountPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the authenticated tenant's subscription status, plan, and expiry info.
 * @summary Get current tenant subscription
 */
export const subscriptionsGetCurrent = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SubscriptionsGetCurrent200>> => {
    
    
    return axios.get(
      `/api/subscriptions/current`,options
    );
  }




export const getSubscriptionsGetCurrentQueryKey = () => {
    return [
    `/api/subscriptions/current`
    ] as const;
    }

    
export const getSubscriptionsGetCurrentQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsGetCurrentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsGetCurrent>>> = ({ signal }) => subscriptionsGetCurrent({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SubscriptionsGetCurrentQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsGetCurrent>>>
export type SubscriptionsGetCurrentQueryError = AxiosError<unknown>


export function useSubscriptionsGetCurrent<TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsGetCurrent>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSubscriptionsGetCurrent<TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsGetCurrent>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsGetCurrent>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSubscriptionsGetCurrent<TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current tenant subscription
 */

export function useSubscriptionsGetCurrent<TData = Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsGetCurrent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSubscriptionsGetCurrentQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve active add-ons that tenants can purchase as optional features.
 * @summary List active public add-ons
 */
export const addonsListActive = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AddonsListActive200>> => {
    
    
    return axios.get(
      `/api/addons`,options
    );
  }




export const getAddonsListActiveQueryKey = () => {
    return [
    `/api/addons`
    ] as const;
    }

    
export const getAddonsListActiveQueryOptions = <TData = Awaited<ReturnType<typeof addonsListActive>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddonsListActiveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addonsListActive>>> = ({ signal }) => addonsListActive({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AddonsListActiveQueryResult = NonNullable<Awaited<ReturnType<typeof addonsListActive>>>
export type AddonsListActiveQueryError = AxiosError<unknown>


export function useAddonsListActive<TData = Awaited<ReturnType<typeof addonsListActive>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addonsListActive>>,
          TError,
          Awaited<ReturnType<typeof addonsListActive>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAddonsListActive<TData = Awaited<ReturnType<typeof addonsListActive>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addonsListActive>>,
          TError,
          Awaited<ReturnType<typeof addonsListActive>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAddonsListActive<TData = Awaited<ReturnType<typeof addonsListActive>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List active public add-ons
 */

export function useAddonsListActive<TData = Awaited<ReturnType<typeof addonsListActive>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addonsListActive>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAddonsListActiveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/export`,options
    );
  }




export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = AxiosError<unknown>


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/search`,options
    );
  }




export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = AxiosError<unknown>


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new pricing-preview
 * @summary POST /api/pricing-preview
 */
export const salesPricingPreview = (
    salesPricingPreviewBody?: SalesPricingPreviewBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/pricing-preview`,
      salesPricingPreviewBody,options
    );
  }



export const getSalesPricingPreviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext> => {

const mutationKey = ['salesPricingPreview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesPricingPreview>>, {data: SalesPricingPreviewBody}> = (props) => {
          const {data} = props ?? {};

          return  salesPricingPreview(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesPricingPreviewMutationResult = NonNullable<Awaited<ReturnType<typeof salesPricingPreview>>>
    export type SalesPricingPreviewMutationBody = SalesPricingPreviewBody
    export type SalesPricingPreviewMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/pricing-preview
 */
export const useSalesPricingPreview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesPricingPreview>>,
        TError,
        {data: SalesPricingPreviewBody},
        TContext
      > => {

      const mutationOptions = getSalesPricingPreviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {ps_id}
 * @summary Delete a product-supplier relationship
 */
export const suppliersDeleteProductSupplier = (
    psId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/product-suppliers/${psId}`,options
    );
  }



export const getSuppliersDeleteProductSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext> => {

const mutationKey = ['suppliersDeleteProductSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, {psId: string}> = (props) => {
          const {psId} = props ?? {};

          return  suppliersDeleteProductSupplier(psId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>>
    
    export type SuppliersDeleteProductSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Delete a product-supplier relationship
 */
export const useSuppliersDeleteProductSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
        TError,
        {psId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new suppliers
 * @summary Add a supplier to a product
 */
export const suppliersAddProductSupplier = (
    productId: string,
    suppliersAddProductSupplierBody?: SuppliersAddProductSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/products/${productId}/suppliers`,
      suppliersAddProductSupplierBody,options
    );
  }



export const getSuppliersAddProductSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext> => {

const mutationKey = ['suppliersAddProductSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, {productId: string;data: SuppliersAddProductSupplierBody}> = (props) => {
          const {productId,data} = props ?? {};

          return  suppliersAddProductSupplier(productId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersAddProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersAddProductSupplier>>>
    export type SuppliersAddProductSupplierMutationBody = SuppliersAddProductSupplierBody
    export type SuppliersAddProductSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Add a supplier to a product
 */
export const useSuppliersAddProductSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
        TError,
        {productId: string;data: SuppliersAddProductSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersAddProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create multiple promissory notes
 */
export const paymentsCreatePromissoryNotes = (
    paymentsCreatePromissoryNotesBody?: PaymentsCreatePromissoryNotesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes`,
      paymentsCreatePromissoryNotesBody,options
    );
  }



export const getPaymentsCreatePromissoryNotesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext> => {

const mutationKey = ['paymentsCreatePromissoryNotes'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, {data: PaymentsCreatePromissoryNotesBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePromissoryNotes(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePromissoryNotesMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>>
    export type PaymentsCreatePromissoryNotesMutationBody = PaymentsCreatePromissoryNotesBody
    export type PaymentsCreatePromissoryNotesMutationError = AxiosError<unknown>

    /**
 * @summary Create multiple promissory notes
 */
export const usePaymentsCreatePromissoryNotes = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
        TError,
        {data: PaymentsCreatePromissoryNotesBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePromissoryNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a promissory note
 */
export const paymentsUpdatePromissoryNote = (
    noteId: string,
    paymentsUpdatePromissoryNoteBody?: PaymentsUpdatePromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/promissory-notes/${noteId}`,
      paymentsUpdatePromissoryNoteBody,options
    );
  }



export const getPaymentsUpdatePromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsUpdatePromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, {noteId: string;data: PaymentsUpdatePromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsUpdatePromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>>
    export type PaymentsUpdatePromissoryNoteMutationBody = PaymentsUpdatePromissoryNoteBody
    export type PaymentsUpdatePromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Update a promissory note
 */
export const usePaymentsUpdatePromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsUpdatePromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const paymentsCollectPromissoryNote = (
    noteId: string,
    paymentsCollectPromissoryNoteBody?: PaymentsCollectPromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes/${noteId}/collect`,
      paymentsCollectPromissoryNoteBody,options
    );
  }



export const getPaymentsCollectPromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsCollectPromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, {noteId: string;data: PaymentsCollectPromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsCollectPromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCollectPromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>>
    export type PaymentsCollectPromissoryNoteMutationBody = PaymentsCollectPromissoryNoteBody
    export type PaymentsCollectPromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const usePaymentsCollectPromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsCollectPromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCollectPromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new register-phone
 * @summary POST /api/register-phone
 */
export const registrationRegisterPhone = (
    registrationRegisterPhoneBody?: RegistrationRegisterPhoneBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/register-phone`,
      registrationRegisterPhoneBody,options
    );
  }



export const getRegistrationRegisterPhoneMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext> => {

const mutationKey = ['registrationRegisterPhone'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationRegisterPhone>>, {data: RegistrationRegisterPhoneBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationRegisterPhone(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationRegisterPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof registrationRegisterPhone>>>
    export type RegistrationRegisterPhoneMutationBody = RegistrationRegisterPhoneBody
    export type RegistrationRegisterPhoneMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/register-phone
 */
export const useRegistrationRegisterPhone = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationRegisterPhone>>,
        TError,
        {data: RegistrationRegisterPhoneBody},
        TContext
      > => {

      const mutationOptions = getRegistrationRegisterPhoneMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve appointments information
 * @summary GET /api/reports/appointments
 */
export const reportsReportAppointments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/appointments`,options
    );
  }




export const getReportsReportAppointmentsQueryKey = () => {
    return [
    `/api/reports/appointments`
    ] as const;
    }

    
export const getReportsReportAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportAppointments>>> = ({ signal }) => reportsReportAppointments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportAppointments>>>
export type ReportsReportAppointmentsQueryError = AxiosError<unknown>


export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/appointments
 */

export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve campaigns information
 * @summary Kampanya raporu
 */
export const reportsReportCampaigns = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/campaigns`,options
    );
  }




export const getReportsReportCampaignsQueryKey = () => {
    return [
    `/api/reports/campaigns`
    ] as const;
    }

    
export const getReportsReportCampaignsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportCampaignsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportCampaigns>>> = ({ signal }) => reportsReportCampaigns({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportCampaigns>>>
export type ReportsReportCampaignsQueryError = AxiosError<unknown>


export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Kampanya raporu
 */

export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportCampaignsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve financial information
 * @summary Mali rapor
 */
export const reportsReportFinancial = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/financial`,options
    );
  }




export const getReportsReportFinancialQueryKey = () => {
    return [
    `/api/reports/financial`
    ] as const;
    }

    
export const getReportsReportFinancialQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportFinancialQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportFinancial>>> = ({ signal }) => reportsReportFinancial({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportFinancialQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportFinancial>>>
export type ReportsReportFinancialQueryError = AxiosError<unknown>


export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Mali rapor
 */

export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportFinancialQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve overview information
 * @summary Genel rapor √∂zeti
 */
export const reportsReportOverview = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/overview`,options
    );
  }




export const getReportsReportOverviewQueryKey = () => {
    return [
    `/api/reports/overview`
    ] as const;
    }

    
export const getReportsReportOverviewQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportOverviewQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportOverview>>> = ({ signal }) => reportsReportOverview({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportOverviewQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportOverview>>>
export type ReportsReportOverviewQueryError = AxiosError<unknown>


export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Genel rapor √∂zeti
 */

export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportOverviewQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve patients information
 * @summary Hasta analizi raporu
 */
export const reportsReportPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/patients`,options
    );
  }




export const getReportsReportPatientsQueryKey = () => {
    return [
    `/api/reports/patients`
    ] as const;
    }

    
export const getReportsReportPatientsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPatients>>> = ({ signal }) => reportsReportPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPatients>>>
export type ReportsReportPatientsQueryError = AxiosError<unknown>


export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Hasta analizi raporu
 */

export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve revenue information
 * @summary GET /api/reports/revenue
 */
export const reportsReportRevenue = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/revenue`,options
    );
  }




export const getReportsReportRevenueQueryKey = () => {
    return [
    `/api/reports/revenue`
    ] as const;
    }

    
export const getReportsReportRevenueQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportRevenueQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportRevenue>>> = ({ signal }) => reportsReportRevenue({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportRevenueQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportRevenue>>>
export type ReportsReportRevenueQueryError = AxiosError<unknown>


export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/revenue
 */

export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportRevenueQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all sales
 * @summary GET /api/sales
 */
export const salesListSales = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale[]>> => {
    
    
    return axios.get(
      `/api/sales`,options
    );
  }




export const getSalesListSalesQueryKey = () => {
    return [
    `/api/sales`
    ] as const;
    }

    
export const getSalesListSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesListSalesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesListSales>>> = ({ signal }) => salesListSales({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesListSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesListSales>>>
export type SalesListSalesQueryError = AxiosError<unknown>


export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesListSales>>,
          TError,
          Awaited<ReturnType<typeof salesListSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesListSales>>,
          TError,
          Awaited<ReturnType<typeof salesListSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sales
 */

export function useSalesListSales<TData = Awaited<ReturnType<typeof salesListSales>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesListSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesListSalesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new sale
 * @summary POST /api/sales
 */
export const salesCreateSale = (
    salesCreateSaleBody: SalesCreateSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.post(
      `/api/sales`,
      salesCreateSaleBody,options
    );
  }



export const getSalesCreateSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext> => {

const mutationKey = ['salesCreateSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSale>>, {data: SalesCreateSaleBody}> = (props) => {
          const {data} = props ?? {};

          return  salesCreateSale(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSale>>>
    export type SalesCreateSaleMutationBody = SalesCreateSaleBody
    export type SalesCreateSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary POST /api/sales
 */
export const useSalesCreateSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSale>>, TError,{data: SalesCreateSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSale>>,
        TError,
        {data: SalesCreateSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get sale details by ID
 * @summary GET /api/sales/{sale_id}
 */
export const salesGetSale = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}`,options
    );
  }




export const getSalesGetSaleQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}`
    ] as const;
    }

    
export const getSalesGetSaleQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSaleQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSale>>> = ({ signal }) => salesGetSale(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSaleQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSale>>>
export type SalesGetSaleQueryError = AxiosError<ErrorResponse>


export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSale>>,
          TError,
          Awaited<ReturnType<typeof salesGetSale>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSale>>,
          TError,
          Awaited<ReturnType<typeof salesGetSale>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sales/{sale_id}
 */

export function useSalesGetSale<TData = Awaited<ReturnType<typeof salesGetSale>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSale>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSaleQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update sale information
 * @summary PUT /api/sales/{sale_id}
 */
export const salesUpdateSale = (
    saleId: string,
    salesUpdateSaleBody: SalesUpdateSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale>> => {
    
    
    return axios.put(
      `/api/sales/${saleId}`,
      salesUpdateSaleBody,options
    );
  }



export const getSalesUpdateSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext> => {

const mutationKey = ['salesUpdateSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSale>>, {saleId: string;data: SalesUpdateSaleBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesUpdateSale(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSale>>>
    export type SalesUpdateSaleMutationBody = SalesUpdateSaleBody
    export type SalesUpdateSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary PUT /api/sales/{sale_id}
 */
export const useSalesUpdateSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSale>>, TError,{saleId: string;data: SalesUpdateSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSale>>,
        TError,
        {saleId: string;data: SalesUpdateSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a sale
 * @summary DELETE /api/sales/{sale_id}
 */
export const salesDeleteSale = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sales/${saleId}`,options
    );
  }



export const getSalesDeleteSaleMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext> => {

const mutationKey = ['salesDeleteSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesDeleteSale>>, {saleId: string}> = (props) => {
          const {saleId} = props ?? {};

          return  salesDeleteSale(saleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesDeleteSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesDeleteSale>>>
    
    export type SalesDeleteSaleMutationError = AxiosError<ErrorResponse>

    /**
 * @summary DELETE /api/sales/{sale_id}
 */
export const useSalesDeleteSale = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesDeleteSale>>, TError,{saleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesDeleteSale>>,
        TError,
        {saleId: string},
        TContext
      > => {

      const mutationOptions = getSalesDeleteSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new payment-plan
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const salesCreateSalePaymentPlan = (
    saleId: string,
    salesCreateSalePaymentPlanBody?: SalesCreateSalePaymentPlanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentRecord>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/payment-plan`,
      salesCreateSalePaymentPlanBody,options
    );
  }



export const getSalesCreateSalePaymentPlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext> => {

const mutationKey = ['salesCreateSalePaymentPlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, {saleId: string;data: SalesCreateSalePaymentPlanBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSalePaymentPlan(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalePaymentPlanMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>>
    export type SalesCreateSalePaymentPlanMutationBody = SalesCreateSalePaymentPlanBody
    export type SalesCreateSalePaymentPlanMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export const useSalesCreateSalePaymentPlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
        TError,
        {saleId: string;data: SalesCreateSalePaymentPlanBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalePaymentPlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all promissory notes for a specific sale
 */
export const paymentsGetSalePromissoryNotes = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/promissory-notes`,options
    );
  }




export const getPaymentsGetSalePromissoryNotesQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetSalePromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetSalePromissoryNotesQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>> = ({ signal }) => paymentsGetSalePromissoryNotes(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetSalePromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>>
export type PaymentsGetSalePromissoryNotesQueryError = AxiosError<unknown>


export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a specific sale
 */

export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = AxiosError<unknown>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetSalePromissoryNotesQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create an invoice for the specified sale
 * @summary Create invoice for sale
 */
export const salesCreateSaleInvoice = (
    saleId: string,
    salesCreateSaleInvoiceBody: SalesCreateSaleInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SalesCreateSaleInvoice201>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/invoice`,
      salesCreateSaleInvoiceBody,options
    );
  }



export const getSalesCreateSaleInvoiceMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext> => {

const mutationKey = ['salesCreateSaleInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, {saleId: string;data: SalesCreateSaleInvoiceBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSaleInvoice(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSaleInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSaleInvoice>>>
    export type SalesCreateSaleInvoiceMutationBody = SalesCreateSaleInvoiceBody
    export type SalesCreateSaleInvoiceMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create invoice for sale
 */
export const useSalesCreateSaleInvoice = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSaleInvoice>>, TError,{saleId: string;data: SalesCreateSaleInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSaleInvoice>>,
        TError,
        {saleId: string;data: SalesCreateSaleInvoiceBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSaleInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve the invoice for the specified sale
 * @summary Get invoice for sale
 */
export const salesGetSaleInvoice = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SalesGetSaleInvoice200>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/invoice`,options
    );
  }




export const getSalesGetSaleInvoiceQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice`
    ] as const;
    }

    
export const getSalesGetSaleInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSaleInvoiceQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSaleInvoice>>> = ({ signal }) => salesGetSaleInvoice(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSaleInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSaleInvoice>>>
export type SalesGetSaleInvoiceQueryError = AxiosError<ErrorResponse>


export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof salesGetSaleInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof salesGetSaleInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice for sale
 */

export function useSalesGetSaleInvoice<TData = Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSaleInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSaleInvoiceQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Generate and download a PDF for the specified sale invoice
 * @summary Generate sale invoice PDF
 */
export const salesGenerateSaleInvoicePdf = (
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/sales/${saleId}/invoice/pdf`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getSalesGenerateSaleInvoicePdfQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice/pdf`
    ] as const;
    }

    
export const getSalesGenerateSaleInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGenerateSaleInvoicePdfQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>> = ({ signal }) => salesGenerateSaleInvoicePdf(saleId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGenerateSaleInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>>
export type SalesGenerateSaleInvoicePdfQueryError = AxiosError<ErrorResponse>


export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate sale invoice PDF
 */

export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = AxiosError<ErrorResponse>>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGenerateSaleInvoicePdfQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update settings information
 * @summary Update system settings
 */
export const updateSettings = (
    updateSettingsBody?: UpdateSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/settings`,
      updateSettingsBody,options
    );
  }



export const getUpdateSettingsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext> => {

const mutationKey = ['updateSettings'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSettings>>, {data: UpdateSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  updateSettings(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateSettings>>>
    export type UpdateSettingsMutationBody = UpdateSettingsBody
    export type UpdateSettingsMutationError = AxiosError<unknown>

    /**
 * @summary Update system settings
 */
export const useUpdateSettings = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSettings>>,
        TError,
        {data: UpdateSettingsBody},
        TContext
      > => {

      const mutationOptions = getUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
    sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/documents`,
      sgkUploadSgkDocumentBody,options
    );
  }



export const getSgkUploadSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext> => {

const mutationKey = ['sgkUploadSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, {data: SgkUploadSgkDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadSgkDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadSgkDocument>>>
    export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody
    export type SgkUploadSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
        TError,
        {data: SgkUploadSgkDocumentBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (
    documentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sgk/documents/${documentId}`,options
    );
  }



export const getSgkDeleteSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['sgkDeleteSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  sgkDeleteSgkDocument(documentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkDeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>>
    
    export type SgkDeleteSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve list of SMS headers
 * @summary Get SMS headers
 */
export const smsGetHeaders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetHeaders200>> => {
    
    
    return axios.get(
      `/api/sms/headers`,options
    );
  }




export const getSmsGetHeadersQueryKey = () => {
    return [
    `/api/sms/headers`
    ] as const;
    }

    
export const getSmsGetHeadersQueryOptions = <TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetHeadersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetHeaders>>> = ({ signal }) => smsGetHeaders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetHeaders>>>
export type SmsGetHeadersQueryError = AxiosError<unknown>


export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof smsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS headers
 */

export function useSmsGetHeaders<TData = Awaited<ReturnType<typeof smsGetHeaders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetHeadersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new SMS header
 * @summary Create SMS header
 */
export const smsCreateHeader = (
    smsCreateHeaderBody: SmsCreateHeaderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sms/headers`,
      smsCreateHeaderBody,options
    );
  }



export const getSmsCreateHeaderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext> => {

const mutationKey = ['smsCreateHeader'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsCreateHeader>>, {data: SmsCreateHeaderBody}> = (props) => {
          const {data} = props ?? {};

          return  smsCreateHeader(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsCreateHeaderMutationResult = NonNullable<Awaited<ReturnType<typeof smsCreateHeader>>>
    export type SmsCreateHeaderMutationBody = SmsCreateHeaderBody
    export type SmsCreateHeaderMutationError = AxiosError<unknown>

    /**
 * @summary Create SMS header
 */
export const useSmsCreateHeader = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateHeader>>, TError,{data: SmsCreateHeaderBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsCreateHeader>>,
        TError,
        {data: SmsCreateHeaderBody},
        TContext
      > => {

      const mutationOptions = getSmsCreateHeaderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve list of SMS audiences
 * @summary Get SMS audiences
 */
export const smsGetAudiences = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetAudiences200>> => {
    
    
    return axios.get(
      `/api/sms/audiences`,options
    );
  }




export const getSmsGetAudiencesQueryKey = () => {
    return [
    `/api/sms/audiences`
    ] as const;
    }

    
export const getSmsGetAudiencesQueryOptions = <TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetAudiencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetAudiences>>> = ({ signal }) => smsGetAudiences({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetAudiencesQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetAudiences>>>
export type SmsGetAudiencesQueryError = AxiosError<unknown>


export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsGetAudiences>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetAudiences>>,
          TError,
          Awaited<ReturnType<typeof smsGetAudiences>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS audiences
 */

export function useSmsGetAudiences<TData = Awaited<ReturnType<typeof smsGetAudiences>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetAudiences>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetAudiencesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new SMS audience
 * @summary Create SMS audience
 */
export const smsCreateAudience = (
    smsCreateAudienceBody: SmsCreateAudienceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sms/audiences`,
      smsCreateAudienceBody,options
    );
  }



export const getSmsCreateAudienceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext> => {

const mutationKey = ['smsCreateAudience'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsCreateAudience>>, {data: SmsCreateAudienceBody}> = (props) => {
          const {data} = props ?? {};

          return  smsCreateAudience(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsCreateAudienceMutationResult = NonNullable<Awaited<ReturnType<typeof smsCreateAudience>>>
    export type SmsCreateAudienceMutationBody = SmsCreateAudienceBody
    export type SmsCreateAudienceMutationError = AxiosError<unknown>

    /**
 * @summary Create SMS audience
 */
export const useSmsCreateAudience = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsCreateAudience>>, TError,{data: SmsCreateAudienceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsCreateAudience>>,
        TError,
        {data: SmsCreateAudienceBody},
        TContext
      > => {

      const mutationOptions = getSmsCreateAudienceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Upload a file to create SMS audience
 * @summary Upload SMS audience file
 */
export const smsUploadAudience = (
    smsUploadAudienceBody: SmsUploadAudienceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    const formData = new FormData();
if(smsUploadAudienceBody.file !== undefined) {
 formData.append(`file`, smsUploadAudienceBody.file)
 }

    return axios.post(
      `/api/sms/audiences/upload`,
      formData,options
    );
  }



export const getSmsUploadAudienceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext> => {

const mutationKey = ['smsUploadAudience'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadAudience>>, {data: SmsUploadAudienceBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadAudience(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadAudienceMutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadAudience>>>
    export type SmsUploadAudienceMutationBody = SmsUploadAudienceBody
    export type SmsUploadAudienceMutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS audience file
 */
export const useSmsUploadAudience = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadAudience>>, TError,{data: SmsUploadAudienceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadAudience>>,
        TError,
        {data: SmsUploadAudienceBody},
        TContext
      > => {

      const mutationOptions = getSmsUploadAudienceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve SMS configuration settings
 * @summary Get SMS configuration
 */
export const smsGetConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetConfig200>> => {
    
    
    return axios.get(
      `/api/sms/config`,options
    );
  }




export const getSmsGetConfigQueryKey = () => {
    return [
    `/api/sms/config`
    ] as const;
    }

    
export const getSmsGetConfigQueryOptions = <TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetConfig>>> = ({ signal }) => smsGetConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetConfig>>>
export type SmsGetConfigQueryError = AxiosError<unknown>


export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetConfig>>,
          TError,
          Awaited<ReturnType<typeof smsGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetConfig>>,
          TError,
          Awaited<ReturnType<typeof smsGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS configuration
 */

export function useSmsGetConfig<TData = Awaited<ReturnType<typeof smsGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update SMS configuration settings
 * @summary Update SMS configuration
 */
export const smsUpdateConfig = (
    smsUpdateConfigBody: SmsUpdateConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/sms/config`,
      smsUpdateConfigBody,options
    );
  }



export const getSmsUpdateConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext> => {

const mutationKey = ['smsUpdateConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUpdateConfig>>, {data: SmsUpdateConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUpdateConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUpdateConfigMutationResult = NonNullable<Awaited<ReturnType<typeof smsUpdateConfig>>>
    export type SmsUpdateConfigMutationBody = SmsUpdateConfigBody
    export type SmsUpdateConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update SMS configuration
 */
export const useSmsUpdateConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUpdateConfig>>, TError,{data: SmsUpdateConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUpdateConfig>>,
        TError,
        {data: SmsUpdateConfigBody},
        TContext
      > => {

      const mutationOptions = getSmsUpdateConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve available SMS packages
 * @summary Get SMS packages
 */
export const smsGetPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetPackages200>> => {
    
    
    return axios.get(
      `/api/sms/packages`,options
    );
  }




export const getSmsGetPackagesQueryKey = () => {
    return [
    `/api/sms/packages`
    ] as const;
    }

    
export const getSmsGetPackagesQueryOptions = <TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetPackages>>> = ({ signal }) => smsGetPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetPackages>>>
export type SmsGetPackagesQueryError = AxiosError<unknown>


export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof smsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof smsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS packages
 */

export function useSmsGetPackages<TData = Awaited<ReturnType<typeof smsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve current SMS credit balance
 * @summary Get SMS credit balance
 */
export const smsGetCredit = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsGetCredit200>> => {
    
    
    return axios.get(
      `/api/sms/credit`,options
    );
  }




export const getSmsGetCreditQueryKey = () => {
    return [
    `/api/sms/credit`
    ] as const;
    }

    
export const getSmsGetCreditQueryOptions = <TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsGetCreditQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsGetCredit>>> = ({ signal }) => smsGetCredit({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsGetCreditQueryResult = NonNullable<Awaited<ReturnType<typeof smsGetCredit>>>
export type SmsGetCreditQueryError = AxiosError<unknown>


export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetCredit>>,
          TError,
          Awaited<ReturnType<typeof smsGetCredit>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsGetCredit>>,
          TError,
          Awaited<ReturnType<typeof smsGetCredit>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS credit balance
 */

export function useSmsGetCredit<TData = Awaited<ReturnType<typeof smsGetCredit>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsGetCredit>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsGetCreditQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Upload SMS-related document
 * @summary Upload SMS document
 */
export const smsUploadDocument = (
    smsUploadDocumentBody: SmsUploadDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    const formData = new FormData();
if(smsUploadDocumentBody.file !== undefined) {
 formData.append(`file`, smsUploadDocumentBody.file)
 }

    return axios.post(
      `/api/sms/upload`,
      formData,options
    );
  }



export const getSmsUploadDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext> => {

const mutationKey = ['smsUploadDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadDocument>>, {data: SmsUploadDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadDocument>>>
    export type SmsUploadDocumentMutationBody = SmsUploadDocumentBody
    export type SmsUploadDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS document
 */
export const useSmsUploadDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadDocument>>,
        TError,
        {data: SmsUploadDocumentBody},
        TContext
      > => {

      const mutationOptions = getSmsUploadDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Download SMS-related document
 * @summary Download SMS document
 */
export const smsDownloadDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    
    return axios.get(
      `/api/sms/documents/${documentType}/download`,{
        responseType: 'blob',
    ...options,}
    );
  }




export const getSmsDownloadDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsDownloadDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsDownloadDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsDownloadDocument>>> = ({ signal }) => smsDownloadDocument(documentType, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsDownloadDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsDownloadDocument>>>
export type SmsDownloadDocumentQueryError = AxiosError<unknown>


export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Download SMS document
 */

export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsDownloadDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete SMS-related document
 * @summary Delete SMS document
 */
export const smsDeleteDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sms/documents/${documentType}`,options
    );
  }



export const getSmsDeleteDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsDeleteDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsDeleteDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsDeleteDocument(documentType,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsDeleteDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsDeleteDocument>>>
    
    export type SmsDeleteDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Delete SMS document
 */
export const useSmsDeleteDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsDeleteDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsDeleteDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sms/monitoring`,options
    );
  }




export const getSmsMonitoringQueryKey = () => {
    return [
    `/api/sms/monitoring`
    ] as const;
    }

    
export const getSmsMonitoringQueryOptions = <TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({ signal }) => smsMonitoring({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsMonitoringQueryResult = NonNullable<Awaited<ReturnType<typeof smsMonitoring>>>
export type SmsMonitoringQueryError = AxiosError<unknown>


export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsMonitoringQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of suppliers with optional filtering and pagination
 * @summary Get list of suppliers
 */
export const suppliersGetSuppliers = (
    params?: SuppliersGetSuppliersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSuppliers200>> => {
    
    
    return axios.get(
      `/api/suppliers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSuppliersGetSuppliersQueryKey = (params?: SuppliersGetSuppliersParams,) => {
    return [
    `/api/suppliers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSuppliersGetSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSuppliersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSuppliers>>> = ({ signal }) => suppliersGetSuppliers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSuppliers>>>
export type SuppliersGetSuppliersQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  SuppliersGetSuppliersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of suppliers
 */

export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = AxiosError<ErrorResponse>>(
 params?: SuppliersGetSuppliersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSuppliersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Register a new supplier with contact and business information
 * @summary Create a new supplier
 */
export const suppliersCreateSupplier = (
    suppliersCreateSupplierBody?: SuppliersCreateSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supplier>> => {
    
    
    return axios.post(
      `/api/suppliers`,
      suppliersCreateSupplierBody,options
    );
  }



export const getSuppliersCreateSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext> => {

const mutationKey = ['suppliersCreateSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersCreateSupplier>>, {data: SuppliersCreateSupplierBody}> = (props) => {
          const {data} = props ?? {};

          return  suppliersCreateSupplier(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersCreateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersCreateSupplier>>>
    export type SuppliersCreateSupplierMutationBody = SuppliersCreateSupplierBody
    export type SuppliersCreateSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Create a new supplier
 */
export const useSuppliersCreateSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersCreateSupplier>>,
        TError,
        {data: SuppliersCreateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersCreateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a supplier from the system
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const suppliersDeleteSupplier = (
    supplierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/suppliers/${supplierId}`,options
    );
  }



export const getSuppliersDeleteSupplierMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext> => {

const mutationKey = ['suppliersDeleteSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, {supplierId: string}> = (props) => {
          const {supplierId} = props ?? {};

          return  suppliersDeleteSupplier(supplierId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteSupplier>>>
    
    export type SuppliersDeleteSupplierMutationError = AxiosError<unknown>

    /**
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const useSuppliersDeleteSupplier = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
        TError,
        {supplierId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update an existing supplier's information
 * @summary Update supplier details
 */
export const suppliersUpdateSupplier = (
    supplierId: string,
    suppliersCreateSupplierBody: SuppliersCreateSupplierBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Supplier>> => {
    
    
    return axios.put(
      `/api/suppliers/${supplierId}`,
      suppliersCreateSupplierBody,options
    );
  }



export const getSuppliersUpdateSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersCreateSupplierBody}, TContext> => {

const mutationKey = ['suppliersUpdateSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, {supplierId: string;data: SuppliersCreateSupplierBody}> = (props) => {
          const {supplierId,data} = props ?? {};

          return  suppliersUpdateSupplier(supplierId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersUpdateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersUpdateSupplier>>>
    export type SuppliersUpdateSupplierMutationBody = SuppliersCreateSupplierBody
    export type SuppliersUpdateSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update supplier details
 */
export const useSuppliersUpdateSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersCreateSupplierBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
        TError,
        {supplierId: string;data: SuppliersCreateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersUpdateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get list of products available from a specific supplier
 * @summary Get all products for a specific supplier
 */
export const suppliersGetSupplierProducts = (
    supplierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/suppliers/${supplierId}/products`,options
    );
  }




export const getSuppliersGetSupplierProductsQueryKey = (supplierId?: string,) => {
    return [
    `/api/suppliers/${supplierId}/products`
    ] as const;
    }

    
export const getSuppliersGetSupplierProductsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierProductsQueryKey(supplierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>> = ({ signal }) => suppliersGetSupplierProducts(supplierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierProductsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>>
export type SuppliersGetSupplierProductsQueryError = AxiosError<unknown>


export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all products for a specific supplier
 */

export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = AxiosError<unknown>>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierProductsQueryOptions(supplierId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get supplier statistics including order history
 * @summary Get supplier statistics
 */
export const suppliersGetSupplierStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/suppliers/stats`,options
    );
  }




export const getSuppliersGetSupplierStatsQueryKey = () => {
    return [
    `/api/suppliers/stats`
    ] as const;
    }

    
export const getSuppliersGetSupplierStatsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierStats>>> = ({ signal }) => suppliersGetSupplierStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierStatsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierStats>>>
export type SuppliersGetSupplierStatsQueryError = AxiosError<unknown>


export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get supplier statistics
 */

export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create new verify-registration-otp
 * @summary POST /api/verify-registration-otp
 */
export const registrationVerifyRegistrationOtp = (
    registrationVerifyRegistrationOtpBody?: RegistrationVerifyRegistrationOtpBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/verify-registration-otp`,
      registrationVerifyRegistrationOtpBody,options
    );
  }



export const getRegistrationVerifyRegistrationOtpMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext> => {

const mutationKey = ['registrationVerifyRegistrationOtp'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, {data: RegistrationVerifyRegistrationOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationVerifyRegistrationOtp(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationVerifyRegistrationOtpMutationResult = NonNullable<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>>
    export type RegistrationVerifyRegistrationOtpMutationBody = RegistrationVerifyRegistrationOtpBody
    export type RegistrationVerifyRegistrationOtpMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/verify-registration-otp
 */
export const useRegistrationVerifyRegistrationOtp = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
        TError,
        {data: RegistrationVerifyRegistrationOtpBody},
        TContext
      > => {

      const mutationOptions = getRegistrationVerifyRegistrationOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a list of all users
 * @summary GET /api/users
 */
export const usersListUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User[]>> => {
    
    
    return axios.get(
      `/api/users`,options
    );
  }




export const getUsersListUsersQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getUsersListUsersQueryOptions = <TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersListUsers>>> = ({ signal }) => usersListUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersListUsers>>>
export type UsersListUsersQueryError = AxiosError<unknown>


export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users
 */

export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user
 * @summary POST /api/users
 */
export const usersCreateUser = (
    usersCreateUserBody: UsersCreateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.post(
      `/api/users`,
      usersCreateUserBody,options
    );
  }



export const getUsersCreateUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext> => {

const mutationKey = ['usersCreateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreateUser>>, {data: UsersCreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  usersCreateUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreateUser>>>
    export type UsersCreateUserMutationBody = UsersCreateUserBody
    export type UsersCreateUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary POST /api/users
 */
export const useUsersCreateUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersCreateUser>>,
        TError,
        {data: UsersCreateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get user details by ID
 * @summary GET /api/users/{user_id}
 */
export const usersGetUser = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.get(
      `/api/users/${userId}`,options
    );
  }




export const getUsersGetUserQueryKey = (userId?: string,) => {
    return [
    `/api/users/${userId}`
    ] as const;
    }

    
export const getUsersGetUserQueryOptions = <TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUser>>> = ({ signal }) => usersGetUser(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersGetUserQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetUser>>>
export type UsersGetUserQueryError = AxiosError<ErrorResponse>


export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users/{user_id}
 */

export function useUsersGetUser<TData = Awaited<ReturnType<typeof usersGetUser>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update user information
 * @summary PUT /api/users/{user_id}
 */
export const usersUpdateUser = (
    userId: string,
    usersUpdateUserBody: UsersUpdateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.put(
      `/api/users/${userId}`,
      usersUpdateUserBody,options
    );
  }



export const getUsersUpdateUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext> => {

const mutationKey = ['usersUpdateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateUser>>, {userId: string;data: UsersUpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersUpdateUser(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateUser>>>
    export type UsersUpdateUserMutationBody = UsersUpdateUserBody
    export type UsersUpdateUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary PUT /api/users/{user_id}
 */
export const useUsersUpdateUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateUser>>,
        TError,
        {userId: string;data: UsersUpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a user
 * @summary DELETE /api/users/{user_id}
 */
export const usersDeleteUser = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/users/${userId}`,options
    );
  }



export const getUsersDeleteUserMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['usersDeleteUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  usersDeleteUser(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUser>>>
    
    export type UsersDeleteUserMutationError = AxiosError<ErrorResponse>

    /**
 * @summary DELETE /api/users/{user_id}
 */
export const useUsersDeleteUser = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getUsersDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get current authenticated user information
 * @summary GET /api/users/me
 */
export const usersGetCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.get(
      `/api/users/me`,options
    );
  }




export const getUsersGetCurrentUserQueryKey = () => {
    return [
    `/api/users/me`
    ] as const;
    }

    
export const getUsersGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetCurrentUser>>> = ({ signal }) => usersGetCurrentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersGetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetCurrentUser>>>
export type UsersGetCurrentUserQueryError = AxiosError<ErrorResponse>


export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof usersGetCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users/me
 */

export function useUsersGetCurrentUser<TData = Awaited<ReturnType<typeof usersGetCurrentUser>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update current user profile
 */
export const usersUpdateMe = (
    usersUpdateMeBody: UsersUpdateMeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.put(
      `/api/users/me`,
      usersUpdateMeBody,options
    );
  }



export const getUsersUpdateMeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext> => {

const mutationKey = ['usersUpdateMe'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateMe>>, {data: UsersUpdateMeBody}> = (props) => {
          const {data} = props ?? {};

          return  usersUpdateMe(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateMe>>>
    export type UsersUpdateMeMutationBody = UsersUpdateMeBody
    export type UsersUpdateMeMutationError = AxiosError<unknown>

    /**
 * @summary Update current user profile
 */
export const useUsersUpdateMe = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateMe>>,
        TError,
        {data: UsersUpdateMeBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateMeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Change current user password
 */
export const usersChangePassword = (
    usersChangePasswordBody: UsersChangePasswordBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UsersChangePassword200>> => {
    
    
    return axios.post(
      `/api/users/me/password`,
      usersChangePasswordBody,options
    );
  }



export const getUsersChangePasswordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext> => {

const mutationKey = ['usersChangePassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersChangePassword>>, {data: UsersChangePasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  usersChangePassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersChangePassword>>>
    export type UsersChangePasswordMutationBody = UsersChangePasswordBody
    export type UsersChangePasswordMutationError = AxiosError<unknown>

    /**
 * @summary Change current user password
 */
export const useUsersChangePassword = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersChangePassword>>,
        TError,
        {data: UsersChangePasswordBody},
        TContext
      > => {

      const mutationOptions = getUsersChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List tenant users
 */
export const tenantUsersList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersList200>> => {
    
    
    return axios.get(
      `/api/tenant/users`,options
    );
  }




export const getTenantUsersListQueryKey = () => {
    return [
    `/api/tenant/users`
    ] as const;
    }

    
export const getTenantUsersListQueryOptions = <TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTenantUsersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantUsersList>>> = ({ signal }) => tenantUsersList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TenantUsersListQueryResult = NonNullable<Awaited<ReturnType<typeof tenantUsersList>>>
export type TenantUsersListQueryError = AxiosError<unknown>


export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersList>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersList>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List tenant users
 */

export function useTenantUsersList<TData = Awaited<ReturnType<typeof tenantUsersList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTenantUsersListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Invite/Create tenant user
 */
export const tenantUsersInvite = (
    tenantUsersInviteBody: TenantUsersInviteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersInvite201>> => {
    
    
    return axios.post(
      `/api/tenant/users`,
      tenantUsersInviteBody,options
    );
  }



export const getTenantUsersInviteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext> => {

const mutationKey = ['tenantUsersInvite'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersInvite>>, {data: TenantUsersInviteBody}> = (props) => {
          const {data} = props ?? {};

          return  tenantUsersInvite(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersInviteMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersInvite>>>
    export type TenantUsersInviteMutationBody = TenantUsersInviteBody
    export type TenantUsersInviteMutationError = AxiosError<unknown>

    /**
 * @summary Invite/Create tenant user
 */
export const useTenantUsersInvite = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersInvite>>, TError,{data: TenantUsersInviteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersInvite>>,
        TError,
        {data: TenantUsersInviteBody},
        TContext
      > => {

      const mutationOptions = getTenantUsersInviteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete tenant user
 */
export const tenantUsersDelete = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TenantUsersDelete200>> => {
    
    
    return axios.delete(
      `/api/tenant/users/${userId}`,options
    );
  }



export const getTenantUsersDeleteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext> => {

const mutationKey = ['tenantUsersDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersDelete>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  tenantUsersDelete(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersDelete>>>
    
    export type TenantUsersDeleteMutationError = AxiosError<unknown>

    /**
 * @summary Delete tenant user
 */
export const useTenantUsersDelete = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersDelete>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getTenantUsersDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create new entities
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntities = (
    ocrExtractEntitiesBody?: OcrExtractEntitiesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/entities`,
      ocrExtractEntitiesBody,options
    );
  }



export const getOcrExtractEntitiesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext> => {

const mutationKey = ['ocrExtractEntities'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractEntities>>, {data: OcrExtractEntitiesBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractEntities(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractEntitiesMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractEntities>>>
    export type OcrExtractEntitiesMutationBody = OcrExtractEntitiesBody
    export type OcrExtractEntitiesMutationError = AxiosError<unknown>

    /**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntities = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractEntities>>,
        TError,
        {data: OcrExtractEntitiesBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractEntitiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Extract patient name from document image using OCR
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientName = (
    ocrExtractPatientNameBody?: OcrExtractPatientNameBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/extract_patient`,
      ocrExtractPatientNameBody,options
    );
  }



export const getOcrExtractPatientNameMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext> => {

const mutationKey = ['ocrExtractPatientName'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractPatientName>>, {data: OcrExtractPatientNameBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractPatientName(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractPatientNameMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractPatientName>>>
    export type OcrExtractPatientNameMutationBody = OcrExtractPatientNameBody
    export type OcrExtractPatientNameMutationError = AxiosError<unknown>

    /**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientName = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractPatientName>>,
        TError,
        {data: OcrExtractPatientNameBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractPatientNameMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Health check for OCR service availability
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/health`,options
    );
  }




export const getOcrHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getOcrHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOcrHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheck>>> = ({ signal }) => ocrHealthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type OcrHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof ocrHealthCheck>>>
export type OcrHealthCheckQueryError = AxiosError<unknown>


export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getOcrHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Initialize OCR service database and create required tables
 * @summary Initialize database and create tables
 */
export const ocrInitDatabase = (
    ocrInitDatabaseBody?: OcrInitDatabaseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/init-db`,
      ocrInitDatabaseBody,options
    );
  }



export const getOcrInitDatabaseMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext> => {

const mutationKey = ['ocrInitDatabase'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitDatabase>>, {data: OcrInitDatabaseBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitDatabase(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitDatabase>>>
    export type OcrInitDatabaseMutationBody = OcrInitDatabaseBody
    export type OcrInitDatabaseMutationError = AxiosError<unknown>

    /**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabase = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitDatabase>>,
        TError,
        {data: OcrInitDatabaseBody},
        TContext
      > => {

      const mutationOptions = getOcrInitDatabaseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Initialize NLP/OCR processing service
 * @summary Initialize NLP/OCR service
 */
export const ocrInitializeNlpEndpoint = (
    ocrInitializeNlpEndpointBody?: OcrInitializeNlpEndpointBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/initialize`,
      ocrInitializeNlpEndpointBody,options
    );
  }



export const getOcrInitializeNlpEndpointMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext> => {

const mutationKey = ['ocrInitializeNlpEndpoint'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, {data: OcrInitializeNlpEndpointBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitializeNlpEndpoint(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitializeNlpEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>>
    export type OcrInitializeNlpEndpointMutationBody = OcrInitializeNlpEndpointBody
    export type OcrInitializeNlpEndpointMutationError = AxiosError<unknown>

    /**
 * @summary Initialize NLP/OCR service
 */
export const useOcrInitializeNlpEndpoint = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
        TError,
        {data: OcrInitializeNlpEndpointBody},
        TContext
      > => {

      const mutationOptions = getOcrInitializeNlpEndpointMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Process document using OCR to extract text and data
 * @summary Process document with OCR
 */
export const ocrProcessDocument = (
    ocrProcessDocumentBody?: OcrProcessDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/process`,
      ocrProcessDocumentBody,options
    );
  }



export const getOcrProcessDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext> => {

const mutationKey = ['ocrProcessDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrProcessDocument>>, {data: OcrProcessDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrProcessDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrProcessDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof ocrProcessDocument>>>
    export type OcrProcessDocumentMutationBody = OcrProcessDocumentBody
    export type OcrProcessDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Process document with OCR
 */
export const useOcrProcessDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrProcessDocument>>,
        TError,
        {data: OcrProcessDocumentBody},
        TContext
      > => {

      const mutationOptions = getOcrProcessDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Calculate similarity between documents using OCR text analysis
 * @summary Calculate similarity between two images using OCR text
 */
export const ocrCalculateSimilarity = (
    ocrCalculateSimilarityBody?: OcrCalculateSimilarityBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/similarity`,
      ocrCalculateSimilarityBody,options
    );
  }



export const getOcrCalculateSimilarityMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext> => {

const mutationKey = ['ocrCalculateSimilarity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, {data: OcrCalculateSimilarityBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrCalculateSimilarity(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCalculateSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof ocrCalculateSimilarity>>>
    export type OcrCalculateSimilarityMutationBody = OcrCalculateSimilarityBody
    export type OcrCalculateSimilarityMutationError = AxiosError<unknown>

    /**
 * @summary Calculate similarity between two images using OCR text
 */
export const useOcrCalculateSimilarity = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
        TError,
        {data: OcrCalculateSimilarityBody},
        TContext
      > => {

      const mutationOptions = getOcrCalculateSimilarityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This helps local development: visit http://<backend-host>:<port>/swagger.html so the
Swagger UI and `/api/openapi.yaml` are on the same origin and no CORS overrides are needed.
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */
export const serveSwaggerUi = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/swagger.html`,options
    );
  }




export const getServeSwaggerUiQueryKey = () => {
    return [
    `/swagger.html`
    ] as const;
    }

    
export const getServeSwaggerUiQueryOptions = <TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeSwaggerUiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveSwaggerUi>>> = ({ signal }) => serveSwaggerUi({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeSwaggerUiQueryResult = NonNullable<Awaited<ReturnType<typeof serveSwaggerUi>>>
export type ServeSwaggerUiQueryError = AxiosError<unknown>


export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */

export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeSwaggerUiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve purchase invoices for the specified supplier
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */
export const suppliersGetSupplierInvoices = (
    supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSupplierInvoices200>> => {
    
    
    return axios.get(
      `/api/suppliers/${supplierId}/invoices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSuppliersGetSupplierInvoicesQueryKey = (supplierId?: string,
    params?: SuppliersGetSupplierInvoicesParams,) => {
    return [
    `/api/suppliers/${supplierId}/invoices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSuppliersGetSupplierInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierInvoicesQueryKey(supplierId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>> = ({ signal }) => suppliersGetSupplierInvoices(supplierId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>>
export type SuppliersGetSupplierInvoicesQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params: undefined |  SuppliersGetSupplierInvoicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get supplier purchase invoices (incoming and outgoing)
 */

export function useSuppliersGetSupplierInvoices<TData = Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError = AxiosError<ErrorResponse>>(
 supplierId: string,
    params?: SuppliersGetSupplierInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierInvoicesQueryOptions(supplierId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of suggested suppliers based on incoming invoices
 * @summary Get suggested suppliers (pending approval)
 */
export const suppliersGetSuggestedSuppliers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersGetSuggestedSuppliers200>> => {
    
    
    return axios.get(
      `/api/suppliers/suggested`,options
    );
  }




export const getSuppliersGetSuggestedSuppliersQueryKey = () => {
    return [
    `/api/suppliers/suggested`
    ] as const;
    }

    
export const getSuppliersGetSuggestedSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSuggestedSuppliersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>> = ({ signal }) => suppliersGetSuggestedSuppliers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSuggestedSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>>
export type SuppliersGetSuggestedSuppliersQueryError = AxiosError<ErrorResponse>


export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get suggested suppliers (pending approval)
 */

export function useSuppliersGetSuggestedSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuggestedSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSuggestedSuppliersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Accept a suggested supplier and create or link to a supplier by tax number
 * @summary Accept suggested supplier and create/link supplier record
 */
export const suppliersAcceptSuggestedSupplier = (
    suggestedId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersAcceptSuggestedSupplier200 | SuppliersAcceptSuggestedSupplier201>> => {
    
    
    return axios.post(
      `/api/suppliers/suggested/${suggestedId}/accept`,undefined,options
    );
  }



export const getSuppliersAcceptSuggestedSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext> => {

const mutationKey = ['suppliersAcceptSuggestedSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, {suggestedId: string}> = (props) => {
          const {suggestedId} = props ?? {};

          return  suppliersAcceptSuggestedSupplier(suggestedId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersAcceptSuggestedSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>>
    
    export type SuppliersAcceptSuggestedSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Accept suggested supplier and create/link supplier record
 */
export const useSuppliersAcceptSuggestedSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersAcceptSuggestedSupplier>>,
        TError,
        {suggestedId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersAcceptSuggestedSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reject and mark a suggested supplier as rejected
 * @summary Reject a suggested supplier
 */
export const suppliersRejectSuggestedSupplier = (
    suggestedId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuppliersRejectSuggestedSupplier200>> => {
    
    
    return axios.delete(
      `/api/suppliers/suggested/${suggestedId}`,options
    );
  }



export const getSuppliersRejectSuggestedSupplierMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext> => {

const mutationKey = ['suppliersRejectSuggestedSupplier'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, {suggestedId: string}> = (props) => {
          const {suggestedId} = props ?? {};

          return  suppliersRejectSuggestedSupplier(suggestedId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersRejectSuggestedSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>>
    
    export type SuppliersRejectSuggestedSupplierMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Reject a suggested supplier
 */
export const useSuppliersRejectSuggestedSupplier = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>, TError,{suggestedId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersRejectSuggestedSupplier>>,
        TError,
        {suggestedId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersRejectSuggestedSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Trigger invoice synchronization from integrator to local database
 * @summary Sync invoices from BirFatura provider
 */
export const birfaturaSyncInvoices = (
    birfaturaSyncInvoicesBody?: BirfaturaSyncInvoicesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BirfaturaSyncInvoices200>> => {
    
    
    return axios.post(
      `/api/birfatura/sync-invoices`,
      birfaturaSyncInvoicesBody,options
    );
  }



export const getBirfaturaSyncInvoicesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext> => {

const mutationKey = ['birfaturaSyncInvoices'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, {data: BirfaturaSyncInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaSyncInvoices(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaSyncInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaSyncInvoices>>>
    export type BirfaturaSyncInvoicesMutationBody = BirfaturaSyncInvoicesBody
    export type BirfaturaSyncInvoicesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Sync invoices from BirFatura provider
 */
export const useBirfaturaSyncInvoices = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
        TError,
        {data: BirfaturaSyncInvoicesBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaSyncInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/EFatura/sendBasicInvoice
 */
export const birfaturaBpSendBasicInvoice = (
    birfaturaBpSendBasicInvoiceBody?: BirfaturaBpSendBasicInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/EFatura/sendBasicInvoice`,
      birfaturaBpSendBasicInvoiceBody,options
    );
  }



export const getBirfaturaBpSendBasicInvoiceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>, TError,{data: BirfaturaBpSendBasicInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>, TError,{data: BirfaturaBpSendBasicInvoiceBody}, TContext> => {

const mutationKey = ['birfaturaBpSendBasicInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>, {data: BirfaturaBpSendBasicInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpSendBasicInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpSendBasicInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>>
    export type BirfaturaBpSendBasicInvoiceMutationBody = BirfaturaBpSendBasicInvoiceBody
    export type BirfaturaBpSendBasicInvoiceMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/EFatura/sendBasicInvoice
 */
export const useBirfaturaBpSendBasicInvoice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>, TError,{data: BirfaturaBpSendBasicInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpSendBasicInvoice>>,
        TError,
        {data: BirfaturaBpSendBasicInvoiceBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpSendBasicInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/EFatura/sendDocument
 */
export const birfaturaBpSendDocument = (
    birfaturaBpSendDocumentBody?: BirfaturaBpSendDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/EFatura/sendDocument`,
      birfaturaBpSendDocumentBody,options
    );
  }



export const getBirfaturaBpSendDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendDocument>>, TError,{data: BirfaturaBpSendDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendDocument>>, TError,{data: BirfaturaBpSendDocumentBody}, TContext> => {

const mutationKey = ['birfaturaBpSendDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpSendDocument>>, {data: BirfaturaBpSendDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpSendDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpSendDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpSendDocument>>>
    export type BirfaturaBpSendDocumentMutationBody = BirfaturaBpSendDocumentBody
    export type BirfaturaBpSendDocumentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/EFatura/sendDocument
 */
export const useBirfaturaBpSendDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpSendDocument>>, TError,{data: BirfaturaBpSendDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpSendDocument>>,
        TError,
        {data: BirfaturaBpSendDocumentBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpSendDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * In mock mode, returns document from local inbox by UUID.
 * @summary Proxy for Birfatura DocumentDownloadByUUID.
 */
export const birfaturaBpOutDocumentDownloadByUuid = (
    birfaturaBpOutDocumentDownloadByUuidBody?: BirfaturaBpOutDocumentDownloadByUuidBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/DocumentDownloadByUUID`,
      birfaturaBpOutDocumentDownloadByUuidBody,options
    );
  }



export const getBirfaturaBpOutDocumentDownloadByUuidMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>, TError,{data: BirfaturaBpOutDocumentDownloadByUuidBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>, TError,{data: BirfaturaBpOutDocumentDownloadByUuidBody}, TContext> => {

const mutationKey = ['birfaturaBpOutDocumentDownloadByUuid'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>, {data: BirfaturaBpOutDocumentDownloadByUuidBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutDocumentDownloadByUuid(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutDocumentDownloadByUuidMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>>
    export type BirfaturaBpOutDocumentDownloadByUuidMutationBody = BirfaturaBpOutDocumentDownloadByUuidBody
    export type BirfaturaBpOutDocumentDownloadByUuidMutationError = AxiosError<unknown>

    /**
 * @summary Proxy for Birfatura DocumentDownloadByUUID.
 */
export const useBirfaturaBpOutDocumentDownloadByUuid = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>, TError,{data: BirfaturaBpOutDocumentDownloadByUuidBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutDocumentDownloadByUuid>>,
        TError,
        {data: BirfaturaBpOutDocumentDownloadByUuidBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutDocumentDownloadByUuidMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * In mock mode, reads from local inbox directory and returns parsed invoice list.
 * @summary Proxy for Birfatura GetInBoxDocuments.
 */
export const birfaturaBpOutGetInboxDocuments = (
    birfaturaBpOutGetInboxDocumentsBody?: BirfaturaBpOutGetInboxDocumentsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/GetInBoxDocuments`,
      birfaturaBpOutGetInboxDocumentsBody,options
    );
  }



export const getBirfaturaBpOutGetInboxDocumentsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>, TError,{data: BirfaturaBpOutGetInboxDocumentsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>, TError,{data: BirfaturaBpOutGetInboxDocumentsBody}, TContext> => {

const mutationKey = ['birfaturaBpOutGetInboxDocuments'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>, {data: BirfaturaBpOutGetInboxDocumentsBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutGetInboxDocuments(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutGetInboxDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>>
    export type BirfaturaBpOutGetInboxDocumentsMutationBody = BirfaturaBpOutGetInboxDocumentsBody
    export type BirfaturaBpOutGetInboxDocumentsMutationError = AxiosError<unknown>

    /**
 * @summary Proxy for Birfatura GetInBoxDocuments.
 */
export const useBirfaturaBpOutGetInboxDocuments = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>, TError,{data: BirfaturaBpOutGetInboxDocumentsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocuments>>,
        TError,
        {data: BirfaturaBpOutGetInboxDocumentsBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutGetInboxDocumentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * In mock mode, returns invoice list with jsonData (XML content).
 * @summary Proxy for Birfatura GetInBoxDocumentsWithDetail.
 */
export const birfaturaBpOutGetInboxDocumentsWithDetail = (
    birfaturaBpOutGetInboxDocumentsWithDetailBody?: BirfaturaBpOutGetInboxDocumentsWithDetailBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/GetInBoxDocumentsWithDetail`,
      birfaturaBpOutGetInboxDocumentsWithDetailBody,options
    );
  }



export const getBirfaturaBpOutGetInboxDocumentsWithDetailMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>, TError,{data: BirfaturaBpOutGetInboxDocumentsWithDetailBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>, TError,{data: BirfaturaBpOutGetInboxDocumentsWithDetailBody}, TContext> => {

const mutationKey = ['birfaturaBpOutGetInboxDocumentsWithDetail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>, {data: BirfaturaBpOutGetInboxDocumentsWithDetailBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutGetInboxDocumentsWithDetail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>>
    export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationBody = BirfaturaBpOutGetInboxDocumentsWithDetailBody
    export type BirfaturaBpOutGetInboxDocumentsWithDetailMutationError = AxiosError<unknown>

    /**
 * @summary Proxy for Birfatura GetInBoxDocumentsWithDetail.
 */
export const useBirfaturaBpOutGetInboxDocumentsWithDetail = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>, TError,{data: BirfaturaBpOutGetInboxDocumentsWithDetailBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutGetInboxDocumentsWithDetail>>,
        TError,
        {data: BirfaturaBpOutGetInboxDocumentsWithDetailBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutGetInboxDocumentsWithDetailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * In mock mode, generates PDF from provided XML.
 * @summary Proxy for Birfatura PreviewDocumentReturnPDF.
 */
export const birfaturaBpOutPreviewDocumentReturnPdf = (
    birfaturaBpOutPreviewDocumentReturnPdfBody?: BirfaturaBpOutPreviewDocumentReturnPdfBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/PreviewDocumentReturnPDF`,
      birfaturaBpOutPreviewDocumentReturnPdfBody,options
    );
  }



export const getBirfaturaBpOutPreviewDocumentReturnPdfMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>, TError,{data: BirfaturaBpOutPreviewDocumentReturnPdfBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>, TError,{data: BirfaturaBpOutPreviewDocumentReturnPdfBody}, TContext> => {

const mutationKey = ['birfaturaBpOutPreviewDocumentReturnPdf'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>, {data: BirfaturaBpOutPreviewDocumentReturnPdfBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutPreviewDocumentReturnPdf(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutPreviewDocumentReturnPdfMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>>
    export type BirfaturaBpOutPreviewDocumentReturnPdfMutationBody = BirfaturaBpOutPreviewDocumentReturnPdfBody
    export type BirfaturaBpOutPreviewDocumentReturnPdfMutationError = AxiosError<unknown>

    /**
 * @summary Proxy for Birfatura PreviewDocumentReturnPDF.
 */
export const useBirfaturaBpOutPreviewDocumentReturnPdf = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>, TError,{data: BirfaturaBpOutPreviewDocumentReturnPdfBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutPreviewDocumentReturnPdf>>,
        TError,
        {data: BirfaturaBpOutPreviewDocumentReturnPdfBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutPreviewDocumentReturnPdfMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * and writes the XML to `instance/birfatura_inbox/` with a provided `filename` or timestamped name.
 * @summary Simple inbox simulator endpoint: accepts JSON with `xml` or `documentBase64` (or raw body)
 */
export const birfaturaBpOutReceiveDocument = (
    birfaturaBpOutReceiveDocumentBody?: BirfaturaBpOutReceiveDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/ReceiveDocument`,
      birfaturaBpOutReceiveDocumentBody,options
    );
  }



export const getBirfaturaBpOutReceiveDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>, TError,{data: BirfaturaBpOutReceiveDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>, TError,{data: BirfaturaBpOutReceiveDocumentBody}, TContext> => {

const mutationKey = ['birfaturaBpOutReceiveDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>, {data: BirfaturaBpOutReceiveDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutReceiveDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutReceiveDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>>
    export type BirfaturaBpOutReceiveDocumentMutationBody = BirfaturaBpOutReceiveDocumentBody
    export type BirfaturaBpOutReceiveDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Simple inbox simulator endpoint: accepts JSON with `xml` or `documentBase64` (or raw body)
 */
export const useBirfaturaBpOutReceiveDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>, TError,{data: BirfaturaBpOutReceiveDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutReceiveDocument>>,
        TError,
        {data: BirfaturaBpOutReceiveDocumentBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutReceiveDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/OutEBelgeV2/SendBasicInvoiceFromModel
 */
export const birfaturaBpOutSendBasicInvoiceFromModel = (
    birfaturaBpOutSendBasicInvoiceFromModelBody?: BirfaturaBpOutSendBasicInvoiceFromModelBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/SendBasicInvoiceFromModel`,
      birfaturaBpOutSendBasicInvoiceFromModelBody,options
    );
  }



export const getBirfaturaBpOutSendBasicInvoiceFromModelMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>, TError,{data: BirfaturaBpOutSendBasicInvoiceFromModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>, TError,{data: BirfaturaBpOutSendBasicInvoiceFromModelBody}, TContext> => {

const mutationKey = ['birfaturaBpOutSendBasicInvoiceFromModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>, {data: BirfaturaBpOutSendBasicInvoiceFromModelBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutSendBasicInvoiceFromModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutSendBasicInvoiceFromModelMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>>
    export type BirfaturaBpOutSendBasicInvoiceFromModelMutationBody = BirfaturaBpOutSendBasicInvoiceFromModelBody
    export type BirfaturaBpOutSendBasicInvoiceFromModelMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/OutEBelgeV2/SendBasicInvoiceFromModel
 */
export const useBirfaturaBpOutSendBasicInvoiceFromModel = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>, TError,{data: BirfaturaBpOutSendBasicInvoiceFromModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutSendBasicInvoiceFromModel>>,
        TError,
        {data: BirfaturaBpOutSendBasicInvoiceFromModelBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutSendBasicInvoiceFromModelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/OutEBelgeV2/SendDocument
 */
export const birfaturaBpOutSendDocument = (
    birfaturaBpOutSendDocumentBody?: BirfaturaBpOutSendDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/SendDocument`,
      birfaturaBpOutSendDocumentBody,options
    );
  }



export const getBirfaturaBpOutSendDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>, TError,{data: BirfaturaBpOutSendDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>, TError,{data: BirfaturaBpOutSendDocumentBody}, TContext> => {

const mutationKey = ['birfaturaBpOutSendDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>, {data: BirfaturaBpOutSendDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaBpOutSendDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaBpOutSendDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>>
    export type BirfaturaBpOutSendDocumentMutationBody = BirfaturaBpOutSendDocumentBody
    export type BirfaturaBpOutSendDocumentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/OutEBelgeV2/SendDocument
 */
export const useBirfaturaBpOutSendDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>, TError,{data: BirfaturaBpOutSendDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaBpOutSendDocument>>,
        TError,
        {data: BirfaturaBpOutSendDocumentBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaBpOutSendDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Updates the read status of a document
 * @summary Update document read status
 */
export const postApiOutEBelgeV2UpdateUnreadedStatus = (
    updateUnreadedStatusRequestData: UpdateUnreadedStatusRequestData, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseString>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/UpdateUnreadedStatus`,
      updateUnreadedStatusRequestData,options
    );
  }



export const getPostApiOutEBelgeV2UpdateUnreadedStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>, TError,{data: UpdateUnreadedStatusRequestData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>, TError,{data: UpdateUnreadedStatusRequestData}, TContext> => {

const mutationKey = ['postApiOutEBelgeV2UpdateUnreadedStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>, {data: UpdateUnreadedStatusRequestData}> = (props) => {
          const {data} = props ?? {};

          return  postApiOutEBelgeV2UpdateUnreadedStatus(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationResult = NonNullable<Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>>
    export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationBody = UpdateUnreadedStatusRequestData
    export type PostApiOutEBelgeV2UpdateUnreadedStatusMutationError = AxiosError<unknown>

    /**
 * @summary Update document read status
 */
export const usePostApiOutEBelgeV2UpdateUnreadedStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>, TError,{data: UpdateUnreadedStatusRequestData}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiOutEBelgeV2UpdateUnreadedStatus>>,
        TError,
        {data: UpdateUnreadedStatusRequestData},
        TContext
      > => {

      const mutationOptions = getPostApiOutEBelgeV2UpdateUnreadedStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Sends an answer (KABUL, RED, IPTAL) for an incoming document
 * @summary Send document answer (accept/reject/cancel)
 */
export const postApiOutEBelgeV2SendDocumentAnswer = (
    sendDocumentAnswerRequestData: SendDocumentAnswerRequestData, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiResponseSendDocumentAnswerResponse>> => {
    
    
    return axios.post(
      `/api/OutEBelgeV2/SendDocumentAnswer`,
      sendDocumentAnswerRequestData,options
    );
  }



export const getPostApiOutEBelgeV2SendDocumentAnswerMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>, TError,{data: SendDocumentAnswerRequestData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>, TError,{data: SendDocumentAnswerRequestData}, TContext> => {

const mutationKey = ['postApiOutEBelgeV2SendDocumentAnswer'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>, {data: SendDocumentAnswerRequestData}> = (props) => {
          const {data} = props ?? {};

          return  postApiOutEBelgeV2SendDocumentAnswer(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiOutEBelgeV2SendDocumentAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>>
    export type PostApiOutEBelgeV2SendDocumentAnswerMutationBody = SendDocumentAnswerRequestData
    export type PostApiOutEBelgeV2SendDocumentAnswerMutationError = AxiosError<unknown>

    /**
 * @summary Send document answer (accept/reject/cancel)
 */
export const usePostApiOutEBelgeV2SendDocumentAnswer = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>, TError,{data: SendDocumentAnswerRequestData}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiOutEBelgeV2SendDocumentAnswer>>,
        TError,
        {data: SendDocumentAnswerRequestData},
        TContext
      > => {

      const mutationOptions = getPostApiOutEBelgeV2SendDocumentAnswerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Activity Logs
 */
export const activityLogsGetActivityLogs = (
    params?: ActivityLogsGetActivityLogsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityLogsGetActivityLogs200>> => {
    
    
    return axios.get(
      `/api/activity-logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getActivityLogsGetActivityLogsQueryKey = (params?: ActivityLogsGetActivityLogsParams,) => {
    return [
    `/api/activity-logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getActivityLogsGetActivityLogsQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError = AxiosError<unknown>>(params?: ActivityLogsGetActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsGetActivityLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>> = ({ signal }) => activityLogsGetActivityLogs(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsGetActivityLogsQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>>
export type ActivityLogsGetActivityLogsQueryError = AxiosError<unknown>


export function useActivityLogsGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError = AxiosError<unknown>>(
 params: undefined |  ActivityLogsGetActivityLogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetActivityLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError = AxiosError<unknown>>(
 params?: ActivityLogsGetActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetActivityLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError = AxiosError<unknown>>(
 params?: ActivityLogsGetActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Activity Logs
 */

export function useActivityLogsGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError = AxiosError<unknown>>(
 params?: ActivityLogsGetActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsGetActivityLogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get available filter options for activity logs
 */
export const activityLogsGetFilterOptions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityLogsGetFilterOptions200>> => {
    
    
    return axios.get(
      `/api/activity-logs/filter-options`,options
    );
  }




export const getActivityLogsGetFilterOptionsQueryKey = () => {
    return [
    `/api/activity-logs/filter-options`
    ] as const;
    }

    
export const getActivityLogsGetFilterOptionsQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsGetFilterOptionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>> = ({ signal }) => activityLogsGetFilterOptions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsGetFilterOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>>
export type ActivityLogsGetFilterOptionsQueryError = AxiosError<unknown>


export function useActivityLogsGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetFilterOptions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetFilterOptions>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetFilterOptions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available filter options for activity logs
 */

export function useActivityLogsGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsGetFilterOptionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get a single activity log entry with full details
 */
export const activityLogsGetActivityLogDetail = (
    logId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/activity-logs/${logId}`,options
    );
  }




export const getActivityLogsGetActivityLogDetailQueryKey = (logId?: string,) => {
    return [
    `/api/activity-logs/${logId}`
    ] as const;
    }

    
export const getActivityLogsGetActivityLogDetailQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError = AxiosError<unknown>>(logId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsGetActivityLogDetailQueryKey(logId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>> = ({ signal }) => activityLogsGetActivityLogDetail(logId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(logId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsGetActivityLogDetailQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>>
export type ActivityLogsGetActivityLogDetailQueryError = AxiosError<unknown>


export function useActivityLogsGetActivityLogDetail<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError = AxiosError<unknown>>(
 logId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetActivityLogDetail<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError = AxiosError<unknown>>(
 logId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>,
          TError,
          Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsGetActivityLogDetail<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError = AxiosError<unknown>>(
 logId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a single activity log entry with full details
 */

export function useActivityLogsGetActivityLogDetail<TData = Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError = AxiosError<unknown>>(
 logId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsGetActivityLogDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsGetActivityLogDetailQueryOptions(logId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Query params:
page: int - Page number (default 1)
page_size: int - Items per page (default 20, max 100)
tenant_id: str - Filter by tenant
branch_id: str - Filter by branch
user_id: str - Filter by user
role: str - Filter by role
action: str - Filter by exact action
action_type: str - Filter by action prefix (e.g., "patient", "invoice")
date_from: str - ISO date string
date_to: str - ISO date string
critical_only: bool - Only show critical actions
search: str - Search in message, action, entity_id
Returns:
{
success: true,
data: {
logs: [...],
meta: { total, page, pageSize, totalPages }
}
}
 * @summary Get all activity logs for platform admin.
 */
export const activityLogsAdminGetActivityLogs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/activity-logs`,options
    );
  }




export const getActivityLogsAdminGetActivityLogsQueryKey = () => {
    return [
    `/api/admin/activity-logs`
    ] as const;
    }

    
export const getActivityLogsAdminGetActivityLogsQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsAdminGetActivityLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>> = ({ signal }) => activityLogsAdminGetActivityLogs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsAdminGetActivityLogsQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>>
export type ActivityLogsAdminGetActivityLogsQueryError = AxiosError<unknown>


export function useActivityLogsAdminGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all activity logs for platform admin.
 */

export function useActivityLogsAdminGetActivityLogs<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsAdminGetActivityLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get filter options for admin panel activity logs
 */
export const activityLogsAdminGetFilterOptions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/activity-logs/filter-options`,options
    );
  }




export const getActivityLogsAdminGetFilterOptionsQueryKey = () => {
    return [
    `/api/admin/activity-logs/filter-options`
    ] as const;
    }

    
export const getActivityLogsAdminGetFilterOptionsQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsAdminGetFilterOptionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>> = ({ signal }) => activityLogsAdminGetFilterOptions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsAdminGetFilterOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>>
export type ActivityLogsAdminGetFilterOptionsQueryError = AxiosError<unknown>


export function useActivityLogsAdminGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get filter options for admin panel activity logs
 */

export function useActivityLogsAdminGetFilterOptions<TData = Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetFilterOptions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsAdminGetFilterOptionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns action counts, top users, etc.
 * @summary Get activity statistics for platform admin.
 */
export const activityLogsAdminGetActivityStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/activity-logs/stats`,options
    );
  }




export const getActivityLogsAdminGetActivityStatsQueryKey = () => {
    return [
    `/api/admin/activity-logs/stats`
    ] as const;
    }

    
export const getActivityLogsAdminGetActivityStatsQueryOptions = <TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getActivityLogsAdminGetActivityStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>> = ({ signal }) => activityLogsAdminGetActivityStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ActivityLogsAdminGetActivityStatsQueryResult = NonNullable<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>>
export type ActivityLogsAdminGetActivityStatsQueryError = AxiosError<unknown>


export function useActivityLogsAdminGetActivityStats<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetActivityStats<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>,
          TError,
          Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useActivityLogsAdminGetActivityStats<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get activity statistics for platform admin.
 */

export function useActivityLogsAdminGetActivityStats<TData = Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof activityLogsAdminGetActivityStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getActivityLogsAdminGetActivityStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new add-on
 */
export const adminAddonsCreateAddon = (
    adminAddonsCreateAddonBody?: AdminAddonsCreateAddonBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/addons`,
      adminAddonsCreateAddonBody,options
    );
  }



export const getAdminAddonsCreateAddonMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAddonsCreateAddon>>, TError,{data: AdminAddonsCreateAddonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminAddonsCreateAddon>>, TError,{data: AdminAddonsCreateAddonBody}, TContext> => {

const mutationKey = ['adminAddonsCreateAddon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminAddonsCreateAddon>>, {data: AdminAddonsCreateAddonBody}> = (props) => {
          const {data} = props ?? {};

          return  adminAddonsCreateAddon(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminAddonsCreateAddonMutationResult = NonNullable<Awaited<ReturnType<typeof adminAddonsCreateAddon>>>
    export type AdminAddonsCreateAddonMutationBody = AdminAddonsCreateAddonBody
    export type AdminAddonsCreateAddonMutationError = AxiosError<unknown>

    /**
 * @summary Create a new add-on
 */
export const useAdminAddonsCreateAddon = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAddonsCreateAddon>>, TError,{data: AdminAddonsCreateAddonBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminAddonsCreateAddon>>,
        TError,
        {data: AdminAddonsCreateAddonBody},
        TContext
      > => {

      const mutationOptions = getAdminAddonsCreateAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete add-on (soft delete by setting is_active=False)
 */
export const adminAddonsDeleteAddon = (
    addonId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/addons/${addonId}`,options
    );
  }



export const getAdminAddonsDeleteAddonMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAddonsDeleteAddon>>, TError,{addonId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminAddonsDeleteAddon>>, TError,{addonId: string}, TContext> => {

const mutationKey = ['adminAddonsDeleteAddon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminAddonsDeleteAddon>>, {addonId: string}> = (props) => {
          const {addonId} = props ?? {};

          return  adminAddonsDeleteAddon(addonId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminAddonsDeleteAddonMutationResult = NonNullable<Awaited<ReturnType<typeof adminAddonsDeleteAddon>>>
    
    export type AdminAddonsDeleteAddonMutationError = AxiosError<unknown>

    /**
 * @summary Delete add-on (soft delete by setting is_active=False)
 */
export const useAdminAddonsDeleteAddon = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAddonsDeleteAddon>>, TError,{addonId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminAddonsDeleteAddon>>,
        TError,
        {addonId: string},
        TContext
      > => {

      const mutationOptions = getAdminAddonsDeleteAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin kullanƒ±cƒ±larƒ± rolleriyle birlikte listele
 */
export const adminRolesGetAdminUsersWithRoles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/admin-users`,options
    );
  }




export const getAdminRolesGetAdminUsersWithRolesQueryKey = () => {
    return [
    `/api/admin/admin-users`
    ] as const;
    }

    
export const getAdminRolesGetAdminUsersWithRolesQueryOptions = <TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminRolesGetAdminUsersWithRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>> = ({ signal }) => adminRolesGetAdminUsersWithRoles({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminRolesGetAdminUsersWithRolesQueryResult = NonNullable<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>>
export type AdminRolesGetAdminUsersWithRolesQueryError = AxiosError<unknown>


export function useAdminRolesGetAdminUsersWithRoles<TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminUsersWithRoles<TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminUsersWithRoles<TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin kullanƒ±cƒ±larƒ± rolleriyle birlikte listele
 */

export function useAdminRolesGetAdminUsersWithRoles<TData = Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUsersWithRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminRolesGetAdminUsersWithRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin kullanƒ±cƒ± detayƒ±
 */
export const adminRolesGetAdminUserDetail = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/admin-users/${userId}`,options
    );
  }




export const getAdminRolesGetAdminUserDetailQueryKey = (userId?: string,) => {
    return [
    `/api/admin/admin-users/${userId}`
    ] as const;
    }

    
export const getAdminRolesGetAdminUserDetailQueryOptions = <TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError = AxiosError<unknown>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminRolesGetAdminUserDetailQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>> = ({ signal }) => adminRolesGetAdminUserDetail(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminRolesGetAdminUserDetailQueryResult = NonNullable<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>>
export type AdminRolesGetAdminUserDetailQueryError = AxiosError<unknown>


export function useAdminRolesGetAdminUserDetail<TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError = AxiosError<unknown>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminUserDetail<TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminUserDetail<TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin kullanƒ±cƒ± detayƒ±
 */

export function useAdminRolesGetAdminUserDetail<TData = Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminUserDetail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminRolesGetAdminUserDetailQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Body:
role_ids: list[str] - Rol ID'leri
Not: admin@x-ear.com kullanƒ±cƒ±sƒ±ndan SuperAdmin rol√º kaldƒ±rƒ±lamaz
 * @summary Kullanƒ±cƒ±ya rol ata
 */
export const adminRolesUpdateAdminUserRoles = (
    userId: string,
    adminRolesUpdateAdminUserRolesBody?: AdminRolesUpdateAdminUserRolesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/admin-users/${userId}/roles`,
      adminRolesUpdateAdminUserRolesBody,options
    );
  }



export const getAdminRolesUpdateAdminUserRolesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>, TError,{userId: string;data: AdminRolesUpdateAdminUserRolesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>, TError,{userId: string;data: AdminRolesUpdateAdminUserRolesBody}, TContext> => {

const mutationKey = ['adminRolesUpdateAdminUserRoles'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>, {userId: string;data: AdminRolesUpdateAdminUserRolesBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  adminRolesUpdateAdminUserRoles(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminRolesUpdateAdminUserRolesMutationResult = NonNullable<Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>>
    export type AdminRolesUpdateAdminUserRolesMutationBody = AdminRolesUpdateAdminUserRolesBody
    export type AdminRolesUpdateAdminUserRolesMutationError = AxiosError<unknown>

    /**
 * @summary Kullanƒ±cƒ±ya rol ata
 */
export const useAdminRolesUpdateAdminUserRoles = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>, TError,{userId: string;data: AdminRolesUpdateAdminUserRolesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminRolesUpdateAdminUserRoles>>,
        TError,
        {userId: string;data: AdminRolesUpdateAdminUserRolesBody},
        TContext
      > => {

      const mutationOptions = getAdminRolesUpdateAdminUserRolesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get admin analytics data
 */
export const adminAnalyticsGetAdminAnalytics = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/analytics`,options
    );
  }




export const getAdminAnalyticsGetAdminAnalyticsQueryKey = () => {
    return [
    `/api/admin/analytics`
    ] as const;
    }

    
export const getAdminAnalyticsGetAdminAnalyticsQueryOptions = <TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminAnalyticsGetAdminAnalyticsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>> = ({ signal }) => adminAnalyticsGetAdminAnalytics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminAnalyticsGetAdminAnalyticsQueryResult = NonNullable<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>>
export type AdminAnalyticsGetAdminAnalyticsQueryError = AxiosError<unknown>


export function useAdminAnalyticsGetAdminAnalytics<TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
          TError,
          Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminAnalyticsGetAdminAnalytics<TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>,
          TError,
          Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminAnalyticsGetAdminAnalytics<TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get admin analytics data
 */

export function useAdminAnalyticsGetAdminAnalytics<TData = Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAnalyticsGetAdminAnalytics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminAnalyticsGetAdminAnalyticsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new API key
 */
export const adminApiKeysCreateApiKey = (
    adminApiKeysCreateApiKeyBody?: AdminApiKeysCreateApiKeyBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/api-keys`,
      adminApiKeysCreateApiKeyBody,options
    );
  }



export const getAdminApiKeysCreateApiKeyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>, TError,{data: AdminApiKeysCreateApiKeyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>, TError,{data: AdminApiKeysCreateApiKeyBody}, TContext> => {

const mutationKey = ['adminApiKeysCreateApiKey'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>, {data: AdminApiKeysCreateApiKeyBody}> = (props) => {
          const {data} = props ?? {};

          return  adminApiKeysCreateApiKey(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminApiKeysCreateApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>>
    export type AdminApiKeysCreateApiKeyMutationBody = AdminApiKeysCreateApiKeyBody
    export type AdminApiKeysCreateApiKeyMutationError = AxiosError<unknown>

    /**
 * @summary Create a new API key
 */
export const useAdminApiKeysCreateApiKey = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>, TError,{data: AdminApiKeysCreateApiKeyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminApiKeysCreateApiKey>>,
        TError,
        {data: AdminApiKeysCreateApiKeyBody},
        TContext
      > => {

      const mutationOptions = getAdminApiKeysCreateApiKeyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Initialize API Key table
 */
export const adminApiKeysInitDb = (
    adminApiKeysInitDbBody?: AdminApiKeysInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/api-keys/init-db`,
      adminApiKeysInitDbBody,options
    );
  }



export const getAdminApiKeysInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysInitDb>>, TError,{data: AdminApiKeysInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysInitDb>>, TError,{data: AdminApiKeysInitDbBody}, TContext> => {

const mutationKey = ['adminApiKeysInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminApiKeysInitDb>>, {data: AdminApiKeysInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminApiKeysInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminApiKeysInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminApiKeysInitDb>>>
    export type AdminApiKeysInitDbMutationBody = AdminApiKeysInitDbBody
    export type AdminApiKeysInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize API Key table
 */
export const useAdminApiKeysInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysInitDb>>, TError,{data: AdminApiKeysInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminApiKeysInitDb>>,
        TError,
        {data: AdminApiKeysInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminApiKeysInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Revoke (delete) an API key
 */
export const adminApiKeysRevokeApiKey = (
    keyId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/api-keys/${keyId}`,options
    );
  }



export const getAdminApiKeysRevokeApiKeyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>, TError,{keyId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>, TError,{keyId: string}, TContext> => {

const mutationKey = ['adminApiKeysRevokeApiKey'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>, {keyId: string}> = (props) => {
          const {keyId} = props ?? {};

          return  adminApiKeysRevokeApiKey(keyId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminApiKeysRevokeApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>>
    
    export type AdminApiKeysRevokeApiKeyMutationError = AxiosError<unknown>

    /**
 * @summary Revoke (delete) an API key
 */
export const useAdminApiKeysRevokeApiKey = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>, TError,{keyId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminApiKeysRevokeApiKey>>,
        TError,
        {keyId: string},
        TContext
      > => {

      const mutationOptions = getAdminApiKeysRevokeApiKeyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of ALL appointments from ALL tenants
 */
export const adminAppointmentsGetAllAppointments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/appointments`,options
    );
  }




export const getAdminAppointmentsGetAllAppointmentsQueryKey = () => {
    return [
    `/api/admin/appointments`
    ] as const;
    }

    
export const getAdminAppointmentsGetAllAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminAppointmentsGetAllAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>> = ({ signal }) => adminAppointmentsGetAllAppointments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminAppointmentsGetAllAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>>
export type AdminAppointmentsGetAllAppointmentsQueryError = AxiosError<unknown>


export function useAdminAppointmentsGetAllAppointments<TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
          TError,
          Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminAppointmentsGetAllAppointments<TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>,
          TError,
          Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminAppointmentsGetAllAppointments<TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of ALL appointments from ALL tenants
 */

export function useAdminAppointmentsGetAllAppointments<TData = Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAppointmentsGetAllAppointments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminAppointmentsGetAllAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin login endpoint
 */
export const adminAdminLogin = (
    adminAdminLoginBody?: AdminAdminLoginBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/auth/login`,
      adminAdminLoginBody,options
    );
  }



export const getAdminAdminLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAdminLogin>>, TError,{data: AdminAdminLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminAdminLogin>>, TError,{data: AdminAdminLoginBody}, TContext> => {

const mutationKey = ['adminAdminLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminAdminLogin>>, {data: AdminAdminLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  adminAdminLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminAdminLoginMutationResult = NonNullable<Awaited<ReturnType<typeof adminAdminLogin>>>
    export type AdminAdminLoginMutationBody = AdminAdminLoginBody
    export type AdminAdminLoginMutationError = AxiosError<unknown>

    /**
 * @summary Admin login endpoint
 */
export const useAdminAdminLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAdminLogin>>, TError,{data: AdminAdminLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminAdminLogin>>,
        TError,
        {data: AdminAdminLoginBody},
        TContext
      > => {

      const mutationOptions = getAdminAdminLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get invoices with BirFatura status
 */
export const adminBirfaturaGetInvoices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/birfatura/invoices`,options
    );
  }




export const getAdminBirfaturaGetInvoicesQueryKey = () => {
    return [
    `/api/admin/birfatura/invoices`
    ] as const;
    }

    
export const getAdminBirfaturaGetInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminBirfaturaGetInvoicesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>> = ({ signal }) => adminBirfaturaGetInvoices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminBirfaturaGetInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>>
export type AdminBirfaturaGetInvoicesQueryError = AxiosError<unknown>


export function useAdminBirfaturaGetInvoices<TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetInvoices<TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetInvoices<TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoices with BirFatura status
 */

export function useAdminBirfaturaGetInvoices<TData = Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminBirfaturaGetInvoicesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get BirFatura related logs
 */
export const adminBirfaturaGetLogs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/birfatura/logs`,options
    );
  }




export const getAdminBirfaturaGetLogsQueryKey = () => {
    return [
    `/api/admin/birfatura/logs`
    ] as const;
    }

    
export const getAdminBirfaturaGetLogsQueryOptions = <TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminBirfaturaGetLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>> = ({ signal }) => adminBirfaturaGetLogs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminBirfaturaGetLogsQueryResult = NonNullable<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>>
export type AdminBirfaturaGetLogsQueryError = AxiosError<unknown>


export function useAdminBirfaturaGetLogs<TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetLogs<TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetLogs>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetLogs>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetLogs<TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get BirFatura related logs
 */

export function useAdminBirfaturaGetLogs<TData = Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetLogs>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminBirfaturaGetLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get BirFatura statistics
 */
export const adminBirfaturaGetStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/birfatura/stats`,options
    );
  }




export const getAdminBirfaturaGetStatsQueryKey = () => {
    return [
    `/api/admin/birfatura/stats`
    ] as const;
    }

    
export const getAdminBirfaturaGetStatsQueryOptions = <TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminBirfaturaGetStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminBirfaturaGetStats>>> = ({ signal }) => adminBirfaturaGetStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminBirfaturaGetStatsQueryResult = NonNullable<Awaited<ReturnType<typeof adminBirfaturaGetStats>>>
export type AdminBirfaturaGetStatsQueryError = AxiosError<unknown>


export function useAdminBirfaturaGetStats<TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetStats<TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminBirfaturaGetStats>>,
          TError,
          Awaited<ReturnType<typeof adminBirfaturaGetStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminBirfaturaGetStats<TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get BirFatura statistics
 */

export function useAdminBirfaturaGetStats<TData = Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminBirfaturaGetStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminBirfaturaGetStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get dashboard metrics
 */
export const adminDashboardGetDashboardMetrics = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/dashboard/metrics`,options
    );
  }




export const getAdminDashboardGetDashboardMetricsQueryKey = () => {
    return [
    `/api/admin/dashboard/metrics`
    ] as const;
    }

    
export const getAdminDashboardGetDashboardMetricsQueryOptions = <TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminDashboardGetDashboardMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>> = ({ signal }) => adminDashboardGetDashboardMetrics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminDashboardGetDashboardMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>>
export type AdminDashboardGetDashboardMetricsQueryError = AxiosError<unknown>


export function useAdminDashboardGetDashboardMetrics<TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
          TError,
          Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDashboardGetDashboardMetrics<TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>,
          TError,
          Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDashboardGetDashboardMetrics<TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get dashboard metrics
 */

export function useAdminDashboardGetDashboardMetrics<TData = Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDashboardGetDashboardMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminDashboardGetDashboardMetricsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Only available to admin@x-ear.com user.
 * @summary Get all available roles for debugging.
 */
export const adminDebugAvailableRoles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDebugAvailableRoles200>> => {
    
    
    return axios.get(
      `/api/admin/debug/available-roles`,options
    );
  }




export const getAdminDebugAvailableRolesQueryKey = () => {
    return [
    `/api/admin/debug/available-roles`
    ] as const;
    }

    
export const getAdminDebugAvailableRolesQueryOptions = <TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminDebugAvailableRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminDebugAvailableRoles>>> = ({ signal }) => adminDebugAvailableRoles({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminDebugAvailableRolesQueryResult = NonNullable<Awaited<ReturnType<typeof adminDebugAvailableRoles>>>
export type AdminDebugAvailableRolesQueryError = AxiosError<unknown>


export function useAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof adminDebugAvailableRoles>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDebugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof adminDebugAvailableRoles>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available roles for debugging.
 */

export function useAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugAvailableRoles>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminDebugAvailableRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Only available to admin@x-ear.com user.
 * @summary Get permissions for a specific page based on the effective role.
 */
export const adminDebugPagePermissions = (
    pageKey: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDebugPagePermissions200>> => {
    
    
    return axios.get(
      `/api/admin/debug/page-permissions/${pageKey}`,options
    );
  }




export const getAdminDebugPagePermissionsQueryKey = (pageKey?: string,) => {
    return [
    `/api/admin/debug/page-permissions/${pageKey}`
    ] as const;
    }

    
export const getAdminDebugPagePermissionsQueryOptions = <TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError = AxiosError<unknown>>(pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminDebugPagePermissionsQueryKey(pageKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminDebugPagePermissions>>> = ({ signal }) => adminDebugPagePermissions(pageKey, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(pageKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminDebugPagePermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof adminDebugPagePermissions>>>
export type AdminDebugPagePermissionsQueryError = AxiosError<unknown>


export function useAdminDebugPagePermissions<TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError = AxiosError<unknown>>(
 pageKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDebugPagePermissions>>,
          TError,
          Awaited<ReturnType<typeof adminDebugPagePermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDebugPagePermissions<TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError = AxiosError<unknown>>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminDebugPagePermissions>>,
          TError,
          Awaited<ReturnType<typeof adminDebugPagePermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminDebugPagePermissions<TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError = AxiosError<unknown>>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get permissions for a specific page based on the effective role.
 */

export function useAdminDebugPagePermissions<TData = Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError = AxiosError<unknown>>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDebugPagePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminDebugPagePermissionsQueryOptions(pageKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Only available to admin@x-ear.com user.
Returns a new JWT with the selected role's permissions.
 * @summary Switch to a different role for debugging purposes.
 */
export const adminDebugSwitchRole = (
    adminDebugSwitchRoleBody: AdminDebugSwitchRoleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDebugSwitchRole200>> => {
    
    
    return axios.post(
      `/api/admin/debug/switch-role`,
      adminDebugSwitchRoleBody,options
    );
  }



export const getAdminDebugSwitchRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDebugSwitchRole>>, TError,{data: AdminDebugSwitchRoleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminDebugSwitchRole>>, TError,{data: AdminDebugSwitchRoleBody}, TContext> => {

const mutationKey = ['adminDebugSwitchRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminDebugSwitchRole>>, {data: AdminDebugSwitchRoleBody}> = (props) => {
          const {data} = props ?? {};

          return  adminDebugSwitchRole(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminDebugSwitchRoleMutationResult = NonNullable<Awaited<ReturnType<typeof adminDebugSwitchRole>>>
    export type AdminDebugSwitchRoleMutationBody = AdminDebugSwitchRoleBody
    export type AdminDebugSwitchRoleMutationError = AxiosError<unknown>

    /**
 * @summary Switch to a different role for debugging purposes.
 */
export const useAdminDebugSwitchRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDebugSwitchRole>>, TError,{data: AdminDebugSwitchRoleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminDebugSwitchRole>>,
        TError,
        {data: AdminDebugSwitchRoleBody},
        TContext
      > => {

      const mutationOptions = getAdminDebugSwitchRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Authorization: user must have `settings.update` or `features.toggle`.
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const adminPatchFeatures = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/admin/features`,undefined,options
    );
  }



export const getAdminPatchFeaturesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,void, TContext> => {

const mutationKey = ['adminPatchFeatures'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminPatchFeatures>>, void> = () => {
          

          return  adminPatchFeatures(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminPatchFeaturesMutationResult = NonNullable<Awaited<ReturnType<typeof adminPatchFeatures>>>
    
    export type AdminPatchFeaturesMutationError = AxiosError<unknown>

    /**
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const useAdminPatchFeatures = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminPatchFeatures>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAdminPatchFeaturesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update BirFatura integration configuration
 */
export const adminIntegrationsUpdateBirfaturaConfig = (
    adminIntegrationsUpdateBirfaturaConfigBody?: AdminIntegrationsUpdateBirfaturaConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/integrations/birfatura/config`,
      adminIntegrationsUpdateBirfaturaConfigBody,options
    );
  }



export const getAdminIntegrationsUpdateBirfaturaConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>, TError,{data: AdminIntegrationsUpdateBirfaturaConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>, TError,{data: AdminIntegrationsUpdateBirfaturaConfigBody}, TContext> => {

const mutationKey = ['adminIntegrationsUpdateBirfaturaConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>, {data: AdminIntegrationsUpdateBirfaturaConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  adminIntegrationsUpdateBirfaturaConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminIntegrationsUpdateBirfaturaConfigMutationResult = NonNullable<Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>>
    export type AdminIntegrationsUpdateBirfaturaConfigMutationBody = AdminIntegrationsUpdateBirfaturaConfigBody
    export type AdminIntegrationsUpdateBirfaturaConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update BirFatura integration configuration
 */
export const useAdminIntegrationsUpdateBirfaturaConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>, TError,{data: AdminIntegrationsUpdateBirfaturaConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminIntegrationsUpdateBirfaturaConfig>>,
        TError,
        {data: AdminIntegrationsUpdateBirfaturaConfigBody},
        TContext
      > => {

      const mutationOptions = getAdminIntegrationsUpdateBirfaturaConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Initialize integration config tables
 */
export const adminIntegrationsInitDb = (
    adminIntegrationsInitDbBody?: AdminIntegrationsInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/integrations/init-db`,
      adminIntegrationsInitDbBody,options
    );
  }



export const getAdminIntegrationsInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsInitDb>>, TError,{data: AdminIntegrationsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsInitDb>>, TError,{data: AdminIntegrationsInitDbBody}, TContext> => {

const mutationKey = ['adminIntegrationsInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminIntegrationsInitDb>>, {data: AdminIntegrationsInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminIntegrationsInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminIntegrationsInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminIntegrationsInitDb>>>
    export type AdminIntegrationsInitDbMutationBody = AdminIntegrationsInitDbBody
    export type AdminIntegrationsInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize integration config tables
 */
export const useAdminIntegrationsInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsInitDb>>, TError,{data: AdminIntegrationsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminIntegrationsInitDb>>,
        TError,
        {data: AdminIntegrationsInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminIntegrationsInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update VatanSMS integration configuration
 */
export const adminIntegrationsUpdateVatanSmsConfig = (
    adminIntegrationsUpdateVatanSmsConfigBody?: AdminIntegrationsUpdateVatanSmsConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/integrations/vatan-sms/config`,
      adminIntegrationsUpdateVatanSmsConfigBody,options
    );
  }



export const getAdminIntegrationsUpdateVatanSmsConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>, TError,{data: AdminIntegrationsUpdateVatanSmsConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>, TError,{data: AdminIntegrationsUpdateVatanSmsConfigBody}, TContext> => {

const mutationKey = ['adminIntegrationsUpdateVatanSmsConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>, {data: AdminIntegrationsUpdateVatanSmsConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  adminIntegrationsUpdateVatanSmsConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminIntegrationsUpdateVatanSmsConfigMutationResult = NonNullable<Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>>
    export type AdminIntegrationsUpdateVatanSmsConfigMutationBody = AdminIntegrationsUpdateVatanSmsConfigBody
    export type AdminIntegrationsUpdateVatanSmsConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update VatanSMS integration configuration
 */
export const useAdminIntegrationsUpdateVatanSmsConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>, TError,{data: AdminIntegrationsUpdateVatanSmsConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminIntegrationsUpdateVatanSmsConfig>>,
        TError,
        {data: AdminIntegrationsUpdateVatanSmsConfigBody},
        TContext
      > => {

      const mutationOptions = getAdminIntegrationsUpdateVatanSmsConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of ALL devices/inventory from ALL tenants
 */
export const adminInventoryGetAllInventory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/inventory`,options
    );
  }




export const getAdminInventoryGetAllInventoryQueryKey = () => {
    return [
    `/api/admin/inventory`
    ] as const;
    }

    
export const getAdminInventoryGetAllInventoryQueryOptions = <TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminInventoryGetAllInventoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>> = ({ signal }) => adminInventoryGetAllInventory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminInventoryGetAllInventoryQueryResult = NonNullable<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>>
export type AdminInventoryGetAllInventoryQueryError = AxiosError<unknown>


export function useAdminInventoryGetAllInventory<TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
          TError,
          Awaited<ReturnType<typeof adminInventoryGetAllInventory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInventoryGetAllInventory<TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInventoryGetAllInventory>>,
          TError,
          Awaited<ReturnType<typeof adminInventoryGetAllInventory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInventoryGetAllInventory<TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of ALL devices/inventory from ALL tenants
 */

export function useAdminInventoryGetAllInventory<TData = Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInventoryGetAllInventory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminInventoryGetAllInventoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/admin/invoices
 */
export const adminInvoicesCreateAdminInvoice = (
    adminInvoicesCreateAdminInvoiceBody?: AdminInvoicesCreateAdminInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/invoices`,
      adminInvoicesCreateAdminInvoiceBody,options
    );
  }



export const getAdminInvoicesCreateAdminInvoiceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>, TError,{data: AdminInvoicesCreateAdminInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>, TError,{data: AdminInvoicesCreateAdminInvoiceBody}, TContext> => {

const mutationKey = ['adminInvoicesCreateAdminInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>, {data: AdminInvoicesCreateAdminInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  adminInvoicesCreateAdminInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminInvoicesCreateAdminInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>>
    export type AdminInvoicesCreateAdminInvoiceMutationBody = AdminInvoicesCreateAdminInvoiceBody
    export type AdminInvoicesCreateAdminInvoiceMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/admin/invoices
 */
export const useAdminInvoicesCreateAdminInvoice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>, TError,{data: AdminInvoicesCreateAdminInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminInvoicesCreateAdminInvoice>>,
        TError,
        {data: AdminInvoicesCreateAdminInvoiceBody},
        TContext
      > => {

      const mutationOptions = getAdminInvoicesCreateAdminInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/admin/invoices/{id}
 */
export const adminInvoicesGetAdminInvoice = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/invoices/${id}`,options
    );
  }




export const getAdminInvoicesGetAdminInvoiceQueryKey = (id?: string,) => {
    return [
    `/api/admin/invoices/${id}`
    ] as const;
    }

    
export const getAdminInvoicesGetAdminInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminInvoicesGetAdminInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>> = ({ signal }) => adminInvoicesGetAdminInvoice(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminInvoicesGetAdminInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>>
export type AdminInvoicesGetAdminInvoiceQueryError = AxiosError<unknown>


export function useAdminInvoicesGetAdminInvoice<TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
          TError,
          Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInvoicesGetAdminInvoice<TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>,
          TError,
          Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInvoicesGetAdminInvoice<TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/admin/invoices/{id}
 */

export function useAdminInvoicesGetAdminInvoice<TData = Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetAdminInvoice>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminInvoicesGetAdminInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/admin/invoices/{id}/payment
 */
export const adminInvoicesRecordPayment = (
    id: string,
    adminInvoicesRecordPaymentBody?: AdminInvoicesRecordPaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/invoices/${id}/payment`,
      adminInvoicesRecordPaymentBody,options
    );
  }



export const getAdminInvoicesRecordPaymentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesRecordPayment>>, TError,{id: string;data: AdminInvoicesRecordPaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesRecordPayment>>, TError,{id: string;data: AdminInvoicesRecordPaymentBody}, TContext> => {

const mutationKey = ['adminInvoicesRecordPayment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminInvoicesRecordPayment>>, {id: string;data: AdminInvoicesRecordPaymentBody}> = (props) => {
          const {id,data} = props ?? {};

          return  adminInvoicesRecordPayment(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminInvoicesRecordPaymentMutationResult = NonNullable<Awaited<ReturnType<typeof adminInvoicesRecordPayment>>>
    export type AdminInvoicesRecordPaymentMutationBody = AdminInvoicesRecordPaymentBody
    export type AdminInvoicesRecordPaymentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/admin/invoices/{id}/payment
 */
export const useAdminInvoicesRecordPayment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminInvoicesRecordPayment>>, TError,{id: string;data: AdminInvoicesRecordPaymentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminInvoicesRecordPayment>>,
        TError,
        {id: string;data: AdminInvoicesRecordPaymentBody},
        TContext
      > => {

      const mutationOptions = getAdminInvoicesRecordPaymentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/admin/invoices/{id}/pdf
 */
export const adminInvoicesGetInvoicePdf = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/invoices/${id}/pdf`,options
    );
  }




export const getAdminInvoicesGetInvoicePdfQueryKey = (id?: string,) => {
    return [
    `/api/admin/invoices/${id}/pdf`
    ] as const;
    }

    
export const getAdminInvoicesGetInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminInvoicesGetInvoicePdfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>> = ({ signal }) => adminInvoicesGetInvoicePdf(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminInvoicesGetInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>>
export type AdminInvoicesGetInvoicePdfQueryError = AxiosError<unknown>


export function useAdminInvoicesGetInvoicePdf<TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInvoicesGetInvoicePdf<TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminInvoicesGetInvoicePdf<TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/admin/invoices/{id}/pdf
 */

export function useAdminInvoicesGetInvoicePdf<TData = Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminInvoicesGetInvoicePdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminInvoicesGetInvoicePdfQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initialize Marketplace tables
 */
export const adminMarketplacesInitDb = (
    adminMarketplacesInitDbBody?: AdminMarketplacesInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/marketplaces/init-db`,
      adminMarketplacesInitDbBody,options
    );
  }



export const getAdminMarketplacesInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesInitDb>>, TError,{data: AdminMarketplacesInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesInitDb>>, TError,{data: AdminMarketplacesInitDbBody}, TContext> => {

const mutationKey = ['adminMarketplacesInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminMarketplacesInitDb>>, {data: AdminMarketplacesInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminMarketplacesInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminMarketplacesInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminMarketplacesInitDb>>>
    export type AdminMarketplacesInitDbMutationBody = AdminMarketplacesInitDbBody
    export type AdminMarketplacesInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize Marketplace tables
 */
export const useAdminMarketplacesInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesInitDb>>, TError,{data: AdminMarketplacesInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminMarketplacesInitDb>>,
        TError,
        {data: AdminMarketplacesInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminMarketplacesInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new marketplace integration
 */
export const adminMarketplacesCreateIntegration = (
    adminMarketplacesCreateIntegrationBody?: AdminMarketplacesCreateIntegrationBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/marketplaces/integrations`,
      adminMarketplacesCreateIntegrationBody,options
    );
  }



export const getAdminMarketplacesCreateIntegrationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>, TError,{data: AdminMarketplacesCreateIntegrationBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>, TError,{data: AdminMarketplacesCreateIntegrationBody}, TContext> => {

const mutationKey = ['adminMarketplacesCreateIntegration'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>, {data: AdminMarketplacesCreateIntegrationBody}> = (props) => {
          const {data} = props ?? {};

          return  adminMarketplacesCreateIntegration(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminMarketplacesCreateIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>>
    export type AdminMarketplacesCreateIntegrationMutationBody = AdminMarketplacesCreateIntegrationBody
    export type AdminMarketplacesCreateIntegrationMutationError = AxiosError<unknown>

    /**
 * @summary Create a new marketplace integration
 */
export const useAdminMarketplacesCreateIntegration = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>, TError,{data: AdminMarketplacesCreateIntegrationBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminMarketplacesCreateIntegration>>,
        TError,
        {data: AdminMarketplacesCreateIntegrationBody},
        TContext
      > => {

      const mutationOptions = getAdminMarketplacesCreateIntegrationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Trigger sync for an integration (Mock)
 */
export const adminMarketplacesSyncIntegration = (
    id: string,
    adminMarketplacesSyncIntegrationBody?: AdminMarketplacesSyncIntegrationBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/marketplaces/integrations/${id}/sync`,
      adminMarketplacesSyncIntegrationBody,options
    );
  }



export const getAdminMarketplacesSyncIntegrationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>, TError,{id: string;data: AdminMarketplacesSyncIntegrationBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>, TError,{id: string;data: AdminMarketplacesSyncIntegrationBody}, TContext> => {

const mutationKey = ['adminMarketplacesSyncIntegration'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>, {id: string;data: AdminMarketplacesSyncIntegrationBody}> = (props) => {
          const {id,data} = props ?? {};

          return  adminMarketplacesSyncIntegration(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminMarketplacesSyncIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>>
    export type AdminMarketplacesSyncIntegrationMutationBody = AdminMarketplacesSyncIntegrationBody
    export type AdminMarketplacesSyncIntegrationMutationError = AxiosError<unknown>

    /**
 * @summary Trigger sync for an integration (Mock)
 */
export const useAdminMarketplacesSyncIntegration = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>, TError,{id: string;data: AdminMarketplacesSyncIntegrationBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminMarketplacesSyncIntegration>>,
        TError,
        {id: string;data: AdminMarketplacesSyncIntegrationBody},
        TContext
      > => {

      const mutationOptions = getAdminMarketplacesSyncIntegrationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Frontend i√ßin - sidebar, buton gizleme vb.
 * @summary Mevcut admin kullanƒ±cƒ±sƒ±nƒ±n izinlerini d√∂nd√ºr√ºr.
 */
export const adminRolesGetMyAdminPermissions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/my-permissions`,options
    );
  }




export const getAdminRolesGetMyAdminPermissionsQueryKey = () => {
    return [
    `/api/admin/my-permissions`
    ] as const;
    }

    
export const getAdminRolesGetMyAdminPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminRolesGetMyAdminPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>> = ({ signal }) => adminRolesGetMyAdminPermissions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminRolesGetMyAdminPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>>
export type AdminRolesGetMyAdminPermissionsQueryError = AxiosError<unknown>


export function useAdminRolesGetMyAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetMyAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetMyAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Mevcut admin kullanƒ±cƒ±sƒ±nƒ±n izinlerini d√∂nd√ºr√ºr.
 */

export function useAdminRolesGetMyAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetMyAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminRolesGetMyAdminPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get list of notifications
 */
export const adminNotificationsGetNotifications = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/notifications`,options
    );
  }




export const getAdminNotificationsGetNotificationsQueryKey = () => {
    return [
    `/api/admin/notifications`
    ] as const;
    }

    
export const getAdminNotificationsGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminNotificationsGetNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>> = ({ signal }) => adminNotificationsGetNotifications({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminNotificationsGetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>>
export type AdminNotificationsGetNotificationsQueryError = AxiosError<unknown>


export function useAdminNotificationsGetNotifications<TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof adminNotificationsGetNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminNotificationsGetNotifications<TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminNotificationsGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof adminNotificationsGetNotifications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminNotificationsGetNotifications<TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of notifications
 */

export function useAdminNotificationsGetNotifications<TData = Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminNotificationsGetNotifications>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminNotificationsGetNotificationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initialize notification tables
 */
export const adminNotificationsInitDb = (
    adminNotificationsInitDbBody?: AdminNotificationsInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/notifications/init-db`,
      adminNotificationsInitDbBody,options
    );
  }



export const getAdminNotificationsInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsInitDb>>, TError,{data: AdminNotificationsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsInitDb>>, TError,{data: AdminNotificationsInitDbBody}, TContext> => {

const mutationKey = ['adminNotificationsInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminNotificationsInitDb>>, {data: AdminNotificationsInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminNotificationsInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminNotificationsInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminNotificationsInitDb>>>
    export type AdminNotificationsInitDbMutationBody = AdminNotificationsInitDbBody
    export type AdminNotificationsInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize notification tables
 */
export const useAdminNotificationsInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsInitDb>>, TError,{data: AdminNotificationsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminNotificationsInitDb>>,
        TError,
        {data: AdminNotificationsInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminNotificationsInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Send a notification to tenants
 */
export const adminNotificationsSendNotification = (
    adminNotificationsSendNotificationBody?: AdminNotificationsSendNotificationBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/notifications/send`,
      adminNotificationsSendNotificationBody,options
    );
  }



export const getAdminNotificationsSendNotificationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsSendNotification>>, TError,{data: AdminNotificationsSendNotificationBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsSendNotification>>, TError,{data: AdminNotificationsSendNotificationBody}, TContext> => {

const mutationKey = ['adminNotificationsSendNotification'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminNotificationsSendNotification>>, {data: AdminNotificationsSendNotificationBody}> = (props) => {
          const {data} = props ?? {};

          return  adminNotificationsSendNotification(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminNotificationsSendNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof adminNotificationsSendNotification>>>
    export type AdminNotificationsSendNotificationMutationBody = AdminNotificationsSendNotificationBody
    export type AdminNotificationsSendNotificationMutationError = AxiosError<unknown>

    /**
 * @summary Send a notification to tenants
 */
export const useAdminNotificationsSendNotification = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsSendNotification>>, TError,{data: AdminNotificationsSendNotificationBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminNotificationsSendNotification>>,
        TError,
        {data: AdminNotificationsSendNotificationBody},
        TContext
      > => {

      const mutationOptions = getAdminNotificationsSendNotificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new notification template
 */
export const adminNotificationsCreateTemplate = (
    adminNotificationsCreateTemplateBody?: AdminNotificationsCreateTemplateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/notifications/templates`,
      adminNotificationsCreateTemplateBody,options
    );
  }



export const getAdminNotificationsCreateTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>, TError,{data: AdminNotificationsCreateTemplateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>, TError,{data: AdminNotificationsCreateTemplateBody}, TContext> => {

const mutationKey = ['adminNotificationsCreateTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>, {data: AdminNotificationsCreateTemplateBody}> = (props) => {
          const {data} = props ?? {};

          return  adminNotificationsCreateTemplate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminNotificationsCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>>
    export type AdminNotificationsCreateTemplateMutationBody = AdminNotificationsCreateTemplateBody
    export type AdminNotificationsCreateTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Create a new notification template
 */
export const useAdminNotificationsCreateTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>, TError,{data: AdminNotificationsCreateTemplateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminNotificationsCreateTemplate>>,
        TError,
        {data: AdminNotificationsCreateTemplateBody},
        TContext
      > => {

      const mutationOptions = getAdminNotificationsCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a notification template
 */
export const adminNotificationsDeleteTemplate = (
    templateId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/notifications/templates/${templateId}`,options
    );
  }



export const getAdminNotificationsDeleteTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>, TError,{templateId: string}, TContext> => {

const mutationKey = ['adminNotificationsDeleteTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>, {templateId: string}> = (props) => {
          const {templateId} = props ?? {};

          return  adminNotificationsDeleteTemplate(templateId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminNotificationsDeleteTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>>
    
    export type AdminNotificationsDeleteTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Delete a notification template
 */
export const useAdminNotificationsDeleteTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>, TError,{templateId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminNotificationsDeleteTemplate>>,
        TError,
        {templateId: string},
        TContext
      > => {

      const mutationOptions = getAdminNotificationsDeleteTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of ALL patients from ALL tenants
 */
export const adminPatientsGetAllPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/patients`,options
    );
  }




export const getAdminPatientsGetAllPatientsQueryKey = () => {
    return [
    `/api/admin/patients`
    ] as const;
    }

    
export const getAdminPatientsGetAllPatientsQueryOptions = <TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminPatientsGetAllPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>> = ({ signal }) => adminPatientsGetAllPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminPatientsGetAllPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>>
export type AdminPatientsGetAllPatientsQueryError = AxiosError<unknown>


export function useAdminPatientsGetAllPatients<TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
          TError,
          Awaited<ReturnType<typeof adminPatientsGetAllPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminPatientsGetAllPatients<TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminPatientsGetAllPatients>>,
          TError,
          Awaited<ReturnType<typeof adminPatientsGetAllPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminPatientsGetAllPatients<TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of ALL patients from ALL tenants
 */

export function useAdminPatientsGetAllPatients<TData = Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminPatientsGetAllPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminPatientsGetAllPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Query params:
category: str - Kategoriye g√∂re filtrele
 * @summary T√ºm izinleri listele
 */
export const adminRolesGetAdminPermissions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/permissions`,options
    );
  }




export const getAdminRolesGetAdminPermissionsQueryKey = () => {
    return [
    `/api/admin/permissions`
    ] as const;
    }

    
export const getAdminRolesGetAdminPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminRolesGetAdminPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>> = ({ signal }) => adminRolesGetAdminPermissions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminRolesGetAdminPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>>
export type AdminRolesGetAdminPermissionsQueryError = AxiosError<unknown>


export function useAdminRolesGetAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>,
          TError,
          Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminRolesGetAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary T√ºm izinleri listele
 */

export function useAdminRolesGetAdminPermissions<TData = Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminRolesGetAdminPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminRolesGetAdminPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Belirli bir endpoint i√ßin gerekli permission'ƒ± d√∂nd√ºr√ºr.
 */
export const permissionAdminCheckEndpointPermission = (
    endpointPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/permissions/check/${endpointPath}`,options
    );
  }




export const getPermissionAdminCheckEndpointPermissionQueryKey = (endpointPath?: string,) => {
    return [
    `/api/admin/permissions/check/${endpointPath}`
    ] as const;
    }

    
export const getPermissionAdminCheckEndpointPermissionQueryOptions = <TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError = AxiosError<unknown>>(endpointPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionAdminCheckEndpointPermissionQueryKey(endpointPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>> = ({ signal }) => permissionAdminCheckEndpointPermission(endpointPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(endpointPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionAdminCheckEndpointPermissionQueryResult = NonNullable<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>>
export type PermissionAdminCheckEndpointPermissionQueryError = AxiosError<unknown>


export function usePermissionAdminCheckEndpointPermission<TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError = AxiosError<unknown>>(
 endpointPath: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminCheckEndpointPermission<TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError = AxiosError<unknown>>(
 endpointPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminCheckEndpointPermission<TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError = AxiosError<unknown>>(
 endpointPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Belirli bir endpoint i√ßin gerekli permission'ƒ± d√∂nd√ºr√ºr.
 */

export function usePermissionAdminCheckEndpointPermission<TData = Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError = AxiosError<unknown>>(
 endpointPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminCheckEndpointPermission>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionAdminCheckEndpointPermissionQueryOptions(endpointPath,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Permission coverage raporunu d√∂nd√ºr√ºr.
 */
export const permissionAdminGetPermissionCoverage = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/permissions/coverage`,options
    );
  }




export const getPermissionAdminGetPermissionCoverageQueryKey = () => {
    return [
    `/api/admin/permissions/coverage`
    ] as const;
    }

    
export const getPermissionAdminGetPermissionCoverageQueryOptions = <TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionAdminGetPermissionCoverageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>> = ({ signal }) => permissionAdminGetPermissionCoverage({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionAdminGetPermissionCoverageQueryResult = NonNullable<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>>
export type PermissionAdminGetPermissionCoverageQueryError = AxiosError<unknown>


export function usePermissionAdminGetPermissionCoverage<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminGetPermissionCoverage<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminGetPermissionCoverage<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Permission coverage raporunu d√∂nd√ºr√ºr.
 */

export function usePermissionAdminGetPermissionCoverage<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionCoverage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionAdminGetPermissionCoverageQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary T√ºm endpoint-permission mapping'ini d√∂nd√ºr√ºr.
 */
export const permissionAdminGetPermissionMap = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/permissions/map`,options
    );
  }




export const getPermissionAdminGetPermissionMapQueryKey = () => {
    return [
    `/api/admin/permissions/map`
    ] as const;
    }

    
export const getPermissionAdminGetPermissionMapQueryOptions = <TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionAdminGetPermissionMapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>> = ({ signal }) => permissionAdminGetPermissionMap({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionAdminGetPermissionMapQueryResult = NonNullable<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>>
export type PermissionAdminGetPermissionMapQueryError = AxiosError<unknown>


export function usePermissionAdminGetPermissionMap<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminGetPermissionMap<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>,
          TError,
          Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionAdminGetPermissionMap<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary T√ºm endpoint-permission mapping'ini d√∂nd√ºr√ºr.
 */

export function usePermissionAdminGetPermissionMap<TData = Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionAdminGetPermissionMap>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionAdminGetPermissionMapQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new plan
 */
export const adminPlansCreatePlan = (
    adminPlansCreatePlanBody?: AdminPlansCreatePlanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/plans`,
      adminPlansCreatePlanBody,options
    );
  }



export const getAdminPlansCreatePlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPlansCreatePlan>>, TError,{data: AdminPlansCreatePlanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminPlansCreatePlan>>, TError,{data: AdminPlansCreatePlanBody}, TContext> => {

const mutationKey = ['adminPlansCreatePlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminPlansCreatePlan>>, {data: AdminPlansCreatePlanBody}> = (props) => {
          const {data} = props ?? {};

          return  adminPlansCreatePlan(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminPlansCreatePlanMutationResult = NonNullable<Awaited<ReturnType<typeof adminPlansCreatePlan>>>
    export type AdminPlansCreatePlanMutationBody = AdminPlansCreatePlanBody
    export type AdminPlansCreatePlanMutationError = AxiosError<unknown>

    /**
 * @summary Create a new plan
 */
export const useAdminPlansCreatePlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPlansCreatePlan>>, TError,{data: AdminPlansCreatePlanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminPlansCreatePlan>>,
        TError,
        {data: AdminPlansCreatePlanBody},
        TContext
      > => {

      const mutationOptions = getAdminPlansCreatePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete plan (soft delete by setting is_active=False)
 */
export const adminPlansDeletePlan = (
    planId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/plans/${planId}`,options
    );
  }



export const getAdminPlansDeletePlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPlansDeletePlan>>, TError,{planId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminPlansDeletePlan>>, TError,{planId: string}, TContext> => {

const mutationKey = ['adminPlansDeletePlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminPlansDeletePlan>>, {planId: string}> = (props) => {
          const {planId} = props ?? {};

          return  adminPlansDeletePlan(planId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminPlansDeletePlanMutationResult = NonNullable<Awaited<ReturnType<typeof adminPlansDeletePlan>>>
    
    export type AdminPlansDeletePlanMutationError = AxiosError<unknown>

    /**
 * @summary Delete plan (soft delete by setting is_active=False)
 */
export const useAdminPlansDeletePlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPlansDeletePlan>>, TError,{planId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminPlansDeletePlan>>,
        TError,
        {planId: string},
        TContext
      > => {

      const mutationOptions = getAdminPlansDeletePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Initialize Production Orders table
 */
export const adminProductionInitDb = (
    adminProductionInitDbBody?: AdminProductionInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/production/init-db`,
      adminProductionInitDbBody,options
    );
  }



export const getAdminProductionInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminProductionInitDb>>, TError,{data: AdminProductionInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminProductionInitDb>>, TError,{data: AdminProductionInitDbBody}, TContext> => {

const mutationKey = ['adminProductionInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminProductionInitDb>>, {data: AdminProductionInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminProductionInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminProductionInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminProductionInitDb>>>
    export type AdminProductionInitDbMutationBody = AdminProductionInitDbBody
    export type AdminProductionInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize Production Orders table
 */
export const useAdminProductionInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminProductionInitDb>>, TError,{data: AdminProductionInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminProductionInitDb>>,
        TError,
        {data: AdminProductionInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminProductionInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get production orders
 */
export const adminProductionGetOrders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/production/orders`,options
    );
  }




export const getAdminProductionGetOrdersQueryKey = () => {
    return [
    `/api/admin/production/orders`
    ] as const;
    }

    
export const getAdminProductionGetOrdersQueryOptions = <TData = Awaited<ReturnType<typeof adminProductionGetOrders>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminProductionGetOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminProductionGetOrders>>> = ({ signal }) => adminProductionGetOrders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminProductionGetOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof adminProductionGetOrders>>>
export type AdminProductionGetOrdersQueryError = AxiosError<unknown>


export function useAdminProductionGetOrders<TData = Awaited<ReturnType<typeof adminProductionGetOrders>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminProductionGetOrders>>,
          TError,
          Awaited<ReturnType<typeof adminProductionGetOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminProductionGetOrders<TData = Awaited<ReturnType<typeof adminProductionGetOrders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminProductionGetOrders>>,
          TError,
          Awaited<ReturnType<typeof adminProductionGetOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminProductionGetOrders<TData = Awaited<ReturnType<typeof adminProductionGetOrders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get production orders
 */

export function useAdminProductionGetOrders<TData = Awaited<ReturnType<typeof adminProductionGetOrders>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminProductionGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminProductionGetOrdersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update order status
 */
export const adminProductionUpdateOrderStatus = (
    id: string,
    adminProductionUpdateOrderStatusBody?: AdminProductionUpdateOrderStatusBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/production/orders/${id}/status`,
      adminProductionUpdateOrderStatusBody,options
    );
  }



export const getAdminProductionUpdateOrderStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>, TError,{id: string;data: AdminProductionUpdateOrderStatusBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>, TError,{id: string;data: AdminProductionUpdateOrderStatusBody}, TContext> => {

const mutationKey = ['adminProductionUpdateOrderStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>, {id: string;data: AdminProductionUpdateOrderStatusBody}> = (props) => {
          const {id,data} = props ?? {};

          return  adminProductionUpdateOrderStatus(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminProductionUpdateOrderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>>
    export type AdminProductionUpdateOrderStatusMutationBody = AdminProductionUpdateOrderStatusBody
    export type AdminProductionUpdateOrderStatusMutationError = AxiosError<unknown>

    /**
 * @summary Update order status
 */
export const useAdminProductionUpdateOrderStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>, TError,{id: string;data: AdminProductionUpdateOrderStatusBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminProductionUpdateOrderStatus>>,
        TError,
        {id: string;data: AdminProductionUpdateOrderStatusBody},
        TContext
      > => {

      const mutationOptions = getAdminProductionUpdateOrderStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Body:
name: str - Rol adƒ± (unique)
description: str - A√ßƒ±klama
permissions: list[str] - ƒ∞zin kodlarƒ±
 * @summary Yeni rol olu≈ütur
 */
export const adminRolesCreateAdminRole = (
    adminRolesCreateAdminRoleBody?: AdminRolesCreateAdminRoleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/roles`,
      adminRolesCreateAdminRoleBody,options
    );
  }



export const getAdminRolesCreateAdminRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesCreateAdminRole>>, TError,{data: AdminRolesCreateAdminRoleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminRolesCreateAdminRole>>, TError,{data: AdminRolesCreateAdminRoleBody}, TContext> => {

const mutationKey = ['adminRolesCreateAdminRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminRolesCreateAdminRole>>, {data: AdminRolesCreateAdminRoleBody}> = (props) => {
          const {data} = props ?? {};

          return  adminRolesCreateAdminRole(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminRolesCreateAdminRoleMutationResult = NonNullable<Awaited<ReturnType<typeof adminRolesCreateAdminRole>>>
    export type AdminRolesCreateAdminRoleMutationBody = AdminRolesCreateAdminRoleBody
    export type AdminRolesCreateAdminRoleMutationError = AxiosError<unknown>

    /**
 * @summary Yeni rol olu≈ütur
 */
export const useAdminRolesCreateAdminRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesCreateAdminRole>>, TError,{data: AdminRolesCreateAdminRoleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminRolesCreateAdminRole>>,
        TError,
        {data: AdminRolesCreateAdminRoleBody},
        TContext
      > => {

      const mutationOptions = getAdminRolesCreateAdminRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Not: System role'ler silinemez
 * @summary Rol sil
 */
export const adminRolesDeleteAdminRole = (
    roleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/roles/${roleId}`,options
    );
  }



export const getAdminRolesDeleteAdminRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>, TError,{roleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>, TError,{roleId: string}, TContext> => {

const mutationKey = ['adminRolesDeleteAdminRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  adminRolesDeleteAdminRole(roleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminRolesDeleteAdminRoleMutationResult = NonNullable<Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>>
    
    export type AdminRolesDeleteAdminRoleMutationError = AxiosError<unknown>

    /**
 * @summary Rol sil
 */
export const useAdminRolesDeleteAdminRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>, TError,{roleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminRolesDeleteAdminRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getAdminRolesDeleteAdminRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Body:
permissions: list[str] - ƒ∞zin kodlarƒ±
Not: SuperAdmin rol√ºn√ºn izinleri deƒüi≈ütirilemez
 * @summary Rol izinlerini g√ºncelle
 */
export const adminRolesUpdateAdminRolePermissions = (
    roleId: string,
    adminRolesUpdateAdminRolePermissionsBody?: AdminRolesUpdateAdminRolePermissionsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/roles/${roleId}/permissions`,
      adminRolesUpdateAdminRolePermissionsBody,options
    );
  }



export const getAdminRolesUpdateAdminRolePermissionsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>, TError,{roleId: string;data: AdminRolesUpdateAdminRolePermissionsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>, TError,{roleId: string;data: AdminRolesUpdateAdminRolePermissionsBody}, TContext> => {

const mutationKey = ['adminRolesUpdateAdminRolePermissions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>, {roleId: string;data: AdminRolesUpdateAdminRolePermissionsBody}> = (props) => {
          const {roleId,data} = props ?? {};

          return  adminRolesUpdateAdminRolePermissions(roleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminRolesUpdateAdminRolePermissionsMutationResult = NonNullable<Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>>
    export type AdminRolesUpdateAdminRolePermissionsMutationBody = AdminRolesUpdateAdminRolePermissionsBody
    export type AdminRolesUpdateAdminRolePermissionsMutationError = AxiosError<unknown>

    /**
 * @summary Rol izinlerini g√ºncelle
 */
export const useAdminRolesUpdateAdminRolePermissions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>, TError,{roleId: string;data: AdminRolesUpdateAdminRolePermissionsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminRolesUpdateAdminRolePermissions>>,
        TError,
        {roleId: string;data: AdminRolesUpdateAdminRolePermissionsBody},
        TContext
      > => {

      const mutationOptions = getAdminRolesUpdateAdminRolePermissionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get scan queue items
 */
export const adminScanQueueGetScanQueue = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/scan-queue`,options
    );
  }




export const getAdminScanQueueGetScanQueueQueryKey = () => {
    return [
    `/api/admin/scan-queue`
    ] as const;
    }

    
export const getAdminScanQueueGetScanQueueQueryOptions = <TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminScanQueueGetScanQueueQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>> = ({ signal }) => adminScanQueueGetScanQueue({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminScanQueueGetScanQueueQueryResult = NonNullable<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>>
export type AdminScanQueueGetScanQueueQueryError = AxiosError<unknown>


export function useAdminScanQueueGetScanQueue<TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
          TError,
          Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminScanQueueGetScanQueue<TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>,
          TError,
          Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminScanQueueGetScanQueue<TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get scan queue items
 */

export function useAdminScanQueueGetScanQueue<TData = Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminScanQueueGetScanQueue>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminScanQueueGetScanQueueQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initialize Scan Queue table
 */
export const adminScanQueueInitDb = (
    adminScanQueueInitDbBody?: AdminScanQueueInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/scan-queue/init-db`,
      adminScanQueueInitDbBody,options
    );
  }



export const getAdminScanQueueInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueInitDb>>, TError,{data: AdminScanQueueInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueInitDb>>, TError,{data: AdminScanQueueInitDbBody}, TContext> => {

const mutationKey = ['adminScanQueueInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminScanQueueInitDb>>, {data: AdminScanQueueInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminScanQueueInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminScanQueueInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminScanQueueInitDb>>>
    export type AdminScanQueueInitDbMutationBody = AdminScanQueueInitDbBody
    export type AdminScanQueueInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize Scan Queue table
 */
export const useAdminScanQueueInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueInitDb>>, TError,{data: AdminScanQueueInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminScanQueueInitDb>>,
        TError,
        {data: AdminScanQueueInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminScanQueueInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Retry a failed scan
 */
export const adminScanQueueRetryScan = (
    id: string,
    adminScanQueueRetryScanBody?: AdminScanQueueRetryScanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/scan-queue/${id}/retry`,
      adminScanQueueRetryScanBody,options
    );
  }



export const getAdminScanQueueRetryScanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueRetryScan>>, TError,{id: string;data: AdminScanQueueRetryScanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueRetryScan>>, TError,{id: string;data: AdminScanQueueRetryScanBody}, TContext> => {

const mutationKey = ['adminScanQueueRetryScan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminScanQueueRetryScan>>, {id: string;data: AdminScanQueueRetryScanBody}> = (props) => {
          const {id,data} = props ?? {};

          return  adminScanQueueRetryScan(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminScanQueueRetryScanMutationResult = NonNullable<Awaited<ReturnType<typeof adminScanQueueRetryScan>>>
    export type AdminScanQueueRetryScanMutationBody = AdminScanQueueRetryScanBody
    export type AdminScanQueueRetryScanMutationError = AxiosError<unknown>

    /**
 * @summary Retry a failed scan
 */
export const useAdminScanQueueRetryScan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminScanQueueRetryScan>>, TError,{id: string;data: AdminScanQueueRetryScanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminScanQueueRetryScan>>,
        TError,
        {id: string;data: AdminScanQueueRetryScanBody},
        TContext
      > => {

      const mutationOptions = getAdminScanQueueRetryScanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update system settings
 */
export const adminSettingsUpdateSettings = (
    adminSettingsUpdateSettingsBody?: AdminSettingsUpdateSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/settings`,
      adminSettingsUpdateSettingsBody,options
    );
  }



export const getAdminSettingsUpdateSettingsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsUpdateSettings>>, TError,{data: AdminSettingsUpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSettingsUpdateSettings>>, TError,{data: AdminSettingsUpdateSettingsBody}, TContext> => {

const mutationKey = ['adminSettingsUpdateSettings'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSettingsUpdateSettings>>, {data: AdminSettingsUpdateSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSettingsUpdateSettings(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSettingsUpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof adminSettingsUpdateSettings>>>
    export type AdminSettingsUpdateSettingsMutationBody = AdminSettingsUpdateSettingsBody
    export type AdminSettingsUpdateSettingsMutationError = AxiosError<unknown>

    /**
 * @summary Update system settings
 */
export const useAdminSettingsUpdateSettings = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsUpdateSettings>>, TError,{data: AdminSettingsUpdateSettingsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSettingsUpdateSettings>>,
        TError,
        {data: AdminSettingsUpdateSettingsBody},
        TContext
      > => {

      const mutationOptions = getAdminSettingsUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Trigger database backup (Mock)
 */
export const adminSettingsTriggerBackup = (
    adminSettingsTriggerBackupBody?: AdminSettingsTriggerBackupBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/settings/backup`,
      adminSettingsTriggerBackupBody,options
    );
  }



export const getAdminSettingsTriggerBackupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsTriggerBackup>>, TError,{data: AdminSettingsTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSettingsTriggerBackup>>, TError,{data: AdminSettingsTriggerBackupBody}, TContext> => {

const mutationKey = ['adminSettingsTriggerBackup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSettingsTriggerBackup>>, {data: AdminSettingsTriggerBackupBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSettingsTriggerBackup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSettingsTriggerBackupMutationResult = NonNullable<Awaited<ReturnType<typeof adminSettingsTriggerBackup>>>
    export type AdminSettingsTriggerBackupMutationBody = AdminSettingsTriggerBackupBody
    export type AdminSettingsTriggerBackupMutationError = AxiosError<unknown>

    /**
 * @summary Trigger database backup (Mock)
 */
export const useAdminSettingsTriggerBackup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsTriggerBackup>>, TError,{data: AdminSettingsTriggerBackupBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSettingsTriggerBackup>>,
        TError,
        {data: AdminSettingsTriggerBackupBody},
        TContext
      > => {

      const mutationOptions = getAdminSettingsTriggerBackupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Clear system cache (Mock)
 */
export const adminSettingsClearCache = (
    adminSettingsClearCacheBody?: AdminSettingsClearCacheBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/settings/cache/clear`,
      adminSettingsClearCacheBody,options
    );
  }



export const getAdminSettingsClearCacheMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsClearCache>>, TError,{data: AdminSettingsClearCacheBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSettingsClearCache>>, TError,{data: AdminSettingsClearCacheBody}, TContext> => {

const mutationKey = ['adminSettingsClearCache'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSettingsClearCache>>, {data: AdminSettingsClearCacheBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSettingsClearCache(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSettingsClearCacheMutationResult = NonNullable<Awaited<ReturnType<typeof adminSettingsClearCache>>>
    export type AdminSettingsClearCacheMutationBody = AdminSettingsClearCacheBody
    export type AdminSettingsClearCacheMutationError = AxiosError<unknown>

    /**
 * @summary Clear system cache (Mock)
 */
export const useAdminSettingsClearCache = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsClearCache>>, TError,{data: AdminSettingsClearCacheBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSettingsClearCache>>,
        TError,
        {data: AdminSettingsClearCacheBody},
        TContext
      > => {

      const mutationOptions = getAdminSettingsClearCacheMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Initialize System Settings table
 */
export const adminSettingsInitDb = (
    adminSettingsInitDbBody?: AdminSettingsInitDbBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/settings/init-db`,
      adminSettingsInitDbBody,options
    );
  }



export const getAdminSettingsInitDbMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsInitDb>>, TError,{data: AdminSettingsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSettingsInitDb>>, TError,{data: AdminSettingsInitDbBody}, TContext> => {

const mutationKey = ['adminSettingsInitDb'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSettingsInitDb>>, {data: AdminSettingsInitDbBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSettingsInitDb(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSettingsInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof adminSettingsInitDb>>>
    export type AdminSettingsInitDbMutationBody = AdminSettingsInitDbBody
    export type AdminSettingsInitDbMutationError = AxiosError<unknown>

    /**
 * @summary Initialize System Settings table
 */
export const useAdminSettingsInitDb = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSettingsInitDb>>, TError,{data: AdminSettingsInitDbBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSettingsInitDb>>,
        TError,
        {data: AdminSettingsInitDbBody},
        TContext
      > => {

      const mutationOptions = getAdminSettingsInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin List SMS Headers
 */
export const adminSmsGetHeaders = (
    params?: AdminSmsGetHeadersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminSmsGetHeaders200>> => {
    
    
    return axios.get(
      `/api/admin/sms/headers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getAdminSmsGetHeadersQueryKey = (params?: AdminSmsGetHeadersParams,) => {
    return [
    `/api/admin/sms/headers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAdminSmsGetHeadersQueryOptions = <TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminSmsGetHeadersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminSmsGetHeaders>>> = ({ signal }) => adminSmsGetHeaders(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminSmsGetHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof adminSmsGetHeaders>>>
export type AdminSmsGetHeadersQueryError = AxiosError<unknown>


export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params: undefined |  AdminSmsGetHeadersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetHeaders>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetHeaders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Headers
 */

export function useAdminSmsGetHeaders<TData = Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError = AxiosError<unknown>>(
 params?: AdminSmsGetHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetHeaders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminSmsGetHeadersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin Update SMS Header Status
 */
export const adminSmsUpdateHeaderStatus = (
    headerId: string,
    adminSmsUpdateHeaderStatusBody: AdminSmsUpdateHeaderStatusBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSHeaderRequest>> => {
    
    
    return axios.put(
      `/api/admin/sms/headers/${headerId}/status`,
      adminSmsUpdateHeaderStatusBody,options
    );
  }



export const getAdminSmsUpdateHeaderStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext> => {

const mutationKey = ['adminSmsUpdateHeaderStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, {headerId: string;data: AdminSmsUpdateHeaderStatusBody}> = (props) => {
          const {headerId,data} = props ?? {};

          return  adminSmsUpdateHeaderStatus(headerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsUpdateHeaderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>>
    export type AdminSmsUpdateHeaderStatusMutationBody = AdminSmsUpdateHeaderStatusBody
    export type AdminSmsUpdateHeaderStatusMutationError = AxiosError<unknown>

    /**
 * @summary Admin Update SMS Header Status
 */
export const useAdminSmsUpdateHeaderStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>, TError,{headerId: string;data: AdminSmsUpdateHeaderStatusBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsUpdateHeaderStatus>>,
        TError,
        {headerId: string;data: AdminSmsUpdateHeaderStatusBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsUpdateHeaderStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin List SMS Packages
 */
export const adminSmsGetPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminSmsGetPackages200>> => {
    
    
    return axios.get(
      `/api/admin/sms/packages`,options
    );
  }




export const getAdminSmsGetPackagesQueryKey = () => {
    return [
    `/api/admin/sms/packages`
    ] as const;
    }

    
export const getAdminSmsGetPackagesQueryOptions = <TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminSmsGetPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminSmsGetPackages>>> = ({ signal }) => adminSmsGetPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminSmsGetPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof adminSmsGetPackages>>>
export type AdminSmsGetPackagesQueryError = AxiosError<unknown>


export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminSmsGetPackages>>,
          TError,
          Awaited<ReturnType<typeof adminSmsGetPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Packages
 */

export function useAdminSmsGetPackages<TData = Awaited<ReturnType<typeof adminSmsGetPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminSmsGetPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminSmsGetPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin Create SMS Package
 */
export const adminSmsCreatePackage = (
    adminSmsCreatePackageBody: AdminSmsCreatePackageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSPackage>> => {
    
    
    return axios.post(
      `/api/admin/sms/packages`,
      adminSmsCreatePackageBody,options
    );
  }



export const getAdminSmsCreatePackageMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext> => {

const mutationKey = ['adminSmsCreatePackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsCreatePackage>>, {data: AdminSmsCreatePackageBody}> = (props) => {
          const {data} = props ?? {};

          return  adminSmsCreatePackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsCreatePackageMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsCreatePackage>>>
    export type AdminSmsCreatePackageMutationBody = AdminSmsCreatePackageBody
    export type AdminSmsCreatePackageMutationError = AxiosError<unknown>

    /**
 * @summary Admin Create SMS Package
 */
export const useAdminSmsCreatePackage = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsCreatePackage>>, TError,{data: AdminSmsCreatePackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsCreatePackage>>,
        TError,
        {data: AdminSmsCreatePackageBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsCreatePackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin Update SMS Package
 */
export const adminSmsUpdatePackage = (
    pkgId: string,
    adminSmsUpdatePackageBody: AdminSmsUpdatePackageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SMSPackage>> => {
    
    
    return axios.put(
      `/api/admin/sms/packages/${pkgId}`,
      adminSmsUpdatePackageBody,options
    );
  }



export const getAdminSmsUpdatePackageMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext> => {

const mutationKey = ['adminSmsUpdatePackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, {pkgId: string;data: AdminSmsUpdatePackageBody}> = (props) => {
          const {pkgId,data} = props ?? {};

          return  adminSmsUpdatePackage(pkgId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminSmsUpdatePackageMutationResult = NonNullable<Awaited<ReturnType<typeof adminSmsUpdatePackage>>>
    export type AdminSmsUpdatePackageMutationBody = AdminSmsUpdatePackageBody
    export type AdminSmsUpdatePackageMutationError = AxiosError<unknown>

    /**
 * @summary Admin Update SMS Package
 */
export const useAdminSmsUpdatePackage = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminSmsUpdatePackage>>, TError,{pkgId: string;data: AdminSmsUpdatePackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminSmsUpdatePackage>>,
        TError,
        {pkgId: string;data: AdminSmsUpdatePackageBody},
        TContext
      > => {

      const mutationOptions = getAdminSmsUpdatePackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create tenant
 */
export const adminTenantsCreateTenant = (
    adminTenantsCreateTenantBody?: AdminTenantsCreateTenantBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tenants`,
      adminTenantsCreateTenantBody,options
    );
  }



export const getAdminTenantsCreateTenantMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenant>>, TError,{data: AdminTenantsCreateTenantBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenant>>, TError,{data: AdminTenantsCreateTenantBody}, TContext> => {

const mutationKey = ['adminTenantsCreateTenant'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsCreateTenant>>, {data: AdminTenantsCreateTenantBody}> = (props) => {
          const {data} = props ?? {};

          return  adminTenantsCreateTenant(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsCreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsCreateTenant>>>
    export type AdminTenantsCreateTenantMutationBody = AdminTenantsCreateTenantBody
    export type AdminTenantsCreateTenantMutationError = AxiosError<unknown>

    /**
 * @summary Create tenant
 */
export const useAdminTenantsCreateTenant = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenant>>, TError,{data: AdminTenantsCreateTenantBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsCreateTenant>>,
        TError,
        {data: AdminTenantsCreateTenantBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsCreateTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete tenant (soft delete)
 */
export const adminTenantsDeleteTenant = (
    tenantId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/admin/tenants/${tenantId}`,options
    );
  }



export const getAdminTenantsDeleteTenantMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsDeleteTenant>>, TError,{tenantId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsDeleteTenant>>, TError,{tenantId: string}, TContext> => {

const mutationKey = ['adminTenantsDeleteTenant'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsDeleteTenant>>, {tenantId: string}> = (props) => {
          const {tenantId} = props ?? {};

          return  adminTenantsDeleteTenant(tenantId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsDeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsDeleteTenant>>>
    
    export type AdminTenantsDeleteTenantMutationError = AxiosError<unknown>

    /**
 * @summary Delete tenant (soft delete)
 */
export const useAdminTenantsDeleteTenant = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsDeleteTenant>>, TError,{tenantId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsDeleteTenant>>,
        TError,
        {tenantId: string},
        TContext
      > => {

      const mutationOptions = getAdminTenantsDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Add addon to tenant (Admin override)
 */
export const adminTenantsAddTenantAddon = (
    tenantId: string,
    adminTenantsAddTenantAddonBody?: AdminTenantsAddTenantAddonBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tenants/${tenantId}/addons`,
      adminTenantsAddTenantAddonBody,options
    );
  }



export const getAdminTenantsAddTenantAddonMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>, TError,{tenantId: string;data: AdminTenantsAddTenantAddonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>, TError,{tenantId: string;data: AdminTenantsAddTenantAddonBody}, TContext> => {

const mutationKey = ['adminTenantsAddTenantAddon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>, {tenantId: string;data: AdminTenantsAddTenantAddonBody}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  adminTenantsAddTenantAddon(tenantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsAddTenantAddonMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>>
    export type AdminTenantsAddTenantAddonMutationBody = AdminTenantsAddTenantAddonBody
    export type AdminTenantsAddTenantAddonMutationError = AxiosError<unknown>

    /**
 * @summary Add addon to tenant (Admin override)
 */
export const useAdminTenantsAddTenantAddon = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>, TError,{tenantId: string;data: AdminTenantsAddTenantAddonBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsAddTenantAddon>>,
        TError,
        {tenantId: string;data: AdminTenantsAddTenantAddonBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsAddTenantAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update tenant status
 */
export const adminTenantsUpdateTenantStatus = (
    tenantId: string,
    adminTenantsUpdateTenantStatusBody?: AdminTenantsUpdateTenantStatusBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/tenants/${tenantId}/status`,
      adminTenantsUpdateTenantStatusBody,options
    );
  }



export const getAdminTenantsUpdateTenantStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>, TError,{tenantId: string;data: AdminTenantsUpdateTenantStatusBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>, TError,{tenantId: string;data: AdminTenantsUpdateTenantStatusBody}, TContext> => {

const mutationKey = ['adminTenantsUpdateTenantStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>, {tenantId: string;data: AdminTenantsUpdateTenantStatusBody}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  adminTenantsUpdateTenantStatus(tenantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsUpdateTenantStatusMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>>
    export type AdminTenantsUpdateTenantStatusMutationBody = AdminTenantsUpdateTenantStatusBody
    export type AdminTenantsUpdateTenantStatusMutationError = AxiosError<unknown>

    /**
 * @summary Update tenant status
 */
export const useAdminTenantsUpdateTenantStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>, TError,{tenantId: string;data: AdminTenantsUpdateTenantStatusBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsUpdateTenantStatus>>,
        TError,
        {tenantId: string;data: AdminTenantsUpdateTenantStatusBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsUpdateTenantStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Subscribe tenant to a plan (Admin override)
 */
export const adminTenantsSubscribeTenant = (
    tenantId: string,
    adminTenantsSubscribeTenantBody?: AdminTenantsSubscribeTenantBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tenants/${tenantId}/subscribe`,
      adminTenantsSubscribeTenantBody,options
    );
  }



export const getAdminTenantsSubscribeTenantMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>, TError,{tenantId: string;data: AdminTenantsSubscribeTenantBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>, TError,{tenantId: string;data: AdminTenantsSubscribeTenantBody}, TContext> => {

const mutationKey = ['adminTenantsSubscribeTenant'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>, {tenantId: string;data: AdminTenantsSubscribeTenantBody}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  adminTenantsSubscribeTenant(tenantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsSubscribeTenantMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>>
    export type AdminTenantsSubscribeTenantMutationBody = AdminTenantsSubscribeTenantBody
    export type AdminTenantsSubscribeTenantMutationError = AxiosError<unknown>

    /**
 * @summary Subscribe tenant to a plan (Admin override)
 */
export const useAdminTenantsSubscribeTenant = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>, TError,{tenantId: string;data: AdminTenantsSubscribeTenantBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsSubscribeTenant>>,
        TError,
        {tenantId: string;data: AdminTenantsSubscribeTenantBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsSubscribeTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a user for a specific tenant
 */
export const adminTenantsCreateTenantUser = (
    tenantId: string,
    adminTenantsCreateTenantUserBody?: AdminTenantsCreateTenantUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tenants/${tenantId}/users`,
      adminTenantsCreateTenantUserBody,options
    );
  }



export const getAdminTenantsCreateTenantUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>, TError,{tenantId: string;data: AdminTenantsCreateTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>, TError,{tenantId: string;data: AdminTenantsCreateTenantUserBody}, TContext> => {

const mutationKey = ['adminTenantsCreateTenantUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>, {tenantId: string;data: AdminTenantsCreateTenantUserBody}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  adminTenantsCreateTenantUser(tenantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsCreateTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>>
    export type AdminTenantsCreateTenantUserMutationBody = AdminTenantsCreateTenantUserBody
    export type AdminTenantsCreateTenantUserMutationError = AxiosError<unknown>

    /**
 * @summary Create a user for a specific tenant
 */
export const useAdminTenantsCreateTenantUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>, TError,{tenantId: string;data: AdminTenantsCreateTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsCreateTenantUser>>,
        TError,
        {tenantId: string;data: AdminTenantsCreateTenantUserBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsCreateTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a tenant user
 */
export const adminTenantsUpdateTenantUser = (
    tenantId: string,
    userId: string,
    adminTenantsUpdateTenantUserBody?: AdminTenantsUpdateTenantUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/tenants/${tenantId}/users/${userId}`,
      adminTenantsUpdateTenantUserBody,options
    );
  }



export const getAdminTenantsUpdateTenantUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>, TError,{tenantId: string;userId: string;data: AdminTenantsUpdateTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>, TError,{tenantId: string;userId: string;data: AdminTenantsUpdateTenantUserBody}, TContext> => {

const mutationKey = ['adminTenantsUpdateTenantUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>, {tenantId: string;userId: string;data: AdminTenantsUpdateTenantUserBody}> = (props) => {
          const {tenantId,userId,data} = props ?? {};

          return  adminTenantsUpdateTenantUser(tenantId,userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTenantsUpdateTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>>
    export type AdminTenantsUpdateTenantUserMutationBody = AdminTenantsUpdateTenantUserBody
    export type AdminTenantsUpdateTenantUserMutationError = AxiosError<unknown>

    /**
 * @summary Update a tenant user
 */
export const useAdminTenantsUpdateTenantUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>, TError,{tenantId: string;userId: string;data: AdminTenantsUpdateTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTenantsUpdateTenantUser>>,
        TError,
        {tenantId: string;userId: string;data: AdminTenantsUpdateTenantUserBody},
        TContext
      > => {

      const mutationOptions = getAdminTenantsUpdateTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/admin/tickets
 */
export const adminTicketsCreateAdminTicket = (
    adminTicketsCreateAdminTicketBody?: AdminTicketsCreateAdminTicketBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tickets`,
      adminTicketsCreateAdminTicketBody,options
    );
  }



export const getAdminTicketsCreateAdminTicketMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>, TError,{data: AdminTicketsCreateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>, TError,{data: AdminTicketsCreateAdminTicketBody}, TContext> => {

const mutationKey = ['adminTicketsCreateAdminTicket'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>, {data: AdminTicketsCreateAdminTicketBody}> = (props) => {
          const {data} = props ?? {};

          return  adminTicketsCreateAdminTicket(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTicketsCreateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>>
    export type AdminTicketsCreateAdminTicketMutationBody = AdminTicketsCreateAdminTicketBody
    export type AdminTicketsCreateAdminTicketMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/admin/tickets
 */
export const useAdminTicketsCreateAdminTicket = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>, TError,{data: AdminTicketsCreateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTicketsCreateAdminTicket>>,
        TError,
        {data: AdminTicketsCreateAdminTicketBody},
        TContext
      > => {

      const mutationOptions = getAdminTicketsCreateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/admin/tickets/{id}
 */
export const adminTicketsUpdateAdminTicket = (
    id: string,
    adminTicketsUpdateAdminTicketBody?: AdminTicketsUpdateAdminTicketBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/tickets/${id}`,
      adminTicketsUpdateAdminTicketBody,options
    );
  }



export const getAdminTicketsUpdateAdminTicketMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>, TError,{id: string;data: AdminTicketsUpdateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>, TError,{id: string;data: AdminTicketsUpdateAdminTicketBody}, TContext> => {

const mutationKey = ['adminTicketsUpdateAdminTicket'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>, {id: string;data: AdminTicketsUpdateAdminTicketBody}> = (props) => {
          const {id,data} = props ?? {};

          return  adminTicketsUpdateAdminTicket(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminTicketsUpdateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>>
    export type AdminTicketsUpdateAdminTicketMutationBody = AdminTicketsUpdateAdminTicketBody
    export type AdminTicketsUpdateAdminTicketMutationError = AxiosError<unknown>

    /**
 * @summary PUT /api/admin/tickets/{id}
 */
export const useAdminTicketsUpdateAdminTicket = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>, TError,{id: string;data: AdminTicketsUpdateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminTicketsUpdateAdminTicket>>,
        TError,
        {id: string;data: AdminTicketsUpdateAdminTicketBody},
        TContext
      > => {

      const mutationOptions = getAdminTicketsUpdateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update support ticket (placeholder)
 */
export const adminUpdateAdminTicket = (
    ticketId: string,
    adminUpdateAdminTicketBody?: AdminUpdateAdminTicketBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/tickets/${ticketId}`,
      adminUpdateAdminTicketBody,options
    );
  }



export const getAdminUpdateAdminTicketMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAdminTicket>>, TError,{ticketId: string;data: AdminUpdateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAdminTicket>>, TError,{ticketId: string;data: AdminUpdateAdminTicketBody}, TContext> => {

const mutationKey = ['adminUpdateAdminTicket'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateAdminTicket>>, {ticketId: string;data: AdminUpdateAdminTicketBody}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  adminUpdateAdminTicket(ticketId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateAdminTicket>>>
    export type AdminUpdateAdminTicketMutationBody = AdminUpdateAdminTicketBody
    export type AdminUpdateAdminTicketMutationError = AxiosError<unknown>

    /**
 * @summary Update support ticket (placeholder)
 */
export const useAdminUpdateAdminTicket = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAdminTicket>>, TError,{ticketId: string;data: AdminUpdateAdminTicketBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminUpdateAdminTicket>>,
        TError,
        {ticketId: string;data: AdminUpdateAdminTicketBody},
        TContext
      > => {

      const mutationOptions = getAdminUpdateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create response for support ticket (placeholder)
 */
export const adminCreateTicketResponse = (
    ticketId: string,
    adminCreateTicketResponseBody?: AdminCreateTicketResponseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/admin/tickets/${ticketId}/responses`,
      adminCreateTicketResponseBody,options
    );
  }



export const getAdminCreateTicketResponseMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateTicketResponse>>, TError,{ticketId: string;data: AdminCreateTicketResponseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminCreateTicketResponse>>, TError,{ticketId: string;data: AdminCreateTicketResponseBody}, TContext> => {

const mutationKey = ['adminCreateTicketResponse'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminCreateTicketResponse>>, {ticketId: string;data: AdminCreateTicketResponseBody}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  adminCreateTicketResponse(ticketId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminCreateTicketResponseMutationResult = NonNullable<Awaited<ReturnType<typeof adminCreateTicketResponse>>>
    export type AdminCreateTicketResponseMutationBody = AdminCreateTicketResponseBody
    export type AdminCreateTicketResponseMutationError = AxiosError<unknown>

    /**
 * @summary Create response for support ticket (placeholder)
 */
export const useAdminCreateTicketResponse = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateTicketResponse>>, TError,{ticketId: string;data: AdminCreateTicketResponseBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminCreateTicketResponse>>,
        TError,
        {ticketId: string;data: AdminCreateTicketResponseBody},
        TContext
      > => {

      const mutationOptions = getAdminCreateTicketResponseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get list of admin users
 */
export const adminGetAdminUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/users`,options
    );
  }




export const getAdminGetAdminUsersQueryKey = () => {
    return [
    `/api/admin/users`
    ] as const;
    }

    
export const getAdminGetAdminUsersQueryOptions = <TData = Awaited<ReturnType<typeof adminGetAdminUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminGetAdminUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminGetAdminUsers>>> = ({ signal }) => adminGetAdminUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminGetAdminUsersQueryResult = NonNullable<Awaited<ReturnType<typeof adminGetAdminUsers>>>
export type AdminGetAdminUsersQueryError = AxiosError<unknown>


export function useAdminGetAdminUsers<TData = Awaited<ReturnType<typeof adminGetAdminUsers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof adminGetAdminUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetAdminUsers<TData = Awaited<ReturnType<typeof adminGetAdminUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof adminGetAdminUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetAdminUsers<TData = Awaited<ReturnType<typeof adminGetAdminUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of admin users
 */

export function useAdminGetAdminUsers<TData = Awaited<ReturnType<typeof adminGetAdminUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAdminUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminGetAdminUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get list of ALL users from ALL tenants
 */
export const adminGetAllTenantUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/admin/users/all`,options
    );
  }




export const getAdminGetAllTenantUsersQueryKey = () => {
    return [
    `/api/admin/users/all`
    ] as const;
    }

    
export const getAdminGetAllTenantUsersQueryOptions = <TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminGetAllTenantUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminGetAllTenantUsers>>> = ({ signal }) => adminGetAllTenantUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminGetAllTenantUsersQueryResult = NonNullable<Awaited<ReturnType<typeof adminGetAllTenantUsers>>>
export type AdminGetAllTenantUsersQueryError = AxiosError<unknown>


export function useAdminGetAllTenantUsers<TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof adminGetAllTenantUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetAllTenantUsers<TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof adminGetAllTenantUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetAllTenantUsers<TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of ALL users from ALL tenants
 */

export function useAdminGetAllTenantUsers<TData = Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetAllTenantUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminGetAllTenantUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update any tenant user (Admin Panel)
 */
export const adminUpdateAnyTenantUser = (
    userId: string,
    adminUpdateAnyTenantUserBody?: AdminUpdateAnyTenantUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/admin/users/all/${userId}`,
      adminUpdateAnyTenantUserBody,options
    );
  }



export const getAdminUpdateAnyTenantUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>, TError,{userId: string;data: AdminUpdateAnyTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>, TError,{userId: string;data: AdminUpdateAnyTenantUserBody}, TContext> => {

const mutationKey = ['adminUpdateAnyTenantUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>, {userId: string;data: AdminUpdateAnyTenantUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  adminUpdateAnyTenantUser(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateAnyTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>>
    export type AdminUpdateAnyTenantUserMutationBody = AdminUpdateAnyTenantUserBody
    export type AdminUpdateAnyTenantUserMutationError = AxiosError<unknown>

    /**
 * @summary Update any tenant user (Admin Panel)
 */
export const useAdminUpdateAnyTenantUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>, TError,{userId: string;data: AdminUpdateAnyTenantUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminUpdateAnyTenantUser>>,
        TError,
        {userId: string;data: AdminUpdateAnyTenantUserBody},
        TContext
      > => {

      const mutationOptions = getAdminUpdateAnyTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/auth/forgot-password
 */
export const authForgotPassword = (
    authForgotPasswordBody?: AuthForgotPasswordBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/auth/forgot-password`,
      authForgotPasswordBody,options
    );
  }



export const getAuthForgotPasswordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext> => {

const mutationKey = ['authForgotPassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authForgotPassword>>, {data: AuthForgotPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  authForgotPassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authForgotPassword>>>
    export type AuthForgotPasswordMutationBody = AuthForgotPasswordBody
    export type AuthForgotPasswordMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/auth/forgot-password
 */
export const useAuthForgotPassword = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authForgotPassword>>,
        TError,
        {data: AuthForgotPasswordBody},
        TContext
      > => {

      const mutationOptions = getAuthForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/auth/login
 */
export const authLogin = (
    authLoginBody?: AuthLoginBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/auth/login`,
      authLoginBody,options
    );
  }



export const getAuthLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext> => {

const mutationKey = ['authLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authLogin>>, {data: AuthLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  authLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authLogin>>>
    export type AuthLoginMutationBody = AuthLoginBody
    export type AuthLoginMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/auth/login
 */
export const useAuthLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authLogin>>,
        TError,
        {data: AuthLoginBody},
        TContext
      > => {

      const mutationOptions = getAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Refresh access token using refresh token
 */
export const authRefresh = (
    authRefreshBody?: AuthRefreshBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/auth/refresh`,
      authRefreshBody,options
    );
  }



export const getAuthRefreshMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRefresh>>, TError,{data: AuthRefreshBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authRefresh>>, TError,{data: AuthRefreshBody}, TContext> => {

const mutationKey = ['authRefresh'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authRefresh>>, {data: AuthRefreshBody}> = (props) => {
          const {data} = props ?? {};

          return  authRefresh(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authRefresh>>>
    export type AuthRefreshMutationBody = AuthRefreshBody
    export type AuthRefreshMutationError = AxiosError<unknown>

    /**
 * @summary Refresh access token using refresh token
 */
export const useAuthRefresh = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authRefresh>>, TError,{data: AuthRefreshBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authRefresh>>,
        TError,
        {data: AuthRefreshBody},
        TContext
      > => {

      const mutationOptions = getAuthRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Send OTP to the user's phone number (requires pre-auth token)
 */
export const authSendVerificationOtp = (
    authSendVerificationOtpBody?: AuthSendVerificationOtpBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/auth/send-verification-otp`,
      authSendVerificationOtpBody,options
    );
  }



export const getAuthSendVerificationOtpMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authSendVerificationOtp>>, TError,{data: AuthSendVerificationOtpBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authSendVerificationOtp>>, TError,{data: AuthSendVerificationOtpBody}, TContext> => {

const mutationKey = ['authSendVerificationOtp'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authSendVerificationOtp>>, {data: AuthSendVerificationOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  authSendVerificationOtp(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthSendVerificationOtpMutationResult = NonNullable<Awaited<ReturnType<typeof authSendVerificationOtp>>>
    export type AuthSendVerificationOtpMutationBody = AuthSendVerificationOtpBody
    export type AuthSendVerificationOtpMutationError = AxiosError<unknown>

    /**
 * @summary Send OTP to the user's phone number (requires pre-auth token)
 */
export const useAuthSendVerificationOtp = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authSendVerificationOtp>>, TError,{data: AuthSendVerificationOtpBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authSendVerificationOtp>>,
        TError,
        {data: AuthSendVerificationOtpBody},
        TContext
      > => {

      const mutationOptions = getAuthSendVerificationOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/auth/verify-otp
 */
export const authVerifyOtp = (
    authVerifyOtpBody?: AuthVerifyOtpBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/auth/verify-otp`,
      authVerifyOtpBody,options
    );
  }



export const getAuthVerifyOtpMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext> => {

const mutationKey = ['authVerifyOtp'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authVerifyOtp>>, {data: AuthVerifyOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  authVerifyOtp(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthVerifyOtpMutationResult = NonNullable<Awaited<ReturnType<typeof authVerifyOtp>>>
    export type AuthVerifyOtpMutationBody = AuthVerifyOtpBody
    export type AuthVerifyOtpMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/auth/verify-otp
 */
export const useAuthVerifyOtp = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authVerifyOtp>>,
        TError,
        {data: AuthVerifyOtpBody},
        TContext
      > => {

      const mutationOptions = getAuthVerifyOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Query params:
- name: filename in the inbox directory (required)
- format: 'xml' (default) or 'pdf'
 * @summary Return raw XML or rendered PDF for a given inbox filename.
 */
export const birfaturaBpBirfaturaInboxFile = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/birfatura/inbox/file`,options
    );
  }




export const getBirfaturaBpBirfaturaInboxFileQueryKey = () => {
    return [
    `/api/birfatura/inbox/file`
    ] as const;
    }

    
export const getBirfaturaBpBirfaturaInboxFileQueryOptions = <TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBirfaturaBpBirfaturaInboxFileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>> = ({ signal }) => birfaturaBpBirfaturaInboxFile({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type BirfaturaBpBirfaturaInboxFileQueryResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>>
export type BirfaturaBpBirfaturaInboxFileQueryError = AxiosError<unknown>


export function useBirfaturaBpBirfaturaInboxFile<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
          TError,
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBirfaturaBpBirfaturaInboxFile<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>,
          TError,
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBirfaturaBpBirfaturaInboxFile<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Return raw XML or rendered PDF for a given inbox filename.
 */

export function useBirfaturaBpBirfaturaInboxFile<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxFile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getBirfaturaBpBirfaturaInboxFileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List files saved in the birfatura_inbox directory.
 */
export const birfaturaBpBirfaturaInboxList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/birfatura/inbox/list`,options
    );
  }




export const getBirfaturaBpBirfaturaInboxListQueryKey = () => {
    return [
    `/api/birfatura/inbox/list`
    ] as const;
    }

    
export const getBirfaturaBpBirfaturaInboxListQueryOptions = <TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBirfaturaBpBirfaturaInboxListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>> = ({ signal }) => birfaturaBpBirfaturaInboxList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type BirfaturaBpBirfaturaInboxListQueryResult = NonNullable<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>>
export type BirfaturaBpBirfaturaInboxListQueryError = AxiosError<unknown>


export function useBirfaturaBpBirfaturaInboxList<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
          TError,
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBirfaturaBpBirfaturaInboxList<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>,
          TError,
          Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useBirfaturaBpBirfaturaInboxList<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List files saved in the birfatura_inbox directory.
 */

export function useBirfaturaBpBirfaturaInboxList<TData = Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof birfaturaBpBirfaturaInboxList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getBirfaturaBpBirfaturaInboxListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary DELETE /api/branches/{branch_id}
 */
export const branchesDeleteBranch = (
    branchId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/branches/${branchId}`,options
    );
  }



export const getBranchesDeleteBranchMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof branchesDeleteBranch>>, TError,{branchId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof branchesDeleteBranch>>, TError,{branchId: string}, TContext> => {

const mutationKey = ['branchesDeleteBranch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof branchesDeleteBranch>>, {branchId: string}> = (props) => {
          const {branchId} = props ?? {};

          return  branchesDeleteBranch(branchId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BranchesDeleteBranchMutationResult = NonNullable<Awaited<ReturnType<typeof branchesDeleteBranch>>>
    
    export type BranchesDeleteBranchMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/branches/{branch_id}
 */
export const useBranchesDeleteBranch = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof branchesDeleteBranch>>, TError,{branchId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof branchesDeleteBranch>>,
        TError,
        {branchId: string},
        TContext
      > => {

      const mutationOptions = getBranchesDeleteBranchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const cashRecordsCreateCashRecord = (
    cashRecordsCreateCashRecordBody?: CashRecordsCreateCashRecordBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/cash-records`,
      cashRecordsCreateCashRecordBody,options
    );
  }



export const getCashRecordsCreateCashRecordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext> => {

const mutationKey = ['cashRecordsCreateCashRecord'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, {data: CashRecordsCreateCashRecordBody}> = (props) => {
          const {data} = props ?? {};

          return  cashRecordsCreateCashRecord(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CashRecordsCreateCashRecordMutationResult = NonNullable<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>>
    export type CashRecordsCreateCashRecordMutationBody = CashRecordsCreateCashRecordBody
    export type CashRecordsCreateCashRecordMutationError = AxiosError<unknown>

    /**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const useCashRecordsCreateCashRecord = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
        TError,
        {data: CashRecordsCreateCashRecordBody},
        TContext
      > => {

      const mutationOptions = getCashRecordsCreateCashRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a cash record by ID.
 */
export const cashRecordsDeleteCashRecord = (
    recordId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/cash-records/${recordId}`,options
    );
  }



export const getCashRecordsDeleteCashRecordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext> => {

const mutationKey = ['cashRecordsDeleteCashRecord'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, {recordId: string}> = (props) => {
          const {recordId} = props ?? {};

          return  cashRecordsDeleteCashRecord(recordId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CashRecordsDeleteCashRecordMutationResult = NonNullable<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>>
    
    export type CashRecordsDeleteCashRecordMutationError = AxiosError<unknown>

    /**
 * @summary Delete a cash record by ID.
 */
export const useCashRecordsDeleteCashRecord = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
        TError,
        {recordId: string},
        TContext
      > => {

      const mutationOptions = getCashRecordsDeleteCashRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Mock endpoint to confirm a payment (simulating a webhook or successful callback).
 */
export const checkoutConfirmPayment = (
    checkoutConfirmPaymentBody?: CheckoutConfirmPaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/checkout/confirm`,
      checkoutConfirmPaymentBody,options
    );
  }



export const getCheckoutConfirmPaymentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPayment>>, TError,{data: CheckoutConfirmPaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPayment>>, TError,{data: CheckoutConfirmPaymentBody}, TContext> => {

const mutationKey = ['checkoutConfirmPayment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutConfirmPayment>>, {data: CheckoutConfirmPaymentBody}> = (props) => {
          const {data} = props ?? {};

          return  checkoutConfirmPayment(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutConfirmPaymentMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutConfirmPayment>>>
    export type CheckoutConfirmPaymentMutationBody = CheckoutConfirmPaymentBody
    export type CheckoutConfirmPaymentMutationError = AxiosError<unknown>

    /**
 * @summary Mock endpoint to confirm a payment (simulating a webhook or successful callback).
 */
export const useCheckoutConfirmPayment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutConfirmPayment>>, TError,{data: CheckoutConfirmPaymentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutConfirmPayment>>,
        TError,
        {data: CheckoutConfirmPaymentBody},
        TContext
      > => {

      const mutationOptions = getCheckoutConfirmPaymentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * In a real scenario, this would create a Stripe Checkout Session.
For now, it simulates the process and returns a success URL or mock payment data.
 * @summary Initiates a checkout session for a plan purchase.
 */
export const checkoutCreateCheckoutSession = (
    checkoutCreateCheckoutSessionBody?: CheckoutCreateCheckoutSessionBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/checkout/session`,
      checkoutCreateCheckoutSessionBody,options
    );
  }



export const getCheckoutCreateCheckoutSessionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>, TError,{data: CheckoutCreateCheckoutSessionBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>, TError,{data: CheckoutCreateCheckoutSessionBody}, TContext> => {

const mutationKey = ['checkoutCreateCheckoutSession'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>, {data: CheckoutCreateCheckoutSessionBody}> = (props) => {
          const {data} = props ?? {};

          return  checkoutCreateCheckoutSession(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckoutCreateCheckoutSessionMutationResult = NonNullable<Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>>
    export type CheckoutCreateCheckoutSessionMutationBody = CheckoutCreateCheckoutSessionBody
    export type CheckoutCreateCheckoutSessionMutationError = AxiosError<unknown>

    /**
 * @summary Initiates a checkout session for a plan purchase.
 */
export const useCheckoutCreateCheckoutSession = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>, TError,{data: CheckoutCreateCheckoutSessionBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkoutCreateCheckoutSession>>,
        TError,
        {data: CheckoutCreateCheckoutSessionBody},
        TContext
      > => {

      const mutationOptions = getCheckoutCreateCheckoutSessionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a manual communication history entry
 */
export const communicationsCreateCommunicationHistory = (
    communicationsCreateCommunicationHistoryBody?: CommunicationsCreateCommunicationHistoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/communications/history`,
      communicationsCreateCommunicationHistoryBody,options
    );
  }



export const getCommunicationsCreateCommunicationHistoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>, TError,{data: CommunicationsCreateCommunicationHistoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>, TError,{data: CommunicationsCreateCommunicationHistoryBody}, TContext> => {

const mutationKey = ['communicationsCreateCommunicationHistory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>, {data: CommunicationsCreateCommunicationHistoryBody}> = (props) => {
          const {data} = props ?? {};

          return  communicationsCreateCommunicationHistory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsCreateCommunicationHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>>
    export type CommunicationsCreateCommunicationHistoryMutationBody = CommunicationsCreateCommunicationHistoryBody
    export type CommunicationsCreateCommunicationHistoryMutationError = AxiosError<unknown>

    /**
 * @summary Create a manual communication history entry
 */
export const useCommunicationsCreateCommunicationHistory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>, TError,{data: CommunicationsCreateCommunicationHistoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsCreateCommunicationHistory>>,
        TError,
        {data: CommunicationsCreateCommunicationHistoryBody},
        TContext
      > => {

      const mutationOptions = getCommunicationsCreateCommunicationHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Send Email message
 */
export const communicationsSendEmail = (
    communicationsSendEmailBody?: CommunicationsSendEmailBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/communications/messages/send-email`,
      communicationsSendEmailBody,options
    );
  }



export const getCommunicationsSendEmailMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsSendEmail>>, TError,{data: CommunicationsSendEmailBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsSendEmail>>, TError,{data: CommunicationsSendEmailBody}, TContext> => {

const mutationKey = ['communicationsSendEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsSendEmail>>, {data: CommunicationsSendEmailBody}> = (props) => {
          const {data} = props ?? {};

          return  communicationsSendEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsSendEmailMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsSendEmail>>>
    export type CommunicationsSendEmailMutationBody = CommunicationsSendEmailBody
    export type CommunicationsSendEmailMutationError = AxiosError<unknown>

    /**
 * @summary Send Email message
 */
export const useCommunicationsSendEmail = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsSendEmail>>, TError,{data: CommunicationsSendEmailBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsSendEmail>>,
        TError,
        {data: CommunicationsSendEmailBody},
        TContext
      > => {

      const mutationOptions = getCommunicationsSendEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Send SMS message
 */
export const communicationsSendSms = (
    communicationsSendSmsBody?: CommunicationsSendSmsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/communications/messages/send-sms`,
      communicationsSendSmsBody,options
    );
  }



export const getCommunicationsSendSmsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsSendSms>>, TError,{data: CommunicationsSendSmsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof communicationsSendSms>>, TError,{data: CommunicationsSendSmsBody}, TContext> => {

const mutationKey = ['communicationsSendSms'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsSendSms>>, {data: CommunicationsSendSmsBody}> = (props) => {
          const {data} = props ?? {};

          return  communicationsSendSms(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsSendSmsMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsSendSms>>>
    export type CommunicationsSendSmsMutationBody = CommunicationsSendSmsBody
    export type CommunicationsSendSmsMutationError = AxiosError<unknown>

    /**
 * @summary Send SMS message
 */
export const useCommunicationsSendSms = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsSendSms>>, TError,{data: CommunicationsSendSmsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsSendSms>>,
        TError,
        {data: CommunicationsSendSmsBody},
        TContext
      > => {

      const mutationOptions = getCommunicationsSendSmsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get communication statistics
 */
export const communicationsCommunicationStats = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/communications/stats`,options
    );
  }




export const getCommunicationsCommunicationStatsQueryKey = () => {
    return [
    `/api/communications/stats`
    ] as const;
    }

    
export const getCommunicationsCommunicationStatsQueryOptions = <TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsCommunicationStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsCommunicationStats>>> = ({ signal }) => communicationsCommunicationStats({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsCommunicationStatsQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsCommunicationStats>>>
export type CommunicationsCommunicationStatsQueryError = AxiosError<unknown>


export function useCommunicationsCommunicationStats<TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsCommunicationStats>>,
          TError,
          Awaited<ReturnType<typeof communicationsCommunicationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsCommunicationStats<TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsCommunicationStats>>,
          TError,
          Awaited<ReturnType<typeof communicationsCommunicationStats>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsCommunicationStats<TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get communication statistics
 */

export function useCommunicationsCommunicationStats<TData = Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsCommunicationStats>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsCommunicationStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/config
 */
export const configGetConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/config`,options
    );
  }




export const getConfigGetConfigQueryKey = () => {
    return [
    `/api/config`
    ] as const;
    }

    
export const getConfigGetConfigQueryOptions = <TData = Awaited<ReturnType<typeof configGetConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConfigGetConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof configGetConfig>>> = ({ signal }) => configGetConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ConfigGetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof configGetConfig>>>
export type ConfigGetConfigQueryError = AxiosError<unknown>


export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGetConfig>>,
          TError,
          Awaited<ReturnType<typeof configGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGetConfig>>,
          TError,
          Awaited<ReturnType<typeof configGetConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/config
 */

export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getConfigGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/dashboard/charts/patient-distribution
 */
export const dashboardPatientDistribution = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/dashboard/charts/patient-distribution`,options
    );
  }




export const getDashboardPatientDistributionQueryKey = () => {
    return [
    `/api/dashboard/charts/patient-distribution`
    ] as const;
    }

    
export const getDashboardPatientDistributionQueryOptions = <TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardPatientDistributionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardPatientDistribution>>> = ({ signal }) => dashboardPatientDistribution({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardPatientDistributionQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardPatientDistribution>>>
export type DashboardPatientDistributionQueryError = AxiosError<unknown>


export function useDashboardPatientDistribution<TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientDistribution>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientDistribution>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientDistribution<TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientDistribution>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientDistribution>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientDistribution<TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/patient-distribution
 */

export function useDashboardPatientDistribution<TData = Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientDistribution>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardPatientDistributionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update a device assignment (e.g., cancel, update serial numbers, pricing)
 */
export const salesUpdateDeviceAssignment = (
    assignmentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/device-assignments/${assignmentId}`,undefined,options
    );
  }



export const getSalesUpdateDeviceAssignmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>, TError,{assignmentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>, TError,{assignmentId: string}, TContext> => {

const mutationKey = ['salesUpdateDeviceAssignment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>, {assignmentId: string}> = (props) => {
          const {assignmentId} = props ?? {};

          return  salesUpdateDeviceAssignment(assignmentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateDeviceAssignmentMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>>
    
    export type SalesUpdateDeviceAssignmentMutationError = AxiosError<unknown>

    /**
 * @summary Update a device assignment (e.g., cancel, update serial numbers, pricing)
 */
export const useSalesUpdateDeviceAssignment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>, TError,{assignmentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateDeviceAssignment>>,
        TError,
        {assignmentId: string},
        TContext
      > => {

      const mutationOptions = getSalesUpdateDeviceAssignmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new brand
 */
export const inventoryCreateBrand = (
    inventoryCreateBrandBody?: InventoryCreateBrandBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/brands`,
      inventoryCreateBrandBody,options
    );
  }



export const getInventoryCreateBrandMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext> => {

const mutationKey = ['inventoryCreateBrand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryCreateBrand>>, {data: InventoryCreateBrandBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryCreateBrand(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryCreateBrandMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryCreateBrand>>>
    export type InventoryCreateBrandMutationBody = InventoryCreateBrandBody
    export type InventoryCreateBrandMutationError = AxiosError<unknown>

    /**
 * @summary Create a new brand
 */
export const useInventoryCreateBrand = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryCreateBrand>>, TError,{data: InventoryCreateBrandBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryCreateBrand>>,
        TError,
        {data: InventoryCreateBrandBody},
        TContext
      > => {

      const mutationOptions = getInventoryCreateBrandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all available product brands with counts and categories
 */
export const inventoryGetBrandsOld = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/brands_old`,options
    );
  }




export const getInventoryGetBrandsOldQueryKey = () => {
    return [
    `/api/inventory/brands_old`
    ] as const;
    }

    
export const getInventoryGetBrandsOldQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetBrandsOldQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetBrandsOld>>> = ({ signal }) => inventoryGetBrandsOld({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetBrandsOldQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetBrandsOld>>>
export type InventoryGetBrandsOldQueryError = AxiosError<unknown>


export function useInventoryGetBrandsOld<TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrandsOld>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrandsOld<TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrandsOld>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrandsOld>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrandsOld<TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product brands with counts and categories
 */

export function useInventoryGetBrandsOld<TData = Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrandsOld>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetBrandsOldQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Bulk upload inventory items from CSV/XLSX. Returns {created, updated, errors}.
 */
export const inventoryBulkUploadInventory = (
    inventoryBulkUploadInventoryBody?: InventoryBulkUploadInventoryBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/inventory/bulk_upload`,
      inventoryBulkUploadInventoryBody,options
    );
  }



export const getInventoryBulkUploadInventoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryBulkUploadInventory>>, TError,{data: InventoryBulkUploadInventoryBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof inventoryBulkUploadInventory>>, TError,{data: InventoryBulkUploadInventoryBody}, TContext> => {

const mutationKey = ['inventoryBulkUploadInventory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryBulkUploadInventory>>, {data: InventoryBulkUploadInventoryBody}> = (props) => {
          const {data} = props ?? {};

          return  inventoryBulkUploadInventory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryBulkUploadInventoryMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryBulkUploadInventory>>>
    export type InventoryBulkUploadInventoryMutationBody = InventoryBulkUploadInventoryBody
    export type InventoryBulkUploadInventoryMutationError = AxiosError<unknown>

    /**
 * @summary Bulk upload inventory items from CSV/XLSX. Returns {created, updated, errors}.
 */
export const useInventoryBulkUploadInventory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryBulkUploadInventory>>, TError,{data: InventoryBulkUploadInventoryBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryBulkUploadInventory>>,
        TError,
        {data: InventoryBulkUploadInventoryBody},
        TContext
      > => {

      const mutationOptions = getInventoryBulkUploadInventoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all available product categories with counts
 */
export const inventoryGetCategoriesOld = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/categories_old`,options
    );
  }




export const getInventoryGetCategoriesOldQueryKey = () => {
    return [
    `/api/inventory/categories_old`
    ] as const;
    }

    
export const getInventoryGetCategoriesOldQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetCategoriesOldQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>> = ({ signal }) => inventoryGetCategoriesOld({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetCategoriesOldQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>>
export type InventoryGetCategoriesOldQueryError = AxiosError<unknown>


export function useInventoryGetCategoriesOld<TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategoriesOld>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategoriesOld<TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategoriesOld>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategoriesOld>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategoriesOld<TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product categories with counts
 */

export function useInventoryGetCategoriesOld<TData = Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategoriesOld>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetCategoriesOldQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all available product features with counts
 */
export const inventoryGetFeatures = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/features`,options
    );
  }




export const getInventoryGetFeaturesQueryKey = () => {
    return [
    `/api/inventory/features`
    ] as const;
    }

    
export const getInventoryGetFeaturesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetFeaturesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetFeatures>>> = ({ signal }) => inventoryGetFeatures({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetFeatures>>>
export type InventoryGetFeaturesQueryError = AxiosError<unknown>


export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetFeatures>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetFeatures>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product features with counts
 */

export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetFeaturesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Advanced product search with comprehensive filtering
 */
export const inventoryAdvancedSearch = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/search`,options
    );
  }




export const getInventoryAdvancedSearchQueryKey = () => {
    return [
    `/api/inventory/search`
    ] as const;
    }

    
export const getInventoryAdvancedSearchQueryOptions = <TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryAdvancedSearchQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryAdvancedSearch>>> = ({ signal }) => inventoryAdvancedSearch({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryAdvancedSearchQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryAdvancedSearch>>>
export type InventoryAdvancedSearchQueryError = AxiosError<unknown>


export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
          TError,
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
          TError,
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Advanced product search with comprehensive filtering
 */

export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryAdvancedSearchQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all available unit types for inventory items
 */
export const inventoryGetUnits = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/inventory/units`,options
    );
  }




export const getInventoryGetUnitsQueryKey = () => {
    return [
    `/api/inventory/units`
    ] as const;
    }

    
export const getInventoryGetUnitsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetUnits>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetUnitsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetUnits>>> = ({ signal }) => inventoryGetUnits({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetUnitsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetUnits>>>
export type InventoryGetUnitsQueryError = AxiosError<unknown>


export function useInventoryGetUnits<TData = Awaited<ReturnType<typeof inventoryGetUnits>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetUnits>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetUnits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetUnits<TData = Awaited<ReturnType<typeof inventoryGetUnits>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetUnits>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetUnits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetUnits<TData = Awaited<ReturnType<typeof inventoryGetUnits>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available unit types for inventory items
 */

export function useInventoryGetUnits<TData = Awaited<ReturnType<typeof inventoryGetUnits>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetUnits>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetUnitsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Generate multiple invoices at once
 */
export const invoicesBatchGenerateInvoices = (
    invoicesBatchGenerateInvoicesBody?: InvoicesBatchGenerateInvoicesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/batch-generate`,
      invoicesBatchGenerateInvoicesBody,options
    );
  }



export const getInvoicesBatchGenerateInvoicesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>, TError,{data: InvoicesBatchGenerateInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>, TError,{data: InvoicesBatchGenerateInvoicesBody}, TContext> => {

const mutationKey = ['invoicesBatchGenerateInvoices'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>, {data: InvoicesBatchGenerateInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesBatchGenerateInvoices(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesBatchGenerateInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>>
    export type InvoicesBatchGenerateInvoicesMutationBody = InvoicesBatchGenerateInvoicesBody
    export type InvoicesBatchGenerateInvoicesMutationError = AxiosError<unknown>

    /**
 * @summary Generate multiple invoices at once
 */
export const useInvoicesBatchGenerateInvoices = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>, TError,{data: InvoicesBatchGenerateInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesBatchGenerateInvoices>>,
        TError,
        {data: InvoicesBatchGenerateInvoicesBody},
        TContext
      > => {

      const mutationOptions = getInvoicesBatchGenerateInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Bulk upload invoices from CSV/XLSX. Returns {created, updated, errors}.
 */
export const invoicesBulkUploadInvoices = (
    invoicesBulkUploadInvoicesBody?: InvoicesBulkUploadInvoicesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/bulk_upload`,
      invoicesBulkUploadInvoicesBody,options
    );
  }



export const getInvoicesBulkUploadInvoicesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext> => {

const mutationKey = ['invoicesBulkUploadInvoices'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, {data: InvoicesBulkUploadInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesBulkUploadInvoices(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesBulkUploadInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>>
    export type InvoicesBulkUploadInvoicesMutationBody = InvoicesBulkUploadInvoicesBody
    export type InvoicesBulkUploadInvoicesMutationError = AxiosError<unknown>

    /**
 * @summary Bulk upload invoices from CSV/XLSX. Returns {created, updated, errors}.
 */
export const useInvoicesBulkUploadInvoices = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>, TError,{data: InvoicesBulkUploadInvoicesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesBulkUploadInvoices>>,
        TError,
        {data: InvoicesBulkUploadInvoicesBody},
        TContext
      > => {

      const mutationOptions = getInvoicesBulkUploadInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Add invoices to print queue
 */
export const invoicesAddToPrintQueue = (
    invoicesAddToPrintQueueBody?: InvoicesAddToPrintQueueBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/print-queue`,
      invoicesAddToPrintQueueBody,options
    );
  }



export const getInvoicesAddToPrintQueueMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext> => {

const mutationKey = ['invoicesAddToPrintQueue'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, {data: InvoicesAddToPrintQueueBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesAddToPrintQueue(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesAddToPrintQueueMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>>
    export type InvoicesAddToPrintQueueMutationBody = InvoicesAddToPrintQueueBody
    export type InvoicesAddToPrintQueueMutationError = AxiosError<unknown>

    /**
 * @summary Add invoices to print queue
 */
export const useInvoicesAddToPrintQueue = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
        TError,
        {data: InvoicesAddToPrintQueueBody},
        TContext
      > => {

      const mutationOptions = getInvoicesAddToPrintQueueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a custom invoice template
 */
export const invoicesCreateInvoiceTemplate = (
    invoicesCreateInvoiceTemplateBody?: InvoicesCreateInvoiceTemplateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/templates`,
      invoicesCreateInvoiceTemplateBody,options
    );
  }



export const getInvoicesCreateInvoiceTemplateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>, TError,{data: InvoicesCreateInvoiceTemplateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>, TError,{data: InvoicesCreateInvoiceTemplateBody}, TContext> => {

const mutationKey = ['invoicesCreateInvoiceTemplate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>, {data: InvoicesCreateInvoiceTemplateBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateInvoiceTemplate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateInvoiceTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>>
    export type InvoicesCreateInvoiceTemplateMutationBody = InvoicesCreateInvoiceTemplateBody
    export type InvoicesCreateInvoiceTemplateMutationError = AxiosError<unknown>

    /**
 * @summary Create a custom invoice template
 */
export const useInvoicesCreateInvoiceTemplate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>, TError,{data: InvoicesCreateInvoiceTemplateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateInvoiceTemplate>>,
        TError,
        {data: InvoicesCreateInvoiceTemplateBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateInvoiceTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/invoices/{invoice_id}/copy
 */
export const invoicesActionsCopyInvoice = (
    invoiceId: string,
    invoicesActionsCopyInvoiceBody?: InvoicesActionsCopyInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/copy`,
      invoicesActionsCopyInvoiceBody,options
    );
  }



export const getInvoicesActionsCopyInvoiceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceBody}, TContext> => {

const mutationKey = ['invoicesActionsCopyInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>, {invoiceId: string;data: InvoicesActionsCopyInvoiceBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesActionsCopyInvoice(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesActionsCopyInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>>
    export type InvoicesActionsCopyInvoiceMutationBody = InvoicesActionsCopyInvoiceBody
    export type InvoicesActionsCopyInvoiceMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/invoices/{invoice_id}/copy
 */
export const useInvoicesActionsCopyInvoice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesActionsCopyInvoice>>,
        TError,
        {invoiceId: string;data: InvoicesActionsCopyInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesActionsCopyInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/invoices/{invoice_id}/copy-cancel
 */
export const invoicesActionsCopyInvoiceCancel = (
    invoiceId: string,
    invoicesActionsCopyInvoiceCancelBody?: InvoicesActionsCopyInvoiceCancelBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/copy-cancel`,
      invoicesActionsCopyInvoiceCancelBody,options
    );
  }



export const getInvoicesActionsCopyInvoiceCancelMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceCancelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceCancelBody}, TContext> => {

const mutationKey = ['invoicesActionsCopyInvoiceCancel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>, {invoiceId: string;data: InvoicesActionsCopyInvoiceCancelBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesActionsCopyInvoiceCancel(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesActionsCopyInvoiceCancelMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>>
    export type InvoicesActionsCopyInvoiceCancelMutationBody = InvoicesActionsCopyInvoiceCancelBody
    export type InvoicesActionsCopyInvoiceCancelMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/invoices/{invoice_id}/copy-cancel
 */
export const useInvoicesActionsCopyInvoiceCancel = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>, TError,{invoiceId: string;data: InvoicesActionsCopyInvoiceCancelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesActionsCopyInvoiceCancel>>,
        TError,
        {invoiceId: string;data: InvoicesActionsCopyInvoiceCancelBody},
        TContext
      > => {

      const mutationOptions = getInvoicesActionsCopyInvoiceCancelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/invoices/{invoice_id}/issue
 */
export const invoicesActionsIssueInvoice = (
    invoiceId: string,
    invoicesActionsIssueInvoiceBody?: InvoicesActionsIssueInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/issue`,
      invoicesActionsIssueInvoiceBody,options
    );
  }



export const getInvoicesActionsIssueInvoiceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>, TError,{invoiceId: string;data: InvoicesActionsIssueInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>, TError,{invoiceId: string;data: InvoicesActionsIssueInvoiceBody}, TContext> => {

const mutationKey = ['invoicesActionsIssueInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>, {invoiceId: string;data: InvoicesActionsIssueInvoiceBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesActionsIssueInvoice(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesActionsIssueInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>>
    export type InvoicesActionsIssueInvoiceMutationBody = InvoicesActionsIssueInvoiceBody
    export type InvoicesActionsIssueInvoiceMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/invoices/{invoice_id}/issue
 */
export const useInvoicesActionsIssueInvoice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>, TError,{invoiceId: string;data: InvoicesActionsIssueInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesActionsIssueInvoice>>,
        TError,
        {invoiceId: string;data: InvoicesActionsIssueInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesActionsIssueInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/invoices/{invoice_id}/shipping-pdf
 */
export const invoicesActionsServeShippingPdf = (
    invoiceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/invoices/${invoiceId}/shipping-pdf`,options
    );
  }




export const getInvoicesActionsServeShippingPdfQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}/shipping-pdf`
    ] as const;
    }

    
export const getInvoicesActionsServeShippingPdfQueryOptions = <TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError = AxiosError<unknown>>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesActionsServeShippingPdfQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>> = ({ signal }) => invoicesActionsServeShippingPdf(invoiceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesActionsServeShippingPdfQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>>
export type InvoicesActionsServeShippingPdfQueryError = AxiosError<unknown>


export function useInvoicesActionsServeShippingPdf<TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError = AxiosError<unknown>>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesActionsServeShippingPdf<TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError = AxiosError<unknown>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesActionsServeShippingPdf<TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError = AxiosError<unknown>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/invoices/{invoice_id}/shipping-pdf
 */

export function useInvoicesActionsServeShippingPdf<TData = Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError = AxiosError<unknown>>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesActionsServeShippingPdf>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesActionsServeShippingPdfQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Called to check if Gƒ∞B has approved/rejected the invoice and fetch PDF if available.
 * @summary Update invoice status from Birfatura.
 */
export const invoicesUpdateInvoiceGibStatus = (
    invoiceId: string,
    invoicesUpdateInvoiceGibStatusBody?: InvoicesUpdateInvoiceGibStatusBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/update-gib-status`,
      invoicesUpdateInvoiceGibStatusBody,options
    );
  }



export const getInvoicesUpdateInvoiceGibStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>, TError,{invoiceId: string;data: InvoicesUpdateInvoiceGibStatusBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>, TError,{invoiceId: string;data: InvoicesUpdateInvoiceGibStatusBody}, TContext> => {

const mutationKey = ['invoicesUpdateInvoiceGibStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>, {invoiceId: string;data: InvoicesUpdateInvoiceGibStatusBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesUpdateInvoiceGibStatus(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesUpdateInvoiceGibStatusMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>>
    export type InvoicesUpdateInvoiceGibStatusMutationBody = InvoicesUpdateInvoiceGibStatusBody
    export type InvoicesUpdateInvoiceGibStatusMutationError = AxiosError<unknown>

    /**
 * @summary Update invoice status from Birfatura.
 */
export const useInvoicesUpdateInvoiceGibStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>, TError,{invoiceId: string;data: InvoicesUpdateInvoiceGibStatusBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesUpdateInvoiceGibStatus>>,
        TError,
        {invoiceId: string;data: InvoicesUpdateInvoiceGibStatusBody},
        TContext
      > => {

      const mutationOptions = getInvoicesUpdateInvoiceGibStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Upload an XML (e.g., from birfatura) and save it for this invoice.
 */
export const invoicesUploadInvoiceXml = (
    invoiceId: string,
    invoicesUploadInvoiceXmlBody?: InvoicesUploadInvoiceXmlBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/invoices/${invoiceId}/xml`,
      invoicesUploadInvoiceXmlBody,options
    );
  }



export const getInvoicesUploadInvoiceXmlMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>, TError,{invoiceId: string;data: InvoicesUploadInvoiceXmlBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>, TError,{invoiceId: string;data: InvoicesUploadInvoiceXmlBody}, TContext> => {

const mutationKey = ['invoicesUploadInvoiceXml'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>, {invoiceId: string;data: InvoicesUploadInvoiceXmlBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesUploadInvoiceXml(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesUploadInvoiceXmlMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>>
    export type InvoicesUploadInvoiceXmlMutationBody = InvoicesUploadInvoiceXmlBody
    export type InvoicesUploadInvoiceXmlMutationError = AxiosError<unknown>

    /**
 * @summary Upload an XML (e.g., from birfatura) and save it for this invoice.
 */
export const useInvoicesUploadInvoiceXml = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>, TError,{invoiceId: string;data: InvoicesUploadInvoiceXmlBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesUploadInvoiceXml>>,
        TError,
        {invoiceId: string;data: InvoicesUploadInvoiceXmlBody},
        TContext
      > => {

      const mutationOptions = getInvoicesUploadInvoiceXmlMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/notifications/settings
 */
export const notificationsSetUserNotificationSettings = (
    notificationsSetUserNotificationSettingsBody?: NotificationsSetUserNotificationSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/notifications/settings`,
      notificationsSetUserNotificationSettingsBody,options
    );
  }



export const getNotificationsSetUserNotificationSettingsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext> => {

const mutationKey = ['notificationsSetUserNotificationSettings'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, {data: NotificationsSetUserNotificationSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  notificationsSetUserNotificationSettings(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsSetUserNotificationSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>>
    export type NotificationsSetUserNotificationSettingsMutationBody = NotificationsSetUserNotificationSettingsBody
    export type NotificationsSetUserNotificationSettingsMutationError = AxiosError<unknown>

    /**
 * @summary PUT /api/notifications/settings
 */
export const useNotificationsSetUserNotificationSettings = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
        TError,
        {data: NotificationsSetUserNotificationSettingsBody},
        TContext
      > => {

      const mutationOptions = getNotificationsSetUserNotificationSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Request JSON: { "text": "..." }
Returns: { hf_ner: [...], spacy_entities: [...], tokens: [...] }
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const ocrDebugNer = (
    ocrDebugNerBody?: OcrDebugNerBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/debug_ner`,
      ocrDebugNerBody,options
    );
  }



export const getOcrDebugNerMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext> => {

const mutationKey = ['ocrDebugNer'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrDebugNer>>, {data: OcrDebugNerBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrDebugNer(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrDebugNerMutationResult = NonNullable<Awaited<ReturnType<typeof ocrDebugNer>>>
    export type OcrDebugNerMutationBody = OcrDebugNerBody
    export type OcrDebugNerMutationError = AxiosError<unknown>

    /**
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const useOcrDebugNer = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrDebugNer>>,
        TError,
        {data: OcrDebugNerBody},
        TContext
      > => {

      const mutationOptions = getOcrDebugNerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntitiesV2 = (
    ocrExtractEntitiesV2Body?: OcrExtractEntitiesV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/entities`,
      ocrExtractEntitiesV2Body,options
    );
  }



export const getOcrExtractEntitiesV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext> => {

const mutationKey = ['ocrExtractEntitiesV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, {data: OcrExtractEntitiesV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractEntitiesV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractEntitiesV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>>
    export type OcrExtractEntitiesV2MutationBody = OcrExtractEntitiesV2Body
    export type OcrExtractEntitiesV2MutationError = AxiosError<unknown>

    /**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntitiesV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
        TError,
        {data: OcrExtractEntitiesV2Body},
        TContext
      > => {

      const mutationOptions = getOcrExtractEntitiesV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientNameV2 = (
    ocrExtractPatientNameV2Body?: OcrExtractPatientNameV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/extract_patient`,
      ocrExtractPatientNameV2Body,options
    );
  }



export const getOcrExtractPatientNameV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext> => {

const mutationKey = ['ocrExtractPatientNameV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, {data: OcrExtractPatientNameV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractPatientNameV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractPatientNameV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>>
    export type OcrExtractPatientNameV2MutationBody = OcrExtractPatientNameV2Body
    export type OcrExtractPatientNameV2MutationError = AxiosError<unknown>

    /**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientNameV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
        TError,
        {data: OcrExtractPatientNameV2Body},
        TContext
      > => {

      const mutationOptions = getOcrExtractPatientNameV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheckApi = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/ocr/health`,options
    );
  }




export const getOcrHealthCheckApiQueryKey = () => {
    return [
    `/api/ocr/health`
    ] as const;
    }

    
export const getOcrHealthCheckApiQueryOptions = <TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOcrHealthCheckApiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheckApi>>> = ({ signal }) => ocrHealthCheckApi({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type OcrHealthCheckApiQueryResult = NonNullable<Awaited<ReturnType<typeof ocrHealthCheckApi>>>
export type OcrHealthCheckApiQueryError = AxiosError<unknown>


export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheckApi>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheckApi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheckApi>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheckApi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getOcrHealthCheckApiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initialize database and create tables
 */
export const ocrInitDatabaseV2 = (
    ocrInitDatabaseV2Body?: OcrInitDatabaseV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/init-db`,
      ocrInitDatabaseV2Body,options
    );
  }



export const getOcrInitDatabaseV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext> => {

const mutationKey = ['ocrInitDatabaseV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, {data: OcrInitDatabaseV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitDatabaseV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitDatabaseV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitDatabaseV2>>>
    export type OcrInitDatabaseV2MutationBody = OcrInitDatabaseV2Body
    export type OcrInitDatabaseV2MutationError = AxiosError<unknown>

    /**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabaseV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
        TError,
        {data: OcrInitDatabaseV2Body},
        TContext
      > => {

      const mutationOptions = getOcrInitDatabaseV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Starts model initialization in a background thread so the HTTP request
can return quickly and heavy imports/downloads happen asynchronously.
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const ocrInitializeNlpEndpointV2 = (
    ocrInitializeNlpEndpointV2Body?: OcrInitializeNlpEndpointV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/initialize`,
      ocrInitializeNlpEndpointV2Body,options
    );
  }



export const getOcrInitializeNlpEndpointV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext> => {

const mutationKey = ['ocrInitializeNlpEndpointV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, {data: OcrInitializeNlpEndpointV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitializeNlpEndpointV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitializeNlpEndpointV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>>
    export type OcrInitializeNlpEndpointV2MutationBody = OcrInitializeNlpEndpointV2Body
    export type OcrInitializeNlpEndpointV2MutationError = AxiosError<unknown>

    /**
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const useOcrInitializeNlpEndpointV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
        TError,
        {data: OcrInitializeNlpEndpointV2Body},
        TContext
      > => {

      const mutationOptions = getOcrInitializeNlpEndpointV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new OCR job
 */
export const ocrCreateJob = (
    ocrCreateJobBody?: OcrCreateJobBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/jobs`,
      ocrCreateJobBody,options
    );
  }



export const getOcrCreateJobMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext> => {

const mutationKey = ['ocrCreateJob'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCreateJob>>, {data: OcrCreateJobBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrCreateJob(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCreateJobMutationResult = NonNullable<Awaited<ReturnType<typeof ocrCreateJob>>>
    export type OcrCreateJobMutationBody = OcrCreateJobBody
    export type OcrCreateJobMutationError = AxiosError<unknown>

    /**
 * @summary Create a new OCR job
 */
export const useOcrCreateJob = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCreateJob>>,
        TError,
        {data: OcrCreateJobBody},
        TContext
      > => {

      const mutationOptions = getOcrCreateJobMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Accepts either {'image_path1':..., 'image_path2':...} or {'text1':..., 'text2':...}
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const ocrCalculateSimilarityV2 = (
    ocrCalculateSimilarityV2Body?: OcrCalculateSimilarityV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/similarity`,
      ocrCalculateSimilarityV2Body,options
    );
  }



export const getOcrCalculateSimilarityV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext> => {

const mutationKey = ['ocrCalculateSimilarityV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, {data: OcrCalculateSimilarityV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrCalculateSimilarityV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCalculateSimilarityV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>>
    export type OcrCalculateSimilarityV2MutationBody = OcrCalculateSimilarityV2Body
    export type OcrCalculateSimilarityV2MutationError = AxiosError<unknown>

    /**
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const useOcrCalculateSimilarityV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
        TError,
        {data: OcrCalculateSimilarityV2Body},
        TContext
      > => {

      const mutationOptions = getOcrCalculateSimilarityV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all invoices for a patient
 */
export const invoicesGetPatientInvoices = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/invoices`,options
    );
  }




export const getInvoicesGetPatientInvoicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/invoices`
    ] as const;
    }

    
export const getInvoicesGetPatientInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetPatientInvoicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>> = ({ signal }) => invoicesGetPatientInvoices(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetPatientInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>>
export type InvoicesGetPatientInvoicesQueryError = AxiosError<unknown>


export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all invoices for a patient
 */

export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetPatientInvoicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all payment records for a patient
 */
export const paymentsGetPatientPaymentRecords = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/payment-records`,options
    );
  }




export const getPaymentsGetPatientPaymentRecordsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/payment-records`
    ] as const;
    }

    
export const getPaymentsGetPatientPaymentRecordsQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPaymentRecordsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>> = ({ signal }) => paymentsGetPatientPaymentRecords(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPaymentRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>>
export type PaymentsGetPatientPaymentRecordsQueryError = AxiosError<unknown>


export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all payment records for a patient
 */

export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPaymentRecordsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new product sale from inventory
 */
export const salesCreateProductSale = (
    patientId: string,
    salesCreateProductSaleBody?: SalesCreateProductSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/product-sales`,
      salesCreateProductSaleBody,options
    );
  }



export const getSalesCreateProductSaleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext> => {

const mutationKey = ['salesCreateProductSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateProductSale>>, {patientId: string;data: SalesCreateProductSaleBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesCreateProductSale(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateProductSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateProductSale>>>
    export type SalesCreateProductSaleMutationBody = SalesCreateProductSaleBody
    export type SalesCreateProductSaleMutationError = AxiosError<unknown>

    /**
 * @summary Create a new product sale from inventory
 */
export const useSalesCreateProductSale = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateProductSale>>,
        TError,
        {patientId: string;data: SalesCreateProductSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateProductSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all proformas for a patient
 */
export const proformasGetPatientProformas = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/proformas`,options
    );
  }




export const getProformasGetPatientProformasQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/proformas`
    ] as const;
    }

    
export const getProformasGetPatientProformasQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetPatientProformasQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetPatientProformas>>> = ({ signal }) => proformasGetPatientProformas(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ProformasGetPatientProformasQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetPatientProformas>>>
export type ProformasGetPatientProformasQueryError = AxiosError<unknown>


export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all proformas for a patient
 */

export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getProformasGetPatientProformasQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const replacementsCreatePatientReplacement = (
    patientId: string,
    replacementsCreatePatientReplacementBody?: ReplacementsCreatePatientReplacementBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/replacements`,
      replacementsCreatePatientReplacementBody,options
    );
  }



export const getReplacementsCreatePatientReplacementMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext> => {

const mutationKey = ['replacementsCreatePatientReplacement'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, {patientId: string;data: ReplacementsCreatePatientReplacementBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  replacementsCreatePatientReplacement(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreatePatientReplacementMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>>
    export type ReplacementsCreatePatientReplacementMutationBody = ReplacementsCreatePatientReplacementBody
    export type ReplacementsCreatePatientReplacementMutationError = AxiosError<unknown>

    /**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const useReplacementsCreatePatientReplacement = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
        TError,
        {patientId: string;data: ReplacementsCreatePatientReplacementBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreatePatientReplacementMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Expected payload: { "status": "cancelled", "total_amount": 1000.0, "paid_amount": 500.0, "notes": "Updated notes" }
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const salesUpdateSalePartial = (
    patientId: string,
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/patients/${patientId}/sales/${saleId}`,undefined,options
    );
  }



export const getSalesUpdateSalePartialMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext> => {

const mutationKey = ['salesUpdateSalePartial'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSalePartial>>, {patientId: string;saleId: string}> = (props) => {
          const {patientId,saleId} = props ?? {};

          return  salesUpdateSalePartial(patientId,saleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSalePartialMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSalePartial>>>
    
    export type SalesUpdateSalePartialMutationError = AxiosError<unknown>

    /**
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const useSalesUpdateSalePartial = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSalePartial>>,
        TError,
        {patientId: string;saleId: string},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSalePartialMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new payment record
 */
export const paymentsCreatePaymentRecord = (
    paymentsCreatePaymentRecordBody?: PaymentsCreatePaymentRecordBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/payment-records`,
      paymentsCreatePaymentRecordBody,options
    );
  }



export const getPaymentsCreatePaymentRecordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext> => {

const mutationKey = ['paymentsCreatePaymentRecord'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, {data: PaymentsCreatePaymentRecordBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePaymentRecord(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePaymentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>>
    export type PaymentsCreatePaymentRecordMutationBody = PaymentsCreatePaymentRecordBody
    export type PaymentsCreatePaymentRecordMutationError = AxiosError<unknown>

    /**
 * @summary Create a new payment record
 */
export const usePaymentsCreatePaymentRecord = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
        TError,
        {data: PaymentsCreatePaymentRecordBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePaymentRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a payment record
 */
export const paymentsUpdatePaymentRecord = (
    recordId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/payment-records/${recordId}`,undefined,options
    );
  }



export const getPaymentsUpdatePaymentRecordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string}, TContext> => {

const mutationKey = ['paymentsUpdatePaymentRecord'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, {recordId: string}> = (props) => {
          const {recordId} = props ?? {};

          return  paymentsUpdatePaymentRecord(recordId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePaymentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>>
    
    export type PaymentsUpdatePaymentRecordMutationError = AxiosError<unknown>

    /**
 * @summary Update a payment record
 */
export const usePaymentsUpdatePaymentRecord = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
        TError,
        {recordId: string},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePaymentRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List all permissions grouped by category
 */
export const permissionsListPermissions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PermissionsListPermissions200>> => {
    
    
    return axios.get(
      `/api/permissions`,options
    );
  }




export const getPermissionsListPermissionsQueryKey = () => {
    return [
    `/api/permissions`
    ] as const;
    }

    
export const getPermissionsListPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsListPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsListPermissions>>> = ({ signal }) => permissionsListPermissions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsListPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsListPermissions>>>
export type PermissionsListPermissionsQueryError = AxiosError<unknown>


export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsListPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsListPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsListPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsListPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all permissions grouped by category
 */

export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsListPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/permissions
 */
export const permissionsCreatePermission = (
    permissionsCreatePermissionBody?: PermissionsCreatePermissionBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/permissions`,
      permissionsCreatePermissionBody,options
    );
  }



export const getPermissionsCreatePermissionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext> => {

const mutationKey = ['permissionsCreatePermission'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof permissionsCreatePermission>>, {data: PermissionsCreatePermissionBody}> = (props) => {
          const {data} = props ?? {};

          return  permissionsCreatePermission(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PermissionsCreatePermissionMutationResult = NonNullable<Awaited<ReturnType<typeof permissionsCreatePermission>>>
    export type PermissionsCreatePermissionMutationBody = PermissionsCreatePermissionBody
    export type PermissionsCreatePermissionMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/permissions
 */
export const usePermissionsCreatePermission = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof permissionsCreatePermission>>,
        TError,
        {data: PermissionsCreatePermissionBody},
        TContext
      > => {

      const mutationOptions = getPermissionsCreatePermissionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current user's permissions based on their role
 */
export const permissionsGetMyPermissions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/permissions/my`,options
    );
  }




export const getPermissionsGetMyPermissionsQueryKey = () => {
    return [
    `/api/permissions/my`
    ] as const;
    }

    
export const getPermissionsGetMyPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsGetMyPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsGetMyPermissions>>> = ({ signal }) => permissionsGetMyPermissions({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsGetMyPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsGetMyPermissions>>>
export type PermissionsGetMyPermissionsQueryError = AxiosError<unknown>


export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current user's permissions based on their role
 */

export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsGetMyPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get permissions for a specific role
 */
export const permissionsGetRolePermissions = (
    roleName: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PermissionsGetRolePermissions200>> => {
    
    
    return axios.get(
      `/api/permissions/role/${roleName}`,options
    );
  }




export const getPermissionsGetRolePermissionsQueryKey = (roleName?: string,) => {
    return [
    `/api/permissions/role/${roleName}`
    ] as const;
    }

    
export const getPermissionsGetRolePermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = AxiosError<unknown>>(roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsGetRolePermissionsQueryKey(roleName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsGetRolePermissions>>> = ({ signal }) => permissionsGetRolePermissions(roleName, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(roleName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsGetRolePermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsGetRolePermissions>>>
export type PermissionsGetRolePermissionsQueryError = AxiosError<unknown>


export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = AxiosError<unknown>>(
 roleName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = AxiosError<unknown>>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = AxiosError<unknown>>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get permissions for a specific role
 */

export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = AxiosError<unknown>>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsGetRolePermissionsQueryOptions(roleName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update permissions for a role (bulk update)
 */
export const permissionsUpdateRolePermissions = (
    roleName: string,
    permissionsUpdateRolePermissionsBody?: PermissionsUpdateRolePermissionsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/permissions/role/${roleName}`,
      permissionsUpdateRolePermissionsBody,options
    );
  }



export const getPermissionsUpdateRolePermissionsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext> => {

const mutationKey = ['permissionsUpdateRolePermissions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, {roleName: string;data: PermissionsUpdateRolePermissionsBody}> = (props) => {
          const {roleName,data} = props ?? {};

          return  permissionsUpdateRolePermissions(roleName,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PermissionsUpdateRolePermissionsMutationResult = NonNullable<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>>
    export type PermissionsUpdateRolePermissionsMutationBody = PermissionsUpdateRolePermissionsBody
    export type PermissionsUpdateRolePermissionsMutationError = AxiosError<unknown>

    /**
 * @summary Update permissions for a role (bulk update)
 */
export const usePermissionsUpdateRolePermissions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
        TError,
        {roleName: string;data: PermissionsUpdateRolePermissionsBody},
        TContext
      > => {

      const mutationOptions = getPermissionsUpdateRolePermissionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new plan (Super Admin only)
 */
export const plansCreatePlan = (
    plansCreatePlanBody?: PlansCreatePlanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/plans`,
      plansCreatePlanBody,options
    );
  }



export const getPlansCreatePlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof plansCreatePlan>>, TError,{data: PlansCreatePlanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof plansCreatePlan>>, TError,{data: PlansCreatePlanBody}, TContext> => {

const mutationKey = ['plansCreatePlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof plansCreatePlan>>, {data: PlansCreatePlanBody}> = (props) => {
          const {data} = props ?? {};

          return  plansCreatePlan(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PlansCreatePlanMutationResult = NonNullable<Awaited<ReturnType<typeof plansCreatePlan>>>
    export type PlansCreatePlanMutationBody = PlansCreatePlanBody
    export type PlansCreatePlanMutationError = AxiosError<unknown>

    /**
 * @summary Create a new plan (Super Admin only)
 */
export const usePlansCreatePlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof plansCreatePlan>>, TError,{data: PlansCreatePlanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof plansCreatePlan>>,
        TError,
        {data: PlansCreatePlanBody},
        TContext
      > => {

      const mutationOptions = getPlansCreatePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all plans for admin (including inactive/private)
 */
export const plansGetAdminPlans = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/plans/admin`,options
    );
  }




export const getPlansGetAdminPlansQueryKey = () => {
    return [
    `/api/plans/admin`
    ] as const;
    }

    
export const getPlansGetAdminPlansQueryOptions = <TData = Awaited<ReturnType<typeof plansGetAdminPlans>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPlansGetAdminPlansQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof plansGetAdminPlans>>> = ({ signal }) => plansGetAdminPlans({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PlansGetAdminPlansQueryResult = NonNullable<Awaited<ReturnType<typeof plansGetAdminPlans>>>
export type PlansGetAdminPlansQueryError = AxiosError<unknown>


export function usePlansGetAdminPlans<TData = Awaited<ReturnType<typeof plansGetAdminPlans>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof plansGetAdminPlans>>,
          TError,
          Awaited<ReturnType<typeof plansGetAdminPlans>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePlansGetAdminPlans<TData = Awaited<ReturnType<typeof plansGetAdminPlans>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof plansGetAdminPlans>>,
          TError,
          Awaited<ReturnType<typeof plansGetAdminPlans>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePlansGetAdminPlans<TData = Awaited<ReturnType<typeof plansGetAdminPlans>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all plans for admin (including inactive/private)
 */

export function usePlansGetAdminPlans<TData = Awaited<ReturnType<typeof plansGetAdminPlans>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof plansGetAdminPlans>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPlansGetAdminPlansQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update a plan (Super Admin only)
 */
export const plansUpdatePlan = (
    planId: string,
    plansUpdatePlanBody?: PlansUpdatePlanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/plans/${planId}`,
      plansUpdatePlanBody,options
    );
  }



export const getPlansUpdatePlanMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof plansUpdatePlan>>, TError,{planId: string;data: PlansUpdatePlanBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof plansUpdatePlan>>, TError,{planId: string;data: PlansUpdatePlanBody}, TContext> => {

const mutationKey = ['plansUpdatePlan'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof plansUpdatePlan>>, {planId: string;data: PlansUpdatePlanBody}> = (props) => {
          const {planId,data} = props ?? {};

          return  plansUpdatePlan(planId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PlansUpdatePlanMutationResult = NonNullable<Awaited<ReturnType<typeof plansUpdatePlan>>>
    export type PlansUpdatePlanMutationBody = PlansUpdatePlanBody
    export type PlansUpdatePlanMutationError = AxiosError<unknown>

    /**
 * @summary Update a plan (Super Admin only)
 */
export const usePlansUpdatePlan = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof plansUpdatePlan>>, TError,{planId: string;data: PlansUpdatePlanBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof plansUpdatePlan>>,
        TError,
        {planId: string;data: PlansUpdatePlanBody},
        TContext
      > => {

      const mutationOptions = getPlansUpdatePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new proforma
 */
export const proformasCreateProforma = (
    proformasCreateProformaBody?: ProformasCreateProformaBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/proformas`,
      proformasCreateProformaBody,options
    );
  }



export const getProformasCreateProformaMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext> => {

const mutationKey = ['proformasCreateProforma'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proformasCreateProforma>>, {data: ProformasCreateProformaBody}> = (props) => {
          const {data} = props ?? {};

          return  proformasCreateProforma(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProformasCreateProformaMutationResult = NonNullable<Awaited<ReturnType<typeof proformasCreateProforma>>>
    export type ProformasCreateProformaMutationBody = ProformasCreateProformaBody
    export type ProformasCreateProformaMutationError = AxiosError<unknown>

    /**
 * @summary Create a new proforma
 */
export const useProformasCreateProforma = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof proformasCreateProforma>>,
        TError,
        {data: ProformasCreateProformaBody},
        TContext
      > => {

      const mutationOptions = getProformasCreateProformaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific proforma
 */
export const proformasGetProforma = (
    proformaId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/proformas/${proformaId}`,options
    );
  }




export const getProformasGetProformaQueryKey = (proformaId?: string,) => {
    return [
    `/api/proformas/${proformaId}`
    ] as const;
    }

    
export const getProformasGetProformaQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = AxiosError<unknown>>(proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetProformaQueryKey(proformaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetProforma>>> = ({ signal }) => proformasGetProforma(proformaId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(proformaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ProformasGetProformaQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetProforma>>>
export type ProformasGetProformaQueryError = AxiosError<unknown>


export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = AxiosError<unknown>>(
 proformaId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetProforma>>,
          TError,
          Awaited<ReturnType<typeof proformasGetProforma>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = AxiosError<unknown>>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetProforma>>,
          TError,
          Awaited<ReturnType<typeof proformasGetProforma>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = AxiosError<unknown>>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific proforma
 */

export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = AxiosError<unknown>>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getProformasGetProformaQueryOptions(proformaId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const proformasConvertProformaToSale = (
    proformaId: string,
    proformasConvertProformaToSaleBody?: ProformasConvertProformaToSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/proformas/${proformaId}/convert`,
      proformasConvertProformaToSaleBody,options
    );
  }



export const getProformasConvertProformaToSaleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext> => {

const mutationKey = ['proformasConvertProformaToSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, {proformaId: string;data: ProformasConvertProformaToSaleBody}> = (props) => {
          const {proformaId,data} = props ?? {};

          return  proformasConvertProformaToSale(proformaId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProformasConvertProformaToSaleMutationResult = NonNullable<Awaited<ReturnType<typeof proformasConvertProformaToSale>>>
    export type ProformasConvertProformaToSaleMutationBody = ProformasConvertProformaToSaleBody
    export type ProformasConvertProformaToSaleMutationError = AxiosError<unknown>

    /**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const useProformasConvertProformaToSale = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
        TError,
        {proformaId: string;data: ProformasConvertProformaToSaleBody},
        TContext
      > => {

      const mutationOptions = getProformasConvertProformaToSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/replacements/{replacement_id}
 */
export const replacementsGetReplacement = (
    replacementId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/replacements/${replacementId}`,options
    );
  }




export const getReplacementsGetReplacementQueryKey = (replacementId?: string,) => {
    return [
    `/api/replacements/${replacementId}`
    ] as const;
    }

    
export const getReplacementsGetReplacementQueryOptions = <TData = Awaited<ReturnType<typeof replacementsGetReplacement>>, TError = AxiosError<unknown>>(replacementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReplacementsGetReplacementQueryKey(replacementId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof replacementsGetReplacement>>> = ({ signal }) => replacementsGetReplacement(replacementId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(replacementId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReplacementsGetReplacementQueryResult = NonNullable<Awaited<ReturnType<typeof replacementsGetReplacement>>>
export type ReplacementsGetReplacementQueryError = AxiosError<unknown>


export function useReplacementsGetReplacement<TData = Awaited<ReturnType<typeof replacementsGetReplacement>>, TError = AxiosError<unknown>>(
 replacementId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof replacementsGetReplacement>>,
          TError,
          Awaited<ReturnType<typeof replacementsGetReplacement>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReplacementsGetReplacement<TData = Awaited<ReturnType<typeof replacementsGetReplacement>>, TError = AxiosError<unknown>>(
 replacementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof replacementsGetReplacement>>,
          TError,
          Awaited<ReturnType<typeof replacementsGetReplacement>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReplacementsGetReplacement<TData = Awaited<ReturnType<typeof replacementsGetReplacement>>, TError = AxiosError<unknown>>(
 replacementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/replacements/{replacement_id}
 */

export function useReplacementsGetReplacement<TData = Awaited<ReturnType<typeof replacementsGetReplacement>>, TError = AxiosError<unknown>>(
 replacementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetReplacement>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReplacementsGetReplacementQueryOptions(replacementId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This implementation stores invoice metadata on the Replacement row (legacy-compatible).
 * @summary Create a supplier return invoice record linked to a replacement.
 */
export const replacementsCreateReturnInvoice = (
    replacementId: string,
    replacementsCreateReturnInvoiceBody?: ReplacementsCreateReturnInvoiceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/replacements/${replacementId}/invoice`,
      replacementsCreateReturnInvoiceBody,options
    );
  }



export const getReplacementsCreateReturnInvoiceMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext> => {

const mutationKey = ['replacementsCreateReturnInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, {replacementId: string;data: ReplacementsCreateReturnInvoiceBody}> = (props) => {
          const {replacementId,data} = props ?? {};

          return  replacementsCreateReturnInvoice(replacementId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreateReturnInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>>
    export type ReplacementsCreateReturnInvoiceMutationBody = ReplacementsCreateReturnInvoiceBody
    export type ReplacementsCreateReturnInvoiceMutationError = AxiosError<unknown>

    /**
 * @summary Create a supplier return invoice record linked to a replacement.
 */
export const useReplacementsCreateReturnInvoice = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
        TError,
        {replacementId: string;data: ReplacementsCreateReturnInvoiceBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreateReturnInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PATCH /api/replacements/{replacement_id}/status
 */
export const replacementsPatchReplacementStatus = (
    replacementId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/replacements/${replacementId}/status`,undefined,options
    );
  }



export const getReplacementsPatchReplacementStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>, TError,{replacementId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>, TError,{replacementId: string}, TContext> => {

const mutationKey = ['replacementsPatchReplacementStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>, {replacementId: string}> = (props) => {
          const {replacementId} = props ?? {};

          return  replacementsPatchReplacementStatus(replacementId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsPatchReplacementStatusMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>>
    
    export type ReplacementsPatchReplacementStatusMutationError = AxiosError<unknown>

    /**
 * @summary PATCH /api/replacements/{replacement_id}/status
 */
export const useReplacementsPatchReplacementStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>, TError,{replacementId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsPatchReplacementStatus>>,
        TError,
        {replacementId: string},
        TContext
      > => {

      const mutationOptions = getReplacementsPatchReplacementStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Kasa √∂zeti raporu - tahsilatlar (Sales tabanlƒ±)
 */
export const reportsReportCashflowSummary = (
    params?: ReportsReportCashflowSummaryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/cashflow-summary`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportsReportCashflowSummaryQueryKey = (params?: ReportsReportCashflowSummaryParams,) => {
    return [
    `/api/reports/cashflow-summary`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportsReportCashflowSummaryQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError = AxiosError<unknown>>(params?: ReportsReportCashflowSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportCashflowSummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportCashflowSummary>>> = ({ signal }) => reportsReportCashflowSummary(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportCashflowSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportCashflowSummary>>>
export type ReportsReportCashflowSummaryQueryError = AxiosError<unknown>


export function useReportsReportCashflowSummary<TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportsReportCashflowSummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCashflowSummary>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCashflowSummary<TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError = AxiosError<unknown>>(
 params?: ReportsReportCashflowSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCashflowSummary>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCashflowSummary>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCashflowSummary<TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError = AxiosError<unknown>>(
 params?: ReportsReportCashflowSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Kasa √∂zeti raporu - tahsilatlar (Sales tabanlƒ±)
 */

export function useReportsReportCashflowSummary<TData = Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError = AxiosError<unknown>>(
 params?: ReportsReportCashflowSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCashflowSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportCashflowSummaryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Senet raporlarƒ± - aylƒ±k sayƒ±, gelir ve √∂zet
 */
export const reportsReportPromissoryNotes = (
    params?: ReportsReportPromissoryNotesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/promissory-notes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportsReportPromissoryNotesQueryKey = (params?: ReportsReportPromissoryNotesParams,) => {
    return [
    `/api/reports/promissory-notes`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportsReportPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError = AxiosError<unknown>>(params?: ReportsReportPromissoryNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPromissoryNotesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>> = ({ signal }) => reportsReportPromissoryNotes(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>>
export type ReportsReportPromissoryNotesQueryError = AxiosError<unknown>


export function useReportsReportPromissoryNotes<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportsReportPromissoryNotesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotes<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotes<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Senet raporlarƒ± - aylƒ±k sayƒ±, gelir ve √∂zet
 */

export function useReportsReportPromissoryNotes<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPromissoryNotesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Hasta bazlƒ± senet √∂zeti - hangi hastanƒ±n ka√ß senedi kalmƒ±≈ü
 */
export const reportsReportPromissoryNotesByPatient = (
    params?: ReportsReportPromissoryNotesByPatientParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/promissory-notes/by-patient`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportsReportPromissoryNotesByPatientQueryKey = (params?: ReportsReportPromissoryNotesByPatientParams,) => {
    return [
    `/api/reports/promissory-notes/by-patient`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportsReportPromissoryNotesByPatientQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError = AxiosError<unknown>>(params?: ReportsReportPromissoryNotesByPatientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPromissoryNotesByPatientQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>> = ({ signal }) => reportsReportPromissoryNotesByPatient(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPromissoryNotesByPatientQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>>
export type ReportsReportPromissoryNotesByPatientQueryError = AxiosError<unknown>


export function useReportsReportPromissoryNotesByPatient<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportsReportPromissoryNotesByPatientParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotesByPatient<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesByPatientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotesByPatient<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesByPatientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Hasta bazlƒ± senet √∂zeti - hangi hastanƒ±n ka√ß senedi kalmƒ±≈ü
 */

export function useReportsReportPromissoryNotesByPatient<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesByPatientParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesByPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPromissoryNotesByPatientQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Toplu senet listesi - modal i√ßin
 */
export const reportsReportPromissoryNotesList = (
    params?: ReportsReportPromissoryNotesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/promissory-notes/list`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportsReportPromissoryNotesListQueryKey = (params?: ReportsReportPromissoryNotesListParams,) => {
    return [
    `/api/reports/promissory-notes/list`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportsReportPromissoryNotesListQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError = AxiosError<unknown>>(params?: ReportsReportPromissoryNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPromissoryNotesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>> = ({ signal }) => reportsReportPromissoryNotesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPromissoryNotesListQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>>
export type ReportsReportPromissoryNotesListQueryError = AxiosError<unknown>


export function useReportsReportPromissoryNotesList<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportsReportPromissoryNotesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotesList<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPromissoryNotesList<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Toplu senet listesi - modal i√ßin
 */

export function useReportsReportPromissoryNotesList<TData = Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError = AxiosError<unknown>>(
 params?: ReportsReportPromissoryNotesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPromissoryNotesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPromissoryNotesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Kalan √∂demeler raporu - hangi hastanƒ±n ne kadar √∂demesi kalmƒ±≈ü
 */
export const reportsReportRemainingPayments = (
    params?: ReportsReportRemainingPaymentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/reports/remaining-payments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportsReportRemainingPaymentsQueryKey = (params?: ReportsReportRemainingPaymentsParams,) => {
    return [
    `/api/reports/remaining-payments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportsReportRemainingPaymentsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError = AxiosError<unknown>>(params?: ReportsReportRemainingPaymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportRemainingPaymentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportRemainingPayments>>> = ({ signal }) => reportsReportRemainingPayments(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportRemainingPaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportRemainingPayments>>>
export type ReportsReportRemainingPaymentsQueryError = AxiosError<unknown>


export function useReportsReportRemainingPayments<TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportsReportRemainingPaymentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRemainingPayments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRemainingPayments<TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError = AxiosError<unknown>>(
 params?: ReportsReportRemainingPaymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRemainingPayments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRemainingPayments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRemainingPayments<TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError = AxiosError<unknown>>(
 params?: ReportsReportRemainingPaymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Kalan √∂demeler raporu - hangi hastanƒ±n ne kadar √∂demesi kalmƒ±≈ü
 */

export function useReportsReportRemainingPayments<TData = Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError = AxiosError<unknown>>(
 params?: ReportsReportRemainingPaymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRemainingPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportRemainingPaymentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Here we mark gib_sent and update replacement status. Actual EFatura/Gƒ∞B integration should be added server-side.
 * @summary Mark return invoice as sent to GIB. In legacy flow Gƒ∞B send triggers replacement completion and stock effects.
 */
export const replacementsSendInvoiceToGib = (
    invoiceId: string,
    replacementsSendInvoiceToGibBody?: ReplacementsSendInvoiceToGibBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/return-invoices/${invoiceId}/send-to-gib`,
      replacementsSendInvoiceToGibBody,options
    );
  }



export const getReplacementsSendInvoiceToGibMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext> => {

const mutationKey = ['replacementsSendInvoiceToGib'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, {invoiceId: string;data: ReplacementsSendInvoiceToGibBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  replacementsSendInvoiceToGib(invoiceId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsSendInvoiceToGibMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>>
    export type ReplacementsSendInvoiceToGibMutationBody = ReplacementsSendInvoiceToGibBody
    export type ReplacementsSendInvoiceToGibMutationError = AxiosError<unknown>

    /**
 * @summary Mark return invoice as sent to GIB. In legacy flow Gƒ∞B send triggers replacement completion and stock effects.
 */
export const useReplacementsSendInvoiceToGib = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
        TError,
        {invoiceId: string;data: ReplacementsSendInvoiceToGibBody},
        TContext
      > => {

      const mutationOptions = getReplacementsSendInvoiceToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/roles
 */
export const rolesCreateRole = (
    rolesCreateRoleBody?: RolesCreateRoleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/roles`,
      rolesCreateRoleBody,options
    );
  }



export const getRolesCreateRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext> => {

const mutationKey = ['rolesCreateRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesCreateRole>>, {data: RolesCreateRoleBody}> = (props) => {
          const {data} = props ?? {};

          return  rolesCreateRole(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesCreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesCreateRole>>>
    export type RolesCreateRoleMutationBody = RolesCreateRoleBody
    export type RolesCreateRoleMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/roles
 */
export const useRolesCreateRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesCreateRole>>,
        TError,
        {data: RolesCreateRoleBody},
        TContext
      > => {

      const mutationOptions = getRolesCreateRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/roles/{role_id}
 */
export const rolesDeleteRole = (
    roleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/roles/${roleId}`,options
    );
  }



export const getRolesDeleteRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesDeleteRole>>, TError,{roleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rolesDeleteRole>>, TError,{roleId: string}, TContext> => {

const mutationKey = ['rolesDeleteRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesDeleteRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  rolesDeleteRole(roleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesDeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesDeleteRole>>>
    
    export type RolesDeleteRoleMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/roles/{role_id}
 */
export const useRolesDeleteRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesDeleteRole>>, TError,{roleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesDeleteRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getRolesDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const rolesAddPermissionToRole = (
    roleId: string,
    rolesAddPermissionToRoleBody?: RolesAddPermissionToRoleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/roles/${roleId}/permissions`,
      rolesAddPermissionToRoleBody,options
    );
  }



export const getRolesAddPermissionToRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext> => {

const mutationKey = ['rolesAddPermissionToRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, {roleId: string;data: RolesAddPermissionToRoleBody}> = (props) => {
          const {roleId,data} = props ?? {};

          return  rolesAddPermissionToRole(roleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesAddPermissionToRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesAddPermissionToRole>>>
    export type RolesAddPermissionToRoleMutationBody = RolesAddPermissionToRoleBody
    export type RolesAddPermissionToRoleMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const useRolesAddPermissionToRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
        TError,
        {roleId: string;data: RolesAddPermissionToRoleBody},
        TContext
      > => {

      const mutationOptions = getRolesAddPermissionToRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const rolesRemovePermissionFromRole = (
    roleId: string,
    permissionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/roles/${roleId}/permissions/${permissionId}`,options
    );
  }



export const getRolesRemovePermissionFromRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext> => {

const mutationKey = ['rolesRemovePermissionFromRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, {roleId: string;permissionId: string}> = (props) => {
          const {roleId,permissionId} = props ?? {};

          return  rolesRemovePermissionFromRole(roleId,permissionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesRemovePermissionFromRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>>
    
    export type RolesRemovePermissionFromRoleMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const useRolesRemovePermissionFromRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
        TError,
        {roleId: string;permissionId: string},
        TContext
      > => {

      const mutationOptions = getRolesRemovePermissionFromRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a sales log entry for cashflow.html page
 */
export const salesCreateSalesLog = (
    salesCreateSalesLogBody?: SalesCreateSalesLogBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sales/logs`,
      salesCreateSalesLogBody,options
    );
  }



export const getSalesCreateSalesLogMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext> => {

const mutationKey = ['salesCreateSalesLog'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalesLog>>, {data: SalesCreateSalesLogBody}> = (props) => {
          const {data} = props ?? {};

          return  salesCreateSalesLog(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalesLogMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalesLog>>>
    export type SalesCreateSalesLogMutationBody = SalesCreateSalesLogBody
    export type SalesCreateSalesLogMutationError = AxiosError<unknown>

    /**
 * @summary Create a sales log entry for cashflow.html page
 */
export const useSalesCreateSalesLog = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalesLog>>,
        TError,
        {data: SalesCreateSalesLogBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalesLogMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ƒ∞steƒüe baƒülƒ± filtreler: body veya query i√ßinde `patientId`, `saleId`, `limit`.
 * @summary Satƒ±≈ü kayƒ±tlarƒ±nƒ±n SGK ve hasta √∂deme tutarlarƒ±nƒ± yeniden hesaplarken kalƒ±cƒ± olarak g√ºnceller.
 */
export const salesRecalcSales = (
    salesRecalcSalesBody?: SalesRecalcSalesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sales/recalc`,
      salesRecalcSalesBody,options
    );
  }



export const getSalesRecalcSalesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext> => {

const mutationKey = ['salesRecalcSales'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesRecalcSales>>, {data: SalesRecalcSalesBody}> = (props) => {
          const {data} = props ?? {};

          return  salesRecalcSales(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesRecalcSalesMutationResult = NonNullable<Awaited<ReturnType<typeof salesRecalcSales>>>
    export type SalesRecalcSalesMutationBody = SalesRecalcSalesBody
    export type SalesRecalcSalesMutationError = AxiosError<unknown>

    /**
 * @summary Satƒ±≈ü kayƒ±tlarƒ±nƒ±n SGK ve hasta √∂deme tutarlarƒ±nƒ± yeniden hesaplarken kalƒ±cƒ± olarak g√ºnceller.
 */
export const useSalesRecalcSales = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesRecalcSales>>,
        TError,
        {data: SalesRecalcSalesBody},
        TContext
      > => {

      const mutationOptions = getSalesRecalcSalesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Pay a specific installment
 */
export const salesPayInstallment = (
    saleId: string,
    installmentId: string,
    salesPayInstallmentBody?: SalesPayInstallmentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/installments/${installmentId}/pay`,
      salesPayInstallmentBody,options
    );
  }



export const getSalesPayInstallmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext> => {

const mutationKey = ['salesPayInstallment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesPayInstallment>>, {saleId: string;installmentId: string;data: SalesPayInstallmentBody}> = (props) => {
          const {saleId,installmentId,data} = props ?? {};

          return  salesPayInstallment(saleId,installmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesPayInstallmentMutationResult = NonNullable<Awaited<ReturnType<typeof salesPayInstallment>>>
    export type SalesPayInstallmentMutationBody = SalesPayInstallmentBody
    export type SalesPayInstallmentMutationError = AxiosError<unknown>

    /**
 * @summary Pay a specific installment
 */
export const useSalesPayInstallment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesPayInstallment>>,
        TError,
        {saleId: string;installmentId: string;data: SalesPayInstallmentBody},
        TContext
      > => {

      const mutationOptions = getSalesPayInstallmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Record a new payment for a sale
 */
export const salesRecordSalePayment = (
    saleId: string,
    salesRecordSalePaymentBody?: SalesRecordSalePaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sales/${saleId}/payments`,
      salesRecordSalePaymentBody,options
    );
  }



export const getSalesRecordSalePaymentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecordSalePayment>>, TError,{saleId: string;data: SalesRecordSalePaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesRecordSalePayment>>, TError,{saleId: string;data: SalesRecordSalePaymentBody}, TContext> => {

const mutationKey = ['salesRecordSalePayment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesRecordSalePayment>>, {saleId: string;data: SalesRecordSalePaymentBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesRecordSalePayment(saleId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesRecordSalePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof salesRecordSalePayment>>>
    export type SalesRecordSalePaymentMutationBody = SalesRecordSalePaymentBody
    export type SalesRecordSalePaymentMutationError = AxiosError<unknown>

    /**
 * @summary Record a new payment for a sale
 */
export const useSalesRecordSalePayment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecordSalePayment>>, TError,{saleId: string;data: SalesRecordSalePaymentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesRecordSalePayment>>,
        TError,
        {saleId: string;data: SalesRecordSalePaymentBody},
        TContext
      > => {

      const mutationOptions = getSalesRecordSalePaymentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get pricing settings specifically
 */
export const getPricingSettings = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/settings/pricing`,options
    );
  }




export const getGetPricingSettingsQueryKey = () => {
    return [
    `/api/settings/pricing`
    ] as const;
    }

    
export const getGetPricingSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPricingSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPricingSettings>>> = ({ signal }) => getPricingSettings({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPricingSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getPricingSettings>>>
export type GetPricingSettingsQueryError = AxiosError<unknown>


export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPricingSettings>>,
          TError,
          Awaited<ReturnType<typeof getPricingSettings>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPricingSettings>>,
          TError,
          Awaited<ReturnType<typeof getPricingSettings>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get pricing settings specifically
 */

export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPricingSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const sgkQueryEReceipt = (
    sgkQueryEReceiptBody?: SgkQueryEReceiptBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/e-receipt/query`,
      sgkQueryEReceiptBody,options
    );
  }



export const getSgkQueryEReceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext> => {

const mutationKey = ['sgkQueryEReceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryEReceipt>>, {data: SgkQueryEReceiptBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryEReceipt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryEReceipt>>>
    export type SgkQueryEReceiptMutationBody = SgkQueryEReceiptBody
    export type SgkQueryEReceiptMutationError = AxiosError<unknown>

    /**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const useSgkQueryEReceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryEReceipt>>,
        TError,
        {data: SgkQueryEReceiptBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const sgkQueryPatientRights = (
    sgkQueryPatientRightsBody?: SgkQueryPatientRightsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/patient-rights/query`,
      sgkQueryPatientRightsBody,options
    );
  }



export const getSgkQueryPatientRightsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext> => {

const mutationKey = ['sgkQueryPatientRights'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryPatientRights>>, {data: SgkQueryPatientRightsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryPatientRights(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryPatientRightsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryPatientRights>>>
    export type SgkQueryPatientRightsMutationBody = SgkQueryPatientRightsBody
    export type SgkQueryPatientRightsMutationError = AxiosError<unknown>

    /**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const useSgkQueryPatientRights = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryPatientRights>>,
        TError,
        {data: SgkQueryPatientRightsBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryPatientRightsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const sgkSeedTestPatients = (
    sgkSeedTestPatientsBody?: SgkSeedTestPatientsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/seed-test-patients`,
      sgkSeedTestPatientsBody,options
    );
  }



export const getSgkSeedTestPatientsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext> => {

const mutationKey = ['sgkSeedTestPatients'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkSeedTestPatients>>, {data: SgkSeedTestPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkSeedTestPatients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkSeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkSeedTestPatients>>>
    export type SgkSeedTestPatientsMutationBody = SgkSeedTestPatientsBody
    export type SgkSeedTestPatientsMutationError = AxiosError<unknown>

    /**
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const useSgkSeedTestPatients = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkSeedTestPatients>>,
        TError,
        {data: SgkSeedTestPatientsBody},
        TContext
      > => {

      const mutationOptions = getSgkSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Saves files to a secure temporary path, runs OCR (worker-first) with auto_crop=True
and returns per-file OCR results including patient_info.
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const sgkUploadAndProcessFiles = (
    sgkUploadAndProcessFilesBody?: SgkUploadAndProcessFilesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/upload`,
      sgkUploadAndProcessFilesBody,options
    );
  }



export const getSgkUploadAndProcessFilesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext> => {

const mutationKey = ['sgkUploadAndProcessFiles'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, {data: SgkUploadAndProcessFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadAndProcessFiles(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadAndProcessFilesMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>>
    export type SgkUploadAndProcessFilesMutationBody = SgkUploadAndProcessFilesBody
    export type SgkUploadAndProcessFilesMutationError = AxiosError<unknown>

    /**
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const useSgkUploadAndProcessFiles = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
        TError,
        {data: SgkUploadAndProcessFilesBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadAndProcessFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const sgkCreateSgkWorkflow = (
    sgkCreateSgkWorkflowBody?: SgkCreateSgkWorkflowBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/workflow/create`,
      sgkCreateSgkWorkflowBody,options
    );
  }



export const getSgkCreateSgkWorkflowMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkCreateSgkWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, {data: SgkCreateSgkWorkflowBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkCreateSgkWorkflow(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkCreateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>>
    export type SgkCreateSgkWorkflowMutationBody = SgkCreateSgkWorkflowBody
    export type SgkCreateSgkWorkflowMutationError = AxiosError<unknown>

    /**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const useSgkCreateSgkWorkflow = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
        TError,
        {data: SgkCreateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkCreateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */
export const sgkGetSgkWorkflow = (
    workflowId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sgk/workflow/${workflowId}`,options
    );
  }




export const getSgkGetSgkWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/sgk/workflow/${workflowId}`
    ] as const;
    }

    
export const getSgkGetSgkWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetSgkWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>> = ({ signal }) => sgkGetSgkWorkflow(workflowId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetSgkWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>>
export type SgkGetSgkWorkflowQueryError = AxiosError<unknown>


export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */

export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetSgkWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const sgkUpdateSgkWorkflow = (
    workflowId: string,
    sgkUpdateSgkWorkflowBody?: SgkUpdateSgkWorkflowBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/sgk/workflow/${workflowId}/update`,
      sgkUpdateSgkWorkflowBody,options
    );
  }



export const getSgkUpdateSgkWorkflowMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkUpdateSgkWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, {workflowId: string;data: SgkUpdateSgkWorkflowBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  sgkUpdateSgkWorkflow(workflowId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUpdateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>>
    export type SgkUpdateSgkWorkflowMutationBody = SgkUpdateSgkWorkflowBody
    export type SgkUpdateSgkWorkflowMutationError = AxiosError<unknown>

    /**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const useSgkUpdateSgkWorkflow = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
        TError,
        {workflowId: string;data: SgkUpdateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkUpdateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Upload SMS Document to S3
 */
export const smsUploadDocumentV2 = (
    smsUploadDocumentV2Body: SmsUploadDocumentV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SmsUploadDocumentV2200>> => {
    
    const formData = new FormData();
formData.append(`file`, smsUploadDocumentV2Body.file)
formData.append(`documentType`, smsUploadDocumentV2Body.documentType)

    return axios.post(
      `/api/sms/documents/upload`,
      formData,options
    );
  }



export const getSmsUploadDocumentV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext> => {

const mutationKey = ['smsUploadDocumentV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadDocumentV2>>, {data: SmsUploadDocumentV2Body}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadDocumentV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadDocumentV2MutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadDocumentV2>>>
    export type SmsUploadDocumentV2MutationBody = SmsUploadDocumentV2Body
    export type SmsUploadDocumentV2MutationError = AxiosError<unknown>

    /**
 * @summary Upload SMS Document to S3
 */
export const useSmsUploadDocumentV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocumentV2>>, TError,{data: SmsUploadDocumentV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadDocumentV2>>,
        TError,
        {data: SmsUploadDocumentV2Body},
        TContext
      > => {

      const mutationOptions = getSmsUploadDocumentV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete an uploaded document
 */
export const smsIntegrationDeleteSmsDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sms/documents/${documentType}`,options
    );
  }



export const getSmsIntegrationDeleteSmsDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsIntegrationDeleteSmsDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsIntegrationDeleteSmsDocument(documentType,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsIntegrationDeleteSmsDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>>
    
    export type SmsIntegrationDeleteSmsDocumentMutationError = AxiosError<unknown>

    /**
 * @summary Delete an uploaded document
 */
export const useSmsIntegrationDeleteSmsDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>, TError,{documentType: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsIntegrationDeleteSmsDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsIntegrationDeleteSmsDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Generate presigned URL for document download
 */
export const smsIntegrationDownloadSmsDocument = (
    documentType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sms/documents/${documentType}/download`,options
    );
  }




export const getSmsIntegrationDownloadSmsDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsIntegrationDownloadSmsDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsIntegrationDownloadSmsDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>> = ({ signal }) => smsIntegrationDownloadSmsDocument(documentType, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsIntegrationDownloadSmsDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>>
export type SmsIntegrationDownloadSmsDocumentQueryError = AxiosError<unknown>


export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>,
          TError,
          Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate presigned URL for document download
 */

export function useSmsIntegrationDownloadSmsDocument<TData = Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError = AxiosError<unknown>>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsIntegrationDownloadSmsDocument>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsIntegrationDownloadSmsDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Register new tenant and subscribe (Public)
 */
export const subscriptionsRegisterAndSubscribe = (
    subscriptionsRegisterAndSubscribeBody?: SubscriptionsRegisterAndSubscribeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/subscriptions/register-and-subscribe`,
      subscriptionsRegisterAndSubscribeBody,options
    );
  }



export const getSubscriptionsRegisterAndSubscribeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>, TError,{data: SubscriptionsRegisterAndSubscribeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>, TError,{data: SubscriptionsRegisterAndSubscribeBody}, TContext> => {

const mutationKey = ['subscriptionsRegisterAndSubscribe'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>, {data: SubscriptionsRegisterAndSubscribeBody}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsRegisterAndSubscribe(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsRegisterAndSubscribeMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>>
    export type SubscriptionsRegisterAndSubscribeMutationBody = SubscriptionsRegisterAndSubscribeBody
    export type SubscriptionsRegisterAndSubscribeMutationError = AxiosError<unknown>

    /**
 * @summary Register new tenant and subscribe (Public)
 */
export const useSubscriptionsRegisterAndSubscribe = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>, TError,{data: SubscriptionsRegisterAndSubscribeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsRegisterAndSubscribe>>,
        TError,
        {data: SubscriptionsRegisterAndSubscribeBody},
        TContext
      > => {

      const mutationOptions = getSubscriptionsRegisterAndSubscribeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Subscribe to a plan (Mock Payment)
 */
export const subscriptionsSubscribe = (
    subscriptionsSubscribeBody?: SubscriptionsSubscribeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/subscriptions/subscribe`,
      subscriptionsSubscribeBody,options
    );
  }



export const getSubscriptionsSubscribeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsSubscribe>>, TError,{data: SubscriptionsSubscribeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsSubscribe>>, TError,{data: SubscriptionsSubscribeBody}, TContext> => {

const mutationKey = ['subscriptionsSubscribe'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsSubscribe>>, {data: SubscriptionsSubscribeBody}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsSubscribe(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsSubscribeMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsSubscribe>>>
    export type SubscriptionsSubscribeMutationBody = SubscriptionsSubscribeBody
    export type SubscriptionsSubscribeMutationError = AxiosError<unknown>

    /**
 * @summary Subscribe to a plan (Mock Payment)
 */
export const useSubscriptionsSubscribe = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsSubscribe>>, TError,{data: SubscriptionsSubscribeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsSubscribe>>,
        TError,
        {data: SubscriptionsSubscribeBody},
        TContext
      > => {

      const mutationOptions = getSubscriptionsSubscribeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Bulk upload suppliers via CSV/XLSX file. Returns summary {created, updated, errors}.
 */
export const suppliersBulkUploadSuppliers = (
    suppliersBulkUploadSuppliersBody?: SuppliersBulkUploadSuppliersBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/suppliers/bulk_upload`,
      suppliersBulkUploadSuppliersBody,options
    );
  }



export const getSuppliersBulkUploadSuppliersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext> => {

const mutationKey = ['suppliersBulkUploadSuppliers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, {data: SuppliersBulkUploadSuppliersBody}> = (props) => {
          const {data} = props ?? {};

          return  suppliersBulkUploadSuppliers(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersBulkUploadSuppliersMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>>
    export type SuppliersBulkUploadSuppliersMutationBody = SuppliersBulkUploadSuppliersBody
    export type SuppliersBulkUploadSuppliersMutationError = AxiosError<unknown>

    /**
 * @summary Bulk upload suppliers via CSV/XLSX file. Returns summary {created, updated, errors}.
 */
export const useSuppliersBulkUploadSuppliers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>, TError,{data: SuppliersBulkUploadSuppliersBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersBulkUploadSuppliers>>,
        TError,
        {data: SuppliersBulkUploadSuppliersBody},
        TContext
      > => {

      const mutationOptions = getSuppliersBulkUploadSuppliersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Fast supplier search for autocomplete
 */
export const suppliersSearchSuppliers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/suppliers/search`,options
    );
  }




export const getSuppliersSearchSuppliersQueryKey = () => {
    return [
    `/api/suppliers/search`
    ] as const;
    }

    
export const getSuppliersSearchSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersSearchSuppliersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersSearchSuppliers>>> = ({ signal }) => suppliersSearchSuppliers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersSearchSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersSearchSuppliers>>>
export type SuppliersSearchSuppliersQueryError = AxiosError<unknown>


export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Fast supplier search for autocomplete
 */

export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersSearchSuppliersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * These are needed for PDF generation and preview.
 * @summary Serve tenant assets (logo, stamp, signature) publicly.
 */
export const tenantUsersServeTenantAsset = (
    tenantId: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/tenant/assets/${tenantId}/${filename}`,options
    );
  }




export const getTenantUsersServeTenantAssetQueryKey = (tenantId?: string,
    filename?: string,) => {
    return [
    `/api/tenant/assets/${tenantId}/${filename}`
    ] as const;
    }

    
export const getTenantUsersServeTenantAssetQueryOptions = <TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError = AxiosError<unknown>>(tenantId: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTenantUsersServeTenantAssetQueryKey(tenantId,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>> = ({ signal }) => tenantUsersServeTenantAsset(tenantId,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(tenantId && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TenantUsersServeTenantAssetQueryResult = NonNullable<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>>
export type TenantUsersServeTenantAssetQueryError = AxiosError<unknown>


export function useTenantUsersServeTenantAsset<TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError = AxiosError<unknown>>(
 tenantId: string,
    filename: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersServeTenantAsset<TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError = AxiosError<unknown>>(
 tenantId: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>,
          TError,
          Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTenantUsersServeTenantAsset<TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError = AxiosError<unknown>>(
 tenantId: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve tenant assets (logo, stamp, signature) publicly.
 */

export function useTenantUsersServeTenantAsset<TData = Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError = AxiosError<unknown>>(
 tenantId: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantUsersServeTenantAsset>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTenantUsersServeTenantAssetQueryOptions(tenantId,filename,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Only tenant_admin can update company info.
 * @summary Update the current tenant's company information.
 */
export const tenantUsersUpdateTenantCompany = (
    tenantUsersUpdateTenantCompanyBody?: TenantUsersUpdateTenantCompanyBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/tenant/company`,
      tenantUsersUpdateTenantCompanyBody,options
    );
  }



export const getTenantUsersUpdateTenantCompanyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>, TError,{data: TenantUsersUpdateTenantCompanyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>, TError,{data: TenantUsersUpdateTenantCompanyBody}, TContext> => {

const mutationKey = ['tenantUsersUpdateTenantCompany'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>, {data: TenantUsersUpdateTenantCompanyBody}> = (props) => {
          const {data} = props ?? {};

          return  tenantUsersUpdateTenantCompany(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersUpdateTenantCompanyMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>>
    export type TenantUsersUpdateTenantCompanyMutationBody = TenantUsersUpdateTenantCompanyBody
    export type TenantUsersUpdateTenantCompanyMutationError = AxiosError<unknown>

    /**
 * @summary Update the current tenant's company information.
 */
export const useTenantUsersUpdateTenantCompany = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>, TError,{data: TenantUsersUpdateTenantCompanyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersUpdateTenantCompany>>,
        TError,
        {data: TenantUsersUpdateTenantCompanyBody},
        TContext
      > => {

      const mutationOptions = getTenantUsersUpdateTenantCompanyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a company asset (logo, stamp, or signature).
 */
export const tenantUsersDeleteTenantAsset = (
    assetType: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/tenant/company/upload/${assetType}`,options
    );
  }



export const getTenantUsersDeleteTenantAssetMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>, TError,{assetType: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>, TError,{assetType: string}, TContext> => {

const mutationKey = ['tenantUsersDeleteTenantAsset'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>, {assetType: string}> = (props) => {
          const {assetType} = props ?? {};

          return  tenantUsersDeleteTenantAsset(assetType,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TenantUsersDeleteTenantAssetMutationResult = NonNullable<Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>>
    
    export type TenantUsersDeleteTenantAssetMutationError = AxiosError<unknown>

    /**
 * @summary Delete a company asset (logo, stamp, or signature).
 */
export const useTenantUsersDeleteTenantAsset = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>, TError,{assetType: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tenantUsersDeleteTenantAsset>>,
        TError,
        {assetType: string},
        TContext
      > => {

      const mutationOptions = getTenantUsersDeleteTenantAssetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ≈ûu kaynak t√ºrlerini birle≈ütirir:
- Sales (satƒ±≈ülar)
- PaymentRecords (√∂deme kayƒ±tlarƒ±)
- Cash Records (nakit kayƒ±tlarƒ±)
Query parametreleri:
- limit: maksimum kayƒ±t sayƒ±sƒ± (varsayƒ±lan: 200)
- start_date, end_date: tarih filtreleri (ISO format)
- record_type: kayƒ±t t√ºr√º filtresi (sale, payment, cash)
- patient_id: hasta ID filtresi
- status: durum filtresi (paid, pending, partial)
 * @summary Birle≈üik cash records endpoint'i - t√ºm finansal kayƒ±tlarƒ± tek yerden d√∂nd√ºr√ºr.
 */
export const unifiedCashGetUnifiedCashRecords = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/unified-cash-records`,options
    );
  }




export const getUnifiedCashGetUnifiedCashRecordsQueryKey = () => {
    return [
    `/api/unified-cash-records`
    ] as const;
    }

    
export const getUnifiedCashGetUnifiedCashRecordsQueryOptions = <TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUnifiedCashGetUnifiedCashRecordsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>> = ({ signal }) => unifiedCashGetUnifiedCashRecords({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UnifiedCashGetUnifiedCashRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>>
export type UnifiedCashGetUnifiedCashRecordsQueryError = AxiosError<unknown>


export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Birle≈üik cash records endpoint'i - t√ºm finansal kayƒ±tlarƒ± tek yerden d√∂nd√ºr√ºr.
 */

export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUnifiedCashGetUnifiedCashRecordsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Query parametreleri:
- period: √∂zet d√∂nemi (today, week, month, year)
- start_date, end_date: √∂zel tarih aralƒ±ƒüƒ±
 * @summary Finansal √∂zet bilgileri d√∂nd√ºr√ºr.
 */
export const unifiedCashGetCashSummary = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/unified-cash-records/summary`,options
    );
  }




export const getUnifiedCashGetCashSummaryQueryKey = () => {
    return [
    `/api/unified-cash-records/summary`
    ] as const;
    }

    
export const getUnifiedCashGetCashSummaryQueryOptions = <TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUnifiedCashGetCashSummaryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>> = ({ signal }) => unifiedCashGetCashSummary({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UnifiedCashGetCashSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>>
export type UnifiedCashGetCashSummaryQueryError = AxiosError<unknown>


export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Finansal √∂zet bilgileri d√∂nd√ºr√ºr.
 */

export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUnifiedCashGetCashSummaryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Query Params:
key (str): S3 key of the file to delete
 * @summary Delete a file
 */
export const uploadDeleteFile = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/upload/files`,options
    );
  }



export const getUploadDeleteFileMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDeleteFile>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadDeleteFile>>, TError,void, TContext> => {

const mutationKey = ['uploadDeleteFile'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadDeleteFile>>, void> = () => {
          

          return  uploadDeleteFile(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadDeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadDeleteFile>>>
    
    export type UploadDeleteFileMutationError = AxiosError<unknown>

    /**
 * @summary Delete a file
 */
export const useUploadDeleteFile = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDeleteFile>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadDeleteFile>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUploadDeleteFileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Request Body:
filename (str): Original filename
folder (str): Target folder (e.g., 'sms_documents', 'invoices')
content_type (str): File content type (optional)
Returns:
JSON: {
'url': str,
'fields': dict,
'key': str
}
 * @summary Get a presigned URL for direct S3 upload
 */
export const uploadGetPresignedUploadUrl = (
    uploadGetPresignedUploadUrlBody?: UploadGetPresignedUploadUrlBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/upload/presigned`,
      uploadGetPresignedUploadUrlBody,options
    );
  }



export const getUploadGetPresignedUploadUrlMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>, TError,{data: UploadGetPresignedUploadUrlBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>, TError,{data: UploadGetPresignedUploadUrlBody}, TContext> => {

const mutationKey = ['uploadGetPresignedUploadUrl'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>, {data: UploadGetPresignedUploadUrlBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadGetPresignedUploadUrl(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadGetPresignedUploadUrlMutationResult = NonNullable<Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>>
    export type UploadGetPresignedUploadUrlMutationBody = UploadGetPresignedUploadUrlBody
    export type UploadGetPresignedUploadUrlMutationError = AxiosError<unknown>

    /**
 * @summary Get a presigned URL for direct S3 upload
 */
export const useUploadGetPresignedUploadUrl = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>, TError,{data: UploadGetPresignedUploadUrlBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadGetPresignedUploadUrl>>,
        TError,
        {data: UploadGetPresignedUploadUrlBody},
        TContext
      > => {

      const mutationOptions = getUploadGetPresignedUploadUrlMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /metrics
 */
export const metrics = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/metrics`,options
    );
  }




export const getMetricsQueryKey = () => {
    return [
    `/metrics`
    ] as const;
    }

    
export const getMetricsQueryOptions = <TData = Awaited<ReturnType<typeof metrics>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof metrics>>> = ({ signal }) => metrics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type MetricsQueryResult = NonNullable<Awaited<ReturnType<typeof metrics>>>
export type MetricsQueryError = AxiosError<unknown>


export function useMetrics<TData = Awaited<ReturnType<typeof metrics>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metrics>>,
          TError,
          Awaited<ReturnType<typeof metrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMetrics<TData = Awaited<ReturnType<typeof metrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metrics>>,
          TError,
          Awaited<ReturnType<typeof metrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMetrics<TData = Awaited<ReturnType<typeof metrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /metrics
 */

export function useMetrics<TData = Awaited<ReturnType<typeof metrics>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMetricsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initiate PayTR Payment
 */
export const paytrInitiate = (
    payTRInitiateRequest: PayTRInitiateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PayTRInitiateResponse>> => {
    
    
    return axios.post(
      `/api/payments/pos/paytr/initiate`,
      payTRInitiateRequest,options
    );
  }



export const getPaytrInitiateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext> => {

const mutationKey = ['paytrInitiate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paytrInitiate>>, {data: PayTRInitiateRequest}> = (props) => {
          const {data} = props ?? {};

          return  paytrInitiate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaytrInitiateMutationResult = NonNullable<Awaited<ReturnType<typeof paytrInitiate>>>
    export type PaytrInitiateMutationBody = PayTRInitiateRequest
    export type PaytrInitiateMutationError = AxiosError<unknown>

    /**
 * @summary Initiate PayTR Payment
 */
export const usePaytrInitiate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paytrInitiate>>,
        TError,
        {data: PayTRInitiateRequest},
        TContext
      > => {

      const mutationOptions = getPaytrInitiateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PayTR Callback
 */
export const paytrCallback = (
    paytrCallbackBody: PaytrCallbackBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    const formUrlEncoded = new URLSearchParams();
if(paytrCallbackBody.merchant_oid !== undefined) {
 formUrlEncoded.append(`merchant_oid`, paytrCallbackBody.merchant_oid)
 }
if(paytrCallbackBody.status !== undefined) {
 formUrlEncoded.append(`status`, paytrCallbackBody.status)
 }
if(paytrCallbackBody.total_amount !== undefined) {
 formUrlEncoded.append(`total_amount`, paytrCallbackBody.total_amount)
 }
if(paytrCallbackBody.hash !== undefined) {
 formUrlEncoded.append(`hash`, paytrCallbackBody.hash)
 }

    return axios.post(
      `/api/payments/pos/paytr/callback`,
      formUrlEncoded,{
        responseType: 'text',
    ...options,}
    );
  }



export const getPaytrCallbackMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext> => {

const mutationKey = ['paytrCallback'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paytrCallback>>, {data: PaytrCallbackBody}> = (props) => {
          const {data} = props ?? {};

          return  paytrCallback(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaytrCallbackMutationResult = NonNullable<Awaited<ReturnType<typeof paytrCallback>>>
    export type PaytrCallbackMutationBody = PaytrCallbackBody
    export type PaytrCallbackMutationError = AxiosError<unknown>

    /**
 * @summary PayTR Callback
 */
export const usePaytrCallback = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paytrCallback>>,
        TError,
        {data: PaytrCallbackBody},
        TContext
      > => {

      const mutationOptions = getPaytrCallbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get PayTR Config
 */
export const getPaytrConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPaytrConfig200>> => {
    
    
    return axios.get(
      `/api/payments/pos/paytr/config`,options
    );
  }




export const getGetPaytrConfigQueryKey = () => {
    return [
    `/api/payments/pos/paytr/config`
    ] as const;
    }

    
export const getGetPaytrConfigQueryOptions = <TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaytrConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaytrConfig>>> = ({ signal }) => getPaytrConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaytrConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getPaytrConfig>>>
export type GetPaytrConfigQueryError = AxiosError<unknown>


export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaytrConfig>>,
          TError,
          Awaited<ReturnType<typeof getPaytrConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaytrConfig>>,
          TError,
          Awaited<ReturnType<typeof getPaytrConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get PayTR Config
 */

export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaytrConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update PayTR Config
 */
export const updatePaytrConfig = (
    updatePaytrConfigBody: UpdatePaytrConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpdatePaytrConfig200>> => {
    
    
    return axios.put(
      `/api/payments/pos/paytr/config`,
      updatePaytrConfigBody,options
    );
  }



export const getUpdatePaytrConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext> => {

const mutationKey = ['updatePaytrConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaytrConfig>>, {data: UpdatePaytrConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  updatePaytrConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaytrConfigMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaytrConfig>>>
    export type UpdatePaytrConfigMutationBody = UpdatePaytrConfigBody
    export type UpdatePaytrConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update PayTR Config
 */
export const useUpdatePaytrConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePaytrConfig>>,
        TError,
        {data: UpdatePaytrConfigBody},
        TContext
      > => {

      const mutationOptions = getUpdatePaytrConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POS Movements Report
 */
export const reportPosMovements = (
    params?: ReportPosMovementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReportPosMovements200>> => {
    
    
    return axios.get(
      `/api/reports/pos-movements`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getReportPosMovementsQueryKey = (params?: ReportPosMovementsParams,) => {
    return [
    `/api/reports/pos-movements`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReportPosMovementsQueryOptions = <TData = Awaited<ReturnType<typeof reportPosMovements>>, TError = AxiosError<unknown>>(params?: ReportPosMovementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportPosMovementsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportPosMovements>>> = ({ signal }) => reportPosMovements(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportPosMovementsQueryResult = NonNullable<Awaited<ReturnType<typeof reportPosMovements>>>
export type ReportPosMovementsQueryError = AxiosError<unknown>


export function useReportPosMovements<TData = Awaited<ReturnType<typeof reportPosMovements>>, TError = AxiosError<unknown>>(
 params: undefined |  ReportPosMovementsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportPosMovements>>,
          TError,
          Awaited<ReturnType<typeof reportPosMovements>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportPosMovements<TData = Awaited<ReturnType<typeof reportPosMovements>>, TError = AxiosError<unknown>>(
 params?: ReportPosMovementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportPosMovements>>,
          TError,
          Awaited<ReturnType<typeof reportPosMovements>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportPosMovements<TData = Awaited<ReturnType<typeof reportPosMovements>>, TError = AxiosError<unknown>>(
 params?: ReportPosMovementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary POS Movements Report
 */

export function useReportPosMovements<TData = Awaited<ReturnType<typeof reportPosMovements>>, TError = AxiosError<unknown>>(
 params?: ReportPosMovementsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportPosMovements>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportPosMovementsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POS Transactions Report
 */
export const getPosTransactions = (
    params?: GetPosTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPosTransactions200>> => {
    
    
    return axios.get(
      `/api/payments/pos/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetPosTransactionsQueryKey = (params?: GetPosTransactionsParams,) => {
    return [
    `/api/payments/pos/transactions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPosTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPosTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPosTransactions>>> = ({ signal }) => getPosTransactions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPosTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getPosTransactions>>>
export type GetPosTransactionsQueryError = AxiosError<unknown>


export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params: undefined |  GetPosTransactionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPosTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPosTransactions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPosTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPosTransactions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary POS Transactions Report
 */

export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPosTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Calculate commission for amount and installments
 */
export const calculateCommission = (
    commissionCalculationRequest: CommissionCalculationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommissionCalculationResponse>> => {
    
    
    return axios.post(
      `/api/pos/commission/calculate`,
      commissionCalculationRequest,options
    );
  }



export const getCalculateCommissionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCommission>>, TError,{data: CommissionCalculationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof calculateCommission>>, TError,{data: CommissionCalculationRequest}, TContext> => {

const mutationKey = ['calculateCommission'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateCommission>>, {data: CommissionCalculationRequest}> = (props) => {
          const {data} = props ?? {};

          return  calculateCommission(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateCommissionMutationResult = NonNullable<Awaited<ReturnType<typeof calculateCommission>>>
    export type CalculateCommissionMutationBody = CommissionCalculationRequest
    export type CalculateCommissionMutationError = AxiosError<unknown>

    /**
 * @summary Calculate commission for amount and installments
 */
export const useCalculateCommission = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCommission>>, TError,{data: CommissionCalculationRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateCommission>>,
        TError,
        {data: CommissionCalculationRequest},
        TContext
      > => {

      const mutationOptions = getCalculateCommissionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get installment options with calculated amounts
 */
export const getInstallmentOptions = (
    installmentOptionsRequest: InstallmentOptionsRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InstallmentOptionsResponse>> => {
    
    
    return axios.post(
      `/api/pos/commission/installment-options`,
      installmentOptionsRequest,options
    );
  }



export const getGetInstallmentOptionsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getInstallmentOptions>>, TError,{data: InstallmentOptionsRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getInstallmentOptions>>, TError,{data: InstallmentOptionsRequest}, TContext> => {

const mutationKey = ['getInstallmentOptions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getInstallmentOptions>>, {data: InstallmentOptionsRequest}> = (props) => {
          const {data} = props ?? {};

          return  getInstallmentOptions(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetInstallmentOptionsMutationResult = NonNullable<Awaited<ReturnType<typeof getInstallmentOptions>>>
    export type GetInstallmentOptionsMutationBody = InstallmentOptionsRequest
    export type GetInstallmentOptionsMutationError = AxiosError<unknown>

    /**
 * @summary Get installment options with calculated amounts
 */
export const useGetInstallmentOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getInstallmentOptions>>, TError,{data: InstallmentOptionsRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getInstallmentOptions>>,
        TError,
        {data: InstallmentOptionsRequest},
        TContext
      > => {

      const mutationOptions = getGetInstallmentOptionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get commission rates for current tenant
 */
export const getCommissionRates = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommissionRatesResponse>> => {
    
    
    return axios.get(
      `/api/pos/commission/rates`,options
    );
  }




export const getGetCommissionRatesQueryKey = () => {
    return [
    `/api/pos/commission/rates`
    ] as const;
    }

    
export const getGetCommissionRatesQueryOptions = <TData = Awaited<ReturnType<typeof getCommissionRates>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommissionRatesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommissionRates>>> = ({ signal }) => getCommissionRates({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCommissionRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getCommissionRates>>>
export type GetCommissionRatesQueryError = AxiosError<unknown>


export function useGetCommissionRates<TData = Awaited<ReturnType<typeof getCommissionRates>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommissionRates<TData = Awaited<ReturnType<typeof getCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCommissionRates<TData = Awaited<ReturnType<typeof getCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get commission rates for current tenant
 */

export function useGetCommissionRates<TData = Awaited<ReturnType<typeof getCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCommissionRatesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get system-wide commission rates
 */
export const getSystemCommissionRates = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetSystemCommissionRates200>> => {
    
    
    return axios.get(
      `/api/pos/commission/rates/system`,options
    );
  }




export const getGetSystemCommissionRatesQueryKey = () => {
    return [
    `/api/pos/commission/rates/system`
    ] as const;
    }

    
export const getGetSystemCommissionRatesQueryOptions = <TData = Awaited<ReturnType<typeof getSystemCommissionRates>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSystemCommissionRatesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemCommissionRates>>> = ({ signal }) => getSystemCommissionRates({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSystemCommissionRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemCommissionRates>>>
export type GetSystemCommissionRatesQueryError = AxiosError<unknown>


export function useGetSystemCommissionRates<TData = Awaited<ReturnType<typeof getSystemCommissionRates>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getSystemCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSystemCommissionRates<TData = Awaited<ReturnType<typeof getSystemCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getSystemCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSystemCommissionRates<TData = Awaited<ReturnType<typeof getSystemCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get system-wide commission rates
 */

export function useGetSystemCommissionRates<TData = Awaited<ReturnType<typeof getSystemCommissionRates>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSystemCommissionRatesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update system-wide commission rates
 */
export const updateSystemCommissionRates = (
    updateSystemCommissionRatesBody: UpdateSystemCommissionRatesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpdateSystemCommissionRates200>> => {
    
    
    return axios.put(
      `/api/pos/commission/rates/system`,
      updateSystemCommissionRatesBody,options
    );
  }



export const getUpdateSystemCommissionRatesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSystemCommissionRates>>, TError,{data: UpdateSystemCommissionRatesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSystemCommissionRates>>, TError,{data: UpdateSystemCommissionRatesBody}, TContext> => {

const mutationKey = ['updateSystemCommissionRates'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSystemCommissionRates>>, {data: UpdateSystemCommissionRatesBody}> = (props) => {
          const {data} = props ?? {};

          return  updateSystemCommissionRates(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSystemCommissionRatesMutationResult = NonNullable<Awaited<ReturnType<typeof updateSystemCommissionRates>>>
    export type UpdateSystemCommissionRatesMutationBody = UpdateSystemCommissionRatesBody
    export type UpdateSystemCommissionRatesMutationError = AxiosError<unknown>

    /**
 * @summary Update system-wide commission rates
 */
export const useUpdateSystemCommissionRates = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSystemCommissionRates>>, TError,{data: UpdateSystemCommissionRatesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSystemCommissionRates>>,
        TError,
        {data: UpdateSystemCommissionRatesBody},
        TContext
      > => {

      const mutationOptions = getUpdateSystemCommissionRatesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get tenant-specific commission rates
 */
export const getTenantCommissionRates = (
    tenantId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetTenantCommissionRates200>> => {
    
    
    return axios.get(
      `/api/pos/commission/rates/tenant/${tenantId}`,options
    );
  }




export const getGetTenantCommissionRatesQueryKey = (tenantId?: string,) => {
    return [
    `/api/pos/commission/rates/tenant/${tenantId}`
    ] as const;
    }

    
export const getGetTenantCommissionRatesQueryOptions = <TData = Awaited<ReturnType<typeof getTenantCommissionRates>>, TError = AxiosError<unknown>>(tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantCommissionRatesQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantCommissionRates>>> = ({ signal }) => getTenantCommissionRates(tenantId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(tenantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantCommissionRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantCommissionRates>>>
export type GetTenantCommissionRatesQueryError = AxiosError<unknown>


export function useGetTenantCommissionRates<TData = Awaited<ReturnType<typeof getTenantCommissionRates>>, TError = AxiosError<unknown>>(
 tenantId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getTenantCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantCommissionRates<TData = Awaited<ReturnType<typeof getTenantCommissionRates>>, TError = AxiosError<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantCommissionRates>>,
          TError,
          Awaited<ReturnType<typeof getTenantCommissionRates>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantCommissionRates<TData = Awaited<ReturnType<typeof getTenantCommissionRates>>, TError = AxiosError<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get tenant-specific commission rates
 */

export function useGetTenantCommissionRates<TData = Awaited<ReturnType<typeof getTenantCommissionRates>>, TError = AxiosError<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantCommissionRates>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantCommissionRatesQueryOptions(tenantId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update tenant-specific commission rates
 */
export const updateTenantCommissionRates = (
    tenantId: string,
    updateTenantCommissionRatesBody: UpdateTenantCommissionRatesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpdateTenantCommissionRates200>> => {
    
    
    return axios.put(
      `/api/pos/commission/rates/tenant/${tenantId}`,
      updateTenantCommissionRatesBody,options
    );
  }



export const getUpdateTenantCommissionRatesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantCommissionRates>>, TError,{tenantId: string;data: UpdateTenantCommissionRatesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateTenantCommissionRates>>, TError,{tenantId: string;data: UpdateTenantCommissionRatesBody}, TContext> => {

const mutationKey = ['updateTenantCommissionRates'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenantCommissionRates>>, {tenantId: string;data: UpdateTenantCommissionRatesBody}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  updateTenantCommissionRates(tenantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantCommissionRatesMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenantCommissionRates>>>
    export type UpdateTenantCommissionRatesMutationBody = UpdateTenantCommissionRatesBody
    export type UpdateTenantCommissionRatesMutationError = AxiosError<unknown>

    /**
 * @summary Update tenant-specific commission rates
 */
export const useUpdateTenantCommissionRates = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantCommissionRates>>, TError,{tenantId: string;data: UpdateTenantCommissionRatesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTenantCommissionRates>>,
        TError,
        {tenantId: string;data: UpdateTenantCommissionRatesBody},
        TContext
      > => {

      const mutationOptions = getUpdateTenantCommissionRatesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
