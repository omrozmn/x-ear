/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from FastAPI backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EReceiptCreate,
  EReceiptUpdate,
  HTTPValidationError,
  HearingTestCreate,
  HearingTestUpdate
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Get all hearing tests for a party
 * @summary List Hearing Tests
 */
export const listHearingTests = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/tests`, method: 'GET', signal
    },
      );
    }
  



export const getListHearingTestsQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/profiles/hearing/tests`
    ] as const;
    }

    
export const getListHearingTestsQueryOptions = <TData = Awaited<ReturnType<typeof listHearingTests>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListHearingTestsQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listHearingTests>>> = ({ signal }) => listHearingTests(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListHearingTestsQueryResult = NonNullable<Awaited<ReturnType<typeof listHearingTests>>>
export type ListHearingTestsQueryError = HTTPValidationError


export function useListHearingTests<TData = Awaited<ReturnType<typeof listHearingTests>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHearingTests>>,
          TError,
          Awaited<ReturnType<typeof listHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListHearingTests<TData = Awaited<ReturnType<typeof listHearingTests>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHearingTests>>,
          TError,
          Awaited<ReturnType<typeof listHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListHearingTests<TData = Awaited<ReturnType<typeof listHearingTests>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Hearing Tests
 */

export function useListHearingTests<TData = Awaited<ReturnType<typeof listHearingTests>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListHearingTestsQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add a new hearing test to party
 * @summary Create Hearing Test
 */
export const createHearingTest = (
    partyId: string,
    hearingTestCreate: HearingTestCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestCreate, signal
    },
      );
    }
  


export const getCreateHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createHearingTest>>, TError,{partyId: string;data: HearingTestCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createHearingTest>>, TError,{partyId: string;data: HearingTestCreate}, TContext> => {

const mutationKey = ['createHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createHearingTest>>, {partyId: string;data: HearingTestCreate}> = (props) => {
          const {partyId,data} = props ?? {};

          return  createHearingTest(partyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof createHearingTest>>>
    export type CreateHearingTestMutationBody = HearingTestCreate
    export type CreateHearingTestMutationError = HTTPValidationError

    /**
 * @summary Create Hearing Test
 */
export const useCreateHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createHearingTest>>, TError,{partyId: string;data: HearingTestCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createHearingTest>>,
        TError,
        {partyId: string;data: HearingTestCreate},
        TContext
      > => {

      const mutationOptions = getCreateHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a hearing test
 * @summary Update Hearing Test
 */
export const updateHearingTest = (
    partyId: string,
    testId: string,
    hearingTestUpdate: HearingTestUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/tests/${testId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestUpdate
    },
      );
    }
  


export const getUpdateHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHearingTest>>, TError,{partyId: string;testId: string;data: HearingTestUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateHearingTest>>, TError,{partyId: string;testId: string;data: HearingTestUpdate}, TContext> => {

const mutationKey = ['updateHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateHearingTest>>, {partyId: string;testId: string;data: HearingTestUpdate}> = (props) => {
          const {partyId,testId,data} = props ?? {};

          return  updateHearingTest(partyId,testId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof updateHearingTest>>>
    export type UpdateHearingTestMutationBody = HearingTestUpdate
    export type UpdateHearingTestMutationError = HTTPValidationError

    /**
 * @summary Update Hearing Test
 */
export const useUpdateHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHearingTest>>, TError,{partyId: string;testId: string;data: HearingTestUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateHearingTest>>,
        TError,
        {partyId: string;testId: string;data: HearingTestUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a hearing test
 * @summary Delete Hearing Test
 */
export const deleteHearingTest = (
    partyId: string,
    testId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHearingTest>>, TError,{partyId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteHearingTest>>, TError,{partyId: string;testId: string}, TContext> => {

const mutationKey = ['deleteHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteHearingTest>>, {partyId: string;testId: string}> = (props) => {
          const {partyId,testId} = props ?? {};

          return  deleteHearingTest(partyId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof deleteHearingTest>>>
    
    export type DeleteHearingTestMutationError = HTTPValidationError

    /**
 * @summary Delete Hearing Test
 */
export const useDeleteHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHearingTest>>, TError,{partyId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteHearingTest>>,
        TError,
        {partyId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getDeleteHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all e-receipts for a party
 * @summary List Hearing Ereceipts
 */
export const listHearingEReceipts = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/ereceipts`, method: 'GET', signal
    },
      );
    }
  



export const getListHearingEReceiptsQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/profiles/hearing/ereceipts`
    ] as const;
    }

    
export const getListHearingEReceiptsQueryOptions = <TData = Awaited<ReturnType<typeof listHearingEReceipts>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListHearingEReceiptsQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listHearingEReceipts>>> = ({ signal }) => listHearingEReceipts(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListHearingEReceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof listHearingEReceipts>>>
export type ListHearingEReceiptsQueryError = HTTPValidationError


export function useListHearingEReceipts<TData = Awaited<ReturnType<typeof listHearingEReceipts>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHearingEReceipts>>,
          TError,
          Awaited<ReturnType<typeof listHearingEReceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListHearingEReceipts<TData = Awaited<ReturnType<typeof listHearingEReceipts>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHearingEReceipts>>,
          TError,
          Awaited<ReturnType<typeof listHearingEReceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListHearingEReceipts<TData = Awaited<ReturnType<typeof listHearingEReceipts>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Hearing Ereceipts
 */

export function useListHearingEReceipts<TData = Awaited<ReturnType<typeof listHearingEReceipts>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHearingEReceipts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListHearingEReceiptsQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new e-receipt for party
 * @summary Create Hearing Ereceipt
 */
export const createHearingEReceipt = (
    partyId: string,
    eReceiptCreate: EReceiptCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptCreate, signal
    },
      );
    }
  


export const getCreateHearingEReceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createHearingEReceipt>>, TError,{partyId: string;data: EReceiptCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createHearingEReceipt>>, TError,{partyId: string;data: EReceiptCreate}, TContext> => {

const mutationKey = ['createHearingEReceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createHearingEReceipt>>, {partyId: string;data: EReceiptCreate}> = (props) => {
          const {partyId,data} = props ?? {};

          return  createHearingEReceipt(partyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateHearingEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof createHearingEReceipt>>>
    export type CreateHearingEReceiptMutationBody = EReceiptCreate
    export type CreateHearingEReceiptMutationError = HTTPValidationError

    /**
 * @summary Create Hearing Ereceipt
 */
export const useCreateHearingEReceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createHearingEReceipt>>, TError,{partyId: string;data: EReceiptCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createHearingEReceipt>>,
        TError,
        {partyId: string;data: EReceiptCreate},
        TContext
      > => {

      const mutationOptions = getCreateHearingEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update an e-receipt
 * @summary Update Hearing Ereceipt
 */
export const updateHearingEReceipt = (
    partyId: string,
    ereceiptId: string,
    eReceiptUpdate: EReceiptUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/ereceipts/${ereceiptId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptUpdate
    },
      );
    }
  


export const getUpdateHearingEReceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHearingEReceipt>>, TError,{partyId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateHearingEReceipt>>, TError,{partyId: string;ereceiptId: string;data: EReceiptUpdate}, TContext> => {

const mutationKey = ['updateHearingEReceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateHearingEReceipt>>, {partyId: string;ereceiptId: string;data: EReceiptUpdate}> = (props) => {
          const {partyId,ereceiptId,data} = props ?? {};

          return  updateHearingEReceipt(partyId,ereceiptId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateHearingEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof updateHearingEReceipt>>>
    export type UpdateHearingEReceiptMutationBody = EReceiptUpdate
    export type UpdateHearingEReceiptMutationError = HTTPValidationError

    /**
 * @summary Update Hearing Ereceipt
 */
export const useUpdateHearingEReceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHearingEReceipt>>, TError,{partyId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateHearingEReceipt>>,
        TError,
        {partyId: string;ereceiptId: string;data: EReceiptUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateHearingEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an e-receipt
 * @summary Delete Hearing Ereceipt
 */
export const deleteHearingEReceipt = (
    partyId: string,
    ereceiptId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/profiles/hearing/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteHearingEReceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHearingEReceipt>>, TError,{partyId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteHearingEReceipt>>, TError,{partyId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['deleteHearingEReceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteHearingEReceipt>>, {partyId: string;ereceiptId: string}> = (props) => {
          const {partyId,ereceiptId} = props ?? {};

          return  deleteHearingEReceipt(partyId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteHearingEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof deleteHearingEReceipt>>>
    
    export type DeleteHearingEReceiptMutationError = HTTPValidationError

    /**
 * @summary Delete Hearing Ereceipt
 */
export const useDeleteHearingEReceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHearingEReceipt>>, TError,{partyId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteHearingEReceipt>>,
        TError,
        {partyId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getDeleteHearingEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    