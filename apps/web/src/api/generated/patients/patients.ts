/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  ErrorResponse,
  Patient,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesCreatePatientNoteBody,
  PatientsBulkUploadPatientsBody,
  PatientsCountPatients200,
  PatientsCountPatientsParams,
  PatientsCreatePatientBody,
  PatientsGetPatientDevices200,
  PatientsGetPatientReplacements200,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  ReplacementsCreatePatientReplacementBody,
  Sale,
  SalesAssignDevicesExtendedBody,
  SalesCreateProductSaleBody,
  SuccessResponse
} from '.././schemas';





/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
    params?: PatientsGetPatientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatients200>> => {
    
    
    return axios.get(
      `/api/patients`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getPatientsGetPatientsQueryKey = (params?: PatientsGetPatientsParams,) => {
    return [
    `/api/patients`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsGetPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatients>>> = ({ signal }) => patientsGetPatients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatients>>>
export type PatientsGetPatientsQueryError = AxiosError<ErrorResponse>


export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  PatientsGetPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = AxiosError<ErrorResponse>>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.post(
      `/api/patients`,
      patientsCreatePatientBody,options
    );
  }



export const getPatientsCreatePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve detailed information about a specific patient
 * @summary Get a specific patient by ID
 */
export const patientsGetPatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}`,options
    );
  }




export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = AxiosError<unknown>


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific patient by ID
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing patient's information
 * @summary Update a patient
 */
export const patientsUpdatePatient = (
    patientId: string,
    patient: Patient, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.put(
      `/api/patients/${patientId}`,
      patient,options
    );
  }



export const getPatientsUpdatePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: Patient}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = Patient
    export type PatientsUpdatePatientMutationError = AxiosError<unknown>

    /**
 * @summary Update a patient
 */
export const usePatientsUpdatePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: Patient},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuccessResponse>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}`,options
    );
  }



export const getPatientsDeletePatientMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/assign-devices-extended`,
      salesAssignDevicesExtendedBody,options
    );
  }



export const getSalesAssignDevicesExtendedMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatientDevices200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/devices`,options
    );
  }




export const getPatientsGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientsGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientDevices>>> = ({ signal }) => patientsGetPatientDevices(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientDevices>>>
export type PatientsGetPatientDevicesQueryError = AxiosError<unknown>


export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/ereceipts`,
      patientSubresourcesCreatePatientEreceiptBody,options
    );
  }



export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/ereceipts/${ereceiptId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/hearing-tests`,
      patientSubresourcesAddPatientHearingTestBody,options
    );
  }



export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/hearing-tests/${testId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
    patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/notes`,
      patientSubresourcesCreatePatientNoteBody,options
    );
  }



export const getPatientSubresourcesCreatePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, {patientId: string;data: PatientSubresourcesCreatePatientNoteBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientNote(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>>
    export type PatientSubresourcesCreatePatientNoteMutationBody = PatientSubresourcesCreatePatientNoteBody
    export type PatientSubresourcesCreatePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
    patientId: string,
    noteId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/patients/${patientId}/notes/${noteId}`,options
    );
  }



export const getPatientSubresourcesDeletePatientNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  patientSubresourcesDeletePatientNote(patientId,noteId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>>
    
    export type PatientSubresourcesDeletePatientNoteMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/promissory-notes`,options
    );
  }




export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = AxiosError<unknown>


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Sale[]>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sales`,options
    );
  }




export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = AxiosError<unknown>


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/sgk-documents`,options
    );
  }




export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = AxiosError<unknown>


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/bulk_upload`,
      patientsBulkUploadPatientsBody,options
    );
  }



export const getPatientsBulkUploadPatientsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = AxiosError<unknown>

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Count patients matching the given filters. Only counts patients with valid phone numbers.
Useful for SMS campaign target audience estimation.

 * @summary Count patients with optional filters for SMS campaigns
 */
export const patientsCountPatients = (
    params?: PatientsCountPatientsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsCountPatients200>> => {
    
    
    return axios.get(
      `/api/patients/count`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getPatientsCountPatientsQueryKey = (params?: PatientsCountPatientsParams,) => {
    return [
    `/api/patients/count`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsCountPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsCountPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsCountPatients>>> = ({ signal }) => patientsCountPatients(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsCountPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsCountPatients>>>
export type PatientsCountPatientsQueryError = AxiosError<unknown>


export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params: undefined |  PatientsCountPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Count patients with optional filters for SMS campaigns
 */

export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = AxiosError<unknown>>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsCountPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/export`,options
    );
  }




export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = AxiosError<unknown>


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/search`,options
    );
  }




export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = AxiosError<unknown>


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all invoices for a patient
 */
export const invoicesGetPatientInvoices = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/invoices`,options
    );
  }




export const getInvoicesGetPatientInvoicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/invoices`
    ] as const;
    }

    
export const getInvoicesGetPatientInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetPatientInvoicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>> = ({ signal }) => invoicesGetPatientInvoices(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetPatientInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>>
export type InvoicesGetPatientInvoicesQueryError = AxiosError<unknown>


export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all invoices for a patient
 */

export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetPatientInvoicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all payment records for a patient
 */
export const paymentsGetPatientPaymentRecords = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/payment-records`,options
    );
  }




export const getPaymentsGetPatientPaymentRecordsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/payment-records`
    ] as const;
    }

    
export const getPaymentsGetPatientPaymentRecordsQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPaymentRecordsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>> = ({ signal }) => paymentsGetPatientPaymentRecords(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPaymentRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>>
export type PaymentsGetPatientPaymentRecordsQueryError = AxiosError<unknown>


export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all payment records for a patient
 */

export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPaymentRecordsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new product sale from inventory
 */
export const salesCreateProductSale = (
    patientId: string,
    salesCreateProductSaleBody?: SalesCreateProductSaleBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/product-sales`,
      salesCreateProductSaleBody,options
    );
  }



export const getSalesCreateProductSaleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext> => {

const mutationKey = ['salesCreateProductSale'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateProductSale>>, {patientId: string;data: SalesCreateProductSaleBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesCreateProductSale(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateProductSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateProductSale>>>
    export type SalesCreateProductSaleMutationBody = SalesCreateProductSaleBody
    export type SalesCreateProductSaleMutationError = AxiosError<unknown>

    /**
 * @summary Create a new product sale from inventory
 */
export const useSalesCreateProductSale = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateProductSale>>,
        TError,
        {patientId: string;data: SalesCreateProductSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateProductSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get all proformas for a patient
 */
export const proformasGetPatientProformas = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/proformas`,options
    );
  }




export const getProformasGetPatientProformasQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/proformas`
    ] as const;
    }

    
export const getProformasGetPatientProformasQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetPatientProformasQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetPatientProformas>>> = ({ signal }) => proformasGetPatientProformas(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ProformasGetPatientProformasQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetPatientProformas>>>
export type ProformasGetPatientProformasQueryError = AxiosError<unknown>


export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all proformas for a patient
 */

export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getProformasGetPatientProformasQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get replacement history for a patient
 */
export const patientsGetPatientReplacements = (
    patientId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PatientsGetPatientReplacements200>> => {
    
    
    return axios.get(
      `/api/patients/${patientId}/replacements`,options
    );
  }




export const getPatientsGetPatientReplacementsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/replacements`
    ] as const;
    }

    
export const getPatientsGetPatientReplacementsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError = AxiosError<unknown>>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientReplacementsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientReplacements>>> = ({ signal }) => patientsGetPatientReplacements(patientId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientReplacementsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientReplacements>>>
export type PatientsGetPatientReplacementsQueryError = AxiosError<unknown>


export function usePatientsGetPatientReplacements<TData = Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError = AxiosError<unknown>>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientReplacements>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientReplacements>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientReplacements<TData = Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientReplacements>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientReplacements>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientReplacements<TData = Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get replacement history for a patient
 */

export function usePatientsGetPatientReplacements<TData = Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError = AxiosError<unknown>>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientReplacements>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientReplacementsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const replacementsCreatePatientReplacement = (
    patientId: string,
    replacementsCreatePatientReplacementBody?: ReplacementsCreatePatientReplacementBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/patients/${patientId}/replacements`,
      replacementsCreatePatientReplacementBody,options
    );
  }



export const getReplacementsCreatePatientReplacementMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext> => {

const mutationKey = ['replacementsCreatePatientReplacement'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, {patientId: string;data: ReplacementsCreatePatientReplacementBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  replacementsCreatePatientReplacement(patientId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreatePatientReplacementMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>>
    export type ReplacementsCreatePatientReplacementMutationBody = ReplacementsCreatePatientReplacementBody
    export type ReplacementsCreatePatientReplacementMutationError = AxiosError<unknown>

    /**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const useReplacementsCreatePatientReplacement = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
        TError,
        {patientId: string;data: ReplacementsCreatePatientReplacementBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreatePatientReplacementMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Expected payload: { "status": "cancelled", "total_amount": 1000.0, "paid_amount": 500.0, "notes": "Updated notes" }
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const salesUpdateSalePartial = (
    patientId: string,
    saleId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/patients/${patientId}/sales/${saleId}`,undefined,options
    );
  }



export const getSalesUpdateSalePartialMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext> => {

const mutationKey = ['salesUpdateSalePartial'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSalePartial>>, {patientId: string;saleId: string}> = (props) => {
          const {patientId,saleId} = props ?? {};

          return  salesUpdateSalePartial(patientId,saleId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSalePartialMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSalePartial>>>
    
    export type SalesUpdateSalePartialMutationError = AxiosError<unknown>

    /**
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const useSalesUpdateSalePartial = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSalePartial>>,
        TError,
        {patientId: string;saleId: string},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSalePartialMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    