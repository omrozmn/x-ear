/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyUploadAndProcessFiles,
  EReceiptQueryRequest,
  HTTPValidationError,
  ListDeliveredEreceiptsParams,
  PatientRightsQueryRequest,
  UploadSGKDocumentRequest,
  WorkflowCreateRequest,
  WorkflowStatusUpdate,
  WorkflowUpdateRequest
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * List SGK documents
 * @summary List Sgk Documents
 */
export const listSgkDocuments = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents`, method: 'GET', signal
    },
      );
    }
  



export const getListSgkDocumentsQueryKey = () => {
    return [
    `/api/sgk/documents`
    ] as const;
    }

    
export const getListSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSgkDocumentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSgkDocuments>>> = ({ signal }) => listSgkDocuments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof listSgkDocuments>>>
export type ListSgkDocumentsQueryError = unknown


export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Sgk Documents
 */

export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListSgkDocumentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload SGK document
 * @summary Upload Sgk Document
 */
export const uploadSgkDocument = (
    uploadSGKDocumentRequest: UploadSGKDocumentRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: uploadSGKDocumentRequest, signal
    },
      );
    }
  


export const getUploadSgkDocumentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadSgkDocument>>, TError,{data: UploadSGKDocumentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadSgkDocument>>, TError,{data: UploadSGKDocumentRequest}, TContext> => {

const mutationKey = ['uploadSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadSgkDocument>>, {data: UploadSGKDocumentRequest}> = (props) => {
          const {data} = props ?? {};

          return  uploadSgkDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof uploadSgkDocument>>>
    export type UploadSgkDocumentMutationBody = UploadSGKDocumentRequest
    export type UploadSgkDocumentMutationError = HTTPValidationError

    /**
 * @summary Upload Sgk Document
 */
export const useUploadSgkDocument = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadSgkDocument>>, TError,{data: UploadSGKDocumentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadSgkDocument>>,
        TError,
        {data: UploadSGKDocumentRequest},
        TContext
      > => {

      const mutationOptions = getUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get SGK document
 * @summary Get Sgk Document
 */
export const getSgkDocument = (
    documentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents/${documentId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSgkDocumentQueryKey = (documentId?: string,) => {
    return [
    `/api/sgk/documents/${documentId}`
    ] as const;
    }

    
export const getGetSgkDocumentQueryOptions = <TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSgkDocumentQueryKey(documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSgkDocument>>> = ({ signal }) => getSgkDocument(documentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSgkDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof getSgkDocument>>>
export type GetSgkDocumentQueryError = HTTPValidationError


export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof getSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof getSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Sgk Document
 */

export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSgkDocumentQueryOptions(documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete SGK document
 * @summary Delete Sgk Document
 */
export const deleteSgkDocument = (
    documentId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSgkDocumentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['deleteSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  deleteSgkDocument(documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSgkDocument>>>
    
    export type DeleteSgkDocumentMutationError = HTTPValidationError

    /**
 * @summary Delete Sgk Document
 */
export const useDeleteSgkDocument = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Upload and process SGK files with OCR
 * @summary Upload And Process Files
 */
export const uploadAndProcessFiles = (
    bodyUploadAndProcessFiles: BodyUploadAndProcessFiles,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
bodyUploadAndProcessFiles.files.forEach(value => formData.append(`files`, value));

      return customInstance<unknown>(
      {url: `/api/sgk/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadAndProcessFilesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadAndProcessFiles>>, TError,{data: BodyUploadAndProcessFiles}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadAndProcessFiles>>, TError,{data: BodyUploadAndProcessFiles}, TContext> => {

const mutationKey = ['uploadAndProcessFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadAndProcessFiles>>, {data: BodyUploadAndProcessFiles}> = (props) => {
          const {data} = props ?? {};

          return  uploadAndProcessFiles(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadAndProcessFilesMutationResult = NonNullable<Awaited<ReturnType<typeof uploadAndProcessFiles>>>
    export type UploadAndProcessFilesMutationBody = BodyUploadAndProcessFiles
    export type UploadAndProcessFilesMutationError = HTTPValidationError

    /**
 * @summary Upload And Process Files
 */
export const useUploadAndProcessFiles = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadAndProcessFiles>>, TError,{data: BodyUploadAndProcessFiles}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadAndProcessFiles>>,
        TError,
        {data: BodyUploadAndProcessFiles},
        TContext
      > => {

      const mutationOptions = getUploadAndProcessFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get SGK documents for a specific patient
 * @summary Get Patient Sgk Documents
 */
export const getPatientSgkDocuments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/sgk-documents`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientSgkDocuments>>> = ({ signal }) => getPatientSgkDocuments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientSgkDocuments>>>
export type GetPatientSgkDocumentsQueryError = HTTPValidationError


export function useGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof getPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof getPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Sgk Documents
 */

export function useGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * E-reÃ§ete sorgulama endpoint'i
 * @summary Query E Receipt
 */
export const queryEReceipt = (
    eReceiptQueryRequest: EReceiptQueryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipt/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptQueryRequest, signal
    },
      );
    }
  


export const getQueryEReceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof queryEReceipt>>, TError,{data: EReceiptQueryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof queryEReceipt>>, TError,{data: EReceiptQueryRequest}, TContext> => {

const mutationKey = ['queryEReceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof queryEReceipt>>, {data: EReceiptQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  queryEReceipt(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type QueryEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof queryEReceipt>>>
    export type QueryEReceiptMutationBody = EReceiptQueryRequest
    export type QueryEReceiptMutationError = HTTPValidationError

    /**
 * @summary Query E Receipt
 */
export const useQueryEReceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof queryEReceipt>>, TError,{data: EReceiptQueryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof queryEReceipt>>,
        TError,
        {data: EReceiptQueryRequest},
        TContext
      > => {

      const mutationOptions = getQueryEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List delivered e-receipts grouped by patient
 * @summary List Delivered Ereceipts
 */
export const listDeliveredEreceipts = (
    params?: ListDeliveredEreceiptsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipts/delivered`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListDeliveredEreceiptsQueryKey = (params?: ListDeliveredEreceiptsParams,) => {
    return [
    `/api/sgk/e-receipts/delivered`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListDeliveredEreceiptsQueryOptions = <TData = Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError = HTTPValidationError>(params?: ListDeliveredEreceiptsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDeliveredEreceiptsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDeliveredEreceipts>>> = ({ signal }) => listDeliveredEreceipts(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListDeliveredEreceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof listDeliveredEreceipts>>>
export type ListDeliveredEreceiptsQueryError = HTTPValidationError


export function useListDeliveredEreceipts<TData = Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError = HTTPValidationError>(
 params: undefined |  ListDeliveredEreceiptsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDeliveredEreceipts>>,
          TError,
          Awaited<ReturnType<typeof listDeliveredEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListDeliveredEreceipts<TData = Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError = HTTPValidationError>(
 params?: ListDeliveredEreceiptsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDeliveredEreceipts>>,
          TError,
          Awaited<ReturnType<typeof listDeliveredEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListDeliveredEreceipts<TData = Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError = HTTPValidationError>(
 params?: ListDeliveredEreceiptsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Delivered Ereceipts
 */

export function useListDeliveredEreceipts<TData = Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError = HTTPValidationError>(
 params?: ListDeliveredEreceiptsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDeliveredEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListDeliveredEreceiptsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * SGK hasta haklarÄ± sorgulama endpoint'i
 * @summary Query Patient Rights
 */
export const queryPatientRights = (
    patientRightsQueryRequest: PatientRightsQueryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/patient-rights/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientRightsQueryRequest, signal
    },
      );
    }
  


export const getQueryPatientRightsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof queryPatientRights>>, TError,{data: PatientRightsQueryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof queryPatientRights>>, TError,{data: PatientRightsQueryRequest}, TContext> => {

const mutationKey = ['queryPatientRights'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof queryPatientRights>>, {data: PatientRightsQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  queryPatientRights(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type QueryPatientRightsMutationResult = NonNullable<Awaited<ReturnType<typeof queryPatientRights>>>
    export type QueryPatientRightsMutationBody = PatientRightsQueryRequest
    export type QueryPatientRightsMutationError = HTTPValidationError

    /**
 * @summary Query Patient Rights
 */
export const useQueryPatientRights = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof queryPatientRights>>, TError,{data: PatientRightsQueryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof queryPatientRights>>,
        TError,
        {data: PatientRightsQueryRequest},
        TContext
      > => {

      const mutationOptions = getQueryPatientRightsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow oluÅŸturma endpoint'i
 * @summary Create Sgk Workflow
 */
export const createSgkWorkflow = (
    workflowCreateRequest: WorkflowCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workflowCreateRequest, signal
    },
      );
    }
  


export const getCreateSgkWorkflowMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflow>>, TError,{data: WorkflowCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflow>>, TError,{data: WorkflowCreateRequest}, TContext> => {

const mutationKey = ['createSgkWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkWorkflow>>, {data: WorkflowCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSgkWorkflow(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkWorkflow>>>
    export type CreateSgkWorkflowMutationBody = WorkflowCreateRequest
    export type CreateSgkWorkflowMutationError = HTTPValidationError

    /**
 * @summary Create Sgk Workflow
 */
export const useCreateSgkWorkflow = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflow>>, TError,{data: WorkflowCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkWorkflow>>,
        TError,
        {data: WorkflowCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow gÃ¼ncelleme endpoint'i
 * @summary Update Sgk Workflow
 */
export const updateSgkWorkflow = (
    workflowId: string,
    workflowUpdateRequest: WorkflowUpdateRequest,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/${workflowId}/update`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflowUpdateRequest
    },
      );
    }
  


export const getUpdateSgkWorkflowMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflow>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflow>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext> => {

const mutationKey = ['updateSgkWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSgkWorkflow>>, {workflowId: string;data: WorkflowUpdateRequest}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  updateSgkWorkflow(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof updateSgkWorkflow>>>
    export type UpdateSgkWorkflowMutationBody = WorkflowUpdateRequest
    export type UpdateSgkWorkflowMutationError = HTTPValidationError

    /**
 * @summary Update Sgk Workflow
 */
export const useUpdateSgkWorkflow = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflow>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSgkWorkflow>>,
        TError,
        {workflowId: string;data: WorkflowUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow detaylarÄ± endpoint'i
 * @summary Get Sgk Workflow
 */
export const getSgkWorkflow = (
    workflowId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/${workflowId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSgkWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/sgk/workflow/${workflowId}`
    ] as const;
    }

    
export const getGetSgkWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSgkWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSgkWorkflow>>> = ({ signal }) => getSgkWorkflow(workflowId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSgkWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getSgkWorkflow>>>
export type GetSgkWorkflowQueryError = HTTPValidationError


export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Sgk Workflow
 */

export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSgkWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update workflow status
 * @summary Update Workflow Status
 */
export const updateWorkflowStatus = (
    workflowId: string,
    workflowStatusUpdate: WorkflowStatusUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflows/${workflowId}/status`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflowStatusUpdate
    },
      );
    }
  


export const getUpdateWorkflowStatusMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext> => {

const mutationKey = ['updateWorkflowStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkflowStatus>>, {workflowId: string;data: WorkflowStatusUpdate}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  updateWorkflowStatus(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkflowStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkflowStatus>>>
    export type UpdateWorkflowStatusMutationBody = WorkflowStatusUpdate
    export type UpdateWorkflowStatusMutationError = HTTPValidationError

    /**
 * @summary Update Workflow Status
 */
export const useUpdateWorkflowStatus = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateWorkflowStatus>>,
        TError,
        {workflowId: string;data: WorkflowStatusUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateWorkflowStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Download patient form as PDF
 * @summary Download Patient Form
 */
export const downloadPatientForm = (
    receiptId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipts/${receiptId}/download-patient-form`, method: 'GET', signal
    },
      );
    }
  



export const getDownloadPatientFormQueryKey = (receiptId?: string,) => {
    return [
    `/api/sgk/e-receipts/${receiptId}/download-patient-form`
    ] as const;
    }

    
export const getDownloadPatientFormQueryOptions = <TData = Awaited<ReturnType<typeof downloadPatientForm>>, TError = HTTPValidationError>(receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadPatientFormQueryKey(receiptId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPatientForm>>> = ({ signal }) => downloadPatientForm(receiptId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(receiptId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DownloadPatientFormQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPatientForm>>>
export type DownloadPatientFormQueryError = HTTPValidationError


export function useDownloadPatientForm<TData = Awaited<ReturnType<typeof downloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof downloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDownloadPatientForm<TData = Awaited<ReturnType<typeof downloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof downloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDownloadPatientForm<TData = Awaited<ReturnType<typeof downloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Download Patient Form
 */

export function useDownloadPatientForm<TData = Awaited<ReturnType<typeof downloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDownloadPatientFormQueryOptions(receiptId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Seed Test Patients
 */
export const seedTestPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/seed-test-patients`, method: 'POST', signal
    },
      );
    }
  


export const getSeedTestPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof seedTestPatients>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof seedTestPatients>>, TError,void, TContext> => {

const mutationKey = ['seedTestPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof seedTestPatients>>, void> = () => {
          

          return  seedTestPatients()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof seedTestPatients>>>
    
    export type SeedTestPatientsMutationError = unknown

    /**
 * @summary Seed Test Patients
 */
export const useSeedTestPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof seedTestPatients>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof seedTestPatients>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    