/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  SgkCreateSgkWorkflowBody,
  SgkQueryEReceiptBody,
  SgkQueryPatientRightsBody,
  SgkSeedTestPatientsBody,
  SgkUpdateSgkWorkflowBody,
  SgkUploadAndProcessFilesBody,
  SgkUploadSgkDocumentBody
} from '.././schemas';





/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
    sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/documents`,
      sgkUploadSgkDocumentBody,options
    );
  }



export const getSgkUploadSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext> => {

const mutationKey = ['sgkUploadSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, {data: SgkUploadSgkDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadSgkDocument(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadSgkDocument>>>
    export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody
    export type SgkUploadSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
        TError,
        {data: SgkUploadSgkDocumentBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (
    documentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `/api/sgk/documents/${documentId}`,options
    );
  }



export const getSgkDeleteSgkDocumentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['sgkDeleteSgkDocument'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  sgkDeleteSgkDocument(documentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkDeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>>
    
    export type SgkDeleteSgkDocumentMutationError = AxiosError<unknown>

    /**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const sgkQueryEReceipt = (
    sgkQueryEReceiptBody?: SgkQueryEReceiptBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/e-receipt/query`,
      sgkQueryEReceiptBody,options
    );
  }



export const getSgkQueryEReceiptMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext> => {

const mutationKey = ['sgkQueryEReceipt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryEReceipt>>, {data: SgkQueryEReceiptBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryEReceipt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryEReceipt>>>
    export type SgkQueryEReceiptMutationBody = SgkQueryEReceiptBody
    export type SgkQueryEReceiptMutationError = AxiosError<unknown>

    /**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const useSgkQueryEReceipt = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryEReceipt>>,
        TError,
        {data: SgkQueryEReceiptBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const sgkQueryPatientRights = (
    sgkQueryPatientRightsBody?: SgkQueryPatientRightsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/patient-rights/query`,
      sgkQueryPatientRightsBody,options
    );
  }



export const getSgkQueryPatientRightsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext> => {

const mutationKey = ['sgkQueryPatientRights'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryPatientRights>>, {data: SgkQueryPatientRightsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryPatientRights(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryPatientRightsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryPatientRights>>>
    export type SgkQueryPatientRightsMutationBody = SgkQueryPatientRightsBody
    export type SgkQueryPatientRightsMutationError = AxiosError<unknown>

    /**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const useSgkQueryPatientRights = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryPatientRights>>,
        TError,
        {data: SgkQueryPatientRightsBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryPatientRightsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const sgkSeedTestPatients = (
    sgkSeedTestPatientsBody?: SgkSeedTestPatientsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/seed-test-patients`,
      sgkSeedTestPatientsBody,options
    );
  }



export const getSgkSeedTestPatientsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext> => {

const mutationKey = ['sgkSeedTestPatients'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkSeedTestPatients>>, {data: SgkSeedTestPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkSeedTestPatients(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkSeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkSeedTestPatients>>>
    export type SgkSeedTestPatientsMutationBody = SgkSeedTestPatientsBody
    export type SgkSeedTestPatientsMutationError = AxiosError<unknown>

    /**
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const useSgkSeedTestPatients = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkSeedTestPatients>>,
        TError,
        {data: SgkSeedTestPatientsBody},
        TContext
      > => {

      const mutationOptions = getSgkSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Saves files to a secure temporary path, runs OCR (worker-first) with auto_crop=True
and returns per-file OCR results including patient_info.
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const sgkUploadAndProcessFiles = (
    sgkUploadAndProcessFilesBody?: SgkUploadAndProcessFilesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/upload`,
      sgkUploadAndProcessFilesBody,options
    );
  }



export const getSgkUploadAndProcessFilesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext> => {

const mutationKey = ['sgkUploadAndProcessFiles'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, {data: SgkUploadAndProcessFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadAndProcessFiles(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadAndProcessFilesMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>>
    export type SgkUploadAndProcessFilesMutationBody = SgkUploadAndProcessFilesBody
    export type SgkUploadAndProcessFilesMutationError = AxiosError<unknown>

    /**
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const useSgkUploadAndProcessFiles = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
        TError,
        {data: SgkUploadAndProcessFilesBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadAndProcessFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const sgkCreateSgkWorkflow = (
    sgkCreateSgkWorkflowBody?: SgkCreateSgkWorkflowBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/sgk/workflow/create`,
      sgkCreateSgkWorkflowBody,options
    );
  }



export const getSgkCreateSgkWorkflowMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkCreateSgkWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, {data: SgkCreateSgkWorkflowBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkCreateSgkWorkflow(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkCreateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>>
    export type SgkCreateSgkWorkflowMutationBody = SgkCreateSgkWorkflowBody
    export type SgkCreateSgkWorkflowMutationError = AxiosError<unknown>

    /**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const useSgkCreateSgkWorkflow = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
        TError,
        {data: SgkCreateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkCreateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */
export const sgkGetSgkWorkflow = (
    workflowId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/sgk/workflow/${workflowId}`,options
    );
  }




export const getSgkGetSgkWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/sgk/workflow/${workflowId}`
    ] as const;
    }

    
export const getSgkGetSgkWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetSgkWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>> = ({ signal }) => sgkGetSgkWorkflow(workflowId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetSgkWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>>
export type SgkGetSgkWorkflowQueryError = AxiosError<unknown>


export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */

export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = AxiosError<unknown>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetSgkWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const sgkUpdateSgkWorkflow = (
    workflowId: string,
    sgkUpdateSgkWorkflowBody?: SgkUpdateSgkWorkflowBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.put(
      `/api/sgk/workflow/${workflowId}/update`,
      sgkUpdateSgkWorkflowBody,options
    );
  }



export const getSgkUpdateSgkWorkflowMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkUpdateSgkWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, {workflowId: string;data: SgkUpdateSgkWorkflowBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  sgkUpdateSgkWorkflow(workflowId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUpdateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>>
    export type SgkUpdateSgkWorkflowMutationBody = SgkUpdateSgkWorkflowBody
    export type SgkUpdateSgkWorkflowMutationError = AxiosError<unknown>

    /**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const useSgkUpdateSgkWorkflow = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
        TError,
        {workflowId: string;data: SgkUpdateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkUpdateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    