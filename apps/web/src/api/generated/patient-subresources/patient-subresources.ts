/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EReceiptCreate,
  EReceiptUpdate,
  HTTPValidationError,
  HearingTestCreate,
  HearingTestUpdate,
  PatientNoteCreate,
  PatientNoteUpdate,
  ResponseEnvelopeListDeviceAssignmentRead
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Get all devices assigned to a specific patient
 * @summary Get Patient Devices
 */
export const listPatientDevices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListDeviceAssignmentRead>(
      {url: `/api/patients/${patientId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getListPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof listPatientDevices>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientDevices>>> = ({ signal }) => listPatientDevices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientDevices>>>
export type ListPatientDevicesQueryError = HTTPValidationError


export function useListPatientDevices<TData = Awaited<ReturnType<typeof listPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof listPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientDevices<TData = Awaited<ReturnType<typeof listPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof listPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientDevices<TData = Awaited<ReturnType<typeof listPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Devices
 */

export function useListPatientDevices<TData = Awaited<ReturnType<typeof listPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all hearing tests for a patient
 * @summary Get Patient Hearing Tests
 */
export const listPatientHearingTests = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientHearingTestsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/hearing-tests`
    ] as const;
    }

    
export const getListPatientHearingTestsQueryOptions = <TData = Awaited<ReturnType<typeof listPatientHearingTests>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientHearingTestsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientHearingTests>>> = ({ signal }) => listPatientHearingTests(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientHearingTestsQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientHearingTests>>>
export type ListPatientHearingTestsQueryError = HTTPValidationError


export function useListPatientHearingTests<TData = Awaited<ReturnType<typeof listPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof listPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientHearingTests<TData = Awaited<ReturnType<typeof listPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof listPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientHearingTests<TData = Awaited<ReturnType<typeof listPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Hearing Tests
 */

export function useListPatientHearingTests<TData = Awaited<ReturnType<typeof listPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientHearingTestsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add a new hearing test to patient
 * @summary Add Patient Hearing Test
 */
export const createPatientHearingTests = (
    patientId: string,
    hearingTestCreate: HearingTestCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestCreate, signal
    },
      );
    }
  


export const getCreatePatientHearingTestsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientHearingTests>>, TError,{patientId: string;data: HearingTestCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPatientHearingTests>>, TError,{patientId: string;data: HearingTestCreate}, TContext> => {

const mutationKey = ['createPatientHearingTests'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPatientHearingTests>>, {patientId: string;data: HearingTestCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  createPatientHearingTests(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePatientHearingTestsMutationResult = NonNullable<Awaited<ReturnType<typeof createPatientHearingTests>>>
    export type CreatePatientHearingTestsMutationBody = HearingTestCreate
    export type CreatePatientHearingTestsMutationError = HTTPValidationError

    /**
 * @summary Add Patient Hearing Test
 */
export const useCreatePatientHearingTests = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientHearingTests>>, TError,{patientId: string;data: HearingTestCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPatientHearingTests>>,
        TError,
        {patientId: string;data: HearingTestCreate},
        TContext
      > => {

      const mutationOptions = getCreatePatientHearingTestsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a hearing test
 * @summary Update Patient Hearing Test
 */
export const updatePatientHearingTest = (
    patientId: string,
    testId: string,
    hearingTestUpdate: HearingTestUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestUpdate
    },
      );
    }
  


export const getUpdatePatientHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext> => {

const mutationKey = ['updatePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientHearingTest>>, {patientId: string;testId: string;data: HearingTestUpdate}> = (props) => {
          const {patientId,testId,data} = props ?? {};

          return  updatePatientHearingTest(patientId,testId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientHearingTest>>>
    export type UpdatePatientHearingTestMutationBody = HearingTestUpdate
    export type UpdatePatientHearingTestMutationError = HTTPValidationError

    /**
 * @summary Update Patient Hearing Test
 */
export const useUpdatePatientHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientHearingTest>>,
        TError,
        {patientId: string;testId: string;data: HearingTestUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a hearing test
 * @summary Delete Patient Hearing Test
 */
export const deletePatientHearingTest = (
    patientId: string,
    testId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['deletePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  deletePatientHearingTest(patientId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientHearingTest>>>
    
    export type DeletePatientHearingTestMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Hearing Test
 */
export const useDeletePatientHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all notes for a patient
 * @summary Get Patient Notes
 */
export const listPatientNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/notes`
    ] as const;
    }

    
export const getListPatientNotesQueryOptions = <TData = Awaited<ReturnType<typeof listPatientNotes>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientNotes>>> = ({ signal }) => listPatientNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientNotesQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientNotes>>>
export type ListPatientNotesQueryError = HTTPValidationError


export function useListPatientNotes<TData = Awaited<ReturnType<typeof listPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof listPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientNotes<TData = Awaited<ReturnType<typeof listPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof listPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientNotes<TData = Awaited<ReturnType<typeof listPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Notes
 */

export function useListPatientNotes<TData = Awaited<ReturnType<typeof listPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new note for patient
 * @summary Create Patient Note
 */
export const createPatientNotes = (
    patientId: string,
    patientNoteCreate: PatientNoteCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteCreate, signal
    },
      );
    }
  


export const getCreatePatientNotesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientNotes>>, TError,{patientId: string;data: PatientNoteCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPatientNotes>>, TError,{patientId: string;data: PatientNoteCreate}, TContext> => {

const mutationKey = ['createPatientNotes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPatientNotes>>, {patientId: string;data: PatientNoteCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  createPatientNotes(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePatientNotesMutationResult = NonNullable<Awaited<ReturnType<typeof createPatientNotes>>>
    export type CreatePatientNotesMutationBody = PatientNoteCreate
    export type CreatePatientNotesMutationError = HTTPValidationError

    /**
 * @summary Create Patient Note
 */
export const useCreatePatientNotes = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientNotes>>, TError,{patientId: string;data: PatientNoteCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPatientNotes>>,
        TError,
        {patientId: string;data: PatientNoteCreate},
        TContext
      > => {

      const mutationOptions = getCreatePatientNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a patient note
 * @summary Update Patient Note
 */
export const updatePatientNote = (
    patientId: string,
    noteId: string,
    patientNoteUpdate: PatientNoteUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteUpdate
    },
      );
    }
  


export const getUpdatePatientNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext> => {

const mutationKey = ['updatePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientNote>>, {patientId: string;noteId: string;data: PatientNoteUpdate}> = (props) => {
          const {patientId,noteId,data} = props ?? {};

          return  updatePatientNote(patientId,noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientNote>>>
    export type UpdatePatientNoteMutationBody = PatientNoteUpdate
    export type UpdatePatientNoteMutationError = HTTPValidationError

    /**
 * @summary Update Patient Note
 */
export const useUpdatePatientNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientNote>>,
        TError,
        {patientId: string;noteId: string;data: PatientNoteUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a patient note
 * @summary Delete Patient Note
 */
export const deletePatientNote = (
    patientId: string,
    noteId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['deletePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  deletePatientNote(patientId,noteId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientNote>>>
    
    export type DeletePatientNoteMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Note
 */
export const useDeletePatientNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all e-receipts for a patient
 * @summary Get Patient Ereceipts
 */
export const listPatientEreceipts = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientEreceiptsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/ereceipts`
    ] as const;
    }

    
export const getListPatientEreceiptsQueryOptions = <TData = Awaited<ReturnType<typeof listPatientEreceipts>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientEreceiptsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientEreceipts>>> = ({ signal }) => listPatientEreceipts(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientEreceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientEreceipts>>>
export type ListPatientEreceiptsQueryError = HTTPValidationError


export function useListPatientEreceipts<TData = Awaited<ReturnType<typeof listPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof listPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientEreceipts<TData = Awaited<ReturnType<typeof listPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof listPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientEreceipts<TData = Awaited<ReturnType<typeof listPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Ereceipts
 */

export function useListPatientEreceipts<TData = Awaited<ReturnType<typeof listPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientEreceiptsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new e-receipt for patient
 * @summary Create Patient Ereceipt
 */
export const createPatientEreceipts = (
    patientId: string,
    eReceiptCreate: EReceiptCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptCreate, signal
    },
      );
    }
  


export const getCreatePatientEreceiptsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipts>>, TError,{patientId: string;data: EReceiptCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipts>>, TError,{patientId: string;data: EReceiptCreate}, TContext> => {

const mutationKey = ['createPatientEreceipts'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPatientEreceipts>>, {patientId: string;data: EReceiptCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  createPatientEreceipts(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePatientEreceiptsMutationResult = NonNullable<Awaited<ReturnType<typeof createPatientEreceipts>>>
    export type CreatePatientEreceiptsMutationBody = EReceiptCreate
    export type CreatePatientEreceiptsMutationError = HTTPValidationError

    /**
 * @summary Create Patient Ereceipt
 */
export const useCreatePatientEreceipts = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipts>>, TError,{patientId: string;data: EReceiptCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPatientEreceipts>>,
        TError,
        {patientId: string;data: EReceiptCreate},
        TContext
      > => {

      const mutationOptions = getCreatePatientEreceiptsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update an e-receipt
 * @summary Update Patient Ereceipt
 */
export const updatePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
    eReceiptUpdate: EReceiptUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptUpdate
    },
      );
    }
  


export const getUpdatePatientEreceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext> => {

const mutationKey = ['updatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientEreceipt>>, {patientId: string;ereceiptId: string;data: EReceiptUpdate}> = (props) => {
          const {patientId,ereceiptId,data} = props ?? {};

          return  updatePatientEreceipt(patientId,ereceiptId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientEreceipt>>>
    export type UpdatePatientEreceiptMutationBody = EReceiptUpdate
    export type UpdatePatientEreceiptMutationError = HTTPValidationError

    /**
 * @summary Update Patient Ereceipt
 */
export const useUpdatePatientEreceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string;data: EReceiptUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an e-receipt
 * @summary Delete Patient Ereceipt
 */
export const deletePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientEreceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['deletePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  deletePatientEreceipt(patientId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientEreceipt>>>
    
    export type DeletePatientEreceiptMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Ereceipt
 */
export const useDeletePatientEreceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all sales for a specific patient - Flask parity
 * @summary Get Patient Sales
 */
export const listPatientSales = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/sales`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getListPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof listPatientSales>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientSales>>> = ({ signal }) => listPatientSales(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientSales>>>
export type ListPatientSalesQueryError = HTTPValidationError


export function useListPatientSales<TData = Awaited<ReturnType<typeof listPatientSales>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientSales>>,
          TError,
          Awaited<ReturnType<typeof listPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientSales<TData = Awaited<ReturnType<typeof listPatientSales>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientSales>>,
          TError,
          Awaited<ReturnType<typeof listPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientSales<TData = Awaited<ReturnType<typeof listPatientSales>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Sales
 */

export function useListPatientSales<TData = Awaited<ReturnType<typeof listPatientSales>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all appointments for a specific patient
 * @summary Get Patient Appointments
 */
export const listPatientAppointments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getListPatientAppointmentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/appointments`
    ] as const;
    }

    
export const getListPatientAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof listPatientAppointments>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPatientAppointmentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPatientAppointments>>> = ({ signal }) => listPatientAppointments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPatientAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof listPatientAppointments>>>
export type ListPatientAppointmentsQueryError = HTTPValidationError


export function useListPatientAppointments<TData = Awaited<ReturnType<typeof listPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof listPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientAppointments<TData = Awaited<ReturnType<typeof listPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof listPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPatientAppointments<TData = Awaited<ReturnType<typeof listPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Appointments
 */

export function useListPatientAppointments<TData = Awaited<ReturnType<typeof listPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPatientAppointmentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




