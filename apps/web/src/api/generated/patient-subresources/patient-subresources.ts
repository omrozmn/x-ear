/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EReceiptCreate,
  EReceiptUpdate,
  HTTPValidationError,
  HearingTestCreate,
  HearingTestUpdate,
  PatientNoteCreate,
  PatientNoteUpdate,
  ResponseEnvelopeListDeviceAssignmentRead
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Get all devices assigned to a specific patient
 * @summary Get Patient Devices
 */
export const getPatientDevices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListDeviceAssignmentRead>(
      {url: `/api/patients/${patientId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof getPatientDevices>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientDevices>>> = ({ signal }) => getPatientDevices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientDevices>>>
export type GetPatientDevicesQueryError = HTTPValidationError


export function useGetPatientDevices<TData = Awaited<ReturnType<typeof getPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof getPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientDevices<TData = Awaited<ReturnType<typeof getPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof getPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientDevices<TData = Awaited<ReturnType<typeof getPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Devices
 */

export function useGetPatientDevices<TData = Awaited<ReturnType<typeof getPatientDevices>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all hearing tests for a patient
 * @summary Get Patient Hearing Tests
 */
export const getPatientHearingTests = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientHearingTestsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/hearing-tests`
    ] as const;
    }

    
export const getGetPatientHearingTestsQueryOptions = <TData = Awaited<ReturnType<typeof getPatientHearingTests>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientHearingTestsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientHearingTests>>> = ({ signal }) => getPatientHearingTests(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientHearingTestsQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientHearingTests>>>
export type GetPatientHearingTestsQueryError = HTTPValidationError


export function useGetPatientHearingTests<TData = Awaited<ReturnType<typeof getPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof getPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientHearingTests<TData = Awaited<ReturnType<typeof getPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof getPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientHearingTests<TData = Awaited<ReturnType<typeof getPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Hearing Tests
 */

export function useGetPatientHearingTests<TData = Awaited<ReturnType<typeof getPatientHearingTests>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientHearingTestsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add a new hearing test to patient
 * @summary Add Patient Hearing Test
 */
export const addPatientHearingTest = (
    patientId: string,
    hearingTestCreate: HearingTestCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestCreate, signal
    },
      );
    }
  


export const getAddPatientHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPatientHearingTest>>, TError,{patientId: string;data: HearingTestCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addPatientHearingTest>>, TError,{patientId: string;data: HearingTestCreate}, TContext> => {

const mutationKey = ['addPatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPatientHearingTest>>, {patientId: string;data: HearingTestCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  addPatientHearingTest(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof addPatientHearingTest>>>
    export type AddPatientHearingTestMutationBody = HearingTestCreate
    export type AddPatientHearingTestMutationError = HTTPValidationError

    /**
 * @summary Add Patient Hearing Test
 */
export const useAddPatientHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPatientHearingTest>>, TError,{patientId: string;data: HearingTestCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addPatientHearingTest>>,
        TError,
        {patientId: string;data: HearingTestCreate},
        TContext
      > => {

      const mutationOptions = getAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a hearing test
 * @summary Update Patient Hearing Test
 */
export const updatePatientHearingTest = (
    patientId: string,
    testId: string,
    hearingTestUpdate: HearingTestUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: hearingTestUpdate
    },
      );
    }
  


export const getUpdatePatientHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext> => {

const mutationKey = ['updatePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientHearingTest>>, {patientId: string;testId: string;data: HearingTestUpdate}> = (props) => {
          const {patientId,testId,data} = props ?? {};

          return  updatePatientHearingTest(patientId,testId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientHearingTest>>>
    export type UpdatePatientHearingTestMutationBody = HearingTestUpdate
    export type UpdatePatientHearingTestMutationError = HTTPValidationError

    /**
 * @summary Update Patient Hearing Test
 */
export const useUpdatePatientHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientHearingTest>>, TError,{patientId: string;testId: string;data: HearingTestUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientHearingTest>>,
        TError,
        {patientId: string;testId: string;data: HearingTestUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a hearing test
 * @summary Delete Patient Hearing Test
 */
export const deletePatientHearingTest = (
    patientId: string,
    testId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientHearingTestMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['deletePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  deletePatientHearingTest(patientId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientHearingTest>>>
    
    export type DeletePatientHearingTestMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Hearing Test
 */
export const useDeletePatientHearingTest = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all notes for a patient
 * @summary Get Patient Notes
 */
export const getPatientNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/notes`
    ] as const;
    }

    
export const getGetPatientNotesQueryOptions = <TData = Awaited<ReturnType<typeof getPatientNotes>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientNotes>>> = ({ signal }) => getPatientNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientNotesQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientNotes>>>
export type GetPatientNotesQueryError = HTTPValidationError


export function useGetPatientNotes<TData = Awaited<ReturnType<typeof getPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof getPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientNotes<TData = Awaited<ReturnType<typeof getPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof getPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientNotes<TData = Awaited<ReturnType<typeof getPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Notes
 */

export function useGetPatientNotes<TData = Awaited<ReturnType<typeof getPatientNotes>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new note for patient
 * @summary Create Patient Note
 */
export const createPatientNote = (
    patientId: string,
    patientNoteCreate: PatientNoteCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteCreate, signal
    },
      );
    }
  


export const getCreatePatientNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientNote>>, TError,{patientId: string;data: PatientNoteCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPatientNote>>, TError,{patientId: string;data: PatientNoteCreate}, TContext> => {

const mutationKey = ['createPatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPatientNote>>, {patientId: string;data: PatientNoteCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  createPatientNote(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof createPatientNote>>>
    export type CreatePatientNoteMutationBody = PatientNoteCreate
    export type CreatePatientNoteMutationError = HTTPValidationError

    /**
 * @summary Create Patient Note
 */
export const useCreatePatientNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientNote>>, TError,{patientId: string;data: PatientNoteCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPatientNote>>,
        TError,
        {patientId: string;data: PatientNoteCreate},
        TContext
      > => {

      const mutationOptions = getCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a patient note
 * @summary Update Patient Note
 */
export const updatePatientNote = (
    patientId: string,
    noteId: string,
    patientNoteUpdate: PatientNoteUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteUpdate
    },
      );
    }
  


export const getUpdatePatientNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext> => {

const mutationKey = ['updatePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientNote>>, {patientId: string;noteId: string;data: PatientNoteUpdate}> = (props) => {
          const {patientId,noteId,data} = props ?? {};

          return  updatePatientNote(patientId,noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientNote>>>
    export type UpdatePatientNoteMutationBody = PatientNoteUpdate
    export type UpdatePatientNoteMutationError = HTTPValidationError

    /**
 * @summary Update Patient Note
 */
export const useUpdatePatientNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientNote>>,
        TError,
        {patientId: string;noteId: string;data: PatientNoteUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a patient note
 * @summary Delete Patient Note
 */
export const deletePatientNote = (
    patientId: string,
    noteId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['deletePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  deletePatientNote(patientId,noteId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientNote>>>
    
    export type DeletePatientNoteMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Note
 */
export const useDeletePatientNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all e-receipts for a patient
 * @summary Get Patient Ereceipts
 */
export const getPatientEreceipts = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientEreceiptsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/ereceipts`
    ] as const;
    }

    
export const getGetPatientEreceiptsQueryOptions = <TData = Awaited<ReturnType<typeof getPatientEreceipts>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientEreceiptsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientEreceipts>>> = ({ signal }) => getPatientEreceipts(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientEreceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientEreceipts>>>
export type GetPatientEreceiptsQueryError = HTTPValidationError


export function useGetPatientEreceipts<TData = Awaited<ReturnType<typeof getPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof getPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientEreceipts<TData = Awaited<ReturnType<typeof getPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof getPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientEreceipts<TData = Awaited<ReturnType<typeof getPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Ereceipts
 */

export function useGetPatientEreceipts<TData = Awaited<ReturnType<typeof getPatientEreceipts>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientEreceiptsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new e-receipt for patient
 * @summary Create Patient Ereceipt
 */
export const createPatientEreceipt = (
    patientId: string,
    eReceiptCreate: EReceiptCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptCreate, signal
    },
      );
    }
  


export const getCreatePatientEreceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipt>>, TError,{patientId: string;data: EReceiptCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipt>>, TError,{patientId: string;data: EReceiptCreate}, TContext> => {

const mutationKey = ['createPatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPatientEreceipt>>, {patientId: string;data: EReceiptCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  createPatientEreceipt(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof createPatientEreceipt>>>
    export type CreatePatientEreceiptMutationBody = EReceiptCreate
    export type CreatePatientEreceiptMutationError = HTTPValidationError

    /**
 * @summary Create Patient Ereceipt
 */
export const useCreatePatientEreceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPatientEreceipt>>, TError,{patientId: string;data: EReceiptCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPatientEreceipt>>,
        TError,
        {patientId: string;data: EReceiptCreate},
        TContext
      > => {

      const mutationOptions = getCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update an e-receipt
 * @summary Update Patient Ereceipt
 */
export const updatePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
    eReceiptUpdate: EReceiptUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptUpdate
    },
      );
    }
  


export const getUpdatePatientEreceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext> => {

const mutationKey = ['updatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePatientEreceipt>>, {patientId: string;ereceiptId: string;data: EReceiptUpdate}> = (props) => {
          const {patientId,ereceiptId,data} = props ?? {};

          return  updatePatientEreceipt(patientId,ereceiptId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof updatePatientEreceipt>>>
    export type UpdatePatientEreceiptMutationBody = EReceiptUpdate
    export type UpdatePatientEreceiptMutationError = HTTPValidationError

    /**
 * @summary Update Patient Ereceipt
 */
export const useUpdatePatientEreceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: EReceiptUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string;data: EReceiptUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an e-receipt
 * @summary Delete Patient Ereceipt
 */
export const deletePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePatientEreceiptMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['deletePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  deletePatientEreceipt(patientId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof deletePatientEreceipt>>>
    
    export type DeletePatientEreceiptMutationError = HTTPValidationError

    /**
 * @summary Delete Patient Ereceipt
 */
export const useDeletePatientEreceipt = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all appointments for a specific patient
 * @summary Get Patient Appointments
 */
export const getPatientAppointments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/patients/${patientId}/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getGetPatientAppointmentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/appointments`
    ] as const;
    }

    
export const getGetPatientAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof getPatientAppointments>>, TError = HTTPValidationError>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPatientAppointmentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPatientAppointments>>> = ({ signal }) => getPatientAppointments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPatientAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getPatientAppointments>>>
export type GetPatientAppointmentsQueryError = HTTPValidationError


export function useGetPatientAppointments<TData = Awaited<ReturnType<typeof getPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof getPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientAppointments<TData = Awaited<ReturnType<typeof getPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof getPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPatientAppointments<TData = Awaited<ReturnType<typeof getPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Patient Appointments
 */

export function useGetPatientAppointments<TData = Awaited<ReturnType<typeof getPatientAppointments>>, TError = HTTPValidationError>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPatientAppointmentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




