/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Merged: manual schemas + auto-generated endpoints
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "../../orval-mutator";

/**
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntities = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/entities`,
    method: "POST",
    signal,
  });
};

export const getOcrExtractEntitiesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractEntities>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrExtractEntities"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    void
  > = () => {
    return ocrExtractEntities();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractEntitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractEntities>>
>;

export type OcrExtractEntitiesMutationError = unknown;

/**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntities = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractEntities>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractEntities>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrExtractEntitiesMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientName = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/extract_patient`,
    method: "POST",
    signal,
  });
};

export const getOcrExtractPatientNameMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrExtractPatientName>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrExtractPatientName"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    void
  > = () => {
    return ocrExtractPatientName();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrExtractPatientNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrExtractPatientName>>
>;

export type OcrExtractPatientNameMutationError = unknown;

/**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientName = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrExtractPatientName>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrExtractPatientName>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrExtractPatientNameMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheck = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/health`,
    method: "GET",
    signal,
  });
};

export const getOcrHealthCheckQueryKey = () => {
  return [`/api/ocr/health`] as const;
};

export const getOcrHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof ocrHealthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOcrHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheck>>> = ({
    signal,
  }) => ocrHealthCheck(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OcrHealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof ocrHealthCheck>>
>;
export type OcrHealthCheckQueryError = unknown;

/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheck<
  TData = Awaited<ReturnType<typeof ocrHealthCheck>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof ocrHealthCheck>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOcrHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initialize database and create tables
 */
export const ocrInitDatabase = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/init-db`,
    method: "POST",
    signal,
  });
};

export const getOcrInitDatabaseMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitDatabase>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrInitDatabase"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    void
  > = () => {
    return ocrInitDatabase();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitDatabaseMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitDatabase>>
>;

export type OcrInitDatabaseMutationError = unknown;

/**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabase = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitDatabase>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitDatabase>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrInitDatabaseMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Starts model initialization in a background thread so the HTTP request
can return quickly and heavy imports/downloads happen asynchronously.
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const ocrInitializeNlpEndpoint = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/initialize`,
    method: "POST",
    signal,
  });
};

export const getOcrInitializeNlpEndpointMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrInitializeNlpEndpoint"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    void
  > = () => {
    return ocrInitializeNlpEndpoint();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrInitializeNlpEndpointMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>
>;

export type OcrInitializeNlpEndpointMutationError = unknown;

/**
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const useOcrInitializeNlpEndpoint = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrInitializeNlpEndpointMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Accepts either {'image_path1':..., 'image_path2':...} or {'text1':..., 'text2':...}
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const ocrCalculateSimilarity = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/similarity`,
    method: "POST",
    signal,
  });
};

export const getOcrCalculateSimilarityMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrCalculateSimilarity"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    void
  > = () => {
    return ocrCalculateSimilarity();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrCalculateSimilarityMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>
>;

export type OcrCalculateSimilarityMutationError = unknown;

/**
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const useOcrCalculateSimilarity = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrCalculateSimilarityMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Request JSON: { "text": "..." }
Returns: { hf_ner: [...], spacy_entities: [...], tokens: [...] }
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const ocrDebugNer = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/debug_ner`,
    method: "POST",
    signal,
  });
};

export const getOcrDebugNerMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrDebugNer>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrDebugNer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    void
  > = () => {
    return ocrDebugNer();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrDebugNerMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrDebugNer>>
>;

export type OcrDebugNerMutationError = unknown;

/**
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const useOcrDebugNer = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrDebugNer>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrDebugNer>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrDebugNerMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Create a new OCR job
 */
export const ocrCreateJob = (signal?: AbortSignal) => {
  return customInstance<void>({ url: `/api/ocr/jobs`, method: "POST", signal });
};

export const getOcrCreateJobMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ocrCreateJob>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["ocrCreateJob"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    void
  > = () => {
    return ocrCreateJob();
  };

  return { mutationFn, ...mutationOptions };
};

export type OcrCreateJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof ocrCreateJob>>
>;

export type OcrCreateJobMutationError = unknown;

/**
 * @summary Create a new OCR job
 */
export const useOcrCreateJob = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ocrCreateJob>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof ocrCreateJob>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOcrCreateJobMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary POST /api/ocr/process
 */
export const sgkProcessOcr = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/ocr/process`,
    method: "POST",
    signal,
  });
};

export const getSgkProcessOcrMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sgkProcessOcr>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["sgkProcessOcr"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    void
  > = () => {
    return sgkProcessOcr();
  };

  return { mutationFn, ...mutationOptions };
};

export type SgkProcessOcrMutationResult = NonNullable<
  Awaited<ReturnType<typeof sgkProcessOcr>>
>;

export type SgkProcessOcrMutationError = unknown;

/**
 * @summary POST /api/ocr/process
 */
export const useSgkProcessOcr = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sgkProcessOcr>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sgkProcessOcr>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSgkProcessOcrMutationOptions(options);

  return useMutation(mutationOptions);
};
