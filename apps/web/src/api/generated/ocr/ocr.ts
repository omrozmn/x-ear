/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  OcrCalculateSimilarityV2Body,
  OcrCreateJobBody,
  OcrDebugNerBody,
  OcrExtractEntitiesV2Body,
  OcrExtractPatientNameV2Body,
  OcrInitDatabaseV2Body,
  OcrInitializeNlpEndpointV2Body,
  SgkProcessOcrBody
} from '.././schemas';





/**
 * Create new process
 * @summary POST /api/ocr/process
 */
export const sgkProcessOcr = (
    sgkProcessOcrBody?: SgkProcessOcrBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/process`,
      sgkProcessOcrBody,options
    );
  }



export const getSgkProcessOcrMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext> => {

const mutationKey = ['sgkProcessOcr'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkProcessOcr>>, {data: SgkProcessOcrBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkProcessOcr(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkProcessOcrMutationResult = NonNullable<Awaited<ReturnType<typeof sgkProcessOcr>>>
    export type SgkProcessOcrMutationBody = SgkProcessOcrBody
    export type SgkProcessOcrMutationError = AxiosError<unknown>

    /**
 * @summary POST /api/ocr/process
 */
export const useSgkProcessOcr = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkProcessOcr>>, TError,{data: SgkProcessOcrBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkProcessOcr>>,
        TError,
        {data: SgkProcessOcrBody},
        TContext
      > => {

      const mutationOptions = getSgkProcessOcrMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Request JSON: { "text": "..." }
Returns: { hf_ner: [...], spacy_entities: [...], tokens: [...] }
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const ocrDebugNer = (
    ocrDebugNerBody?: OcrDebugNerBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/debug_ner`,
      ocrDebugNerBody,options
    );
  }



export const getOcrDebugNerMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext> => {

const mutationKey = ['ocrDebugNer'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrDebugNer>>, {data: OcrDebugNerBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrDebugNer(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrDebugNerMutationResult = NonNullable<Awaited<ReturnType<typeof ocrDebugNer>>>
    export type OcrDebugNerMutationBody = OcrDebugNerBody
    export type OcrDebugNerMutationError = AxiosError<unknown>

    /**
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const useOcrDebugNer = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrDebugNer>>,
        TError,
        {data: OcrDebugNerBody},
        TContext
      > => {

      const mutationOptions = getOcrDebugNerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntitiesV2 = (
    ocrExtractEntitiesV2Body?: OcrExtractEntitiesV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/entities`,
      ocrExtractEntitiesV2Body,options
    );
  }



export const getOcrExtractEntitiesV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext> => {

const mutationKey = ['ocrExtractEntitiesV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, {data: OcrExtractEntitiesV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractEntitiesV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractEntitiesV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>>
    export type OcrExtractEntitiesV2MutationBody = OcrExtractEntitiesV2Body
    export type OcrExtractEntitiesV2MutationError = AxiosError<unknown>

    /**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntitiesV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntitiesV2>>, TError,{data: OcrExtractEntitiesV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractEntitiesV2>>,
        TError,
        {data: OcrExtractEntitiesV2Body},
        TContext
      > => {

      const mutationOptions = getOcrExtractEntitiesV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientNameV2 = (
    ocrExtractPatientNameV2Body?: OcrExtractPatientNameV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/extract_patient`,
      ocrExtractPatientNameV2Body,options
    );
  }



export const getOcrExtractPatientNameV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext> => {

const mutationKey = ['ocrExtractPatientNameV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, {data: OcrExtractPatientNameV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractPatientNameV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractPatientNameV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>>
    export type OcrExtractPatientNameV2MutationBody = OcrExtractPatientNameV2Body
    export type OcrExtractPatientNameV2MutationError = AxiosError<unknown>

    /**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientNameV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientNameV2>>, TError,{data: OcrExtractPatientNameV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractPatientNameV2>>,
        TError,
        {data: OcrExtractPatientNameV2Body},
        TContext
      > => {

      const mutationOptions = getOcrExtractPatientNameV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheckApi = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/ocr/health`,options
    );
  }




export const getOcrHealthCheckApiQueryKey = () => {
    return [
    `/api/ocr/health`
    ] as const;
    }

    
export const getOcrHealthCheckApiQueryOptions = <TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOcrHealthCheckApiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheckApi>>> = ({ signal }) => ocrHealthCheckApi({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type OcrHealthCheckApiQueryResult = NonNullable<Awaited<ReturnType<typeof ocrHealthCheckApi>>>
export type OcrHealthCheckApiQueryError = AxiosError<unknown>


export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheckApi>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheckApi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheckApi>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheckApi>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheckApi<TData = Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheckApi>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getOcrHealthCheckApiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Initialize database and create tables
 */
export const ocrInitDatabaseV2 = (
    ocrInitDatabaseV2Body?: OcrInitDatabaseV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/init-db`,
      ocrInitDatabaseV2Body,options
    );
  }



export const getOcrInitDatabaseV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext> => {

const mutationKey = ['ocrInitDatabaseV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, {data: OcrInitDatabaseV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitDatabaseV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitDatabaseV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitDatabaseV2>>>
    export type OcrInitDatabaseV2MutationBody = OcrInitDatabaseV2Body
    export type OcrInitDatabaseV2MutationError = AxiosError<unknown>

    /**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabaseV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabaseV2>>, TError,{data: OcrInitDatabaseV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitDatabaseV2>>,
        TError,
        {data: OcrInitDatabaseV2Body},
        TContext
      > => {

      const mutationOptions = getOcrInitDatabaseV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Starts model initialization in a background thread so the HTTP request
can return quickly and heavy imports/downloads happen asynchronously.
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const ocrInitializeNlpEndpointV2 = (
    ocrInitializeNlpEndpointV2Body?: OcrInitializeNlpEndpointV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/initialize`,
      ocrInitializeNlpEndpointV2Body,options
    );
  }



export const getOcrInitializeNlpEndpointV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext> => {

const mutationKey = ['ocrInitializeNlpEndpointV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, {data: OcrInitializeNlpEndpointV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitializeNlpEndpointV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitializeNlpEndpointV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>>
    export type OcrInitializeNlpEndpointV2MutationBody = OcrInitializeNlpEndpointV2Body
    export type OcrInitializeNlpEndpointV2MutationError = AxiosError<unknown>

    /**
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const useOcrInitializeNlpEndpointV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>, TError,{data: OcrInitializeNlpEndpointV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitializeNlpEndpointV2>>,
        TError,
        {data: OcrInitializeNlpEndpointV2Body},
        TContext
      > => {

      const mutationOptions = getOcrInitializeNlpEndpointV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Create a new OCR job
 */
export const ocrCreateJob = (
    ocrCreateJobBody?: OcrCreateJobBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/jobs`,
      ocrCreateJobBody,options
    );
  }



export const getOcrCreateJobMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext> => {

const mutationKey = ['ocrCreateJob'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCreateJob>>, {data: OcrCreateJobBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrCreateJob(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCreateJobMutationResult = NonNullable<Awaited<ReturnType<typeof ocrCreateJob>>>
    export type OcrCreateJobMutationBody = OcrCreateJobBody
    export type OcrCreateJobMutationError = AxiosError<unknown>

    /**
 * @summary Create a new OCR job
 */
export const useOcrCreateJob = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCreateJob>>, TError,{data: OcrCreateJobBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCreateJob>>,
        TError,
        {data: OcrCreateJobBody},
        TContext
      > => {

      const mutationOptions = getOcrCreateJobMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Accepts either {'image_path1':..., 'image_path2':...} or {'text1':..., 'text2':...}
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const ocrCalculateSimilarityV2 = (
    ocrCalculateSimilarityV2Body?: OcrCalculateSimilarityV2Body, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/ocr/similarity`,
      ocrCalculateSimilarityV2Body,options
    );
  }



export const getOcrCalculateSimilarityV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext> => {

const mutationKey = ['ocrCalculateSimilarityV2'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, {data: OcrCalculateSimilarityV2Body}> = (props) => {
          const {data} = props ?? {};

          return  ocrCalculateSimilarityV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCalculateSimilarityV2MutationResult = NonNullable<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>>
    export type OcrCalculateSimilarityV2MutationBody = OcrCalculateSimilarityV2Body
    export type OcrCalculateSimilarityV2MutationError = AxiosError<unknown>

    /**
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const useOcrCalculateSimilarityV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>, TError,{data: OcrCalculateSimilarityV2Body}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCalculateSimilarityV2>>,
        TError,
        {data: OcrCalculateSimilarityV2Body},
        TContext
      > => {

      const mutationOptions = getOcrCalculateSimilarityV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    