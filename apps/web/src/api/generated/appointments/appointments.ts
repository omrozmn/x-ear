/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AppointmentCreate,
  AppointmentUpdate,
  GetAppointmentsParams,
  GetAvailabilityParams,
  HTTPValidationError,
  ListAppointmentsParams,
  RescheduleRequest,
  ResponseEnvelopeAppointmentRead,
  ResponseEnvelopeListAppointmentRead
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Get appointments with filtering and pagination
 * @summary Get Appointments
 */
export const getAppointments = (
    params?: GetAppointmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListAppointmentRead>(
      {url: `/api/appointments`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAppointmentsQueryKey = (params?: GetAppointmentsParams,) => {
    return [
    `/api/appointments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof getAppointments>>, TError = HTTPValidationError>(params?: GetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppointmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppointments>>> = ({ signal }) => getAppointments(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getAppointments>>>
export type GetAppointmentsQueryError = HTTPValidationError


export function useGetAppointments<TData = Awaited<ReturnType<typeof getAppointments>>, TError = HTTPValidationError>(
 params: undefined |  GetAppointmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointments>>,
          TError,
          Awaited<ReturnType<typeof getAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointments<TData = Awaited<ReturnType<typeof getAppointments>>, TError = HTTPValidationError>(
 params?: GetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointments>>,
          TError,
          Awaited<ReturnType<typeof getAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointments<TData = Awaited<ReturnType<typeof getAppointments>>, TError = HTTPValidationError>(
 params?: GetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Appointments
 */

export function useGetAppointments<TData = Awaited<ReturnType<typeof getAppointments>>, TError = HTTPValidationError>(
 params?: GetAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppointmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new appointment
 * @summary Create Appointment
 */
export const createAppointment = (
    appointmentCreate: AppointmentCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentCreate, signal
    },
      );
    }
  


export const getCreateAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointment>>, TError,{data: AppointmentCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAppointment>>, TError,{data: AppointmentCreate}, TContext> => {

const mutationKey = ['createAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppointment>>, {data: AppointmentCreate}> = (props) => {
          const {data} = props ?? {};

          return  createAppointment(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof createAppointment>>>
    export type CreateAppointmentMutationBody = AppointmentCreate
    export type CreateAppointmentMutationError = HTTPValidationError

    /**
 * @summary Create Appointment
 */
export const useCreateAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointment>>, TError,{data: AppointmentCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppointment>>,
        TError,
        {data: AppointmentCreate},
        TContext
      > => {

      const mutationOptions = getCreateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a single appointment
 * @summary Get Appointment
 */
export const getAppointment = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAppointmentQueryKey = (appointmentId?: string,) => {
    return [
    `/api/appointments/${appointmentId}`
    ] as const;
    }

    
export const getGetAppointmentQueryOptions = <TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppointmentQueryKey(appointmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppointment>>> = ({ signal }) => getAppointment(appointmentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(appointmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppointmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAppointment>>>
export type GetAppointmentQueryError = HTTPValidationError


export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Appointment
 */

export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppointmentQueryOptions(appointmentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update appointment
 * @summary Update Appointment
 */
export const updateAppointment = (
    appointmentId: string,
    appointmentUpdate: AppointmentUpdate,
 ) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: appointmentUpdate
    },
      );
    }
  


export const getUpdateAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext> => {

const mutationKey = ['updateAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAppointment>>, {appointmentId: string;data: AppointmentUpdate}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  updateAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateAppointment>>>
    export type UpdateAppointmentMutationBody = AppointmentUpdate
    export type UpdateAppointmentMutationError = HTTPValidationError

    /**
 * @summary Update Appointment
 */
export const useUpdateAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an appointment
 * @summary Delete Appointment
 */
export const deleteAppointment = (
    appointmentId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/appointments/${appointmentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['deleteAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  deleteAppointment(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAppointment>>>
    
    export type DeleteAppointmentMutationError = HTTPValidationError

    /**
 * @summary Delete Appointment
 */
export const useDeleteAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Reschedule an appointment
 * @summary Reschedule Appointment
 */
export const rescheduleAppointment = (
    appointmentId: string,
    rescheduleRequest: RescheduleRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/reschedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rescheduleRequest, signal
    },
      );
    }
  


export const getRescheduleAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rescheduleAppointment>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rescheduleAppointment>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext> => {

const mutationKey = ['rescheduleAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rescheduleAppointment>>, {appointmentId: string;data: RescheduleRequest}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  rescheduleAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RescheduleAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof rescheduleAppointment>>>
    export type RescheduleAppointmentMutationBody = RescheduleRequest
    export type RescheduleAppointmentMutationError = HTTPValidationError

    /**
 * @summary Reschedule Appointment
 */
export const useRescheduleAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rescheduleAppointment>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rescheduleAppointment>>,
        TError,
        {appointmentId: string;data: RescheduleRequest},
        TContext
      > => {

      const mutationOptions = getRescheduleAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel an appointment
 * @summary Cancel Appointment
 */
export const cancelAppointment = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/cancel`, method: 'POST', signal
    },
      );
    }
  


export const getCancelAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelAppointment>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['cancelAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  cancelAppointment(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof cancelAppointment>>>
    
    export type CancelAppointmentMutationError = HTTPValidationError

    /**
 * @summary Cancel Appointment
 */
export const useCancelAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelAppointment>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getCancelAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark appointment as completed
 * @summary Complete Appointment
 */
export const completeAppointment = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/complete`, method: 'POST', signal
    },
      );
    }
  


export const getCompleteAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeAppointment>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof completeAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['completeAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  completeAppointment(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof completeAppointment>>>
    
    export type CompleteAppointmentMutationError = HTTPValidationError

    /**
 * @summary Complete Appointment
 */
export const useCompleteAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeAppointment>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getCompleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get available time slots for a date
 * @summary Get Availability
 */
export const getAvailability = (
    params: GetAvailabilityParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/appointments/availability`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAvailabilityQueryKey = (params?: GetAvailabilityParams,) => {
    return [
    `/api/appointments/availability`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof getAvailability>>, TError = HTTPValidationError>(params: GetAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailabilityQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailability>>> = ({ signal }) => getAvailability(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailability>>>
export type GetAvailabilityQueryError = HTTPValidationError


export function useGetAvailability<TData = Awaited<ReturnType<typeof getAvailability>>, TError = HTTPValidationError>(
 params: GetAvailabilityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailability>>,
          TError,
          Awaited<ReturnType<typeof getAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAvailability<TData = Awaited<ReturnType<typeof getAvailability>>, TError = HTTPValidationError>(
 params: GetAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailability>>,
          TError,
          Awaited<ReturnType<typeof getAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAvailability<TData = Awaited<ReturnType<typeof getAvailability>>, TError = HTTPValidationError>(
 params: GetAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Availability
 */

export function useGetAvailability<TData = Awaited<ReturnType<typeof getAvailability>>, TError = HTTPValidationError>(
 params: GetAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAvailabilityQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List appointments with filters
 * @summary List Appointments
 */
export const listAppointments = (
    params?: ListAppointmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListAppointmentRead>(
      {url: `/api/appointments/list`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAppointmentsQueryKey = (params?: ListAppointmentsParams,) => {
    return [
    `/api/appointments/list`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppointmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppointments>>> = ({ signal }) => listAppointments(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof listAppointments>>>
export type ListAppointmentsQueryError = HTTPValidationError


export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params: undefined |  ListAppointmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointments>>,
          TError,
          Awaited<ReturnType<typeof listAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointments>>,
          TError,
          Awaited<ReturnType<typeof listAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Appointments
 */

export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAppointmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




