/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AppointmentCreate,
  AppointmentUpdate,
  HTTPValidationError,
  ListAppointmentAvailabilityParams,
  ListAppointmentListParams,
  ListAppointmentsParams,
  RescheduleRequest,
  ResponseEnvelopeAppointmentAvailability,
  ResponseEnvelopeAppointmentRead,
  ResponseEnvelopeListAppointmentRead
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Get appointments with filtering and pagination
 * @summary Get Appointments
 */
export const listAppointments = (
    params?: ListAppointmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListAppointmentRead>(
      {url: `/api/appointments`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAppointmentsQueryKey = (params?: ListAppointmentsParams,) => {
    return [
    `/api/appointments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppointmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppointments>>> = ({ signal }) => listAppointments(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof listAppointments>>>
export type ListAppointmentsQueryError = HTTPValidationError


export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params: undefined |  ListAppointmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointments>>,
          TError,
          Awaited<ReturnType<typeof listAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointments>>,
          TError,
          Awaited<ReturnType<typeof listAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Appointments
 */

export function useListAppointments<TData = Awaited<ReturnType<typeof listAppointments>>, TError = HTTPValidationError>(
 params?: ListAppointmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAppointmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new appointment
 * @summary Create Appointment
 */
export const createAppointments = (
    appointmentCreate: AppointmentCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentCreate, signal
    },
      );
    }
  


export const getCreateAppointmentsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointments>>, TError,{data: AppointmentCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAppointments>>, TError,{data: AppointmentCreate}, TContext> => {

const mutationKey = ['createAppointments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppointments>>, {data: AppointmentCreate}> = (props) => {
          const {data} = props ?? {};

          return  createAppointments(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppointmentsMutationResult = NonNullable<Awaited<ReturnType<typeof createAppointments>>>
    export type CreateAppointmentsMutationBody = AppointmentCreate
    export type CreateAppointmentsMutationError = HTTPValidationError

    /**
 * @summary Create Appointment
 */
export const useCreateAppointments = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointments>>, TError,{data: AppointmentCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppointments>>,
        TError,
        {data: AppointmentCreate},
        TContext
      > => {

      const mutationOptions = getCreateAppointmentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a single appointment
 * @summary Get Appointment
 */
export const getAppointment = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAppointmentQueryKey = (appointmentId?: string,) => {
    return [
    `/api/appointments/${appointmentId}`
    ] as const;
    }

    
export const getGetAppointmentQueryOptions = <TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppointmentQueryKey(appointmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppointment>>> = ({ signal }) => getAppointment(appointmentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(appointmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppointmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAppointment>>>
export type GetAppointmentQueryError = HTTPValidationError


export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Appointment
 */

export function useGetAppointment<TData = Awaited<ReturnType<typeof getAppointment>>, TError = HTTPValidationError>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppointmentQueryOptions(appointmentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update appointment
 * @summary Update Appointment
 */
export const updateAppointment = (
    appointmentId: string,
    appointmentUpdate: AppointmentUpdate,
 ) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: appointmentUpdate
    },
      );
    }
  


export const getUpdateAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext> => {

const mutationKey = ['updateAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAppointment>>, {appointmentId: string;data: AppointmentUpdate}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  updateAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateAppointment>>>
    export type UpdateAppointmentMutationBody = AppointmentUpdate
    export type UpdateAppointmentMutationError = HTTPValidationError

    /**
 * @summary Update Appointment
 */
export const useUpdateAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppointment>>, TError,{appointmentId: string;data: AppointmentUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an appointment
 * @summary Delete Appointment
 */
export const deleteAppointment = (
    appointmentId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/appointments/${appointmentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAppointmentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['deleteAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  deleteAppointment(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAppointment>>>
    
    export type DeleteAppointmentMutationError = HTTPValidationError

    /**
 * @summary Delete Appointment
 */
export const useDeleteAppointment = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppointment>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Reschedule an appointment
 * @summary Reschedule Appointment
 */
export const createAppointmentReschedule = (
    appointmentId: string,
    rescheduleRequest: RescheduleRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/reschedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rescheduleRequest, signal
    },
      );
    }
  


export const getCreateAppointmentRescheduleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentReschedule>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAppointmentReschedule>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext> => {

const mutationKey = ['createAppointmentReschedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppointmentReschedule>>, {appointmentId: string;data: RescheduleRequest}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  createAppointmentReschedule(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppointmentRescheduleMutationResult = NonNullable<Awaited<ReturnType<typeof createAppointmentReschedule>>>
    export type CreateAppointmentRescheduleMutationBody = RescheduleRequest
    export type CreateAppointmentRescheduleMutationError = HTTPValidationError

    /**
 * @summary Reschedule Appointment
 */
export const useCreateAppointmentReschedule = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentReschedule>>, TError,{appointmentId: string;data: RescheduleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppointmentReschedule>>,
        TError,
        {appointmentId: string;data: RescheduleRequest},
        TContext
      > => {

      const mutationOptions = getCreateAppointmentRescheduleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel an appointment
 * @summary Cancel Appointment
 */
export const createAppointmentCancel = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/cancel`, method: 'POST', signal
    },
      );
    }
  


export const getCreateAppointmentCancelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentCancel>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAppointmentCancel>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['createAppointmentCancel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppointmentCancel>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  createAppointmentCancel(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppointmentCancelMutationResult = NonNullable<Awaited<ReturnType<typeof createAppointmentCancel>>>
    
    export type CreateAppointmentCancelMutationError = HTTPValidationError

    /**
 * @summary Cancel Appointment
 */
export const useCreateAppointmentCancel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentCancel>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppointmentCancel>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getCreateAppointmentCancelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark appointment as completed
 * @summary Complete Appointment
 */
export const createAppointmentComplete = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentRead>(
      {url: `/api/appointments/${appointmentId}/complete`, method: 'POST', signal
    },
      );
    }
  


export const getCreateAppointmentCompleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentComplete>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAppointmentComplete>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['createAppointmentComplete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppointmentComplete>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  createAppointmentComplete(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppointmentCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof createAppointmentComplete>>>
    
    export type CreateAppointmentCompleteMutationError = HTTPValidationError

    /**
 * @summary Complete Appointment
 */
export const useCreateAppointmentComplete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppointmentComplete>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppointmentComplete>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getCreateAppointmentCompleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get available time slots for a date
 * @summary Get Availability
 */
export const listAppointmentAvailability = (
    params: ListAppointmentAvailabilityParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeAppointmentAvailability>(
      {url: `/api/appointments/availability`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAppointmentAvailabilityQueryKey = (params?: ListAppointmentAvailabilityParams,) => {
    return [
    `/api/appointments/availability`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAppointmentAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof listAppointmentAvailability>>, TError = HTTPValidationError>(params: ListAppointmentAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppointmentAvailabilityQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppointmentAvailability>>> = ({ signal }) => listAppointmentAvailability(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAppointmentAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof listAppointmentAvailability>>>
export type ListAppointmentAvailabilityQueryError = HTTPValidationError


export function useListAppointmentAvailability<TData = Awaited<ReturnType<typeof listAppointmentAvailability>>, TError = HTTPValidationError>(
 params: ListAppointmentAvailabilityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointmentAvailability>>,
          TError,
          Awaited<ReturnType<typeof listAppointmentAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointmentAvailability<TData = Awaited<ReturnType<typeof listAppointmentAvailability>>, TError = HTTPValidationError>(
 params: ListAppointmentAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointmentAvailability>>,
          TError,
          Awaited<ReturnType<typeof listAppointmentAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointmentAvailability<TData = Awaited<ReturnType<typeof listAppointmentAvailability>>, TError = HTTPValidationError>(
 params: ListAppointmentAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Availability
 */

export function useListAppointmentAvailability<TData = Awaited<ReturnType<typeof listAppointmentAvailability>>, TError = HTTPValidationError>(
 params: ListAppointmentAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAppointmentAvailabilityQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List appointments with filters
 * @summary List Appointments
 */
export const listAppointmentList = (
    params?: ListAppointmentListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListAppointmentRead>(
      {url: `/api/appointments/list`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAppointmentListQueryKey = (params?: ListAppointmentListParams,) => {
    return [
    `/api/appointments/list`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAppointmentListQueryOptions = <TData = Awaited<ReturnType<typeof listAppointmentList>>, TError = HTTPValidationError>(params?: ListAppointmentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppointmentListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppointmentList>>> = ({ signal }) => listAppointmentList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAppointmentListQueryResult = NonNullable<Awaited<ReturnType<typeof listAppointmentList>>>
export type ListAppointmentListQueryError = HTTPValidationError


export function useListAppointmentList<TData = Awaited<ReturnType<typeof listAppointmentList>>, TError = HTTPValidationError>(
 params: undefined |  ListAppointmentListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointmentList>>,
          TError,
          Awaited<ReturnType<typeof listAppointmentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointmentList<TData = Awaited<ReturnType<typeof listAppointmentList>>, TError = HTTPValidationError>(
 params?: ListAppointmentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppointmentList>>,
          TError,
          Awaited<ReturnType<typeof listAppointmentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAppointmentList<TData = Awaited<ReturnType<typeof listAppointmentList>>, TError = HTTPValidationError>(
 params?: ListAppointmentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Appointments
 */

export function useListAppointmentList<TData = Awaited<ReturnType<typeof listAppointmentList>>, TError = HTTPValidationError>(
 params?: ListAppointmentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppointmentList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAppointmentListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




