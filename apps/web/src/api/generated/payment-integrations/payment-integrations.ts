/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  GetPaytrConfig200,
  GetPosTransactions200,
  GetPosTransactionsParams,
  PayTRInitiateRequest,
  PayTRInitiateResponse,
  PaytrCallbackBody,
  UpdatePaytrConfig200,
  UpdatePaytrConfigBody
} from '.././schemas';





/**
 * @summary Initiate PayTR Payment
 */
export const paytrInitiate = (
    payTRInitiateRequest: PayTRInitiateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PayTRInitiateResponse>> => {
    
    
    return axios.post(
      `/api/payments/pos/paytr/initiate`,
      payTRInitiateRequest,options
    );
  }



export const getPaytrInitiateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext> => {

const mutationKey = ['paytrInitiate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paytrInitiate>>, {data: PayTRInitiateRequest}> = (props) => {
          const {data} = props ?? {};

          return  paytrInitiate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaytrInitiateMutationResult = NonNullable<Awaited<ReturnType<typeof paytrInitiate>>>
    export type PaytrInitiateMutationBody = PayTRInitiateRequest
    export type PaytrInitiateMutationError = AxiosError<unknown>

    /**
 * @summary Initiate PayTR Payment
 */
export const usePaytrInitiate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrInitiate>>, TError,{data: PayTRInitiateRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paytrInitiate>>,
        TError,
        {data: PayTRInitiateRequest},
        TContext
      > => {

      const mutationOptions = getPaytrInitiateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary PayTR Callback
 */
export const paytrCallback = (
    paytrCallbackBody: PaytrCallbackBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    const formUrlEncoded = new URLSearchParams();
if(paytrCallbackBody.merchant_oid !== undefined) {
 formUrlEncoded.append(`merchant_oid`, paytrCallbackBody.merchant_oid)
 }
if(paytrCallbackBody.status !== undefined) {
 formUrlEncoded.append(`status`, paytrCallbackBody.status)
 }
if(paytrCallbackBody.total_amount !== undefined) {
 formUrlEncoded.append(`total_amount`, paytrCallbackBody.total_amount)
 }
if(paytrCallbackBody.hash !== undefined) {
 formUrlEncoded.append(`hash`, paytrCallbackBody.hash)
 }

    return axios.post(
      `/api/payments/pos/paytr/callback`,
      formUrlEncoded,{
        responseType: 'text',
    ...options,}
    );
  }



export const getPaytrCallbackMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext> => {

const mutationKey = ['paytrCallback'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paytrCallback>>, {data: PaytrCallbackBody}> = (props) => {
          const {data} = props ?? {};

          return  paytrCallback(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaytrCallbackMutationResult = NonNullable<Awaited<ReturnType<typeof paytrCallback>>>
    export type PaytrCallbackMutationBody = PaytrCallbackBody
    export type PaytrCallbackMutationError = AxiosError<unknown>

    /**
 * @summary PayTR Callback
 */
export const usePaytrCallback = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paytrCallback>>, TError,{data: PaytrCallbackBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paytrCallback>>,
        TError,
        {data: PaytrCallbackBody},
        TContext
      > => {

      const mutationOptions = getPaytrCallbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get PayTR Config
 */
export const getPaytrConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPaytrConfig200>> => {
    
    
    return axios.get(
      `/api/payments/pos/paytr/config`,options
    );
  }




export const getGetPaytrConfigQueryKey = () => {
    return [
    `/api/payments/pos/paytr/config`
    ] as const;
    }

    
export const getGetPaytrConfigQueryOptions = <TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaytrConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaytrConfig>>> = ({ signal }) => getPaytrConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPaytrConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getPaytrConfig>>>
export type GetPaytrConfigQueryError = AxiosError<unknown>


export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaytrConfig>>,
          TError,
          Awaited<ReturnType<typeof getPaytrConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaytrConfig>>,
          TError,
          Awaited<ReturnType<typeof getPaytrConfig>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get PayTR Config
 */

export function useGetPaytrConfig<TData = Awaited<ReturnType<typeof getPaytrConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaytrConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPaytrConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update PayTR Config
 */
export const updatePaytrConfig = (
    updatePaytrConfigBody: UpdatePaytrConfigBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpdatePaytrConfig200>> => {
    
    
    return axios.put(
      `/api/payments/pos/paytr/config`,
      updatePaytrConfigBody,options
    );
  }



export const getUpdatePaytrConfigMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext> => {

const mutationKey = ['updatePaytrConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaytrConfig>>, {data: UpdatePaytrConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  updatePaytrConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaytrConfigMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaytrConfig>>>
    export type UpdatePaytrConfigMutationBody = UpdatePaytrConfigBody
    export type UpdatePaytrConfigMutationError = AxiosError<unknown>

    /**
 * @summary Update PayTR Config
 */
export const useUpdatePaytrConfig = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaytrConfig>>, TError,{data: UpdatePaytrConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePaytrConfig>>,
        TError,
        {data: UpdatePaytrConfigBody},
        TContext
      > => {

      const mutationOptions = getUpdatePaytrConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary POS Transactions Report
 */
export const getPosTransactions = (
    params?: GetPosTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPosTransactions200>> => {
    
    
    return axios.get(
      `/api/payments/pos/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetPosTransactionsQueryKey = (params?: GetPosTransactionsParams,) => {
    return [
    `/api/payments/pos/transactions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPosTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPosTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPosTransactions>>> = ({ signal }) => getPosTransactions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPosTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getPosTransactions>>>
export type GetPosTransactionsQueryError = AxiosError<unknown>


export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params: undefined |  GetPosTransactionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPosTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPosTransactions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPosTransactions>>,
          TError,
          Awaited<ReturnType<typeof getPosTransactions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary POS Transactions Report
 */

export function useGetPosTransactions<TData = Awaited<ReturnType<typeof getPosTransactions>>, TError = AxiosError<unknown>>(
 params?: GetPosTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosTransactions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPosTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




