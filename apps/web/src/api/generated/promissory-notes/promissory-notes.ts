/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  PaymentsCollectPromissoryNoteBody,
  PaymentsCreatePromissoryNotesBody,
  PaymentsUpdatePromissoryNoteBody
} from '.././schemas';





/**
 * @summary Create multiple promissory notes
 */
export const paymentsCreatePromissoryNotes = (
    paymentsCreatePromissoryNotesBody?: PaymentsCreatePromissoryNotesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes`,
      paymentsCreatePromissoryNotesBody,options
    );
  }



export const getPaymentsCreatePromissoryNotesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext> => {

const mutationKey = ['paymentsCreatePromissoryNotes'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, {data: PaymentsCreatePromissoryNotesBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePromissoryNotes(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePromissoryNotesMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>>
    export type PaymentsCreatePromissoryNotesMutationBody = PaymentsCreatePromissoryNotesBody
    export type PaymentsCreatePromissoryNotesMutationError = AxiosError<unknown>

    /**
 * @summary Create multiple promissory notes
 */
export const usePaymentsCreatePromissoryNotes = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
        TError,
        {data: PaymentsCreatePromissoryNotesBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePromissoryNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Update a promissory note
 */
export const paymentsUpdatePromissoryNote = (
    noteId: string,
    paymentsUpdatePromissoryNoteBody?: PaymentsUpdatePromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.patch(
      `/api/promissory-notes/${noteId}`,
      paymentsUpdatePromissoryNoteBody,options
    );
  }



export const getPaymentsUpdatePromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsUpdatePromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, {noteId: string;data: PaymentsUpdatePromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsUpdatePromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>>
    export type PaymentsUpdatePromissoryNoteMutationBody = PaymentsUpdatePromissoryNoteBody
    export type PaymentsUpdatePromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Update a promissory note
 */
export const usePaymentsUpdatePromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsUpdatePromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const paymentsCollectPromissoryNote = (
    noteId: string,
    paymentsCollectPromissoryNoteBody?: PaymentsCollectPromissoryNoteBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `/api/promissory-notes/${noteId}/collect`,
      paymentsCollectPromissoryNoteBody,options
    );
  }



export const getPaymentsCollectPromissoryNoteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsCollectPromissoryNote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, {noteId: string;data: PaymentsCollectPromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsCollectPromissoryNote(noteId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCollectPromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>>
    export type PaymentsCollectPromissoryNoteMutationBody = PaymentsCollectPromissoryNoteBody
    export type PaymentsCollectPromissoryNoteMutationError = AxiosError<unknown>

    /**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const usePaymentsCollectPromissoryNote = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsCollectPromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCollectPromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    