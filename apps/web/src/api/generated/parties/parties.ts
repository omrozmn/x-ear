/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyCreatePartyBulkUpload,
  HTTPValidationError,
  ListPartiesParams,
  ListPartyCountParams,
  ListPartyExportParams,
  PartyCreate,
  PartyUpdate,
  ResponseEnvelopeListPartyRead,
  ResponseEnvelopePartyRead,
  SchemasBaseResponseEnvelopeBulkUploadResponse1
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * List patients with filtering and pagination
 * @summary List Parties
 */
export const listParties = (
    params?: ListPartiesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopeListPartyRead>(
      {url: `/api/parties`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListPartiesQueryKey = (params?: ListPartiesParams,) => {
    return [
    `/api/parties`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPartiesQueryOptions = <TData = Awaited<ReturnType<typeof listParties>>, TError = HTTPValidationError>(params?: ListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartiesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listParties>>> = ({ signal }) => listParties(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartiesQueryResult = NonNullable<Awaited<ReturnType<typeof listParties>>>
export type ListPartiesQueryError = HTTPValidationError


export function useListParties<TData = Awaited<ReturnType<typeof listParties>>, TError = HTTPValidationError>(
 params: undefined |  ListPartiesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listParties>>,
          TError,
          Awaited<ReturnType<typeof listParties>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListParties<TData = Awaited<ReturnType<typeof listParties>>, TError = HTTPValidationError>(
 params?: ListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listParties>>,
          TError,
          Awaited<ReturnType<typeof listParties>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListParties<TData = Awaited<ReturnType<typeof listParties>>, TError = HTTPValidationError>(
 params?: ListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Parties
 */

export function useListParties<TData = Awaited<ReturnType<typeof listParties>>, TError = HTTPValidationError>(
 params?: ListPartiesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listParties>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartiesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new patient
 * @summary Create Party
 */
export const createParties = (
    partyCreate: PartyCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopePartyRead>(
      {url: `/api/parties`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: partyCreate, signal
    },
      );
    }
  


export const getCreatePartiesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createParties>>, TError,{data: PartyCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createParties>>, TError,{data: PartyCreate}, TContext> => {

const mutationKey = ['createParties'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createParties>>, {data: PartyCreate}> = (props) => {
          const {data} = props ?? {};

          return  createParties(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePartiesMutationResult = NonNullable<Awaited<ReturnType<typeof createParties>>>
    export type CreatePartiesMutationBody = PartyCreate
    export type CreatePartiesMutationError = HTTPValidationError

    /**
 * @summary Create Party
 */
export const useCreateParties = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createParties>>, TError,{data: PartyCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createParties>>,
        TError,
        {data: PartyCreate},
        TContext
      > => {

      const mutationOptions = getCreatePartiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Export patients as CSV
 * @summary Export Parties
 */
export const listPartyExport = (
    params?: ListPartyExportParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/export`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListPartyExportQueryKey = (params?: ListPartyExportParams,) => {
    return [
    `/api/parties/export`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPartyExportQueryOptions = <TData = Awaited<ReturnType<typeof listPartyExport>>, TError = HTTPValidationError>(params?: ListPartyExportParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartyExportQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartyExport>>> = ({ signal }) => listPartyExport(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartyExportQueryResult = NonNullable<Awaited<ReturnType<typeof listPartyExport>>>
export type ListPartyExportQueryError = HTTPValidationError


export function useListPartyExport<TData = Awaited<ReturnType<typeof listPartyExport>>, TError = HTTPValidationError>(
 params: undefined |  ListPartyExportParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyExport>>,
          TError,
          Awaited<ReturnType<typeof listPartyExport>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyExport<TData = Awaited<ReturnType<typeof listPartyExport>>, TError = HTTPValidationError>(
 params?: ListPartyExportParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyExport>>,
          TError,
          Awaited<ReturnType<typeof listPartyExport>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyExport<TData = Awaited<ReturnType<typeof listPartyExport>>, TError = HTTPValidationError>(
 params?: ListPartyExportParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export Parties
 */

export function useListPartyExport<TData = Awaited<ReturnType<typeof listPartyExport>>, TError = HTTPValidationError>(
 params?: ListPartyExportParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyExport>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartyExportQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Count patients
 * @summary Count Parties
 */
export const listPartyCount = (
    params?: ListPartyCountParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/count`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListPartyCountQueryKey = (params?: ListPartyCountParams,) => {
    return [
    `/api/parties/count`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPartyCountQueryOptions = <TData = Awaited<ReturnType<typeof listPartyCount>>, TError = HTTPValidationError>(params?: ListPartyCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartyCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartyCount>>> = ({ signal }) => listPartyCount(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartyCountQueryResult = NonNullable<Awaited<ReturnType<typeof listPartyCount>>>
export type ListPartyCountQueryError = HTTPValidationError


export function useListPartyCount<TData = Awaited<ReturnType<typeof listPartyCount>>, TError = HTTPValidationError>(
 params: undefined |  ListPartyCountParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyCount>>,
          TError,
          Awaited<ReturnType<typeof listPartyCount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyCount<TData = Awaited<ReturnType<typeof listPartyCount>>, TError = HTTPValidationError>(
 params?: ListPartyCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyCount>>,
          TError,
          Awaited<ReturnType<typeof listPartyCount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyCount<TData = Awaited<ReturnType<typeof listPartyCount>>, TError = HTTPValidationError>(
 params?: ListPartyCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Count Parties
 */

export function useListPartyCount<TData = Awaited<ReturnType<typeof listPartyCount>>, TError = HTTPValidationError>(
 params?: ListPartyCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyCount>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartyCountQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get single patient
 * @summary Get Party
 */
export const getParty = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResponseEnvelopePartyRead>(
      {url: `/api/parties/${partyId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetPartyQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}`
    ] as const;
    }

    
export const getGetPartyQueryOptions = <TData = Awaited<ReturnType<typeof getParty>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPartyQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getParty>>> = ({ signal }) => getParty(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPartyQueryResult = NonNullable<Awaited<ReturnType<typeof getParty>>>
export type GetPartyQueryError = HTTPValidationError


export function useGetParty<TData = Awaited<ReturnType<typeof getParty>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParty>>,
          TError,
          Awaited<ReturnType<typeof getParty>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetParty<TData = Awaited<ReturnType<typeof getParty>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParty>>,
          TError,
          Awaited<ReturnType<typeof getParty>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetParty<TData = Awaited<ReturnType<typeof getParty>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Party
 */

export function useGetParty<TData = Awaited<ReturnType<typeof getParty>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPartyQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update patient
 * @summary Update Party
 */
export const updateParty = (
    partyId: string,
    partyUpdate: PartyUpdate,
 ) => {
      
      
      return customInstance<ResponseEnvelopePartyRead>(
      {url: `/api/parties/${partyId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: partyUpdate
    },
      );
    }
  


export const getUpdatePartyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateParty>>, TError,{partyId: string;data: PartyUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateParty>>, TError,{partyId: string;data: PartyUpdate}, TContext> => {

const mutationKey = ['updateParty'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateParty>>, {partyId: string;data: PartyUpdate}> = (props) => {
          const {partyId,data} = props ?? {};

          return  updateParty(partyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePartyMutationResult = NonNullable<Awaited<ReturnType<typeof updateParty>>>
    export type UpdatePartyMutationBody = PartyUpdate
    export type UpdatePartyMutationError = HTTPValidationError

    /**
 * @summary Update Party
 */
export const useUpdateParty = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateParty>>, TError,{partyId: string;data: PartyUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateParty>>,
        TError,
        {partyId: string;data: PartyUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePartyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete patient
 * @summary Delete Party
 */
export const deleteParty = (
    partyId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePartyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteParty>>, TError,{partyId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteParty>>, TError,{partyId: string}, TContext> => {

const mutationKey = ['deleteParty'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteParty>>, {partyId: string}> = (props) => {
          const {partyId} = props ?? {};

          return  deleteParty(partyId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePartyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteParty>>>
    
    export type DeletePartyMutationError = HTTPValidationError

    /**
 * @summary Delete Party
 */
export const useDeleteParty = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteParty>>, TError,{partyId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteParty>>,
        TError,
        {partyId: string},
        TContext
      > => {

      const mutationOptions = getDeletePartyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Bulk upload patients from CSV or XLSX
 * @summary Bulk Upload Parties
 */
export const createPartyBulkUpload = (
    bodyCreatePartyBulkUpload: BodyCreatePartyBulkUpload,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyCreatePartyBulkUpload.file)

      return customInstance<SchemasBaseResponseEnvelopeBulkUploadResponse1>(
      {url: `/api/parties/bulk-upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreatePartyBulkUploadMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartyBulkUpload>>, TError,{data: BodyCreatePartyBulkUpload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPartyBulkUpload>>, TError,{data: BodyCreatePartyBulkUpload}, TContext> => {

const mutationKey = ['createPartyBulkUpload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPartyBulkUpload>>, {data: BodyCreatePartyBulkUpload}> = (props) => {
          const {data} = props ?? {};

          return  createPartyBulkUpload(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePartyBulkUploadMutationResult = NonNullable<Awaited<ReturnType<typeof createPartyBulkUpload>>>
    export type CreatePartyBulkUploadMutationBody = BodyCreatePartyBulkUpload
    export type CreatePartyBulkUploadMutationError = HTTPValidationError

    /**
 * @summary Bulk Upload Parties
 */
export const useCreatePartyBulkUpload = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartyBulkUpload>>, TError,{data: BodyCreatePartyBulkUpload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPartyBulkUpload>>,
        TError,
        {data: BodyCreatePartyBulkUpload},
        TContext
      > => {

      const mutationOptions = getCreatePartyBulkUploadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    