/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  InvoiceSyncRequest,
  MockDetailRequest,
  MockSearchRequest
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * Send document to BirFatura
 * @summary Send Document
 */
export const sendDocument = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/sendDocument`, method: 'POST', signal
    },
      );
    }
  


export const getSendDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocument>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendDocument>>, TError,void, TContext> => {

const mutationKey = ['sendDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendDocument>>, void> = () => {
          

          return  sendDocument()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sendDocument>>>
    
    export type SendDocumentMutationError = unknown

    /**
 * @summary Send Document
 */
export const useSendDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocument>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendDocument>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send basic invoice to BirFatura
 * @summary Send Basic Invoice
 */
export const sendBasicInvoice = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/sendBasicInvoice`, method: 'POST', signal
    },
      );
    }
  


export const getSendBasicInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoice>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoice>>, TError,void, TContext> => {

const mutationKey = ['sendBasicInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendBasicInvoice>>, void> = () => {
          

          return  sendBasicInvoice()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendBasicInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof sendBasicInvoice>>>
    
    export type SendBasicInvoiceMutationError = unknown

    /**
 * @summary Send Basic Invoice
 */
export const useSendBasicInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoice>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendBasicInvoice>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendBasicInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create invoice (draft mode)
 * @summary Create Invoice
 */
export const createEfaturaCreateInvoice = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Create`, method: 'POST', signal
    },
      );
    }
  


export const getCreateEfaturaCreateInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEfaturaCreateInvoice>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEfaturaCreateInvoice>>, TError,void, TContext> => {

const mutationKey = ['createEfaturaCreateInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEfaturaCreateInvoice>>, void> = () => {
          

          return  createEfaturaCreateInvoice()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEfaturaCreateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof createEfaturaCreateInvoice>>>
    
    export type CreateEfaturaCreateInvoiceMutationError = unknown

    /**
 * @summary Create Invoice
 */
export const useCreateEfaturaCreateInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEfaturaCreateInvoice>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEfaturaCreateInvoice>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateEfaturaCreateInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retry sending a failed invoice
 * @summary Retry Invoice
 */
export const retryInvoice = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Retry/${invoiceId}`, method: 'POST', signal
    },
      );
    }
  


export const getRetryInvoiceMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryInvoice>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof retryInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['retryInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof retryInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  retryInvoice(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RetryInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof retryInvoice>>>
    
    export type RetryInvoiceMutationError = HTTPValidationError

    /**
 * @summary Retry Invoice
 */
export const useRetryInvoice = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryInvoice>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof retryInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getRetryInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel an invoice
 * @summary Cancel Invoice
 */
export const cancelInvoice = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Cancel/${invoiceId}`, method: 'POST', signal
    },
      );
    }
  


export const getCancelInvoiceMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelInvoice>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['cancelInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  cancelInvoice(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof cancelInvoice>>>
    
    export type CancelInvoiceMutationError = HTTPValidationError

    /**
 * @summary Cancel Invoice
 */
export const useCancelInvoice = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelInvoice>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getCancelInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Sync invoices from BirFatura API
 * @summary Sync Invoices
 */
export const syncInvoices = (
    invoiceSyncRequest: InvoiceSyncRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/birfatura/sync-invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoiceSyncRequest, signal
    },
      );
    }
  


export const getSyncInvoicesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncInvoices>>, TError,{data: InvoiceSyncRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof syncInvoices>>, TError,{data: InvoiceSyncRequest}, TContext> => {

const mutationKey = ['syncInvoices'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncInvoices>>, {data: InvoiceSyncRequest}> = (props) => {
          const {data} = props ?? {};

          return  syncInvoices(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof syncInvoices>>>
    export type SyncInvoicesMutationBody = InvoiceSyncRequest
    export type SyncInvoicesMutationError = HTTPValidationError

    /**
 * @summary Sync Invoices
 */
export const useSyncInvoices = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncInvoices>>, TError,{data: InvoiceSyncRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncInvoices>>,
        TError,
        {data: InvoiceSyncRequest},
        TContext
      > => {

      const mutationOptions = getSyncInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send document via OutEBelgeV2 API
 * @summary Send Document V2
 */
export const sendDocumentV2 = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/OutEBelgeV2/SendDocument`, method: 'POST', signal
    },
      );
    }
  


export const getSendDocumentV2MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocumentV2>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendDocumentV2>>, TError,void, TContext> => {

const mutationKey = ['sendDocumentV2'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendDocumentV2>>, void> = () => {
          

          return  sendDocumentV2()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendDocumentV2MutationResult = NonNullable<Awaited<ReturnType<typeof sendDocumentV2>>>
    
    export type SendDocumentV2MutationError = unknown

    /**
 * @summary Send Document V2
 */
export const useSendDocumentV2 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocumentV2>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendDocumentV2>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendDocumentV2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send basic invoice from model via OutEBelgeV2 API
 * @summary Send Basic Invoice From Model
 */
export const sendBasicInvoiceFromModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/OutEBelgeV2/SendBasicInvoiceFromModel`, method: 'POST', signal
    },
      );
    }
  


export const getSendBasicInvoiceFromModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>, TError,void, TContext> => {

const mutationKey = ['sendBasicInvoiceFromModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>, void> = () => {
          

          return  sendBasicInvoiceFromModel()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendBasicInvoiceFromModelMutationResult = NonNullable<Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>>
    
    export type SendBasicInvoiceFromModelMutationError = unknown

    /**
 * @summary Send Basic Invoice From Model
 */
export const useSendBasicInvoiceFromModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendBasicInvoiceFromModel>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendBasicInvoiceFromModelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mock customer search endpoint
 * @summary Search Firm Customers Mock
 */
export const searchFirmCustomersMock = (
    mockSearchRequest: MockSearchRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/Musteri/FirmaMusteriGetir`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mockSearchRequest, signal
    },
      );
    }
  


export const getSearchFirmCustomersMockMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchFirmCustomersMock>>, TError,{data: MockSearchRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof searchFirmCustomersMock>>, TError,{data: MockSearchRequest}, TContext> => {

const mutationKey = ['searchFirmCustomersMock'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchFirmCustomersMock>>, {data: MockSearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  searchFirmCustomersMock(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchFirmCustomersMockMutationResult = NonNullable<Awaited<ReturnType<typeof searchFirmCustomersMock>>>
    export type SearchFirmCustomersMockMutationBody = MockSearchRequest
    export type SearchFirmCustomersMockMutationError = HTTPValidationError

    /**
 * @summary Search Firm Customers Mock
 */
export const useSearchFirmCustomersMock = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchFirmCustomersMock>>, TError,{data: MockSearchRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchFirmCustomersMock>>,
        TError,
        {data: MockSearchRequest},
        TContext
      > => {

      const mutationOptions = getSearchFirmCustomersMockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mock PK info endpoint
 * @summary Get Firm Pk Info Mock
 */
export const getFirmPkInfoMock = (
    mockDetailRequest: MockDetailRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/Firma/FirmaPKBilgisiGetir`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mockDetailRequest, signal
    },
      );
    }
  


export const getGetFirmPkInfoMockMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFirmPkInfoMock>>, TError,{data: MockDetailRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getFirmPkInfoMock>>, TError,{data: MockDetailRequest}, TContext> => {

const mutationKey = ['getFirmPkInfoMock'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getFirmPkInfoMock>>, {data: MockDetailRequest}> = (props) => {
          const {data} = props ?? {};

          return  getFirmPkInfoMock(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetFirmPkInfoMockMutationResult = NonNullable<Awaited<ReturnType<typeof getFirmPkInfoMock>>>
    export type GetFirmPkInfoMockMutationBody = MockDetailRequest
    export type GetFirmPkInfoMockMutationError = HTTPValidationError

    /**
 * @summary Get Firm Pk Info Mock
 */
export const useGetFirmPkInfoMock = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFirmPkInfoMock>>, TError,{data: MockDetailRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getFirmPkInfoMock>>,
        TError,
        {data: MockDetailRequest},
        TContext
      > => {

      const mutationOptions = getGetFirmPkInfoMockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mock Address info endpoint
 * @summary Get Firm Address Info Mock
 */
export const getFirmAddressInfoMock = (
    mockDetailRequest: MockDetailRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/Firma/FirmaAdresBilgisiGetir`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mockDetailRequest, signal
    },
      );
    }
  


export const getGetFirmAddressInfoMockMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFirmAddressInfoMock>>, TError,{data: MockDetailRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getFirmAddressInfoMock>>, TError,{data: MockDetailRequest}, TContext> => {

const mutationKey = ['getFirmAddressInfoMock'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getFirmAddressInfoMock>>, {data: MockDetailRequest}> = (props) => {
          const {data} = props ?? {};

          return  getFirmAddressInfoMock(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetFirmAddressInfoMockMutationResult = NonNullable<Awaited<ReturnType<typeof getFirmAddressInfoMock>>>
    export type GetFirmAddressInfoMockMutationBody = MockDetailRequest
    export type GetFirmAddressInfoMockMutationError = HTTPValidationError

    /**
 * @summary Get Firm Address Info Mock
 */
export const useGetFirmAddressInfoMock = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFirmAddressInfoMock>>, TError,{data: MockDetailRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getFirmAddressInfoMock>>,
        TError,
        {data: MockDetailRequest},
        TContext
      > => {

      const mutationOptions = getGetFirmAddressInfoMockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    