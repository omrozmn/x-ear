import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { patientApiService } from '../../services/patient/patient-api.service';
import { PATIENT_CONSTANTS, PATIENT_QUERY_KEYS } from '../../constants/patient/constants';
import type { PatientsCreatePatientBody, PatientsGetPatients200 } from "../../api/generated/xEarCRMAPIAutoGenerated.schemas";
import type { Patient } from "../../types/patient/patient-base.types";
import type { PatientStatus } from "../../api/generated/xEarCRMAPIAutoGenerated.schemas";

// Simple filters interface for the hook
interface SimplePatientFilters {
  page?: number;
  per_page?: number;
  search?: string;
  status?: string;
}

// Offline-first hook for patients list
export function usePatients(filters: Partial<SimplePatientFilters> = {}) {
  const defaultFilters: SimplePatientFilters = {
    page: 1,
    per_page: PATIENT_CONSTANTS.PAGINATION.DEFAULT_PAGE_SIZE,
    ...filters
  };

  return useQuery({
    queryKey: PATIENT_QUERY_KEYS.list(defaultFilters),
    queryFn: async () => {
      const response = await patientApiService.fetchAllPatients();
      
      // fetchAllPatients returns Patient[] directly (not wrapped in data object)
      const patients = Array.isArray(response) ? response : [];
      
      console.log('ðŸ” usePatients hook - patients count:', patients.length);
      
      return {
        patients,
        total: patients.length,
        page: 1,
        pageSize: patients.length,
        hasMore: false
      };
    },
    staleTime: PATIENT_CONSTANTS.CACHE.STALE_TIME,
    gcTime: PATIENT_CONSTANTS.CACHE.GC_TIME,
  });
}

// Hook for creating a new patient
export function useCreatePatient() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (patientData: {
      firstName: string;
      lastName: string;
      phone: string;
      tcNumber?: string;
      email?: string;
      birthDate?: string;
      address?: string;
      status?: PatientStatus;
      segment?: string;
      acquisitionType?: string;
      branchId?: string;
    }) => {
      // Clean empty strings to undefined for optional fields (prevents UNIQUE constraint issues)
      const request: any = {
        firstName: patientData.firstName,
        lastName: patientData.lastName,
        phone: patientData.phone,
        tcNumber: patientData.tcNumber?.trim() || undefined,
        email: patientData.email?.trim() || undefined,
        birthDate: patientData.birthDate?.trim() || undefined,
        address: patientData.address?.trim() || undefined,
        status: patientData.status || 'ACTIVE',
        segment: patientData.segment,
        acquisitionType: patientData.acquisitionType,
        branchId: patientData.branchId,
      };

      const response = await patientApiService.createPatient(request);
      return response;
    },
    onSuccess: (newPatient) => {
      // Invalidate and refetch patients list
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.lists() });
      
      // Optimistically update cache if we have the new patient data
      if (newPatient?.id) {
        queryClient.setQueryData(
          PATIENT_QUERY_KEYS.detail(newPatient.id),
          newPatient
        );
      }
      
      console.log(PATIENT_CONSTANTS.SUCCESS_MESSAGES.PATIENT_CREATED);
    },
    onError: (error: any) => {
      console.error('Failed to create patient:', error);
      console.error(error?.response?.data?.message || 'Failed to create patient');
      // Re-throw error so PatientFormModal can catch it
      throw error;
    },
  });
}

// Delete patient mutation
export const useDeletePatient = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (patientId: string) => {
      await patientApiService.deletePatient(patientId);
      return patientId;
    },
    onSuccess: (deletedId) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: PATIENT_QUERY_KEYS.detail(deletedId) });
      
      // Invalidate lists
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.lists() });
      
      console.log(PATIENT_CONSTANTS.SUCCESS_MESSAGES.PATIENT_DELETED);
    },
    onError: (error) => {
      console.error('Failed to delete patient:', error);
    },
  });
};

export const usePatientNotes = (patientId: string) => {
  return useQuery({
    queryKey: PATIENT_QUERY_KEYS.notes(patientId),
    queryFn: () => patientApiService.getNotes(patientId),
    enabled: !!patientId,
  });
};

export const useCreatePatientNote = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ patientId, note }: { patientId: string; note: string }) => {
      return patientApiService.createNote(patientId, { content: note });
    },
    onSuccess: (_, { patientId }) => {
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.notes(patientId) });
    },
  });
};

export const useDeletePatientNote = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ patientId, noteId }: { patientId: string; noteId: string }) => {
      return patientApiService.deleteNote(patientId, noteId);
    },
    onSuccess: (_, { patientId }) => {
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.notes(patientId) });
    },
  });
};

export const usePatientTimeline = (patientId: string) => {
  return useQuery({
    queryKey: PATIENT_QUERY_KEYS.timeline(patientId),
    queryFn: () => patientApiService.getTimeline(patientId),
    enabled: !!patientId,
  });
};

export const usePatientSales = (patientId: string) => {
  return useQuery({
    queryKey: PATIENT_QUERY_KEYS.sales(patientId),
    queryFn: () => patientApiService.getSales(patientId),
    enabled: !!patientId,
  });
};

export const useBulkUploadPatients = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      return patientApiService.bulkUpload();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.lists() });
    },
  });
};

export const useSearchPatients = (searchParams: any) => {
  return useQuery({
    queryKey: [...PATIENT_QUERY_KEYS.all, 'search', searchParams],
    queryFn: () => patientApiService.search(),
    enabled: !!searchParams?.query,
  });
};

export const useExportPatients = () => {
  return useMutation({
    mutationFn: async () => {
      return patientApiService.exportCsv();
    },
  });
};

export const useUpdatePatient = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ patientId, updates }: { patientId: string; updates: any }) => {
      // Clean empty strings to undefined for optional fields (prevents UNIQUE constraint issues)
      const cleanUpdates = {
        firstName: updates.firstName,
        lastName: updates.lastName,
        phone: updates.phone,
        tcNumber: updates.tcNumber?.trim() || undefined,
        email: updates.email?.trim() || undefined,
        birthDate: updates.birthDate?.trim() || undefined,
        address: updates.address?.trim() || undefined,
        status: updates.status,
        segment: updates.segment,
        acquisitionType: updates.acquisitionType?.trim() || undefined,
        branchId: updates.branchId?.trim() || undefined,
        tags: updates.tags
      };

      console.log('ðŸ” UPDATE PATIENT - Patient ID:', patientId);
      console.log('ðŸ” UPDATE PATIENT - Original updates:', updates);
      console.log('ðŸ” UPDATE PATIENT - Clean updates:', cleanUpdates);
      console.log('ðŸ” UPDATE PATIENT - branchId value:', cleanUpdates.branchId);

      const response = await patientApiService.updatePatient(patientId, cleanUpdates);
      return response;
    },
    onSuccess: (updatedPatient, { patientId }) => {
      // Update cache if update succeeds
      if (updatedPatient) {
        queryClient.setQueryData(
          PATIENT_QUERY_KEYS.detail(patientId),
          updatedPatient
        );
      }

      // Invalidate lists and detail queries
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.lists() });
      queryClient.invalidateQueries({ queryKey: PATIENT_QUERY_KEYS.detail(patientId) });

      console.log(PATIENT_CONSTANTS.SUCCESS_MESSAGES.PATIENT_UPDATED);
    },
    onError: (error: any) => {
      console.error('Failed to update patient:', error);
      console.error(error?.response?.data?.message || 'Failed to update patient');
      // Re-throw error so PatientFormModal can catch it
      throw error;
    },
  });
};