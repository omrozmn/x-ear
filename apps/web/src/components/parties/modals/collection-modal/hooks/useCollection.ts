import { useState, useEffect, useCallback } from 'react';
import type {
  CollectionState,
  PromissoryNoteFormData,
  PromissoryNote,
  PaymentCalculations
} from '../types';
import type { Sale, PaymentRecord } from '../../../../../types/party/party-communication.types';

export const useCollection = (sale: Sale, isOpen: boolean) => {
  // All hooks must be called unconditionally at the top
  const [state, setState] = useState<CollectionState>({
    activeTab: 'payments',
    paymentMethod: 'cash',
    showCreatePromissoryForm: false,
    paymentAmount: 0,
    selectedInstallments: [],
    error: null,
    success: null,
    isLoading: false,
    generateReceipt: false,
    collectingNoteId: null,
    promissoryPaymentAmount: 0,
    promissoryPaymentMethod: 'cash'
  });

  const [promissoryNotes, setPromissoryNotes] = useState<PromissoryNote[]>([]);
  const [newPromissoryNote, setNewPromissoryNote] = useState<PromissoryNoteFormData>({
    noteNumber: '',
    amount: 0,
    dueDate: '',
    notes: ''
  });

  // Calculate payment details - handle undefined sale
  const calculations: PaymentCalculations = {
    totalPaid: sale?.payments?.reduce((sum, payment) => sum + payment.amount, 0) || 0,
    remainingBalance: (sale?.totalAmount || 0) - (sale?.payments?.reduce((sum, payment) => sum + payment.amount, 0) || 0),
    pendingInstallments: [],
    overdueInstallments: []
  };

  // Mock installments - in real app, this would come from sale data
  const installments: PaymentRecord[] = sale ? [
    {
      id: '1',
      amount: sale.totalAmount / 3,
      date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
      status: 'pending',
      note: '1. Taksit'
    },
    {
      id: '2',
      amount: sale.totalAmount / 3,
      date: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000).toISOString(),
      status: 'pending',
      note: '2. Taksit'
    },
    {
      id: '3',
      amount: sale.totalAmount / 3,
      date: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),
      status: 'pending',
      note: '3. Taksit'
    }
  ] : [];

  calculations.pendingInstallments = installments.filter(inst => inst.status === 'pending');
  calculations.overdueInstallments = installments.filter(inst =>
    inst.status === 'pending' && new Date(inst.date) < new Date()
  );

  const loadPromissoryNotes = useCallback(() => {
    if (!sale) return;
    // Mock promissory notes - in real app, this would come from API
    const mockNotes: PromissoryNote[] = [
      {
        id: '1',
        noteNumber: `SN-${sale.id || 'TEMP'}-001`,
        amount: sale.totalAmount * 0.5,
        paidAmount: 0,
        remainingAmount: sale.totalAmount * 0.5,
        dueDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000).toISOString(),
        status: 'active',
        saleId: sale.id || '',
        notes: 'Ä°lk senet'
      }
    ];
    setPromissoryNotes(mockNotes);
  }, [sale]);

  // Load promissory notes when modal opens
  useEffect(() => {
    if (isOpen && sale?.id) {
      loadPromissoryNotes();
      // Update note number when sale changes
      setNewPromissoryNote(prev => ({
        ...prev,
        noteNumber: `SN-${sale.id || 'TEMP'}-001`
      }));
    }
  }, [isOpen, sale?.id, loadPromissoryNotes]);

  const updateState = (updates: Partial<CollectionState>) => {
    setState(prev => ({ ...prev, ...updates }));
  };

  const updateNewPromissoryNote = (updates: Partial<PromissoryNoteFormData>) => {
    setNewPromissoryNote(prev => ({ ...prev, ...updates }));
  };

  const handleInstallmentSelection = (installmentId: string, checked: boolean) => {
    if (checked) {
      setState(prev => ({
        ...prev,
        selectedInstallments: [...prev.selectedInstallments, installmentId]
      }));
    } else {
      setState(prev => ({
        ...prev,
        selectedInstallments: prev.selectedInstallments.filter(id => id !== installmentId)
      }));
    }
  };

  const submitPayment = async (_formData: FormData) => {
    if (!sale.id) {
      setState(prev => ({ ...prev, error: 'Sale ID is required' }));
      return;
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Mock API call - replace with actual implementation
      // const api = getXEarCRMAPIAutoGenerated();

      // const paymentData = {
      //   amount: parseFloat(formData.get('amount') as string),
      //   method: formData.get('method') as string,
      //   installmentIds: state.selectedInstallments,
      //   notes: formData.get('notes') as string
      // };

      // await api.salesCreateSalePaymentPlan(sale.id, paymentData);

      // Mock success response
      await new Promise(resolve => setTimeout(resolve, 1000));

      setState(prev => ({
        ...prev,
        isLoading: false,
        selectedInstallments: [],
        paymentForm: {
          amount: 0,
          method: 'cash',
          notes: ''
        }
      }));

      // Refresh data
      loadPromissoryNotes();
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Payment failed'
      }));
    }
  };

  const submitPromissoryNote = async (_formData: FormData) => {
    if (!sale.id) {
      setState(prev => ({ ...prev, error: 'Sale ID is required' }));
      return;
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Mock API call - replace with actual implementation
      // const api = getXEarCRMAPIAutoGenerated();

      // const noteData = {
      //   saleId: sale.id,
      //   amount: parseFloat(formData.get('amount') as string),
      //   dueDate: formData.get('dueDate') as string,
      //   notes: formData.get('notes') as string
      // };

      // await api.salesCreatePromissoryNote(sale.id, noteData);

      // Mock success response
      await new Promise(resolve => setTimeout(resolve, 1000));

      setState(prev => ({
        ...prev,
        isLoading: false,
        promissoryNoteForm: {
          amount: 0,
          dueDate: '',
          notes: ''
        }
      }));

      // Refresh data
      loadPromissoryNotes();
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to create promissory note'
      }));
    }
  };

  const collectPromissoryPayment = async (_noteId: string, _amount: number) => {
    if (!sale.id) {
      setState(prev => ({ ...prev, error: 'Sale ID is required' }));
      return;
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Mock API call - replace with actual implementation
      // const api = getXEarCRMAPIAutoGenerated();

      // const paymentData = {
      //   noteId,
      //   amount,
      //   paymentDate: new Date().toISOString()
      // };

      // await api.salesCreatePromissoryPayment(sale.id, paymentData);

      // Mock success response
      await new Promise(resolve => setTimeout(resolve, 1000));

      setState(prev => ({ ...prev, isLoading: false }));

      // Refresh data
      loadPromissoryNotes();
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to collect payment'
      }));
    }
  };

  const resetForm = () => {
    setState({
      activeTab: 'payments',
      paymentMethod: 'cash',
      showCreatePromissoryForm: false,
      paymentAmount: 0,
      selectedInstallments: [],
      error: null,
      success: null,
      isLoading: false,
      generateReceipt: false,
      collectingNoteId: null,
      promissoryPaymentAmount: 0,
      promissoryPaymentMethod: 'cash'
    });
    setNewPromissoryNote({
      noteNumber: '',
      amount: 0,
      dueDate: '',
      notes: ''
    });
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('tr-TR', {
      style: 'currency',
      currency: 'TRY'
    }).format(amount);
  };

  return {
    state,
    promissoryNotes,
    newPromissoryNote,
    calculations,
    installments,
    updateState,
    updateNewPromissoryNote,
    handleInstallmentSelection,
    submitPayment,
    submitPromissoryNote,
    collectPromissoryPayment,
    resetForm,
    formatCurrency
  };
};