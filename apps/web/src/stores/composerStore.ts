import { create } from 'zustand';
// We assume these types will be generated by Orval. 
// If not yet available, we will rely on TS inference or temporary any until generation completes.
import type {
    EntityItem,
    Capability,
    SlotConfig,
    ExecuteResponse
} from '../api/generated/schemas';

// Define modes for the state machine
export type ComposerMode = 'idle' | 'context_locked' | 'action_selection' | 'slot_filling' | 'confirmation' | 'executing';

interface ComposerState {
    isOpen: boolean; // Global visibility
    mode: ComposerMode;

    // Query state
    query: string;

    // Context State
    context: EntityItem | null;

    // Action State
    availableActions: Capability[];
    selectedAction: Capability | null;

    // Slot State
    slots: Record<string, unknown>; // Collected arguments
    currentSlot: SlotConfig | null; // The slot currently being asked

    // Execution State
    isDryRun: boolean;
    executionResult: ExecuteResponse | null;

    // Actions
    setOpen: (open: boolean) => void;
    toggleOpen: () => void;

    setQuery: (q: string) => void;
    setContext: (entity: EntityItem | null) => void;
    setAvailableActions: (actions: Capability[]) => void;
    selectAction: (action: Capability, entities?: EntityItem[]) => void;

    updateSlot: (key: string, value: unknown) => void;
    nextSlot: () => void; // Advances to next slot or confirmation

    reset: () => void;
    setExecutionResult: (res: ExecuteResponse) => void;
}

export const useComposerStore = create<ComposerState>((set, get) => ({
    isOpen: false,
    mode: 'idle',
    query: '',
    context: null,
    availableActions: [],
    selectedAction: null,
    slots: {},
    currentSlot: null,
    isDryRun: false,
    executionResult: null,

    setOpen: (open) => set({ isOpen: open }),
    toggleOpen: () => set((state) => ({ isOpen: !state.isOpen })),

    setQuery: (q) => set({ query: q }),

    setContext: (entity) => set({
        context: entity,
        mode: entity ? 'context_locked' : 'idle',
        query: '', // Clear query when context locked
        selectedAction: null,
        slots: {}
    }),

    setAvailableActions: (actions) => set({ availableActions: actions }),

    selectAction: (action, entities) => {
        const currentState = get();
        const initialSlots: Record<string, unknown> = {};

        // Unified source for entities (either passed or from single context)
        const sourceEntities = entities || (currentState.context ? [currentState.context] : []);

        // Map all source entities to available slots
        sourceEntities.forEach(entity => {
            const matchingSlot = action.slots?.find(s => {
                // Map context type to slot name conventions
                // legacy: patient_id compatibility for backward compatibility with old actions
                if (entity.type === 'patient' && (s.name === 'party_id' || s.name === 'patient_id')) return true; // legacy
                if (entity.type === 'device' && (s.name === 'device_id' || s.name === 'inventory_id')) return true;
                if (entity.type === 'invoice' && s.name === 'invoice_id') return true;
                if (entity.type === 'supplier' && s.name === 'supplier_id') return true;
                return false;
            });

            if (matchingSlot) {
                initialSlots[matchingSlot.name] = entity.id;
                initialSlots[`_${matchingSlot.name}_label`] = entity.label;
            }
        });

        set({
            selectedAction: action,
            slots: initialSlots,
            mode: 'slot_filling'
        });

        // Initialize first slot
        const state = get();
        state.nextSlot();
    },

    updateSlot: (key, value) => {
        set((state) => ({
            slots: { ...state.slots, [key]: value }
        }));
    },

    nextSlot: () => {
        const { selectedAction, slots } = get();
        if (!selectedAction) return;

        // Find first missing slot
        const requiredSlots = selectedAction.slots || [];
        const nextMissing = requiredSlots.find(s => {
            const val = slots[s.name];
            return val === undefined || val === null || val === '';
        });

        if (nextMissing) {
            set({ currentSlot: nextMissing, mode: 'slot_filling' });
        } else {
            // All slots filled
            set({ currentSlot: null, mode: 'confirmation' });
        }
    },

    reset: () => set({
        mode: 'idle',
        query: '',
        context: null,
        selectedAction: null,
        slots: {},
        currentSlot: null,
        executionResult: null
    }),

    setExecutionResult: (res) => set({ executionResult: res })
}));
