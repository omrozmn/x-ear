import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
// We assume these types will be generated by Orval. 
// If not yet available, we will rely on TS inference or temporary any until generation completes.
import type {
    EntityItem,
    Capability,
    SlotConfig,
    ExecuteResponse,
    ImpactMetric
} from '../api/generated/schemas';

// Define modes for the state machine
export type ComposerMode = 'idle' | 'context_locked' | 'action_selection' | 'slot_filling' | 'confirmation' | 'executing';

interface ComposerState {
    isOpen: boolean; // Global visibility
    mode: ComposerMode;

    // Query state
    query: string;

    // Context State
    context: EntityItem | null;

    // Action State
    availableActions: Capability[];
    selectedAction: Capability | null;

    // Slot State
    slots: Record<string, any>; // Collected arguments
    currentSlot: SlotConfig | null; // The slot currently being asked

    // Execution State
    isDryRun: boolean;
    executionResult: ExecuteResponse | null;

    // Actions
    setOpen: (open: boolean) => void;
    toggleOpen: () => void;

    setQuery: (q: string) => void;
    setContext: (entity: EntityItem | null) => void;
    setAvailableActions: (actions: Capability[]) => void;
    selectAction: (action: Capability) => void;

    updateSlot: (key: string, value: any) => void;
    nextSlot: () => void; // Advances to next slot or confirmation

    reset: () => void;
    setExecutionResult: (res: ExecuteResponse) => void;
}

export const useComposerStore = create<ComposerState>()(
    devtools(
        (set, get) => ({
            isOpen: false,
            mode: 'idle',
            query: '',
            context: null,
            availableActions: [],
            selectedAction: null,
            slots: {},
            currentSlot: null,
            isDryRun: false,
            executionResult: null,

            setOpen: (open) => set({ isOpen: open }),
            toggleOpen: () => set((state) => ({ isOpen: !state.isOpen })),

            setQuery: (q) => set({ query: q }),

            setContext: (entity) => set({
                context: entity,
                mode: entity ? 'context_locked' : 'idle',
                query: '', // Clear query when context locked
                selectedAction: null,
                slots: {}
            }),

            setAvailableActions: (actions) => set({ availableActions: actions }),

            selectAction: (action) => {
                set({
                    selectedAction: action,
                    slots: {}, // Reset slots
                    mode: 'slot_filling'
                });
                // Initialize first slot
                const state = get();
                state.nextSlot();
            },

            updateSlot: (key, value) => {
                set((state) => ({
                    slots: { ...state.slots, [key]: value }
                }));
            },

            nextSlot: () => {
                const { selectedAction, slots } = get();
                if (!selectedAction) return;

                // Find first missing slot
                const requiredSlots = selectedAction.slots || [];
                const nextMissing = requiredSlots.find(s => {
                    const val = slots[s.name];
                    return val === undefined || val === null || val === '';
                });

                if (nextMissing) {
                    set({ currentSlot: nextMissing, mode: 'slot_filling' });
                } else {
                    // All slots filled
                    set({ currentSlot: null, mode: 'confirmation' });
                }
            },

            reset: () => set({
                mode: 'idle',
                query: '',
                context: null,
                selectedAction: null,
                slots: {},
                currentSlot: null,
                executionResult: null
            }),

            setExecutionResult: (res) => set({ executionResult: res })
        }),
        { name: 'ComposerStore' }
    )
);
