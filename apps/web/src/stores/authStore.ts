import { create } from 'zustand';
import axios from 'axios';
import { persist } from 'zustand/middleware';
import { authLogin, authRefresh } from '../api/generated/xEarCRMAPIAutoGenerated';
import { AUTH_TOKEN, REFRESH_TOKEN } from '../constants/storage-keys';
import { DEV_CONFIG } from '../config/dev-config';
import { subscriptionService } from '../services/subscription.service';

// Extend Window interface to include __AUTH_TOKEN__
declare global {
  interface Window {
    __AUTH_TOKEN__?: string;
  }
}

interface User {
  id: string;
  username?: string;
  email: string;
  name: string;
  role?: string;
  phone?: string;
  isPhoneVerified?: boolean;
}

interface SubscriptionStatus {
  isExpired: boolean;
  daysRemaining: number;
  planName: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
    isInitialized: boolean;
  error: string | null;
  subscription: SubscriptionStatus | null;
  requiresOtp: boolean;
  requiresPhone: boolean;
  maskedPhone: string | null;
}

interface AuthActions {
  setAuth: (user: User, token: string) => void;
  setUser: (user: User) => void;
  clearAuth: () => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  login: (credentials: LoginCredentials) => Promise<void>;
  verifyOtp: (otp: string) => Promise<void>;
  sendOtp: (phone: string) => Promise<void>;
  forgotPassword: (phone: string) => Promise<void>;
  verifyResetOtp: (phone: string, otp: string) => Promise<void>;
  resetPassword: (phone: string, otp: string, newPassword: string) => Promise<void>;
  logout: () => void;
  refreshAuth: () => Promise<void>;
  initializeAuth: () => Promise<void>;
  checkSubscription: () => Promise<void>;
  lookupPhone: (identifier: string) => Promise<{ maskedPhone?: string; isPhoneInput: boolean }>;
}

interface LoginCredentials {
  username: string;
  password: string;
}

type AuthStore = AuthState & AuthActions;

export const useAuthStore = create<AuthStore>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      token: null,
      refreshToken: null,
      isAuthenticated: false,
      isLoading: false,
      isInitialized: false,
      error: null,
      subscription: null,
      requiresOtp: false,
      requiresPhone: false,
      maskedPhone: null,

      // Actions
      setAuth: (user: User, token: string) => {
        set({
          user,
          token,
          isAuthenticated: true,
          error: null,
        });

        // Store token in both legacy and new storage keys for persistence
        try {
          localStorage.setItem('auth_token', token);
          localStorage.setItem(AUTH_TOKEN, token);
        } catch (e) {
          // ignore storage errors
        }

        // Set global token for immediate use
        if (typeof window !== 'undefined') {
          window.__AUTH_TOKEN__ = token;
        }

        // Ensure global axios will send Authorization header for generated clients
        try {
          axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        } catch (e) { }

        // Check subscription after auth set
        get().checkSubscription();
      },

      setUser: (user: User) => {
        set({ user });
      },

      clearAuth: () => {
        set({
          user: null,
          token: null,
          refreshToken: null,
          isAuthenticated: false,
          isInitialized: true,
          error: null,
          subscription: null,
        });

        // Clear localStorage (both legacy and new keys)
        try {
          localStorage.removeItem('auth_token');
          localStorage.removeItem('refresh_token');
          localStorage.removeItem('auth_token_timestamp');
          localStorage.removeItem(AUTH_TOKEN);
          localStorage.removeItem(REFRESH_TOKEN);
        } catch (e) {
          // ignore storage errors
        }

        // Clear global token
        if (typeof window !== 'undefined') {
          delete window.__AUTH_TOKEN__;
        }

        // Remove global axios Authorization header
        try {
          delete axios.defaults.headers.common['Authorization'];
        } catch (e) { }
      },

      setLoading: (loading: boolean) => {
        set({ isLoading: loading });
      },

      setError: (error: string | null) => {
        set({ error });
      },

      checkSubscription: async () => {
        try {
          const subInfo = await subscriptionService.getCurrentSubscription();
          if (subInfo) {
            set({
              subscription: {
                isExpired: Boolean(subInfo.isExpired),
                daysRemaining: subInfo.daysRemaining ?? 0,
                planName: subInfo.plan?.name || 'Unknown'
              }
            });
          }
        } catch (error) {
          console.error('Failed to check subscription:', error);
        }
      },

      login: async (credentials: LoginCredentials) => {
        const { setLoading, setError, checkSubscription } = get();

        try {
          setLoading(true);
          setError(null);

          console.log('Attempting login with credentials:', { username: credentials.username, password: '***' }); // Debug log

          const response = await authLogin({ username: credentials.username, password: credentials.password });

          console.log('Login response:', response); // Debug log
          // Orval returns AxiosResponse, so response.data is the backend payload
          const responseData = response.data as any;
          console.log('Response data:', responseData); // Debug log

          if (response.status === 200 && responseData) {
            // Even if phone is not verified, we proceed with login
            // The UI will handle the unverified state via a modal

            if (responseData.access_token && responseData.data) {
              const userData = responseData.data;
              const user: User = {
                id: userData.id,
                email: userData.email,
                name: userData.fullName || userData.firstName || userData.username,
                role: userData.role || 'user',
                phone: userData.phone,
                isPhoneVerified: userData.isPhoneVerified
              };

              // Store tokens (now includes refresh token from backend)
              set({
                user,
                token: responseData.access_token,
                refreshToken: responseData.refreshToken || null,
                isAuthenticated: true,
                error: null,
                requiresOtp: false,
                requiresPhone: false,
                maskedPhone: null,
              });

              // Persist tokens under both legacy and new keys
              try {
                localStorage.setItem('auth_token', responseData.access_token);
                localStorage.setItem(AUTH_TOKEN, responseData.access_token);
                if (responseData.refreshToken) {
                  localStorage.setItem('refresh_token', responseData.refreshToken);
                  localStorage.setItem(REFRESH_TOKEN, responseData.refreshToken);
                }
                localStorage.setItem('auth_token_timestamp', Date.now().toString());
              } catch (e) {
                // ignore storage errors
              }

              // Set global token for immediate use
              if (typeof window !== 'undefined') {
                window.__AUTH_TOKEN__ = responseData.access_token;
              }

              // Ensure global axios will send Authorization header for generated clients
              try {
                axios.defaults.headers.common['Authorization'] = `Bearer ${responseData.access_token}`;
              } catch (e) { }

              // Check subscription
              await checkSubscription();

              console.log('Login successful, user authenticated'); // Debug log
            } else {
              console.error('Missing required fields:', { success: responseData.success, token: !!responseData.access_token, userData: !!responseData.data });
              throw new Error('Sunucudan geçersiz yanıt alındı - eksik token veya kullanıcı bilgisi');
            }
          } else if (response.status === 401) {
            // Handle authentication error
            const errorMessage = 'Geçersiz kullanıcı adı veya şifre';
            console.error('Authentication failed:', errorMessage);
            setError(errorMessage);
            throw new Error(errorMessage);
          } else {
            console.error('Invalid response structure:', { status: response.status, hasData: !!responseData });
            throw new Error('Sunucudan geçersiz yanıt alındı');
          }
        } catch (error: any) {
          console.log('=== LOGIN ERROR ===');
          console.error('Login error:', error);

          let errorMessage = 'Giriş başarısız';

          if (error.response?.status === 401) {
            errorMessage = 'Geçersiz kullanıcı adı veya şifre';
          } else if (error.response?.data?.error) {
            errorMessage = error.response.data.error;
          } else if (error.message && !error.message.includes('status code')) {
            errorMessage = error.message;
          }

          console.log('Setting error message:', errorMessage);
          setError(errorMessage);
          throw error; // Re-throw so UI can handle it
        } finally {
          setLoading(false);
        }
      },

      verifyOtp: async (otp: string) => {
        const { token, setLoading, setError, checkSubscription } = get();
        // We might be logged in but unverified, so we have a token.
        // Or we might be in a pre-auth state (legacy).
        // With the new flow, we are logged in, so we have a token.

        if (!token) {
          setError('Oturum süresi doldu, lütfen tekrar giriş yapın');
          return;
        }

        try {
          setLoading(true);
          setError(null);

          // Use axios directly to ensure we control the request
          // The backend expects { otp: string }
          const response = await axios.post('/api/auth/verify-otp', { otp }, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });

          if (response.status === 200 && response.data?.success) {
            const { access_token: newToken, refreshToken, data: userData } = response.data;

            // Update user with verified status
            const user: User = {
              id: userData.id,
              username: userData.username,
              email: userData.email,
              name: userData.fullName || userData.firstName || userData.username,
              role: userData.role || 'user',
              phone: userData.phone,
              isPhoneVerified: true // Explicitly set to true
            };

            set({
              user,
              token: newToken,
              refreshToken: refreshToken || null,
              isAuthenticated: true,
              error: null,
              requiresOtp: false,
              requiresPhone: false,
              maskedPhone: null
            });

            // Persist tokens
            try {
              localStorage.setItem('auth_token', newToken);
              localStorage.setItem(AUTH_TOKEN, newToken);
              if (refreshToken) {
                localStorage.setItem('refresh_token', refreshToken);
                localStorage.setItem(REFRESH_TOKEN, refreshToken);
              }
              localStorage.setItem('auth_token_timestamp', Date.now().toString());
            } catch (e) { }

            if (typeof window !== 'undefined') {
              window.__AUTH_TOKEN__ = newToken;
            }

            try {
              axios.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
            } catch (e) { }

            await checkSubscription();
          } else {
            setError('Doğrulama başarısız');
          }
        } catch (error: any) {
          console.error('OTP Verification error:', error);
          setError(error.response?.data?.message || error.message || 'Doğrulama başarısız');
          throw error;
        } finally {
          setLoading(false);
        }
      },

      sendOtp: async (phone: string) => {
        const { token, setLoading, setError } = get();
        if (!token) {
          setError('Oturum süresi doldu, lütfen tekrar giriş yapın');
          return;
        }

        try {
          setLoading(true);
          setError(null);

          await axios.post('/api/auth/send-verification-otp', { phone }, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });

          // If success, we might want to update state to show OTP input if it wasn't shown
          // But usually we just show a success message
          // If phone was required, now it's sent, so we can hide phone input? 
          // Or just keep it.

        } catch (error: any) {
          console.error('Send OTP error:', error);
          setError(error.response?.data?.error || error.message || 'OTP gönderilemedi');
          throw error;
        } finally {
          setLoading(false);
        }
      },

      forgotPassword: async (phone: string) => {
        const { setLoading, setError } = get();

        try {
          setLoading(true);
          setError(null);

          console.log('=== FORGOT PASSWORD DEBUG ===');
          console.log('Phone:', phone);
          console.log('Making request to:', '/api/auth/forgot-password');

          const response = await axios.post('/api/auth/forgot-password', {
            identifier: phone,
            captcha_token: 'dummy' // TODO: Implement proper captcha
          });

          console.log('Response received:', response);
          console.log('Response status:', response.status);
          console.log('Response data:', response.data);

          if (response.status === 200 && response.data?.success) {
            // OTP sent successfully - no error, function completes successfully
            console.log('OTP sent successfully');
          } else {
            console.log('Response not successful, throwing error');
            throw new Error(response.data?.error || 'OTP gönderilemedi');
          }
        } catch (error: any) {
          console.log('=== FORGOT PASSWORD ERROR ===');
          console.error('Forgot password error:', error);
          console.error('Error response:', error.response);
          console.error('Error status:', error.response?.status);
          console.error('Error data:', error.response?.data);

          let errorMessage = 'OTP gönderilemedi';

          if (error.response?.status === 404) {
            errorMessage = 'Bu telefon numarasına kayıtlı kullanıcı bulunamadı';
            console.log('404 error detected, message:', errorMessage);
          } else if (error.response?.data?.error) {
            // Translate common backend errors
            const backendError = error.response.data.error;
            if (backendError.includes('not found') || backendError.includes('User not found')) {
              errorMessage = 'Bu telefon numarasına kayıtlı kullanıcı bulunamadı';
            } else {
              errorMessage = backendError;
            }
            console.log('Backend error message:', errorMessage);
          } else if (error.message) {
            errorMessage = error.message;
            console.log('Generic error message:', errorMessage);
          }

          console.log('Final error message:', errorMessage);
          setError(errorMessage);
          throw new Error(errorMessage);
        } finally {
          setLoading(false);
        }
      },

      lookupPhone: async (identifier: string) => {
        const { setLoading, setError } = get();
        try {
          setLoading(true);
          setError(null);

          const response = await axios.post('/api/auth/lookup-phone', { identifier });

          if (response.status === 200 && response.data?.success) {
            return {
              maskedPhone: response.data.masked_phone,
              isPhoneInput: response.data.is_phone_input
            };
          } else {
            throw new Error(response.data?.error || 'Kullanıcı bulunamadı');
          }
        } catch (error: any) {
          // Handle "not found" explicitly
          if (error.response?.status === 404) {
            const msg = 'Kayıtlı kullanıcı bulunamadı';
            setError(msg);
            throw new Error(msg);
          }
          const msg = error.response?.data?.error || error.message || 'Bir hata oluştu';
          setError(msg);
          throw new Error(msg);
        } finally {
          setLoading(false);
        }
      },


      verifyResetOtp: async (phone: string, otp: string) => {
        const { setLoading, setError } = get();

        try {
          setLoading(true);
          setError(null);

          const response = await axios.post('/api/auth/verify-otp', {
            identifier: phone,
            otp: otp
          });

          if (response.status === 200 && response.data?.success) {
            // OTP verified successfully
          } else {
            throw new Error('Doğrulama başarısız');
          }
        } catch (error: any) {
          console.error('Verify reset OTP error:', error);
          setError(error.response?.data?.message || error.message || 'Doğrulama başarısız');
          throw error;
        } finally {
          setLoading(false);
        }
      },

      resetPassword: async (phone: string, otp: string, newPassword: string) => {
        const { setLoading, setError } = get();

        try {
          setLoading(true);
          setError(null);

          const response = await axios.post('/api/auth/reset-password', {
            identifier: phone,
            otp: otp,
            newPassword: newPassword
          });

          if (response.status === 200 && response.data?.success) {
            // Password reset successfully
          } else {
            throw new Error('Şifre sıfırlanamadı');
          }
        } catch (error: any) {
          console.error('Reset password error:', error);
          setError(error.response?.data?.error || error.message || 'Şifre sıfırlanamadı');
          throw error;
        } finally {
          setLoading(false);
        }
      },

      logout: () => {
        get().clearAuth();
      },

      refreshAuth: async () => {
        try {
          const { refreshToken, clearAuth } = get();

          if (!refreshToken) {
            clearAuth();
            return;
          }

          const response = await authRefresh({ refreshToken });
          if (response.status === 200 && response.data) {
            // Backend should return { access_token, data: user } format
            const responseData = response.data as any;
            const { access_token: newToken } = responseData;
            set({ token: newToken });
            try {
              localStorage.setItem('auth_token', newToken);
              localStorage.setItem(AUTH_TOKEN, newToken);
            } catch (e) { }
            if (typeof window !== 'undefined') {
              window.__AUTH_TOKEN__ = newToken;
            }
            // Update global axios header after refresh
            try {
              axios.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
            } catch (e) { }
          } else {
            clearAuth();
          }
        } catch (error) {
          console.error('Token refresh failed:', error);
          get().clearAuth();
        }
      },

      initializeAuth: async () => {
        const { setLoading, login, isAuthenticated, checkSubscription } = get();

        // Prevent multiple initialization calls
        if (isAuthenticated) {
          checkSubscription();
          return;
        }

        // Try to restore auth from persisted tokens (always)
        let storedToken = localStorage.getItem('auth_token');
        let storedRefreshToken = localStorage.getItem('refresh_token');
        const tokenTimestamp = localStorage.getItem('auth_token_timestamp');

        // If no token in localStorage, attempt to read cookie named 'auth_token' (some dev setups use cookies)
        try {
          if (!storedToken && typeof document !== 'undefined') {
            const match = document.cookie.match(new RegExp('(^| )auth_token=([^;]+)'));
            if (match) storedToken = decodeURIComponent(match[2]);
          }
          if (!storedRefreshToken && typeof document !== 'undefined') {
            const matchR = document.cookie.match(new RegExp('(^| )refresh_token=([^;]+)'));
            if (matchR) storedRefreshToken = decodeURIComponent(matchR[2]);
          }
        } catch (e) {
          // ignore cookie read errors
        }

        if (storedToken) {
          try {
            const now = Date.now();
            const tokenAge = tokenTimestamp ? now - parseInt(tokenTimestamp) : 0;

            if (!tokenTimestamp || tokenAge < DEV_CONFIG.TOKEN_PERSISTENCE_DURATION) {
              // Token is still valid, restore auth state
              if (typeof window !== 'undefined') {
                window.__AUTH_TOKEN__ = storedToken;
              }

              // Get current user info from API
              try {
                const { usersGetCurrentUser } = await import('../api/generated/xEarCRMAPIAutoGenerated');
                const userResponse = await usersGetCurrentUser();

                if (userResponse.status === 200 && userResponse.data) {
                  const userData = userResponse.data;
                  const transformedUser: User = {
                    id: userData.id || '',
                    email: userData.email || '',
                    name: `${userData.firstName || ''} ${userData.lastName || ''}`.trim() || userData.username || '',
                    role: userData.role || 'user',
                    phone: userData.phone,
                    isPhoneVerified: (userData as any).isPhoneVerified
                  };

                  set({
                    user: transformedUser,
                    token: storedToken,
                    refreshToken: storedRefreshToken,
                    isAuthenticated: true,
                    isInitialized: true,
                    error: null,
                  });

                  await checkSubscription();
                  console.log('Auth state restored successfully with user:', transformedUser);
                  return;
                }
              } catch (err) {
                console.warn('Failed to fetch current user during restore:', err);
                // If fetch fails, clear persisted tokens
                localStorage.removeItem('auth_token');
                localStorage.removeItem('refresh_token');
                localStorage.removeItem('auth_token_timestamp');
              }
            }
          } catch (error) {
            console.warn('Failed to restore auth state:', error);
            localStorage.removeItem('auth_token');
            localStorage.removeItem('refresh_token');
            localStorage.removeItem('auth_token_timestamp');
          }
        }

        // If restoration failed and auto-login is enabled in dev, try auto-login
        if (DEV_CONFIG.AUTO_LOGIN_ENABLED) {
          try {
            setLoading(true);
            await login(DEV_CONFIG.DEFAULT_CREDENTIALS);
          } catch (error) {
            console.warn('Auto-login failed:', error);
          } finally {
            setLoading(false);
          }
        }
        // Mark initialization attempt complete (success or failure)
        try {
          set({ isInitialized: true });
        } catch (e) { }
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        token: state.token,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
        subscription: state.subscription,
        error: state.error, // Include error in persistence
      }),
    }
  )
);