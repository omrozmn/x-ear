/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateJobRequest,
  DebugNERRequest,
  EntityExtractionRequest,
  HTTPValidationError,
  ListJobsParams,
  OCRProcessRequest,
  PatientExtractionRequest,
  SimilarityRequest
} from '.././schemas';

import { adminApi } from '../../apiMutator';




/**
 * Health check endpoint (Public)
 * @summary Health Check
 */
export const healthOcrHealthCheck = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/health`, method: 'GET', signal
    },
      );
    }
  



export const getHealthOcrHealthCheckQueryKey = () => {
    return [
    `/api/ocr/health`
    ] as const;
    }

    
export const getHealthOcrHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthOcrHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthOcrHealthCheck>>> = ({ signal }) => healthOcrHealthCheck(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type HealthOcrHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthOcrHealthCheck>>>
export type HealthOcrHealthCheckQueryError = unknown


export function useHealthOcrHealthCheck<TData = Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthOcrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthOcrHealthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthOcrHealthCheck<TData = Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthOcrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthOcrHealthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthOcrHealthCheck<TData = Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health Check
 */

export function useHealthOcrHealthCheck<TData = Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthOcrHealthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getHealthOcrHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Initialize database and create tables (System Admin)
 * @summary Init Database
 */
export const initDatabase = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/init-db`, method: 'POST', signal
    },
      );
    }
  


export const getInitDatabaseMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initDatabase>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof initDatabase>>, TError,void, TContext> => {

const mutationKey = ['initDatabase'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initDatabase>>, void> = () => {
          

          return  initDatabase()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof initDatabase>>>
    
    export type InitDatabaseMutationError = unknown

    /**
 * @summary Init Database
 */
export const useInitDatabase = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initDatabase>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initDatabase>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInitDatabaseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Initialize NLP/OCR service (System Admin)
 * @summary Initialize Nlp Endpoint
 */
export const initializeNlpEndpoint = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/initialize`, method: 'POST', signal
    },
      );
    }
  


export const getInitializeNlpEndpointMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeNlpEndpoint>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof initializeNlpEndpoint>>, TError,void, TContext> => {

const mutationKey = ['initializeNlpEndpoint'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeNlpEndpoint>>, void> = () => {
          

          return  initializeNlpEndpoint()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeNlpEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof initializeNlpEndpoint>>>
    
    export type InitializeNlpEndpointMutationError = unknown

    /**
 * @summary Initialize Nlp Endpoint
 */
export const useInitializeNlpEndpoint = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeNlpEndpoint>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeNlpEndpoint>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInitializeNlpEndpointMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Process document with OCR
 * @summary Process Document
 */
export const processDocument = (
    oCRProcessRequest: OCRProcessRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/process`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: oCRProcessRequest, signal
    },
      );
    }
  


export const getProcessDocumentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDocument>>, TError,{data: OCRProcessRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof processDocument>>, TError,{data: OCRProcessRequest}, TContext> => {

const mutationKey = ['processDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processDocument>>, {data: OCRProcessRequest}> = (props) => {
          const {data} = props ?? {};

          return  processDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof processDocument>>>
    export type ProcessDocumentMutationBody = OCRProcessRequest
    export type ProcessDocumentMutationError = HTTPValidationError

    /**
 * @summary Process Document
 */
export const useProcessDocument = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDocument>>, TError,{data: OCRProcessRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processDocument>>,
        TError,
        {data: OCRProcessRequest},
        TContext
      > => {

      const mutationOptions = getProcessDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Calculate similarity between documents
 * @summary Calculate Similarity
 */
export const calculateSimilarity = (
    similarityRequest: SimilarityRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/similarity`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: similarityRequest, signal
    },
      );
    }
  


export const getCalculateSimilarityMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateSimilarity>>, TError,{data: SimilarityRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof calculateSimilarity>>, TError,{data: SimilarityRequest}, TContext> => {

const mutationKey = ['calculateSimilarity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateSimilarity>>, {data: SimilarityRequest}> = (props) => {
          const {data} = props ?? {};

          return  calculateSimilarity(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof calculateSimilarity>>>
    export type CalculateSimilarityMutationBody = SimilarityRequest
    export type CalculateSimilarityMutationError = HTTPValidationError

    /**
 * @summary Calculate Similarity
 */
export const useCalculateSimilarity = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateSimilarity>>, TError,{data: SimilarityRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateSimilarity>>,
        TError,
        {data: SimilarityRequest},
        TContext
      > => {

      const mutationOptions = getCalculateSimilarityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract entities from image using OCR
 * @summary Extract Entities
 */
export const extractEntities = (
    entityExtractionRequest: EntityExtractionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/entities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: entityExtractionRequest, signal
    },
      );
    }
  


export const getExtractEntitiesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractEntities>>, TError,{data: EntityExtractionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractEntities>>, TError,{data: EntityExtractionRequest}, TContext> => {

const mutationKey = ['extractEntities'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractEntities>>, {data: EntityExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  extractEntities(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractEntitiesMutationResult = NonNullable<Awaited<ReturnType<typeof extractEntities>>>
    export type ExtractEntitiesMutationBody = EntityExtractionRequest
    export type ExtractEntitiesMutationError = HTTPValidationError

    /**
 * @summary Extract Entities
 */
export const useExtractEntities = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractEntities>>, TError,{data: EntityExtractionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof extractEntities>>,
        TError,
        {data: EntityExtractionRequest},
        TContext
      > => {

      const mutationOptions = getExtractEntitiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract patient name from image using OCR
 * @summary Extract Patient Name
 */
export const extractPatientName = (
    patientExtractionRequest: PatientExtractionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/extract_patient`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientExtractionRequest, signal
    },
      );
    }
  


export const getExtractPatientNameMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractPatientName>>, TError,{data: PatientExtractionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractPatientName>>, TError,{data: PatientExtractionRequest}, TContext> => {

const mutationKey = ['extractPatientName'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractPatientName>>, {data: PatientExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  extractPatientName(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractPatientNameMutationResult = NonNullable<Awaited<ReturnType<typeof extractPatientName>>>
    export type ExtractPatientNameMutationBody = PatientExtractionRequest
    export type ExtractPatientNameMutationError = HTTPValidationError

    /**
 * @summary Extract Patient Name
 */
export const useExtractPatientName = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractPatientName>>, TError,{data: PatientExtractionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof extractPatientName>>,
        TError,
        {data: PatientExtractionRequest},
        TContext
      > => {

      const mutationOptions = getExtractPatientNameMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Debug endpoint for NER (System Admin)
 * @summary Debug Ner
 */
export const debugNer = (
    debugNERRequest: DebugNERRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/debug_ner`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: debugNERRequest, signal
    },
      );
    }
  


export const getDebugNerMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugNer>>, TError,{data: DebugNERRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof debugNer>>, TError,{data: DebugNERRequest}, TContext> => {

const mutationKey = ['debugNer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof debugNer>>, {data: DebugNERRequest}> = (props) => {
          const {data} = props ?? {};

          return  debugNer(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DebugNerMutationResult = NonNullable<Awaited<ReturnType<typeof debugNer>>>
    export type DebugNerMutationBody = DebugNERRequest
    export type DebugNerMutationError = HTTPValidationError

    /**
 * @summary Debug Ner
 */
export const useDebugNer = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof debugNer>>, TError,{data: DebugNERRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof debugNer>>,
        TError,
        {data: DebugNERRequest},
        TContext
      > => {

      const mutationOptions = getDebugNerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List OCR jobs
 * @summary List Jobs
 */
export const listJobs = (
    params?: ListJobsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/jobs`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListJobsQueryKey = (params?: ListJobsParams,) => {
    return [
    `/api/ocr/jobs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListJobsQueryOptions = <TData = Awaited<ReturnType<typeof listJobs>>, TError = HTTPValidationError>(params?: ListJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListJobsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listJobs>>> = ({ signal }) => listJobs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListJobsQueryResult = NonNullable<Awaited<ReturnType<typeof listJobs>>>
export type ListJobsQueryError = HTTPValidationError


export function useListJobs<TData = Awaited<ReturnType<typeof listJobs>>, TError = HTTPValidationError>(
 params: undefined |  ListJobsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listJobs>>,
          TError,
          Awaited<ReturnType<typeof listJobs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListJobs<TData = Awaited<ReturnType<typeof listJobs>>, TError = HTTPValidationError>(
 params?: ListJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listJobs>>,
          TError,
          Awaited<ReturnType<typeof listJobs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListJobs<TData = Awaited<ReturnType<typeof listJobs>>, TError = HTTPValidationError>(
 params?: ListJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Jobs
 */

export function useListJobs<TData = Awaited<ReturnType<typeof listJobs>>, TError = HTTPValidationError>(
 params?: ListJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listJobs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListJobsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new OCR job
 * @summary Create Job
 */
export const createJob = (
    createJobRequest: CreateJobRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/jobs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createJobRequest, signal
    },
      );
    }
  


export const getCreateJobMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createJob>>, TError,{data: CreateJobRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createJob>>, TError,{data: CreateJobRequest}, TContext> => {

const mutationKey = ['createJob'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createJob>>, {data: CreateJobRequest}> = (props) => {
          const {data} = props ?? {};

          return  createJob(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateJobMutationResult = NonNullable<Awaited<ReturnType<typeof createJob>>>
    export type CreateJobMutationBody = CreateJobRequest
    export type CreateJobMutationError = HTTPValidationError

    /**
 * @summary Create Job
 */
export const useCreateJob = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createJob>>, TError,{data: CreateJobRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createJob>>,
        TError,
        {data: CreateJobRequest},
        TContext
      > => {

      const mutationOptions = getCreateJobMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get OCR job status
 * @summary Get Job
 */
export const getJob = (
    jobId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/ocr/jobs/${jobId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetJobQueryKey = (jobId?: string,) => {
    return [
    `/api/ocr/jobs/${jobId}`
    ] as const;
    }

    
export const getGetJobQueryOptions = <TData = Awaited<ReturnType<typeof getJob>>, TError = HTTPValidationError>(jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetJobQueryKey(jobId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getJob>>> = ({ signal }) => getJob(jobId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(jobId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetJobQueryResult = NonNullable<Awaited<ReturnType<typeof getJob>>>
export type GetJobQueryError = HTTPValidationError


export function useGetJob<TData = Awaited<ReturnType<typeof getJob>>, TError = HTTPValidationError>(
 jobId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJob>>,
          TError,
          Awaited<ReturnType<typeof getJob>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetJob<TData = Awaited<ReturnType<typeof getJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJob>>,
          TError,
          Awaited<ReturnType<typeof getJob>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetJob<TData = Awaited<ReturnType<typeof getJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Job
 */

export function useGetJob<TData = Awaited<ReturnType<typeof getJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJob>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetJobQueryOptions(jobId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




