/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ErrorResponse,
  InvoicesCreateInvoice201,
  InvoicesCreateInvoiceBody,
  InvoicesDeleteInvoice200,
  InvoicesGetInvoice200,
  InvoicesIssue200,
  InvoicesList200,
  InvoicesListParams,
  InvoicesSendToGib200
} from '../index.schemas';

import { adminApi } from '../../apiMutator';




/**
 * @summary List invoices with filters and pagination
 */
export const invoicesList = (
    params?: InvoicesListParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesList200>(
      {url: `/api/invoices`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getInvoicesListQueryKey = (params?: InvoicesListParams,) => {
    return [
    `/api/invoices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInvoicesListQueryOptions = <TData = Awaited<ReturnType<typeof invoicesList>>, TError = ErrorResponse>(params?: InvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesList>>> = ({ signal }) => invoicesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesListQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesList>>>
export type InvoicesListQueryError = ErrorResponse


export function useInvoicesList<TData = Awaited<ReturnType<typeof invoicesList>>, TError = ErrorResponse>(
 params: undefined |  InvoicesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesList>>,
          TError,
          Awaited<ReturnType<typeof invoicesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesList<TData = Awaited<ReturnType<typeof invoicesList>>, TError = ErrorResponse>(
 params?: InvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesList>>,
          TError,
          Awaited<ReturnType<typeof invoicesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesList<TData = Awaited<ReturnType<typeof invoicesList>>, TError = ErrorResponse>(
 params?: InvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List invoices with filters and pagination
 */

export function useInvoicesList<TData = Awaited<ReturnType<typeof invoicesList>>, TError = ErrorResponse>(
 params?: InvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new invoice for a patient
 * @summary Create a new invoice
 */
export const invoicesCreateInvoice = (
    invoicesCreateInvoiceBody: InvoicesCreateInvoiceBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesCreateInvoice201>(
      {url: `/api/invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesCreateInvoiceBody, signal
    },
      );
    }
  


export const getInvoicesCreateInvoiceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext> => {

const mutationKey = ['invoicesCreateInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateInvoice>>, {data: InvoicesCreateInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateInvoice>>>
    export type InvoicesCreateInvoiceMutationBody = InvoicesCreateInvoiceBody
    export type InvoicesCreateInvoiceMutationError = ErrorResponse

    /**
 * @summary Create a new invoice
 */
export const useInvoicesCreateInvoice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateInvoice>>,
        TError,
        {data: InvoicesCreateInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve an invoice by its ID
 * @summary Get invoice by ID
 */
export const invoicesGetInvoice = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesGetInvoice200>(
      {url: `/api/invoices/${invoiceId}`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetInvoiceQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}`
    ] as const;
    }

    
export const getInvoicesGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = ErrorResponse>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetInvoiceQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetInvoice>>> = ({ signal }) => invoicesGetInvoice(invoiceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetInvoice>>>
export type InvoicesGetInvoiceQueryError = ErrorResponse


export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = ErrorResponse>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice by ID
 */

export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetInvoiceQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete an invoice by its ID
 * @summary Delete invoice by ID
 */
export const invoicesDeleteInvoice = (
    invoiceId: string,
 ) => {
      
      
      return adminApi<InvoicesDeleteInvoice200>(
      {url: `/api/invoices/${invoiceId}`, method: 'DELETE'
    },
      );
    }
  


export const getInvoicesDeleteInvoiceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesDeleteInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesDeleteInvoice(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesDeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesDeleteInvoice>>>
    
    export type InvoicesDeleteInvoiceMutationError = ErrorResponse

    /**
 * @summary Delete invoice by ID
 */
export const useInvoicesDeleteInvoice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate and download a PDF for the specified invoice
 * @summary Generate invoice PDF
 */
export const invoicesGenerateInvoicePdf = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Blob>(
      {url: `/api/invoices/${invoiceId}/pdf`, method: 'GET',
        responseType: 'blob', signal
    },
      );
    }
  



export const getInvoicesGenerateInvoicePdfQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}/pdf`
    ] as const;
    }

    
export const getInvoicesGenerateInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = ErrorResponse>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGenerateInvoicePdfQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>> = ({ signal }) => invoicesGenerateInvoicePdf(invoiceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGenerateInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>>
export type InvoicesGenerateInvoicePdfQueryError = ErrorResponse


export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = ErrorResponse>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate invoice PDF
 */

export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = ErrorResponse>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGenerateInvoicePdfQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Issue invoice (finalize draft and prepare for GÄ°B submission)
 * @summary Issue invoice (finalize and prepare for GÄ°B)
 */
export const invoicesIssue = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesIssue200>(
      {url: `/api/invoices/${invoiceId}/issue`, method: 'POST', signal
    },
      );
    }
  


export const getInvoicesIssueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesIssue>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesIssue>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesIssue'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesIssue>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesIssue(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesIssueMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesIssue>>>
    
    export type InvoicesIssueMutationError = ErrorResponse

    /**
 * @summary Issue invoice (finalize and prepare for GÄ°B)
 */
export const useInvoicesIssue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesIssue>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesIssue>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesIssueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send the invoice to GÄ°B (Turkish Revenue Administration)
 * @summary Send invoice to GÄ°B
 */
export const invoicesSendToGib = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesSendToGib200>(
      {url: `/api/invoices/${invoiceId}/send-to-gib`, method: 'POST', signal
    },
      );
    }
  


export const getInvoicesSendToGibMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesSendToGib'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesSendToGib>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesSendToGib(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesSendToGibMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesSendToGib>>>
    
    export type InvoicesSendToGibMutationError = ErrorResponse

    /**
 * @summary Send invoice to GÄ°B
 */
export const useInvoicesSendToGib = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendToGib>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesSendToGib>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesSendToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    