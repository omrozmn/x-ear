/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ErrorResponse,
  Patient,
  PatientCreate,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesCreatePatientNoteBody,
  PatientsBulkUploadPatientsBody,
  PatientsCreatePatientBody,
  PatientsGetPatientDevices200,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  PatientsUpdatePatient200,
  Sale,
  SalesAssignDevicesExtendedBody,
  SuccessResponse
} from '../index.schemas';

import { adminApi } from '../../apiMutator';




/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
    params?: PatientsGetPatientsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<PatientsGetPatients200>(
      {url: `/api/patients`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getPatientsGetPatientsQueryKey = (params?: PatientsGetPatientsParams,) => {
    return [
    `/api/patients`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsGetPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse>(params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatients>>> = ({ signal }) => patientsGetPatients(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatients>>>
export type PatientsGetPatientsQueryError = ErrorResponse


export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse>(
 params: undefined |  PatientsGetPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Patient>(
      {url: `/api/patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsCreatePatientBody, signal
    },
      );
    }
  


export const getPatientsCreatePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = unknown

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve a single patient by ID
 * @summary GET /api/patients/{patient_id}
 */
export const patientsGetPatient = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Patient>(
      {url: `/api/patients/${patientId}`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = void>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = void


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = void>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = void>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = void>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = void>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing patient record
 * @summary PUT /api/patients/{patient_id}
 */
export const patientsUpdatePatient = (
    patientId: string,
    patientCreate: PatientCreate,
 ) => {
      
      
      return adminApi<PatientsUpdatePatient200>(
      {url: `/api/patients/${patientId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientCreate
    },
      );
    }
  


export const getPatientsUpdatePatientMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientCreate}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: PatientCreate}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = PatientCreate
    export type PatientsUpdatePatientMutationError = void

    /**
 * @summary PUT /api/patients/{patient_id}
 */
export const usePatientsUpdatePatient = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: PatientCreate},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string,
 ) => {
      
      
      return adminApi<SuccessResponse>(
      {url: `/api/patients/${patientId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientsDeletePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/assign-devices-extended`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesAssignDevicesExtendedBody, signal
    },
      );
    }
  


export const getSalesAssignDevicesExtendedMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<PatientsGetPatientDevices200>(
      {url: `/api/patients/${patientId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientsGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientDevices>>> = ({ signal }) => patientsGetPatientDevices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientDevices>>>
export type PatientsGetPatientDevicesQueryError = unknown


export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesCreatePatientEreceiptBody, signal
    },
      );
    }
  


export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesAddPatientHearingTestBody, signal
    },
      );
    }
  


export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
    patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesCreatePatientNoteBody, signal
    },
      );
    }
  


export const getPatientSubresourcesCreatePatientNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, {patientId: string;data: PatientSubresourcesCreatePatientNoteBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientNote(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>>
    export type PatientSubresourcesCreatePatientNoteMutationBody = PatientSubresourcesCreatePatientNoteBody
    export type PatientSubresourcesCreatePatientNoteMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
    patientId: string,
    noteId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  patientSubresourcesDeletePatientNote(patientId,noteId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>>
    
    export type PatientSubresourcesDeletePatientNoteMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/promissory-notes`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = unknown


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Sale[]>(
      {url: `/api/patients/${patientId}/sales`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = unknown


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/sgk-documents`, method: 'GET', signal
    },
      );
    }
  



export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = unknown


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/bulk_upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsBulkUploadPatientsBody, signal
    },
      );
    }
  


export const getPatientsBulkUploadPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = unknown

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/export`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = unknown


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/search`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = unknown


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




