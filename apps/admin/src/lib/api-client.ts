/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * OpenAPI spec version: 0.0.0-auto
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { adminApi } from './apiMutator';
export interface Permission {
  id?: string;
  name?: string;
  description?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface Role {
  id?: string;
  name?: string;
  description?: string;
  isSystem?: boolean;
  permissions?: Permission[];
  createdAt?: string;
  updatedAt?: string;
}

export type SMSProviderConfigDocumentsItem = { [key: string]: unknown };

export interface SMSProviderConfig {
  id?: string;
  tenantId?: string;
  apiUsername?: string;
  documentsEmail?: string;
  isActive?: boolean;
  documents?: SMSProviderConfigDocumentsItem[];
}

export type SMSHeaderRequestHeaderType = typeof SMSHeaderRequestHeaderType[keyof typeof SMSHeaderRequestHeaderType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SMSHeaderRequestHeaderType = {
  company_title: 'company_title',
  trademark: 'trademark',
  domain: 'domain',
  other: 'other',
} as const;

export type SMSHeaderRequestStatus = typeof SMSHeaderRequestStatus[keyof typeof SMSHeaderRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SMSHeaderRequestStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
} as const;

export interface SMSHeaderRequest {
  id?: string;
  tenantId?: string;
  headerText?: string;
  headerType?: SMSHeaderRequestHeaderType;
  status?: SMSHeaderRequestStatus;
  rejectionReason?: string;
  documents?: string[];
  createdAt?: string;
}

export interface SMSPackage {
  id?: string;
  name?: string;
  description?: string;
  smsCount?: number;
  price?: number;
  currency?: string;
  isActive?: boolean;
}

export interface TenantSMSCredit {
  id?: string;
  tenantId?: string;
  balance?: number;
  totalPurchased?: number;
  totalUsed?: number;
}

export type CampaignTargetCriteria = { [key: string]: unknown };

export interface Campaign {
  id?: string;
  tenantId?: string;
  name?: string;
  description?: string;
  campaignType?: string;
  targetSegment?: string;
  targetCriteria?: CampaignTargetCriteria;
  messageTemplate?: string;
  status?: string;
  totalRecipients?: number;
  successfulSends?: number;
  failedSends?: number;
  createdAt?: string;
  sentAt?: string;
}

export type TargetAudienceFilterCriteria = { [key: string]: unknown };

export interface TargetAudience {
  id?: string;
  tenantId?: string;
  name?: string;
  sourceType?: string;
  totalRecords?: number;
  filterCriteria?: TargetAudienceFilterCriteria;
  createdAt?: string;
}

export interface ActivityLog {
  id?: string;
  userId?: string;
  action?: string;
  entityType?: string;
  entityId?: string;
  details?: string;
  ipAddress?: string;
  userAgent?: string;
  createdAt?: string;
}

export interface Notification {
  id?: string;
  userId?: string;
  title?: string;
  message?: string;
  type?: string;
  read?: boolean;
  createdAt?: string;
}

export interface User {
  id?: string;
  username?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  role?: string;
  phone?: string;
  isPhoneVerified?: boolean;
  isActive?: boolean;
  createdAt?: string;
}

export type CommunicationTemplateTemplateType = typeof CommunicationTemplateTemplateType[keyof typeof CommunicationTemplateTemplateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommunicationTemplateTemplateType = {
  sms: 'sms',
  email: 'email',
} as const;

export interface CommunicationTemplate {
  id?: string;
  name?: string;
  description?: string;
  templateType?: CommunicationTemplateTemplateType;
  category?: string;
  subject?: string;
  bodyText?: string;
  bodyHtml?: string;
  variables?: string[];
  isActive?: boolean;
  isSystem?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export type CommunicationTemplateCreateBodyTemplateType = typeof CommunicationTemplateCreateBodyTemplateType[keyof typeof CommunicationTemplateCreateBodyTemplateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommunicationTemplateCreateBodyTemplateType = {
  sms: 'sms',
  email: 'email',
} as const;

export interface CommunicationTemplateCreateBody {
  name: string;
  description?: string;
  templateType: CommunicationTemplateCreateBodyTemplateType;
  category?: string;
  subject?: string;
  bodyText: string;
  bodyHtml?: string;
  variables?: string[];
  isActive?: boolean;
}

export interface InventoryItem {
  id?: string;
  name?: string;
  brand?: string;
  model?: string;
  category?: string;
  barcode?: string;
  stock?: number;
  price?: number;
  currency?: string;
  minStockLevel?: number;
  isActive?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export type TenantStatusProperty = typeof TenantStatusProperty[keyof typeof TenantStatusProperty];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TenantStatusProperty = {
  active: 'active',
  trial: 'trial',
  suspended: 'suspended',
  cancelled: 'cancelled',
} as const;

export type TenantFeatureUsage = { [key: string]: unknown };

export interface Tenant {
  id?: string;
  name?: string;
  slug?: string;
  owner_email?: string;
  billing_email?: string;
  status?: TenantStatusProperty;
  current_plan?: string;
  current_plan_id?: string;
  max_users?: number;
  current_users?: number;
  subscription_start_date?: string;
  subscription_end_date?: string;
  feature_usage?: TenantFeatureUsage;
  created_at?: string;
}

export type TenantStatus = typeof TenantStatus[keyof typeof TenantStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TenantStatus = {
  active: 'active',
  trial: 'trial',
  suspended: 'suspended',
  cancelled: 'cancelled',
} as const;

export type PlanFeatures = { [key: string]: unknown };

export interface Plan {
  id?: string;
  name?: string;
  description?: string;
  plan_type?: string;
  price?: number;
  currency?: string;
  billing_interval?: string;
  features?: PlanFeatures;
  max_users?: number;
  max_storage_gb?: number;
  is_active?: boolean;
  is_public?: boolean;
  created_at?: string;
}

export type PlanInputFeatures = { [key: string]: unknown };

export interface PlanInput {
  name?: string;
  description?: string;
  plan_type?: string;
  price?: number;
  billing_interval?: string;
  features?: PlanInputFeatures;
  max_users?: number;
  max_storage_gb?: number;
  is_active?: boolean;
}

export type AddOnAddonType = typeof AddOnAddonType[keyof typeof AddOnAddonType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddOnAddonType = {
  FLAT_FEE: 'FLAT_FEE',
  PER_USER: 'PER_USER',
  USAGE_BASED: 'USAGE_BASED',
} as const;

export interface AddOn {
  id?: string;
  name?: string;
  slug?: string;
  description?: string;
  addon_type?: AddOnAddonType;
  price?: number;
  currency?: string;
  limit_amount?: number;
  unit_name?: string;
  is_active?: boolean;
}

export interface AdminUser {
  id?: string;
  email?: string;
  first_name?: string;
  last_name?: string;
  role?: AdminUserRole;
  is_active?: boolean;
  isActive?: boolean;
  last_login?: string;
  created_at?: string;
  tenant_id?: string;
  tenant_name?: string;
}

export type AdminUserRole = typeof AdminUserRole[keyof typeof AdminUserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminUserRole = {
  tenant_admin: 'tenant_admin',
  admin: 'admin',
  user: 'user',
  doctor: 'doctor',
  secretary: 'secretary',
  support: 'support',
} as const;

export interface Pagination {
  page?: number;
  limit?: number;
  total?: number;
  totalPages?: number;
}

export type SupportTicketStatus = typeof SupportTicketStatus[keyof typeof SupportTicketStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SupportTicketStatus = {
  open: 'open',
  in_progress: 'in_progress',
  resolved: 'resolved',
  closed: 'closed',
} as const;

export type SupportTicketPriority = typeof SupportTicketPriority[keyof typeof SupportTicketPriority];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SupportTicketPriority = {
  low: 'low',
  medium: 'medium',
  high: 'high',
  critical: 'critical',
} as const;

export interface SupportTicket {
  id?: string;
  title?: string;
  description?: string;
  status?: SupportTicketStatus;
  priority?: SupportTicketPriority;
  category?: string;
  tenant_id?: string;
  tenant_name?: string;
  created_by?: string;
  assigned_to?: string;
  assigned_admin_name?: string;
  created_at?: string;
  sla_due_date?: string;
}

export interface SystemSettings {
  siteName?: string;
  siteDescription?: string;
  timezone?: string;
  language?: string;
  currency?: string;
  maintenanceMode?: boolean;
  registrationEnabled?: boolean;
  emailNotifications?: boolean;
  autoBackup?: boolean;
  smtpHost?: string;
  smtpPort?: string;
  smtpUsername?: string;
  smtpPassword?: string;
  fromEmail?: string;
  fromName?: string;
  smtpSecure?: boolean;
  sessionTimeout?: string;
  maxLoginAttempts?: string;
  passwordMinLength?: string;
  jwtExpiry?: string;
  twoFactorAuth?: boolean;
  forcePasswordChange?: boolean;
  ipWhitelist?: boolean;
  auditLogging?: boolean;
  backupSchedule?: string;
  backupRetention?: string;
  backupLocation?: string;
  backupCompression?: boolean;
  backupEncryptionKey?: string;
  birFaturaApiKey?: string;
  birFaturaApiSecret?: string;
  smsProvider?: string;
  smsUsername?: string;
  smsPassword?: string;
  smsHeader?: string;
  paymentProvider?: string;
  paymentApiKey?: string;
  paymentSecretKey?: string;
}

export type DashboardMetricsOverview = {
  total_tenants?: number;
  active_tenants?: number;
  total_users?: number;
  active_users?: number;
  total_plans?: number;
};

export type DashboardMetricsRevenue = {
  monthly_recurring_revenue?: number;
};

export type DashboardMetricsAlerts = {
  expiring_soon?: number;
  high_churn?: number;
  low_utilization?: number;
};

export type DashboardMetricsHealthMetrics = {
  churn_rate_percent?: number;
  avg_seat_utilization_percent?: number;
};

export type DashboardMetricsRecentActivity = {
  new_tenants_7d?: number;
  expiring_memberships_30d?: number;
};

export interface DashboardMetrics {
  overview?: DashboardMetricsOverview;
  revenue?: DashboardMetricsRevenue;
  alerts?: DashboardMetricsAlerts;
  health_metrics?: DashboardMetricsHealthMetrics;
  recent_activity?: DashboardMetricsRecentActivity;
}

export type InvoiceStatus = typeof InvoiceStatus[keyof typeof InvoiceStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvoiceStatus = {
  draft: 'draft',
  open: 'open',
  paid: 'paid',
  overdue: 'overdue',
  void: 'void',
} as const;

export type InvoiceItemsItem = {
  id?: string;
  description?: string;
  quantity?: number;
  unit_price?: number;
  total?: number;
};

export interface Invoice {
  id?: string;
  invoice_number?: string;
  tenant_id?: string;
  tenant_name?: string;
  status?: InvoiceStatus;
  total?: number;
  subtotal?: number;
  tax_total?: number;
  currency?: string;
  paid_amount?: number;
  issue_date?: string;
  due_date?: string;
  items?: InvoiceItemsItem[];
}

export type AnalyticsDataOverview = {
  total_revenue?: number;
  revenue_growth?: number;
  active_tenants?: number;
  tenants_growth?: number;
  monthly_active_users?: number;
  mau_growth?: number;
  churn_rate?: number;
  churn_growth?: number;
};

export type AnalyticsDataRevenueTrendItem = {
  month?: string;
  revenue?: number;
  growth?: number;
};

export type AnalyticsDataUserEngagementItem = {
  date?: string;
  dau?: number;
  wau?: number;
  mau?: number;
};

export type AnalyticsDataPlanDistributionItem = {
  name?: string;
  value?: number;
  color?: string;
};

export type AnalyticsDataTopTenantsItem = {
  id?: string;
  name?: string;
  revenue?: number;
  growth?: number;
  users?: number;
};

export interface AnalyticsData {
  overview?: AnalyticsDataOverview;
  revenue_trend?: AnalyticsDataRevenueTrendItem[];
  user_engagement?: AnalyticsDataUserEngagementItem[];
  plan_distribution?: AnalyticsDataPlanDistributionItem[];
  top_tenants?: AnalyticsDataTopTenantsItem[];
}

export type AdminPatchFeaturesBody = { [key: string]: unknown };

export type AppointmentsCreateAppointmentBody = { [key: string]: unknown };

export type AppointmentsUpdateAppointmentBody = { [key: string]: unknown };

export type AppointmentsUpdateAppointmentPutBody = { [key: string]: unknown };

export type AppointmentsCancelAppointmentBody = { [key: string]: unknown };

export type AppointmentsCompleteAppointmentBody = { [key: string]: unknown };

export type AppointmentsRescheduleAppointmentBody = { [key: string]: unknown };

export type AppsCreateAppBody = { [key: string]: unknown };

export type AppsUpdateAppBody = { [key: string]: unknown };

export type AppsAssignRoleToUserBody = { [key: string]: unknown };

export type AppsTransferOwnershipBody = { [key: string]: unknown };

export type AutomationTriggerBackupBody = { [key: string]: unknown };

export type AutomationTriggerSgkProcessingBody = { [key: string]: unknown };

export type GetApiCampaignsParams = {
page?: number;
per_page?: number;
status?: string;
};

export type GetApiCampaigns200Meta = {
  total?: number;
  page?: number;
  perPage?: number;
  totalPages?: number;
};

export type GetApiCampaigns200 = {
  success?: boolean;
  data?: Campaign[];
  meta?: GetApiCampaigns200Meta;
};

export type PostApiCampaignsBodyTargetSegment = typeof PostApiCampaignsBodyTargetSegment[keyof typeof PostApiCampaignsBodyTargetSegment];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiCampaignsBodyTargetSegment = {
  all: 'all',
  filter: 'filter',
  excel: 'excel',
} as const;

export type PostApiCampaignsBodyTargetCriteria = { [key: string]: unknown };

export type PostApiCampaignsBody = {
  name: string;
  description?: string;
  targetSegment?: PostApiCampaignsBodyTargetSegment;
  targetCriteria?: PostApiCampaignsBodyTargetCriteria;
  messageTemplate: string;
};

export type PostApiCampaignsCampaignIdSendBody = {
  senderId?: string;
};

export type PostApiCampaignsCampaignIdSend200 = {
  success?: boolean;
  message?: string;
};

export type CashRecordsCreateCashRecordBody = { [key: string]: unknown };

export type DevicesCreateDeviceBody = { [key: string]: unknown };

export type DevicesUpdateDeviceBody = { [key: string]: unknown };

export type DevicesUpdateDevicePutBody = { [key: string]: unknown };

export type DevicesUpdateDeviceStockBody = { [key: string]: unknown };

export type AuthForgotPasswordBody = { [key: string]: unknown };

export type InventoryGetAllInventoryParams = {
category?: string;
search?: string;
lowStock?: boolean;
page?: number;
per_page?: number;
};

export type InventoryGetAllInventory200Data = {
  items?: InventoryItem[];
  total?: number;
  page?: number;
  perPage?: number;
  totalPages?: number;
};

export type InventoryGetAllInventory200 = {
  success?: boolean;
  data?: InventoryGetAllInventory200Data;
};

export type InventoryUpdateInventoryItemBody = { [key: string]: unknown };

export type InventoryLogInventoryActivityBody = { [key: string]: unknown };

export type InventoryAssignToPatientBody = { [key: string]: unknown };

export type InventoryAddSerialNumbersBody = { [key: string]: unknown };

export type InventoryAdvancedSearchParams = {
/**
 * Search query for product name, brand, model, barcode
 */
q?: string;
/**
 * Filter by product category
 */
category?: string;
/**
 * Filter by brand
 */
brand?: string;
/**
 * Minimum price filter
 */
minPrice?: number;
/**
 * Maximum price filter
 */
maxPrice?: number;
/**
 * Filter by stock availability
 */
inStock?: boolean;
/**
 * Filter items with low stock
 */
lowStock?: boolean;
/**
 * Filter by product features (comma-separated)
 */
features?: string;
/**
 * Filter by supplier
 */
supplier?: string;
/**
 * Filter by warranty period (months)
 */
warrantyPeriod?: number;
/**
 * Sort field
 */
sortBy?: InventoryAdvancedSearchSortBy;
/**
 * Sort order
 */
sortOrder?: InventoryAdvancedSearchSortOrder;
/**
 * Page number for pagination
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type InventoryAdvancedSearchSortBy = typeof InventoryAdvancedSearchSortBy[keyof typeof InventoryAdvancedSearchSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InventoryAdvancedSearchSortBy = {
  name: 'name',
  price: 'price',
  stock: 'stock',
  brand: 'brand',
  category: 'category',
  createdAt: 'createdAt',
} as const;

export type InventoryAdvancedSearchSortOrder = typeof InventoryAdvancedSearchSortOrder[keyof typeof InventoryAdvancedSearchSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InventoryAdvancedSearchSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type InventoryAdvancedSearch200DataItemsItem = {
  id?: string;
  name?: string;
  brand?: string;
  model?: string;
  category?: string;
  price?: number;
  stock?: number;
  features?: string[];
  supplier?: string;
  warrantyPeriod?: number;
  barcode?: string;
  status?: string;
  createdAt?: string;
  updatedAt?: string;
};

export type InventoryAdvancedSearch200DataPagination = {
  page?: number;
  limit?: number;
  total?: number;
  totalPages?: number;
};

export type InventoryAdvancedSearch200DataFiltersPriceRange = {
  min?: number;
  max?: number;
};

export type InventoryAdvancedSearch200DataFilters = {
  categories?: string[];
  brands?: string[];
  suppliers?: string[];
  priceRange?: InventoryAdvancedSearch200DataFiltersPriceRange;
};

export type InventoryAdvancedSearch200Data = {
  items?: InventoryAdvancedSearch200DataItemsItem[];
  pagination?: InventoryAdvancedSearch200DataPagination;
  filters?: InventoryAdvancedSearch200DataFilters;
};

export type InventoryAdvancedSearch200 = {
  success?: boolean;
  data?: InventoryAdvancedSearch200Data;
  requestId?: string;
  timestamp?: string;
};

export type InventoryGetCategories200DataItem = {
  id?: string;
  name?: string;
  count?: number;
  description?: string;
};

export type InventoryGetCategories200 = {
  success?: boolean;
  data?: InventoryGetCategories200DataItem[];
  requestId?: string;
  timestamp?: string;
};

export type InventoryGetBrands200DataItem = {
  name?: string;
  count?: number;
  categories?: string[];
};

export type InventoryGetBrands200 = {
  success?: boolean;
  data?: InventoryGetBrands200DataItem[];
  requestId?: string;
  timestamp?: string;
};

export type InventoryGetFeatures200DataItem = {
  name?: string;
  count?: number;
  category?: string;
};

export type InventoryGetFeatures200 = {
  success?: boolean;
  data?: InventoryGetFeatures200DataItem[];
  requestId?: string;
  timestamp?: string;
};

export type InvoicesCreateInvoiceBody = { [key: string]: unknown };

export type InvoicesGenerateInvoicePdf200Data = { [key: string]: unknown };

export type InvoicesGenerateInvoicePdf200 = {
  success?: boolean;
  data?: InvoicesGenerateInvoicePdf200Data;
  message?: string;
};

export type InvoicesSendInvoiceToGibBody = { [key: string]: unknown };

export type InvoicesBatchGenerateBodyInvoiceType = typeof InvoicesBatchGenerateBodyInvoiceType[keyof typeof InvoicesBatchGenerateBodyInvoiceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvoicesBatchGenerateBodyInvoiceType = {
  sale: 'sale',
  proforma: 'proforma',
  return: 'return',
} as const;

export type InvoicesBatchGenerateBodyCustomerInfo = {
  name?: string;
  taxId?: string;
  address?: string;
  phone?: string;
  email?: string;
};

export type InvoicesBatchGenerateBodySettings = {
  includeVat?: boolean;
  vatRate?: number;
  discountRate?: number;
  notes?: string;
};

export type InvoicesBatchGenerateBody = {
  saleIds: string[];
  invoiceType: InvoicesBatchGenerateBodyInvoiceType;
  customerInfo?: InvoicesBatchGenerateBodyCustomerInfo;
  settings?: InvoicesBatchGenerateBodySettings;
};

export type InvoicesBatchGenerate201DataInvoicesItem = { [key: string]: unknown };

export type InvoicesBatchGenerate201DataErrorsItem = { [key: string]: unknown };

export type InvoicesBatchGenerate201Data = {
  invoices?: InvoicesBatchGenerate201DataInvoicesItem[];
  batchId?: string;
  totalCount?: number;
  successCount?: number;
  failedCount?: number;
  errors?: InvoicesBatchGenerate201DataErrorsItem[];
};

export type InvoicesBatchGenerate201 = {
  success?: boolean;
  data?: InvoicesBatchGenerate201Data;
  requestId?: string;
  timestamp?: string;
};

export type InvoicesGetTemplates200DataItemFieldsItem = { [key: string]: unknown };

export type InvoicesGetTemplates200DataItem = {
  id?: string;
  name?: string;
  description?: string;
  fields?: InvoicesGetTemplates200DataItemFieldsItem[];
  isDefault?: boolean;
};

export type InvoicesGetTemplates200 = {
  success?: boolean;
  data?: InvoicesGetTemplates200DataItem[];
  requestId?: string;
  timestamp?: string;
};

export type InvoicesCreateTemplateBodyFieldsItem = {
  name?: string;
  type?: string;
  required?: boolean;
  defaultValue?: string;
};

export type InvoicesCreateTemplateBodyLayoutHeader = { [key: string]: unknown };

export type InvoicesCreateTemplateBodyLayoutBody = { [key: string]: unknown };

export type InvoicesCreateTemplateBodyLayoutFooter = { [key: string]: unknown };

export type InvoicesCreateTemplateBodyLayout = {
  header?: InvoicesCreateTemplateBodyLayoutHeader;
  body?: InvoicesCreateTemplateBodyLayoutBody;
  footer?: InvoicesCreateTemplateBodyLayoutFooter;
};

export type InvoicesCreateTemplateBody = {
  name: string;
  description?: string;
  fields: InvoicesCreateTemplateBodyFieldsItem[];
  layout?: InvoicesCreateTemplateBodyLayout;
};

export type InvoicesGetPrintQueueParams = {
status?: InvoicesGetPrintQueueStatus;
};

export type InvoicesGetPrintQueueStatus = typeof InvoicesGetPrintQueueStatus[keyof typeof InvoicesGetPrintQueueStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvoicesGetPrintQueueStatus = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type InvoicesGetPrintQueue200DataQueueItem = {
  id?: string;
  invoiceId?: string;
  status?: string;
  priority?: number;
  createdAt?: string;
  processedAt?: string;
};

export type InvoicesGetPrintQueue200Data = {
  queue?: InvoicesGetPrintQueue200DataQueueItem[];
  totalCount?: number;
  pendingCount?: number;
};

export type InvoicesGetPrintQueue200 = {
  success?: boolean;
  data?: InvoicesGetPrintQueue200Data;
  requestId?: string;
  timestamp?: string;
};

export type InvoicesAddToPrintQueueBodyPrintOptionsColorMode = typeof InvoicesAddToPrintQueueBodyPrintOptionsColorMode[keyof typeof InvoicesAddToPrintQueueBodyPrintOptionsColorMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvoicesAddToPrintQueueBodyPrintOptionsColorMode = {
  color: 'color',
  grayscale: 'grayscale',
} as const;

export type InvoicesAddToPrintQueueBodyPrintOptions = {
  copies?: number;
  duplex?: boolean;
  colorMode?: InvoicesAddToPrintQueueBodyPrintOptionsColorMode;
};

export type InvoicesAddToPrintQueueBody = {
  invoiceIds: string[];
  /**
   * @minimum 1
   * @maximum 10
   */
  priority?: number;
  printOptions?: InvoicesAddToPrintQueueBodyPrintOptions;
};

export type AuthLoginBody = { [key: string]: unknown };

export type GetApiNotificationsParams = {
user_id: string;
page?: number;
per_page?: number;
};

export type GetApiNotifications200Meta = { [key: string]: unknown };

export type GetApiNotifications200 = {
  success?: boolean;
  data?: Notification[];
  meta?: GetApiNotifications200Meta;
};

export type NotificationsSetUserNotificationSettingsBody = { [key: string]: unknown };

export type GetApiNotificationsStatsParams = {
user_id: string;
};

export type GetApiNotificationsStats200Data = {
  total?: number;
  unread?: number;
};

export type GetApiNotificationsStats200 = {
  success?: boolean;
  data?: GetApiNotificationsStats200Data;
};

export type ProcessDocumentOcrBody = {
  image_path?: string;
  text?: string;
  type?: string;
  auto_crop?: boolean;
};

export type ProcessDocumentOcr200Result = { [key: string]: unknown };

export type ProcessDocumentOcr200 = {
  success?: boolean;
  result?: ProcessDocumentOcr200Result;
};

export type PatientsCreatePatientBody = { [key: string]: unknown };

export type PatientsUpdatePatientBody = { [key: string]: unknown };

export type PatientsUpdatePatientPutBody = { [key: string]: unknown };

export type TimelineLogPatientActivityBody = { [key: string]: unknown };

export type SalesAssignDevicesExtendedBody = { [key: string]: unknown };

export type DocumentsAddPatientDocumentBody = { [key: string]: unknown };

export type PatientSubresourcesCreatePatientEreceiptBody = { [key: string]: unknown };

export type PatientSubresourcesUpdatePatientEreceiptBody = { [key: string]: unknown };

export type PatientSubresourcesAddPatientHearingTestBody = { [key: string]: unknown };

export type PatientSubresourcesUpdatePatientHearingTestBody = { [key: string]: unknown };

export type PatientSubresourcesCreatePatientNoteBody = { [key: string]: unknown };

export type PatientSubresourcesUpdatePatientNoteBody = { [key: string]: unknown };

export type SalesCreateProductSaleBody = { [key: string]: unknown };

export type ReplacementsCreateReplacementBody = { [key: string]: unknown };

export type SalesUpdateSalePartialBody = { [key: string]: unknown };

export type TimelineAddTimelineEventBody = { [key: string]: unknown };

export type PatientsBulkUploadPatientsBody = { [key: string]: unknown };

export type PaymentsCreatePaymentRecordBody = { [key: string]: unknown };

export type PaymentsUpdatePaymentRecordBody = { [key: string]: unknown };

export type PermissionsListPermissions200DataItem = {
  category?: string;
  label?: string;
  icon?: string;
  permissions?: Permission[];
};

export type PermissionsListPermissions200 = {
  success?: boolean;
  data?: PermissionsListPermissions200DataItem[];
  all?: Permission[];
};

export type PermissionsCreatePermissionBody = { [key: string]: unknown };

export type PermissionsGetMyPermissions200Data = {
  permissions?: string[];
  role?: string;
  isSuperAdmin?: boolean;
};

export type PermissionsGetMyPermissions200 = {
  success?: boolean;
  data?: PermissionsGetMyPermissions200Data;
};

export type PermissionsGetRolePermissions200Data = {
  role?: Role;
  permissions?: string[];
};

export type PermissionsGetRolePermissions200 = {
  success?: boolean;
  data?: PermissionsGetRolePermissions200Data;
};

export type PermissionsUpdateRolePermissionsBody = {
  permissions?: string[];
};

export type PermissionsUpdateRolePermissions200Data = {
  role?: Role;
  permissions?: string[];
};

export type PermissionsUpdateRolePermissions200 = {
  success?: boolean;
  data?: PermissionsUpdateRolePermissions200Data;
};

export type SalesPricingPreviewBody = { [key: string]: unknown };

export type SuppliersUpdateProductSupplierBody = { [key: string]: unknown };

export type SuppliersAddProductSupplierBody = { [key: string]: unknown };

export type ProformasCreateProformaBody = { [key: string]: unknown };

export type ProformasConvertProformaToSaleBody = { [key: string]: unknown };

export type PaymentsCreatePromissoryNotesBody = { [key: string]: unknown };

export type PaymentsUpdatePromissoryNoteBody = { [key: string]: unknown };

export type PaymentsCollectPromissoryNoteBody = { [key: string]: unknown };

export type RegistrationRegisterPhoneBody = { [key: string]: unknown };

export type ReplacementsCreateReturnInvoiceBody = { [key: string]: unknown };

export type ReplacementsSendInvoiceToGibBody = { [key: string]: unknown };

export type RolesCreateRoleBody = { [key: string]: unknown };

export type RolesAddPermissionToRoleBody = { [key: string]: unknown };

export type InvoicesCreateSaleInvoiceBody = { [key: string]: unknown };

export type SalesGenerateSaleInvoicePdf200Data = { [key: string]: unknown };

export type SalesGenerateSaleInvoicePdf200 = {
  success?: boolean;
  data?: SalesGenerateSaleInvoicePdf200Data;
  message?: string;
};

export type SalesCreateSalePaymentPlanBodyPlanType = typeof SalesCreateSalePaymentPlanBodyPlanType[keyof typeof SalesCreateSalePaymentPlanBodyPlanType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SalesCreateSalePaymentPlanBodyPlanType = {
  standard: 'standard',
  custom: 'custom',
  installment: 'installment',
} as const;

export type SalesCreateSalePaymentPlanBody = {
  planType: SalesCreateSalePaymentPlanBodyPlanType;
  /**
   * @minimum 1
   * @maximum 36
   */
  installmentCount?: number;
  /** @minimum 0 */
  downPayment?: number;
  /** @minimum 0 */
  monthlyAmount?: number;
  startDate?: string;
  /** @minimum 0 */
  interestRate?: number;
  notes?: string;
};

export type SalesCreateSalePaymentPlan201DataInstallmentsItem = {
  id?: string;
  installmentNumber?: number;
  amount?: number;
  dueDate?: string;
  status?: string;
  paidDate?: string;
  paidAmount?: number;
};

export type SalesCreateSalePaymentPlan201Data = {
  id?: string;
  saleId?: string;
  planType?: string;
  installmentCount?: number;
  downPayment?: number;
  monthlyAmount?: number;
  totalAmount?: number;
  startDate?: string;
  endDate?: string;
  interestRate?: number;
  status?: string;
  createdAt?: string;
  installments?: SalesCreateSalePaymentPlan201DataInstallmentsItem[];
};

export type SalesCreateSalePaymentPlan201 = {
  success?: boolean;
  data?: SalesCreateSalePaymentPlan201Data;
  requestId?: string;
  timestamp?: string;
};

export type SalesGetSalePaymentPlan200DataInstallmentsItem = {
  id?: string;
  installmentNumber?: number;
  amount?: number;
  dueDate?: string;
  status?: string;
  paidDate?: string;
  paidAmount?: number;
};

export type SalesGetSalePaymentPlan200Data = {
  id?: string;
  saleId?: string;
  planType?: string;
  installmentCount?: number;
  downPayment?: number;
  monthlyAmount?: number;
  totalAmount?: number;
  startDate?: string;
  endDate?: string;
  interestRate?: number;
  status?: string;
  createdAt?: string;
  installments?: SalesGetSalePaymentPlan200DataInstallmentsItem[];
};

export type SalesGetSalePaymentPlan200 = {
  success?: boolean;
  data?: SalesGetSalePaymentPlan200Data;
  requestId?: string;
  timestamp?: string;
};

export type SalesGetSalePayments200DataItem = {
  id?: string;
  saleId?: string;
  amount?: number;
  paymentMethod?: string;
  paymentDate?: string;
  installmentId?: string;
  notes?: string;
  status?: string;
  createdAt?: string;
};

export type SalesGetSalePayments200 = {
  success?: boolean;
  data?: SalesGetSalePayments200DataItem[];
  requestId?: string;
  timestamp?: string;
};

export type SalesCreateSalePaymentBodyPaymentMethod = typeof SalesCreateSalePaymentBodyPaymentMethod[keyof typeof SalesCreateSalePaymentBodyPaymentMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SalesCreateSalePaymentBodyPaymentMethod = {
  cash: 'cash',
  card: 'card',
  bank_transfer: 'bank_transfer',
  check: 'check',
  promissory_note: 'promissory_note',
} as const;

export type SalesCreateSalePaymentBody = {
  /** @minimum 0 */
  amount: number;
  paymentMethod: SalesCreateSalePaymentBodyPaymentMethod;
  paymentDate: string;
  installmentId?: string;
  notes?: string;
  checkNumber?: string;
  bankName?: string;
  accountNumber?: string;
};

export type SalesCreateSalePayment201Data = {
  id?: string;
  saleId?: string;
  amount?: number;
  paymentMethod?: string;
  paymentDate?: string;
  installmentId?: string;
  notes?: string;
  status?: string;
  createdAt?: string;
  remainingBalance?: number;
};

export type SalesCreateSalePayment201 = {
  success?: boolean;
  data?: SalesCreateSalePayment201Data;
  requestId?: string;
  timestamp?: string;
};

export type SalesPayInstallmentBodyPaymentMethod = typeof SalesPayInstallmentBodyPaymentMethod[keyof typeof SalesPayInstallmentBodyPaymentMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SalesPayInstallmentBodyPaymentMethod = {
  cash: 'cash',
  card: 'card',
  bank_transfer: 'bank_transfer',
  check: 'check',
  promissory_note: 'promissory_note',
} as const;

export type SalesPayInstallmentBody = {
  /** @minimum 0 */
  amount: number;
  paymentMethod: SalesPayInstallmentBodyPaymentMethod;
  paymentDate: string;
  notes?: string;
};

export type SalesPayInstallment200DataInstallment = {
  id?: string;
  installmentNumber?: number;
  amount?: number;
  dueDate?: string;
  status?: string;
  paidDate?: string;
  paidAmount?: number;
};

export type SalesPayInstallment200DataPayment = {
  id?: string;
  amount?: number;
  paymentMethod?: string;
  paymentDate?: string;
  notes?: string;
};

export type SalesPayInstallment200Data = {
  installment?: SalesPayInstallment200DataInstallment;
  payment?: SalesPayInstallment200DataPayment;
  remainingBalance?: number;
};

export type SalesPayInstallment200 = {
  success?: boolean;
  data?: SalesPayInstallment200Data;
  requestId?: string;
  timestamp?: string;
};

export type SalesCreateSalesLogBody = { [key: string]: unknown };

export type SalesRecalcSalesBody = { [key: string]: unknown };

export type UpdateSettingsBody = { [key: string]: unknown };

export type SaveSettingsBody = { [key: string]: unknown };

export type PatchSettingsBody = { [key: string]: unknown };

export type SgkUploadSgkDocumentBody = { [key: string]: unknown };

export type SgkSeedTestPatientsBody = { [key: string]: unknown };

export type SgkUploadAndProcessFilesBody = { [key: string]: unknown };

export type SuppliersCreateSupplierBody = { [key: string]: unknown };

export type SuppliersUpdateSupplierBody = { [key: string]: unknown };

export type UsersCreateUserBody = { [key: string]: unknown };

export type UsersUpdateUserBody = { [key: string]: unknown };

export type UsersUpdateMeBody = {
  firstName?: string;
  lastName?: string;
  username?: string;
  email?: string;
};

export type UsersUpdateMe200 = {
  success?: boolean;
  data?: User;
};

export type AuthVerifyOtpBody = { [key: string]: unknown };

export type RegistrationVerifyRegistrationOtpBody = { [key: string]: unknown };

export type OcrDebugNerBody = { [key: string]: unknown };

export type OcrExtractEntitiesBody = { [key: string]: unknown };

export type OcrExtractPatientNameBody = { [key: string]: unknown };

export type OcrInitDatabaseBody = { [key: string]: unknown };

export type OcrInitializeNlpEndpointBody = { [key: string]: unknown };

export type OcrProcessDocumentBody = { [key: string]: unknown };

export type OcrCalculateSimilarityBody = { [key: string]: unknown };

export type GetApiSmsConfig200 = {
  success?: boolean;
  data?: SMSProviderConfig;
};

export type PutApiSmsConfigBody = {
  apiUsername?: string;
  apiPassword?: string;
};

export type PostApiSmsHeadersBody = {
  headerText: string;
  headerType: string;
  documents?: string[];
};

export type GetApiAdminSmsPackages200 = {
  success?: boolean;
  data?: SMSPackage[];
};

export type PostApiAdminSmsPackagesBody = {
  name: string;
  description?: string;
  smsCount: number;
  price: number;
  currency?: string;
  isActive?: boolean;
};

export type PutApiAdminSmsPackagesPkgIdBody = {
  name?: string;
  description?: string;
  smsCount?: number;
  price?: number;
  isActive?: boolean;
};

export type GetApiAdminSmsHeadersParams = {
status?: string;
};

export type GetApiAdminSmsHeaders200 = {
  success?: boolean;
  data?: SMSHeaderRequest[];
};

export type PutApiAdminSmsHeadersHeaderIdStatusBodyStatus = typeof PutApiAdminSmsHeadersHeaderIdStatusBodyStatus[keyof typeof PutApiAdminSmsHeadersHeaderIdStatusBodyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutApiAdminSmsHeadersHeaderIdStatusBodyStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
} as const;

export type PutApiAdminSmsHeadersHeaderIdStatusBody = {
  status: PutApiAdminSmsHeadersHeaderIdStatusBodyStatus;
  rejectionReason?: string;
};

export type PostApiSmsUploadBody = {
  file?: Blob;
};

export type PostApiSmsUpload200 = {
  url?: string;
  filename?: string;
};

export type GetApiSmsAudiences200 = {
  success?: boolean;
  data?: TargetAudience[];
};

export type PostApiSmsAudiencesBodySourceType = typeof PostApiSmsAudiencesBodySourceType[keyof typeof PostApiSmsAudiencesBodySourceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiSmsAudiencesBodySourceType = {
  excel: 'excel',
  filter: 'filter',
} as const;

export type PostApiSmsAudiencesBodyFilterCriteria = { [key: string]: unknown };

export type PostApiSmsAudiencesBody = {
  name: string;
  sourceType: PostApiSmsAudiencesBodySourceType;
  filePath?: string;
  totalRecords?: number;
  filterCriteria?: PostApiSmsAudiencesBodyFilterCriteria;
};

export type PostApiSmsAudiencesUploadBody = {
  file?: Blob;
};

export type PostApiSmsAudiencesUpload201 = {
  success?: boolean;
  data?: TargetAudience;
};

export type GetApiActivityLogsParams = {
entity_type?: string;
entity_id?: string;
user_id?: string;
limit?: number;
};

export type GetApiActivityLogs200 = {
  success?: boolean;
  data?: ActivityLog[];
  count?: number;
};

export type UsersChangePasswordBody = {
  currentPassword: string;
  newPassword: string;
};

export type UsersChangePassword200 = {
  success?: boolean;
  message?: string;
};

export type BirfaturaSyncInvoicesBody = {
  start_date?: string;
  end_date?: string;
};

export type CommunicationsListTemplatesParams = {
page?: number;
per_page?: number;
type?: string;
category?: string;
is_active?: string;
search?: string;
};

export type CommunicationsListTemplates200Meta = { [key: string]: unknown };

export type CommunicationsListTemplates200 = {
  success?: boolean;
  data?: CommunicationTemplate[];
  meta?: CommunicationsListTemplates200Meta;
};

export type CommunicationsDeleteTemplate200 = {
  success?: boolean;
  message?: string;
};

export type SmsUploadDocumentBodyDocumentType = typeof SmsUploadDocumentBodyDocumentType[keyof typeof SmsUploadDocumentBodyDocumentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsUploadDocumentBodyDocumentType = {
  contract: 'contract',
  id_card: 'id_card',
  residence: 'residence',
  tax_plate: 'tax_plate',
  activity_cert: 'activity_cert',
  signature_circular: 'signature_circular',
} as const;

export type SmsUploadDocumentBody = {
  file: Blob;
  documentType: SmsUploadDocumentBodyDocumentType;
};

export type SmsUploadDocument200Data = {
  type?: string;
  filename?: string;
  size?: number;
};

export type SmsUploadDocument200 = {
  success?: boolean;
  data?: SmsUploadDocument200Data;
};

export type SmsDownloadDocument200 = {
  success?: boolean;
  url?: string;
};

export type SmsDeleteDocument200 = {
  success?: boolean;
  message?: string;
};

export type GetAdminTenantsParams = {
page?: number;
limit?: number;
status?: string;
search?: string;
};

export type GetAdminTenants200Data = {
  tenants?: Tenant[];
  pagination?: Pagination;
};

export type GetAdminTenants200 = {
  success?: boolean;
  data?: GetAdminTenants200Data;
};

export type GetTenant200Data = {
  tenant?: Tenant;
};

export type GetTenant200 = {
  success?: boolean;
  data?: GetTenant200Data;
};

export type UpdateTenantStatusBody = {
  status?: string;
};

export type GetTenantUsers200Data = {
  users?: User[];
  pagination?: Pagination;
};

export type GetTenantUsers200 = {
  success?: boolean;
  data?: GetTenantUsers200Data;
};

export type SubscribeTenantBody = {
  plan_id?: string;
  billing_interval?: string;
};

export type AddTenantAddonBody = {
  addon_id?: string;
};

export type GetAdminPlansParams = {
limit?: number;
};

export type GetAdminPlans200Data = {
  plans?: Plan[];
  pagination?: Pagination;
};

export type GetAdminPlans200 = {
  success?: boolean;
  data?: GetAdminPlans200Data;
};

export type DeletePlan200 = {
  success?: boolean;
  message?: string;
};

export type GetAdminAddonsParams = {
limit?: number;
};

export type GetAdminAddons200Data = {
  addons?: AddOn[];
  pagination?: Pagination;
};

export type GetAdminAddons200 = {
  success?: boolean;
  data?: GetAdminAddons200Data;
};

export type GetAdminUsersParams = {
page?: number;
limit?: number;
search?: string;
role?: string;
};

export type GetAdminUsers200Data = {
  users?: AdminUser[];
  pagination?: Pagination;
};

export type GetAdminUsers200 = {
  success?: boolean;
  data?: GetAdminUsers200Data;
};

export type GetAllTenantUsersParams = {
page?: number;
limit?: number;
search?: string;
};

export type GetAllTenantUsers200Data = {
  users?: AdminUser[];
  pagination?: Pagination;
};

export type GetAllTenantUsers200 = {
  success?: boolean;
  data?: GetAllTenantUsers200Data;
};

export type UpdateAnyTenantUserBody = {
  isActive?: boolean;
  email?: string;
  first_name?: string;
  last_name?: string;
  role?: string;
  password?: string;
};

export type GetAdminAddon200Data = {
  addon?: AddOn;
};

export type GetAdminAddon200 = {
  success?: boolean;
  data?: GetAdminAddon200Data;
};

export type UpdateAdminAddon200Data = {
  addon?: AddOn;
};

export type UpdateAdminAddon200 = {
  success?: boolean;
  data?: UpdateAdminAddon200Data;
};

export type DeleteAdminAddon200 = {
  success?: boolean;
  message?: string;
};

export type GetAdminTicketsParams = {
page?: number;
limit?: number;
search?: string;
status?: string;
priority?: string;
};

export type GetAdminTickets200Data = {
  tickets?: SupportTicket[];
  pagination?: Pagination;
};

export type GetAdminTickets200 = {
  success?: boolean;
  data?: GetAdminTickets200Data;
};

export type CreateAdminTicketBody = {
  subject?: string;
  description?: string;
  priority?: string;
  category?: string;
  tenant_id?: string;
};

export type CreateAdminTicket201Data = {
  ticket?: SupportTicket;
};

export type CreateAdminTicket201 = {
  success?: boolean;
  data?: CreateAdminTicket201Data;
};

export type UpdateAdminTicketBody = {
  status?: string;
  assigned_to?: string;
};

export type UpdateAdminTicket200Data = {
  ticket?: SupportTicket;
};

export type UpdateAdminTicket200 = {
  success?: boolean;
  data?: UpdateAdminTicket200Data;
};

export type GetAdminSettings200Data = {
  settings?: SystemSettings;
};

export type GetAdminSettings200 = {
  success?: boolean;
  data?: GetAdminSettings200Data;
};

export type UpdateAdminSettings200Data = {
  settings?: SystemSettings;
};

export type UpdateAdminSettings200 = {
  success?: boolean;
  data?: UpdateAdminSettings200Data;
};

export type PatchAdminSettingsBodyUpdates = { [key: string]: unknown };

export type PatchAdminSettingsBody = {
  updates?: PatchAdminSettingsBodyUpdates;
};

export type PatchAdminSettings200Data = {
  settings?: SystemSettings;
};

export type PatchAdminSettings200 = {
  success?: boolean;
  data?: PatchAdminSettings200Data;
};

export type GetAdminDashboardMetrics200Data = {
  metrics?: DashboardMetrics;
};

export type GetAdminDashboardMetrics200 = {
  success?: boolean;
  data?: GetAdminDashboardMetrics200Data;
};

export type GetAdminInvoicesParams = {
page?: number;
limit?: number;
search?: string;
status?: string;
};

export type GetAdminInvoices200Data = {
  invoices?: Invoice[];
  pagination?: Pagination;
};

export type GetAdminInvoices200 = {
  success?: boolean;
  data?: GetAdminInvoices200Data;
};

export type CreateAdminInvoice201Data = {
  invoice?: Invoice;
};

export type CreateAdminInvoice201 = {
  success?: boolean;
  data?: CreateAdminInvoice201Data;
};

export type GetAdminInvoice200Data = {
  invoice?: Invoice;
};

export type GetAdminInvoice200 = {
  success?: boolean;
  data?: GetAdminInvoice200Data;
};

export type RecordAdminInvoicePaymentBody = {
  amount?: number;
};

export type RecordAdminInvoicePayment200Data = {
  invoice?: Invoice;
};

export type RecordAdminInvoicePayment200 = {
  success?: boolean;
  data?: RecordAdminInvoicePayment200Data;
};

export type GetAdminAnalyticsParams = {
start_date?: string;
end_date?: string;
metric?: string;
};

export type GetAdminAnalytics200Data = {
  data?: AnalyticsData;
};

export type GetAdminAnalytics200 = {
  success?: boolean;
  data?: GetAdminAnalytics200Data;
};

export type GetPresignedUploadUrlBody = {
  filename: string;
  folder?: string;
  content_type?: string;
};

export type GetPresignedUploadUrl200DataFields = { [key: string]: unknown };

export type GetPresignedUploadUrl200Data = {
  url?: string;
  fields?: GetPresignedUploadUrl200DataFields;
  key?: string;
};

export type GetPresignedUploadUrl200 = {
  success?: boolean;
  data?: GetPresignedUploadUrl200Data;
};

export type ListFilesParams = {
folder?: string;
};

export type ListFiles200DataFilesItem = {
  key?: string;
  filename?: string;
  size?: number;
  last_modified?: string;
  url?: string;
};

export type ListFiles200Data = {
  files?: ListFiles200DataFilesItem[];
};

export type ListFiles200 = {
  success?: boolean;
  data?: ListFiles200Data;
};

export type UpdateTenantUser200Data = {
  user?: User;
};

export type UpdateTenantUser200 = {
  success?: boolean;
  data?: UpdateTenantUser200Data;
};

export type CreateTicketResponseBody = {
  message?: string;
};

export type AdminLoginBody = {
  email?: string;
  password?: string;
  mfa_token?: string;
};

export type AdminLogin200 = {
  token?: string;
  user?: AdminUser;
  requires_mfa?: boolean;
};

/**
 * Requires JWT; access to the admin panel itself is verified client-side, but
we still require a logged-in user to fetch flags.
 * @summary Return the current feature flags for admin UI.
 */
export const adminGetFeatures = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/admin/features`, method: 'GET', signal
    },
      );
    }
  



export const getAdminGetFeaturesQueryKey = () => {
    return [
    `/api/admin/features`
    ] as const;
    }

    
export const getAdminGetFeaturesQueryOptions = <TData = Awaited<ReturnType<typeof adminGetFeatures>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminGetFeaturesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminGetFeatures>>> = ({ signal }) => adminGetFeatures(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AdminGetFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof adminGetFeatures>>>
export type AdminGetFeaturesQueryError = unknown


export function useAdminGetFeatures<TData = Awaited<ReturnType<typeof adminGetFeatures>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof adminGetFeatures>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetFeatures<TData = Awaited<ReturnType<typeof adminGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof adminGetFeatures>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAdminGetFeatures<TData = Awaited<ReturnType<typeof adminGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Return the current feature flags for admin UI.
 */

export function useAdminGetFeatures<TData = Awaited<ReturnType<typeof adminGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminGetFeatures>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAdminGetFeaturesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Authorization: user must have `settings.update` or `features.toggle`.
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const adminPatchFeatures = (
    adminPatchFeaturesBody?: AdminPatchFeaturesBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/admin/features`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: adminPatchFeaturesBody
    },
      );
    }
  


export const getAdminPatchFeaturesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,{data: AdminPatchFeaturesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,{data: AdminPatchFeaturesBody}, TContext> => {

const mutationKey = ['adminPatchFeatures'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminPatchFeatures>>, {data: AdminPatchFeaturesBody}> = (props) => {
          const {data} = props ?? {};

          return  adminPatchFeatures(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminPatchFeaturesMutationResult = NonNullable<Awaited<ReturnType<typeof adminPatchFeatures>>>
    export type AdminPatchFeaturesMutationBody = AdminPatchFeaturesBody
    export type AdminPatchFeaturesMutationError = unknown

    /**
 * @summary Patch feature flags. Body: { features: { 'integrations_ui': true } }
 */
export const useAdminPatchFeatures = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminPatchFeatures>>, TError,{data: AdminPatchFeaturesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminPatchFeatures>>,
        TError,
        {data: AdminPatchFeaturesBody},
        TContext
      > => {

      const mutationOptions = getAdminPatchFeaturesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/appointments
 */
export const appointmentsGetAppointments = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getAppointmentsGetAppointmentsQueryKey = () => {
    return [
    `/api/appointments`
    ] as const;
    }

    
export const getAppointmentsGetAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAppointments>>> = ({ signal }) => appointmentsGetAppointments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAppointments>>>
export type AppointmentsGetAppointmentsQueryError = unknown


export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments
 */

export function useAppointmentsGetAppointments<TData = Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/appointments
 */
export const appointmentsCreateAppointment = (
    appointmentsCreateAppointmentBody?: AppointmentsCreateAppointmentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsCreateAppointmentBody, signal
    },
      );
    }
  


export const getAppointmentsCreateAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCreateAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, {data: AppointmentsCreateAppointmentBody}> = (props) => {
          const {data} = props ?? {};

          return  appointmentsCreateAppointment(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCreateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCreateAppointment>>>
    export type AppointmentsCreateAppointmentMutationBody = AppointmentsCreateAppointmentBody
    export type AppointmentsCreateAppointmentMutationError = unknown

    /**
 * @summary POST /api/appointments
 */
export const useAppointmentsCreateAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCreateAppointment>>, TError,{data: AppointmentsCreateAppointmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCreateAppointment>>,
        TError,
        {data: AppointmentsCreateAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCreateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/appointments/{appointment_id}
 */
export const appointmentsGetAppointment = (
    appointmentId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}`, method: 'GET', signal
    },
      );
    }
  



export const getAppointmentsGetAppointmentQueryKey = (appointmentId?: string,) => {
    return [
    `/api/appointments/${appointmentId}`
    ] as const;
    }

    
export const getAppointmentsGetAppointmentQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError = unknown>(appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAppointmentQueryKey(appointmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAppointment>>> = ({ signal }) => appointmentsGetAppointment(appointmentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(appointmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAppointmentQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAppointment>>>
export type AppointmentsGetAppointmentQueryError = unknown


export function useAppointmentsGetAppointment<TData = Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError = unknown>(
 appointmentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointment>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointment<TData = Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError = unknown>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAppointment>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAppointment>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAppointment<TData = Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError = unknown>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/{appointment_id}
 */

export function useAppointmentsGetAppointment<TData = Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError = unknown>(
 appointmentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAppointment>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAppointmentQueryOptions(appointmentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update appointment (PUT full update or PATCH partial update)
 */
export const appointmentsUpdateAppointment = (
    appointmentId: string,
    appointmentsUpdateAppointmentBody?: AppointmentsUpdateAppointmentBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsUpdateAppointmentBody
    },
      );
    }
  


export const getAppointmentsUpdateAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointment>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointment>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsUpdateAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsUpdateAppointment>>, {appointmentId: string;data: AppointmentsUpdateAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsUpdateAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsUpdateAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsUpdateAppointment>>>
    export type AppointmentsUpdateAppointmentMutationBody = AppointmentsUpdateAppointmentBody
    export type AppointmentsUpdateAppointmentMutationError = unknown

    /**
 * @summary Update appointment (PUT full update or PATCH partial update)
 */
export const useAppointmentsUpdateAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointment>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsUpdateAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsUpdateAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsUpdateAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update appointment (PUT full update or PATCH partial update)
 */
export const appointmentsUpdateAppointmentPut = (
    appointmentId: string,
    appointmentsUpdateAppointmentPutBody?: AppointmentsUpdateAppointmentPutBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsUpdateAppointmentPutBody
    },
      );
    }
  


export const getAppointmentsUpdateAppointmentPutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentPutBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentPutBody}, TContext> => {

const mutationKey = ['appointmentsUpdateAppointmentPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>, {appointmentId: string;data: AppointmentsUpdateAppointmentPutBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsUpdateAppointmentPut(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsUpdateAppointmentPutMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>>
    export type AppointmentsUpdateAppointmentPutMutationBody = AppointmentsUpdateAppointmentPutBody
    export type AppointmentsUpdateAppointmentPutMutationError = unknown

    /**
 * @summary Update appointment (PUT full update or PATCH partial update)
 */
export const useAppointmentsUpdateAppointmentPut = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>, TError,{appointmentId: string;data: AppointmentsUpdateAppointmentPutBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsUpdateAppointmentPut>>,
        TError,
        {appointmentId: string;data: AppointmentsUpdateAppointmentPutBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsUpdateAppointmentPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const appointmentsDeleteAppointment = (
    appointmentId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}`, method: 'DELETE'
    },
      );
    }
  


export const getAppointmentsDeleteAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext> => {

const mutationKey = ['appointmentsDeleteAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, {appointmentId: string}> = (props) => {
          const {appointmentId} = props ?? {};

          return  appointmentsDeleteAppointment(appointmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsDeleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>>
    
    export type AppointmentsDeleteAppointmentMutationError = unknown

    /**
 * @summary DELETE /api/appointments/{appointment_id}
 */
export const useAppointmentsDeleteAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsDeleteAppointment>>, TError,{appointmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsDeleteAppointment>>,
        TError,
        {appointmentId: string},
        TContext
      > => {

      const mutationOptions = getAppointmentsDeleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const appointmentsCancelAppointment = (
    appointmentId: string,
    appointmentsCancelAppointmentBody?: AppointmentsCancelAppointmentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}/cancel`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsCancelAppointmentBody, signal
    },
      );
    }
  


export const getAppointmentsCancelAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCancelAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, {appointmentId: string;data: AppointmentsCancelAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCancelAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCancelAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCancelAppointment>>>
    export type AppointmentsCancelAppointmentMutationBody = AppointmentsCancelAppointmentBody
    export type AppointmentsCancelAppointmentMutationError = unknown

    /**
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export const useAppointmentsCancelAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCancelAppointment>>, TError,{appointmentId: string;data: AppointmentsCancelAppointmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCancelAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCancelAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCancelAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const appointmentsCompleteAppointment = (
    appointmentId: string,
    appointmentsCompleteAppointmentBody?: AppointmentsCompleteAppointmentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}/complete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsCompleteAppointmentBody, signal
    },
      );
    }
  


export const getAppointmentsCompleteAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsCompleteAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, {appointmentId: string;data: AppointmentsCompleteAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsCompleteAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsCompleteAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>>
    export type AppointmentsCompleteAppointmentMutationBody = AppointmentsCompleteAppointmentBody
    export type AppointmentsCompleteAppointmentMutationError = unknown

    /**
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export const useAppointmentsCompleteAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsCompleteAppointment>>, TError,{appointmentId: string;data: AppointmentsCompleteAppointmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsCompleteAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsCompleteAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsCompleteAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const appointmentsRescheduleAppointment = (
    appointmentId: string,
    appointmentsRescheduleAppointmentBody?: AppointmentsRescheduleAppointmentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/${appointmentId}/reschedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appointmentsRescheduleAppointmentBody, signal
    },
      );
    }
  


export const getAppointmentsRescheduleAppointmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext> => {

const mutationKey = ['appointmentsRescheduleAppointment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, {appointmentId: string;data: AppointmentsRescheduleAppointmentBody}> = (props) => {
          const {appointmentId,data} = props ?? {};

          return  appointmentsRescheduleAppointment(appointmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsRescheduleAppointmentMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>>
    export type AppointmentsRescheduleAppointmentMutationBody = AppointmentsRescheduleAppointmentBody
    export type AppointmentsRescheduleAppointmentMutationError = unknown

    /**
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export const useAppointmentsRescheduleAppointment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>, TError,{appointmentId: string;data: AppointmentsRescheduleAppointmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsRescheduleAppointment>>,
        TError,
        {appointmentId: string;data: AppointmentsRescheduleAppointmentBody},
        TContext
      > => {

      const mutationOptions = getAppointmentsRescheduleAppointmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/appointments/availability
 */
export const appointmentsGetAvailability = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/availability`, method: 'GET', signal
    },
      );
    }
  



export const getAppointmentsGetAvailabilityQueryKey = () => {
    return [
    `/api/appointments/availability`
    ] as const;
    }

    
export const getAppointmentsGetAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsGetAvailabilityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsGetAvailability>>> = ({ signal }) => appointmentsGetAvailability(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsGetAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsGetAvailability>>>
export type AppointmentsGetAvailabilityQueryError = unknown


export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsGetAvailability>>,
          TError,
          Awaited<ReturnType<typeof appointmentsGetAvailability>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/availability
 */

export function useAppointmentsGetAvailability<TData = Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsGetAvailability>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsGetAvailabilityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/appointments/list
 */
export const appointmentsListAppointments = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/appointments/list`, method: 'GET', signal
    },
      );
    }
  



export const getAppointmentsListAppointmentsQueryKey = () => {
    return [
    `/api/appointments/list`
    ] as const;
    }

    
export const getAppointmentsListAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsListAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsListAppointments>>> = ({ signal }) => appointmentsListAppointments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppointmentsListAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsListAppointments>>>
export type AppointmentsListAppointmentsQueryError = unknown


export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsListAppointments>>,
          TError,
          Awaited<ReturnType<typeof appointmentsListAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/appointments/list
 */

export function useAppointmentsListAppointments<TData = Awaited<ReturnType<typeof appointmentsListAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsListAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppointmentsListAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/apps
 */
export const appsListApps = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/apps`, method: 'GET', signal
    },
      );
    }
  



export const getAppsListAppsQueryKey = () => {
    return [
    `/api/apps`
    ] as const;
    }

    
export const getAppsListAppsQueryOptions = <TData = Awaited<ReturnType<typeof appsListApps>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppsListAppsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appsListApps>>> = ({ signal }) => appsListApps(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppsListAppsQueryResult = NonNullable<Awaited<ReturnType<typeof appsListApps>>>
export type AppsListAppsQueryError = unknown


export function useAppsListApps<TData = Awaited<ReturnType<typeof appsListApps>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appsListApps>>,
          TError,
          Awaited<ReturnType<typeof appsListApps>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppsListApps<TData = Awaited<ReturnType<typeof appsListApps>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appsListApps>>,
          TError,
          Awaited<ReturnType<typeof appsListApps>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppsListApps<TData = Awaited<ReturnType<typeof appsListApps>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/apps
 */

export function useAppsListApps<TData = Awaited<ReturnType<typeof appsListApps>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsListApps>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppsListAppsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/apps
 */
export const appsCreateApp = (
    appsCreateAppBody?: AppsCreateAppBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/apps`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appsCreateAppBody, signal
    },
      );
    }
  


export const getAppsCreateAppMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsCreateApp>>, TError,{data: AppsCreateAppBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appsCreateApp>>, TError,{data: AppsCreateAppBody}, TContext> => {

const mutationKey = ['appsCreateApp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appsCreateApp>>, {data: AppsCreateAppBody}> = (props) => {
          const {data} = props ?? {};

          return  appsCreateApp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppsCreateAppMutationResult = NonNullable<Awaited<ReturnType<typeof appsCreateApp>>>
    export type AppsCreateAppMutationBody = AppsCreateAppBody
    export type AppsCreateAppMutationError = unknown

    /**
 * @summary POST /api/apps
 */
export const useAppsCreateApp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsCreateApp>>, TError,{data: AppsCreateAppBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appsCreateApp>>,
        TError,
        {data: AppsCreateAppBody},
        TContext
      > => {

      const mutationOptions = getAppsCreateAppMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/apps/{app_id}
 */
export const appsGetApp = (
    appId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/apps/${appId}`, method: 'GET', signal
    },
      );
    }
  



export const getAppsGetAppQueryKey = (appId?: string,) => {
    return [
    `/api/apps/${appId}`
    ] as const;
    }

    
export const getAppsGetAppQueryOptions = <TData = Awaited<ReturnType<typeof appsGetApp>>, TError = unknown>(appId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppsGetAppQueryKey(appId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appsGetApp>>> = ({ signal }) => appsGetApp(appId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(appId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppsGetAppQueryResult = NonNullable<Awaited<ReturnType<typeof appsGetApp>>>
export type AppsGetAppQueryError = unknown


export function useAppsGetApp<TData = Awaited<ReturnType<typeof appsGetApp>>, TError = unknown>(
 appId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appsGetApp>>,
          TError,
          Awaited<ReturnType<typeof appsGetApp>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppsGetApp<TData = Awaited<ReturnType<typeof appsGetApp>>, TError = unknown>(
 appId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appsGetApp>>,
          TError,
          Awaited<ReturnType<typeof appsGetApp>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppsGetApp<TData = Awaited<ReturnType<typeof appsGetApp>>, TError = unknown>(
 appId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/apps/{app_id}
 */

export function useAppsGetApp<TData = Awaited<ReturnType<typeof appsGetApp>>, TError = unknown>(
 appId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appsGetApp>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppsGetAppQueryOptions(appId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary PUT /api/apps/{app_id}
 */
export const appsUpdateApp = (
    appId: string,
    appsUpdateAppBody?: AppsUpdateAppBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/apps/${appId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: appsUpdateAppBody
    },
      );
    }
  


export const getAppsUpdateAppMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsUpdateApp>>, TError,{appId: string;data: AppsUpdateAppBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appsUpdateApp>>, TError,{appId: string;data: AppsUpdateAppBody}, TContext> => {

const mutationKey = ['appsUpdateApp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appsUpdateApp>>, {appId: string;data: AppsUpdateAppBody}> = (props) => {
          const {appId,data} = props ?? {};

          return  appsUpdateApp(appId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppsUpdateAppMutationResult = NonNullable<Awaited<ReturnType<typeof appsUpdateApp>>>
    export type AppsUpdateAppMutationBody = AppsUpdateAppBody
    export type AppsUpdateAppMutationError = unknown

    /**
 * @summary PUT /api/apps/{app_id}
 */
export const useAppsUpdateApp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsUpdateApp>>, TError,{appId: string;data: AppsUpdateAppBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appsUpdateApp>>,
        TError,
        {appId: string;data: AppsUpdateAppBody},
        TContext
      > => {

      const mutationOptions = getAppsUpdateAppMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/apps/{app_id}
 */
export const appsDeleteApp = (
    appId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/apps/${appId}`, method: 'DELETE'
    },
      );
    }
  


export const getAppsDeleteAppMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsDeleteApp>>, TError,{appId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appsDeleteApp>>, TError,{appId: string}, TContext> => {

const mutationKey = ['appsDeleteApp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appsDeleteApp>>, {appId: string}> = (props) => {
          const {appId} = props ?? {};

          return  appsDeleteApp(appId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppsDeleteAppMutationResult = NonNullable<Awaited<ReturnType<typeof appsDeleteApp>>>
    
    export type AppsDeleteAppMutationError = unknown

    /**
 * @summary DELETE /api/apps/{app_id}
 */
export const useAppsDeleteApp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsDeleteApp>>, TError,{appId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appsDeleteApp>>,
        TError,
        {appId: string},
        TContext
      > => {

      const mutationOptions = getAppsDeleteAppMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/apps/{app_id}/assign
 */
export const appsAssignRoleToUser = (
    appId: string,
    appsAssignRoleToUserBody?: AppsAssignRoleToUserBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/apps/${appId}/assign`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appsAssignRoleToUserBody, signal
    },
      );
    }
  


export const getAppsAssignRoleToUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsAssignRoleToUser>>, TError,{appId: string;data: AppsAssignRoleToUserBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appsAssignRoleToUser>>, TError,{appId: string;data: AppsAssignRoleToUserBody}, TContext> => {

const mutationKey = ['appsAssignRoleToUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appsAssignRoleToUser>>, {appId: string;data: AppsAssignRoleToUserBody}> = (props) => {
          const {appId,data} = props ?? {};

          return  appsAssignRoleToUser(appId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppsAssignRoleToUserMutationResult = NonNullable<Awaited<ReturnType<typeof appsAssignRoleToUser>>>
    export type AppsAssignRoleToUserMutationBody = AppsAssignRoleToUserBody
    export type AppsAssignRoleToUserMutationError = unknown

    /**
 * @summary POST /api/apps/{app_id}/assign
 */
export const useAppsAssignRoleToUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsAssignRoleToUser>>, TError,{appId: string;data: AppsAssignRoleToUserBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appsAssignRoleToUser>>,
        TError,
        {appId: string;data: AppsAssignRoleToUserBody},
        TContext
      > => {

      const mutationOptions = getAppsAssignRoleToUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/apps/{app_id}/transfer_ownership
 */
export const appsTransferOwnership = (
    appId: string,
    appsTransferOwnershipBody?: AppsTransferOwnershipBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/apps/${appId}/transfer_ownership`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appsTransferOwnershipBody, signal
    },
      );
    }
  


export const getAppsTransferOwnershipMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsTransferOwnership>>, TError,{appId: string;data: AppsTransferOwnershipBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appsTransferOwnership>>, TError,{appId: string;data: AppsTransferOwnershipBody}, TContext> => {

const mutationKey = ['appsTransferOwnership'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appsTransferOwnership>>, {appId: string;data: AppsTransferOwnershipBody}> = (props) => {
          const {appId,data} = props ?? {};

          return  appsTransferOwnership(appId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppsTransferOwnershipMutationResult = NonNullable<Awaited<ReturnType<typeof appsTransferOwnership>>>
    export type AppsTransferOwnershipMutationBody = AppsTransferOwnershipBody
    export type AppsTransferOwnershipMutationError = unknown

    /**
 * @summary POST /api/apps/{app_id}/transfer_ownership
 */
export const useAppsTransferOwnership = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appsTransferOwnership>>, TError,{appId: string;data: AppsTransferOwnershipBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof appsTransferOwnership>>,
        TError,
        {appId: string;data: AppsTransferOwnershipBody},
        TContext
      > => {

      const mutationOptions = getAppsTransferOwnershipMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/audit
 */
export const auditListAudit = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/audit`, method: 'GET', signal
    },
      );
    }
  



export const getAuditListAuditQueryKey = () => {
    return [
    `/api/audit`
    ] as const;
    }

    
export const getAuditListAuditQueryOptions = <TData = Awaited<ReturnType<typeof auditListAudit>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuditListAuditQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof auditListAudit>>> = ({ signal }) => auditListAudit(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AuditListAuditQueryResult = NonNullable<Awaited<ReturnType<typeof auditListAudit>>>
export type AuditListAuditQueryError = unknown


export function useAuditListAudit<TData = Awaited<ReturnType<typeof auditListAudit>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof auditListAudit>>,
          TError,
          Awaited<ReturnType<typeof auditListAudit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuditListAudit<TData = Awaited<ReturnType<typeof auditListAudit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof auditListAudit>>,
          TError,
          Awaited<ReturnType<typeof auditListAudit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAuditListAudit<TData = Awaited<ReturnType<typeof auditListAudit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/audit
 */

export function useAuditListAudit<TData = Awaited<ReturnType<typeof auditListAudit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof auditListAudit>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAuditListAuditQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Trigger system backup
 */
export const automationTriggerBackup = (
    automationTriggerBackupBody?: AutomationTriggerBackupBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/automation/backup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: automationTriggerBackupBody, signal
    },
      );
    }
  


export const getAutomationTriggerBackupMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext> => {

const mutationKey = ['automationTriggerBackup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerBackup>>, {data: AutomationTriggerBackupBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerBackup(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerBackupMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerBackup>>>
    export type AutomationTriggerBackupMutationBody = AutomationTriggerBackupBody
    export type AutomationTriggerBackupMutationError = unknown

    /**
 * @summary Trigger system backup
 */
export const useAutomationTriggerBackup = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerBackup>>, TError,{data: AutomationTriggerBackupBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerBackup>>,
        TError,
        {data: AutomationTriggerBackupBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerBackupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get automation logs
 */
export const automationGetAutomationLogs = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/automation/logs`, method: 'GET', signal
    },
      );
    }
  



export const getAutomationGetAutomationLogsQueryKey = () => {
    return [
    `/api/automation/logs`
    ] as const;
    }

    
export const getAutomationGetAutomationLogsQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationLogs>>> = ({ signal }) => automationGetAutomationLogs(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationLogsQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationLogs>>>
export type AutomationGetAutomationLogsQueryError = unknown


export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationLogs>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation logs
 */

export function useAutomationGetAutomationLogs<TData = Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationLogs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Trigger SGK document processing
 */
export const automationTriggerSgkProcessing = (
    automationTriggerSgkProcessingBody?: AutomationTriggerSgkProcessingBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/automation/sgk/process`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: automationTriggerSgkProcessingBody, signal
    },
      );
    }
  


export const getAutomationTriggerSgkProcessingMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext> => {

const mutationKey = ['automationTriggerSgkProcessing'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, {data: AutomationTriggerSgkProcessingBody}> = (props) => {
          const {data} = props ?? {};

          return  automationTriggerSgkProcessing(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AutomationTriggerSgkProcessingMutationResult = NonNullable<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>>
    export type AutomationTriggerSgkProcessingMutationBody = AutomationTriggerSgkProcessingBody
    export type AutomationTriggerSgkProcessingMutationError = unknown

    /**
 * @summary Trigger SGK document processing
 */
export const useAutomationTriggerSgkProcessing = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof automationTriggerSgkProcessing>>, TError,{data: AutomationTriggerSgkProcessingBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof automationTriggerSgkProcessing>>,
        TError,
        {data: AutomationTriggerSgkProcessingBody},
        TContext
      > => {

      const mutationOptions = getAutomationTriggerSgkProcessingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get automation system status
 */
export const automationGetAutomationStatus = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/automation/status`, method: 'GET', signal
    },
      );
    }
  



export const getAutomationGetAutomationStatusQueryKey = () => {
    return [
    `/api/automation/status`
    ] as const;
    }

    
export const getAutomationGetAutomationStatusQueryOptions = <TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAutomationGetAutomationStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof automationGetAutomationStatus>>> = ({ signal }) => automationGetAutomationStatus(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AutomationGetAutomationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof automationGetAutomationStatus>>>
export type AutomationGetAutomationStatusQueryError = unknown


export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof automationGetAutomationStatus>>,
          TError,
          Awaited<ReturnType<typeof automationGetAutomationStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get automation system status
 */

export function useAutomationGetAutomationStatus<TData = Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof automationGetAutomationStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAutomationGetAutomationStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Campaigns
 */
export const getApiCampaigns = (
    params?: GetApiCampaignsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiCampaigns200>(
      {url: `/api/campaigns`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetApiCampaignsQueryKey = (params?: GetApiCampaignsParams,) => {
    return [
    `/api/campaigns`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiCampaignsQueryOptions = <TData = Awaited<ReturnType<typeof getApiCampaigns>>, TError = unknown>(params?: GetApiCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiCampaignsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiCampaigns>>> = ({ signal }) => getApiCampaigns(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiCampaigns>>>
export type GetApiCampaignsQueryError = unknown


export function useGetApiCampaigns<TData = Awaited<ReturnType<typeof getApiCampaigns>>, TError = unknown>(
 params: undefined |  GetApiCampaignsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiCampaigns>>,
          TError,
          Awaited<ReturnType<typeof getApiCampaigns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiCampaigns<TData = Awaited<ReturnType<typeof getApiCampaigns>>, TError = unknown>(
 params?: GetApiCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiCampaigns>>,
          TError,
          Awaited<ReturnType<typeof getApiCampaigns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiCampaigns<TData = Awaited<ReturnType<typeof getApiCampaigns>>, TError = unknown>(
 params?: GetApiCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Campaigns
 */

export function useGetApiCampaigns<TData = Awaited<ReturnType<typeof getApiCampaigns>>, TError = unknown>(
 params?: GetApiCampaignsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiCampaigns>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiCampaignsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Campaign
 */
export const postApiCampaigns = (
    postApiCampaignsBody: PostApiCampaignsBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Campaign>(
      {url: `/api/campaigns`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postApiCampaignsBody, signal
    },
      );
    }
  


export const getPostApiCampaignsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiCampaigns>>, TError,{data: PostApiCampaignsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiCampaigns>>, TError,{data: PostApiCampaignsBody}, TContext> => {

const mutationKey = ['postApiCampaigns'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiCampaigns>>, {data: PostApiCampaignsBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiCampaigns(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiCampaignsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiCampaigns>>>
    export type PostApiCampaignsMutationBody = PostApiCampaignsBody
    export type PostApiCampaignsMutationError = unknown

    /**
 * @summary Create Campaign
 */
export const usePostApiCampaigns = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiCampaigns>>, TError,{data: PostApiCampaignsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiCampaigns>>,
        TError,
        {data: PostApiCampaignsBody},
        TContext
      > => {

      const mutationOptions = getPostApiCampaignsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Send Campaign
 */
export const postApiCampaignsCampaignIdSend = (
    campaignId: string,
    postApiCampaignsCampaignIdSendBody: PostApiCampaignsCampaignIdSendBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<PostApiCampaignsCampaignIdSend200>(
      {url: `/api/campaigns/${campaignId}/send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postApiCampaignsCampaignIdSendBody, signal
    },
      );
    }
  


export const getPostApiCampaignsCampaignIdSendMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>, TError,{campaignId: string;data: PostApiCampaignsCampaignIdSendBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>, TError,{campaignId: string;data: PostApiCampaignsCampaignIdSendBody}, TContext> => {

const mutationKey = ['postApiCampaignsCampaignIdSend'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>, {campaignId: string;data: PostApiCampaignsCampaignIdSendBody}> = (props) => {
          const {campaignId,data} = props ?? {};

          return  postApiCampaignsCampaignIdSend(campaignId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiCampaignsCampaignIdSendMutationResult = NonNullable<Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>>
    export type PostApiCampaignsCampaignIdSendMutationBody = PostApiCampaignsCampaignIdSendBody
    export type PostApiCampaignsCampaignIdSendMutationError = unknown

    /**
 * @summary Send Campaign
 */
export const usePostApiCampaignsCampaignIdSend = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>, TError,{campaignId: string;data: PostApiCampaignsCampaignIdSendBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiCampaignsCampaignIdSend>>,
        TError,
        {campaignId: string;data: PostApiCampaignsCampaignIdSendBody},
        TContext
      > => {

      const mutationOptions = getPostApiCampaignsCampaignIdSendMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Maps PaymentRecord rows to a simplified format:
{
id, date, transactionType, recordType, patientId, patientName, amount, description
}
Optional query params:
- limit: max number of rows (default 200)
- start_date, end_date: ISO date filters
- status: filter by payment status (paid/pending/partial)
 * @summary Return cash register records for cashflow.html consumption.
 */
export const cashRecordsGetCashRecords = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/cash-records`, method: 'GET', signal
    },
      );
    }
  



export const getCashRecordsGetCashRecordsQueryKey = () => {
    return [
    `/api/cash-records`
    ] as const;
    }

    
export const getCashRecordsGetCashRecordsQueryOptions = <TData = Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCashRecordsGetCashRecordsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>> = ({ signal }) => cashRecordsGetCashRecords(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CashRecordsGetCashRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>>
export type CashRecordsGetCashRecordsQueryError = unknown


export function useCashRecordsGetCashRecords<TData = Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof cashRecordsGetCashRecords>>,
          TError,
          Awaited<ReturnType<typeof cashRecordsGetCashRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCashRecordsGetCashRecords<TData = Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof cashRecordsGetCashRecords>>,
          TError,
          Awaited<ReturnType<typeof cashRecordsGetCashRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCashRecordsGetCashRecords<TData = Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Return cash register records for cashflow.html consumption.
 */

export function useCashRecordsGetCashRecords<TData = Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cashRecordsGetCashRecords>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCashRecordsGetCashRecordsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const cashRecordsCreateCashRecord = (
    cashRecordsCreateCashRecordBody?: CashRecordsCreateCashRecordBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/cash-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cashRecordsCreateCashRecordBody, signal
    },
      );
    }
  


export const getCashRecordsCreateCashRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext> => {

const mutationKey = ['cashRecordsCreateCashRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, {data: CashRecordsCreateCashRecordBody}> = (props) => {
          const {data} = props ?? {};

          return  cashRecordsCreateCashRecord(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CashRecordsCreateCashRecordMutationResult = NonNullable<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>>
    export type CashRecordsCreateCashRecordMutationBody = CashRecordsCreateCashRecordBody
    export type CashRecordsCreateCashRecordMutationError = unknown

    /**
 * @summary Create a new cash record from cashflow.html form submission.
 */
export const useCashRecordsCreateCashRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>, TError,{data: CashRecordsCreateCashRecordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cashRecordsCreateCashRecord>>,
        TError,
        {data: CashRecordsCreateCashRecordBody},
        TContext
      > => {

      const mutationOptions = getCashRecordsCreateCashRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a cash record by ID.
 */
export const cashRecordsDeleteCashRecord = (
    recordId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/cash-records/${recordId}`, method: 'DELETE'
    },
      );
    }
  


export const getCashRecordsDeleteCashRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext> => {

const mutationKey = ['cashRecordsDeleteCashRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, {recordId: string}> = (props) => {
          const {recordId} = props ?? {};

          return  cashRecordsDeleteCashRecord(recordId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CashRecordsDeleteCashRecordMutationResult = NonNullable<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>>
    
    export type CashRecordsDeleteCashRecordMutationError = unknown

    /**
 * @summary Delete a cash record by ID.
 */
export const useCashRecordsDeleteCashRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>, TError,{recordId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cashRecordsDeleteCashRecord>>,
        TError,
        {recordId: string},
        TContext
      > => {

      const mutationOptions = getCashRecordsDeleteCashRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/config
 */
export const configGetConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/config`, method: 'GET', signal
    },
      );
    }
  



export const getConfigGetConfigQueryKey = () => {
    return [
    `/api/config`
    ] as const;
    }

    
export const getConfigGetConfigQueryOptions = <TData = Awaited<ReturnType<typeof configGetConfig>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConfigGetConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof configGetConfig>>> = ({ signal }) => configGetConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ConfigGetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof configGetConfig>>>
export type ConfigGetConfigQueryError = unknown


export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGetConfig>>,
          TError,
          Awaited<ReturnType<typeof configGetConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGetConfig>>,
          TError,
          Awaited<ReturnType<typeof configGetConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/config
 */

export function useConfigGetConfig<TData = Awaited<ReturnType<typeof configGetConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof configGetConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getConfigGetConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/config/turnstile
 */
export const registrationGetTurnstileConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/config/turnstile`, method: 'GET', signal
    },
      );
    }
  



export const getRegistrationGetTurnstileConfigQueryKey = () => {
    return [
    `/api/config/turnstile`
    ] as const;
    }

    
export const getRegistrationGetTurnstileConfigQueryOptions = <TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRegistrationGetTurnstileConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>> = ({ signal }) => registrationGetTurnstileConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type RegistrationGetTurnstileConfigQueryResult = NonNullable<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>>
export type RegistrationGetTurnstileConfigQueryError = unknown


export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>,
          TError,
          Awaited<ReturnType<typeof registrationGetTurnstileConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/config/turnstile
 */

export function useRegistrationGetTurnstileConfig<TData = Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof registrationGetTurnstileConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRegistrationGetTurnstileConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Main dashboard endpoint that returns all dashboard data
 */
export const dashboardGetDashboard = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/dashboard`, method: 'GET', signal
    },
      );
    }
  



export const getDashboardGetDashboardQueryKey = () => {
    return [
    `/api/dashboard`
    ] as const;
    }

    
export const getDashboardGetDashboardQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetDashboard>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetDashboard>>> = ({ signal }) => dashboardGetDashboard(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetDashboard>>>
export type DashboardGetDashboardQueryError = unknown


export function useDashboardGetDashboard<TData = Awaited<ReturnType<typeof dashboardGetDashboard>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboard>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboard<TData = Awaited<ReturnType<typeof dashboardGetDashboard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetDashboard>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetDashboard<TData = Awaited<ReturnType<typeof dashboardGetDashboard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Main dashboard endpoint that returns all dashboard data
 */

export function useDashboardGetDashboard<TData = Awaited<ReturnType<typeof dashboardGetDashboard>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetDashboardQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/dashboard/charts/patient-trends
 */
export const dashboardPatientTrends = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/dashboard/charts/patient-trends`, method: 'GET', signal
    },
      );
    }
  



export const getDashboardPatientTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/patient-trends`
    ] as const;
    }

    
export const getDashboardPatientTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardPatientTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardPatientTrends>>> = ({ signal }) => dashboardPatientTrends(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardPatientTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardPatientTrends>>>
export type DashboardPatientTrendsQueryError = unknown


export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardPatientTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardPatientTrends>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/patient-trends
 */

export function useDashboardPatientTrends<TData = Awaited<ReturnType<typeof dashboardPatientTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardPatientTrends>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardPatientTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/dashboard/charts/revenue-trends
 */
export const dashboardRevenueTrends = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/dashboard/charts/revenue-trends`, method: 'GET', signal
    },
      );
    }
  



export const getDashboardRevenueTrendsQueryKey = () => {
    return [
    `/api/dashboard/charts/revenue-trends`
    ] as const;
    }

    
export const getDashboardRevenueTrendsQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRevenueTrendsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRevenueTrends>>> = ({ signal }) => dashboardRevenueTrends(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRevenueTrendsQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRevenueTrends>>>
export type DashboardRevenueTrendsQueryError = unknown


export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRevenueTrends>>,
          TError,
          Awaited<ReturnType<typeof dashboardRevenueTrends>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/charts/revenue-trends
 */

export function useDashboardRevenueTrends<TData = Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRevenueTrends>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRevenueTrendsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/dashboard/kpis
 */
export const dashboardGetKpis = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/dashboard/kpis`, method: 'GET', signal
    },
      );
    }
  



export const getDashboardGetKpisQueryKey = () => {
    return [
    `/api/dashboard/kpis`
    ] as const;
    }

    
export const getDashboardGetKpisQueryOptions = <TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardGetKpisQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardGetKpis>>> = ({ signal }) => dashboardGetKpis(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardGetKpisQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardGetKpis>>>
export type DashboardGetKpisQueryError = unknown


export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardGetKpis>>,
          TError,
          Awaited<ReturnType<typeof dashboardGetKpis>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/kpis
 */

export function useDashboardGetKpis<TData = Awaited<ReturnType<typeof dashboardGetKpis>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardGetKpis>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardGetKpisQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/dashboard/recent-activity
 */
export const dashboardRecentActivity = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/dashboard/recent-activity`, method: 'GET', signal
    },
      );
    }
  



export const getDashboardRecentActivityQueryKey = () => {
    return [
    `/api/dashboard/recent-activity`
    ] as const;
    }

    
export const getDashboardRecentActivityQueryOptions = <TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDashboardRecentActivityQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardRecentActivity>>> = ({ signal }) => dashboardRecentActivity(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DashboardRecentActivityQueryResult = NonNullable<Awaited<ReturnType<typeof dashboardRecentActivity>>>
export type DashboardRecentActivityQueryError = unknown


export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardRecentActivity>>,
          TError,
          Awaited<ReturnType<typeof dashboardRecentActivity>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/dashboard/recent-activity
 */

export function useDashboardRecentActivity<TData = Awaited<ReturnType<typeof dashboardRecentActivity>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dashboardRecentActivity>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDashboardRecentActivityQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get devices with filtering
 */
export const devicesGetDevices = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices`, method: 'GET', signal
    },
      );
    }
  



export const getDevicesGetDevicesQueryKey = () => {
    return [
    `/api/devices`
    ] as const;
    }

    
export const getDevicesGetDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDevicesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDevices>>> = ({ signal }) => devicesGetDevices(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDevices>>>
export type DevicesGetDevicesQueryError = unknown


export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get devices with filtering
 */

export function useDevicesGetDevices<TData = Awaited<ReturnType<typeof devicesGetDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDevicesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new device
 */
export const devicesCreateDevice = (
    devicesCreateDeviceBody?: DevicesCreateDeviceBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: devicesCreateDeviceBody, signal
    },
      );
    }
  


export const getDevicesCreateDeviceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext> => {

const mutationKey = ['devicesCreateDevice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesCreateDevice>>, {data: DevicesCreateDeviceBody}> = (props) => {
          const {data} = props ?? {};

          return  devicesCreateDevice(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesCreateDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesCreateDevice>>>
    export type DevicesCreateDeviceMutationBody = DevicesCreateDeviceBody
    export type DevicesCreateDeviceMutationError = unknown

    /**
 * @summary Create a new device
 */
export const useDevicesCreateDevice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesCreateDevice>>, TError,{data: DevicesCreateDeviceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesCreateDevice>>,
        TError,
        {data: DevicesCreateDeviceBody},
        TContext
      > => {

      const mutationOptions = getDevicesCreateDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific device
 */
export const devicesGetDevice = (
    deviceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/${deviceId}`, method: 'GET', signal
    },
      );
    }
  



export const getDevicesGetDeviceQueryKey = (deviceId?: string,) => {
    return [
    `/api/devices/${deviceId}`
    ] as const;
    }

    
export const getDevicesGetDeviceQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDevice>>, TError = unknown>(deviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceQueryKey(deviceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDevice>>> = ({ signal }) => devicesGetDevice(deviceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(deviceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDevice>>>
export type DevicesGetDeviceQueryError = unknown


export function useDevicesGetDevice<TData = Awaited<ReturnType<typeof devicesGetDevice>>, TError = unknown>(
 deviceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevice>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevice<TData = Awaited<ReturnType<typeof devicesGetDevice>>, TError = unknown>(
 deviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDevice>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDevice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDevice<TData = Awaited<ReturnType<typeof devicesGetDevice>>, TError = unknown>(
 deviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific device
 */

export function useDevicesGetDevice<TData = Awaited<ReturnType<typeof devicesGetDevice>>, TError = unknown>(
 deviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDevice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceQueryOptions(deviceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update a device (PUT full update or PATCH partial update)
 */
export const devicesUpdateDevice = (
    deviceId: string,
    devicesUpdateDeviceBody?: DevicesUpdateDeviceBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/${deviceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: devicesUpdateDeviceBody
    },
      );
    }
  


export const getDevicesUpdateDeviceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevice>>, TError,{deviceId: string;data: DevicesUpdateDeviceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevice>>, TError,{deviceId: string;data: DevicesUpdateDeviceBody}, TContext> => {

const mutationKey = ['devicesUpdateDevice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesUpdateDevice>>, {deviceId: string;data: DevicesUpdateDeviceBody}> = (props) => {
          const {deviceId,data} = props ?? {};

          return  devicesUpdateDevice(deviceId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesUpdateDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesUpdateDevice>>>
    export type DevicesUpdateDeviceMutationBody = DevicesUpdateDeviceBody
    export type DevicesUpdateDeviceMutationError = unknown

    /**
 * @summary Update a device (PUT full update or PATCH partial update)
 */
export const useDevicesUpdateDevice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevice>>, TError,{deviceId: string;data: DevicesUpdateDeviceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesUpdateDevice>>,
        TError,
        {deviceId: string;data: DevicesUpdateDeviceBody},
        TContext
      > => {

      const mutationOptions = getDevicesUpdateDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a device (PUT full update or PATCH partial update)
 */
export const devicesUpdateDevicePut = (
    deviceId: string,
    devicesUpdateDevicePutBody?: DevicesUpdateDevicePutBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/${deviceId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: devicesUpdateDevicePutBody
    },
      );
    }
  


export const getDevicesUpdateDevicePutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevicePut>>, TError,{deviceId: string;data: DevicesUpdateDevicePutBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevicePut>>, TError,{deviceId: string;data: DevicesUpdateDevicePutBody}, TContext> => {

const mutationKey = ['devicesUpdateDevicePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesUpdateDevicePut>>, {deviceId: string;data: DevicesUpdateDevicePutBody}> = (props) => {
          const {deviceId,data} = props ?? {};

          return  devicesUpdateDevicePut(deviceId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesUpdateDevicePutMutationResult = NonNullable<Awaited<ReturnType<typeof devicesUpdateDevicePut>>>
    export type DevicesUpdateDevicePutMutationBody = DevicesUpdateDevicePutBody
    export type DevicesUpdateDevicePutMutationError = unknown

    /**
 * @summary Update a device (PUT full update or PATCH partial update)
 */
export const useDevicesUpdateDevicePut = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDevicePut>>, TError,{deviceId: string;data: DevicesUpdateDevicePutBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesUpdateDevicePut>>,
        TError,
        {deviceId: string;data: DevicesUpdateDevicePutBody},
        TContext
      > => {

      const mutationOptions = getDevicesUpdateDevicePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a device
 */
export const devicesDeleteDevice = (
    deviceId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/${deviceId}`, method: 'DELETE'
    },
      );
    }
  


export const getDevicesDeleteDeviceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext> => {

const mutationKey = ['devicesDeleteDevice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesDeleteDevice>>, {deviceId: string}> = (props) => {
          const {deviceId} = props ?? {};

          return  devicesDeleteDevice(deviceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesDeleteDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof devicesDeleteDevice>>>
    
    export type DevicesDeleteDeviceMutationError = unknown

    /**
 * @summary Delete a device
 */
export const useDevicesDeleteDevice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesDeleteDevice>>, TError,{deviceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesDeleteDevice>>,
        TError,
        {deviceId: string},
        TContext
      > => {

      const mutationOptions = getDevicesDeleteDeviceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally permissive for tests â€” real inventory logic
should live in a dedicated inventory table/service.
 * @summary Update device stock levels (simplified).
 */
export const devicesUpdateDeviceStock = (
    deviceId: string,
    devicesUpdateDeviceStockBody?: DevicesUpdateDeviceStockBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/${deviceId}/stock-update`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: devicesUpdateDeviceStockBody, signal
    },
      );
    }
  


export const getDevicesUpdateDeviceStockMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext> => {

const mutationKey = ['devicesUpdateDeviceStock'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, {deviceId: string;data: DevicesUpdateDeviceStockBody}> = (props) => {
          const {deviceId,data} = props ?? {};

          return  devicesUpdateDeviceStock(deviceId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DevicesUpdateDeviceStockMutationResult = NonNullable<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>>
    export type DevicesUpdateDeviceStockMutationBody = DevicesUpdateDeviceStockBody
    export type DevicesUpdateDeviceStockMutationError = unknown

    /**
 * @summary Update device stock levels (simplified).
 */
export const useDevicesUpdateDeviceStock = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof devicesUpdateDeviceStock>>, TError,{deviceId: string;data: DevicesUpdateDeviceStockBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof devicesUpdateDeviceStock>>,
        TError,
        {deviceId: string;data: DevicesUpdateDeviceStockBody},
        TContext
      > => {

      const mutationOptions = getDevicesUpdateDeviceStockMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get available device brands
 */
export const devicesGetDeviceBrands = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/brands`, method: 'GET', signal
    },
      );
    }
  



export const getDevicesGetDeviceBrandsQueryKey = () => {
    return [
    `/api/devices/brands`
    ] as const;
    }

    
export const getDevicesGetDeviceBrandsQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceBrands>>> = ({ signal }) => devicesGetDeviceBrands(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceBrands>>>
export type DevicesGetDeviceBrandsQueryError = unknown


export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceBrands>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device brands
 */

export function useDevicesGetDeviceBrands<TData = Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceBrands>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get available device categories
 */
export const devicesGetDeviceCategories = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/categories`, method: 'GET', signal
    },
      );
    }
  



export const getDevicesGetDeviceCategoriesQueryKey = () => {
    return [
    `/api/devices/categories`
    ] as const;
    }

    
export const getDevicesGetDeviceCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetDeviceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetDeviceCategories>>> = ({ signal }) => devicesGetDeviceCategories(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetDeviceCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetDeviceCategories>>>
export type DevicesGetDeviceCategoriesQueryError = unknown


export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>,
          TError,
          Awaited<ReturnType<typeof devicesGetDeviceCategories>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available device categories
 */

export function useDevicesGetDeviceCategories<TData = Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetDeviceCategories>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetDeviceCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get devices with low stock levels
 */
export const devicesGetLowStockDevices = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/devices/low-stock`, method: 'GET', signal
    },
      );
    }
  



export const getDevicesGetLowStockDevicesQueryKey = () => {
    return [
    `/api/devices/low-stock`
    ] as const;
    }

    
export const getDevicesGetLowStockDevicesQueryOptions = <TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDevicesGetLowStockDevicesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesGetLowStockDevices>>> = ({ signal }) => devicesGetLowStockDevices(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DevicesGetLowStockDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof devicesGetLowStockDevices>>>
export type DevicesGetLowStockDevicesQueryError = unknown


export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>,
          TError,
          Awaited<ReturnType<typeof devicesGetLowStockDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get devices with low stock levels
 */

export function useDevicesGetLowStockDevices<TData = Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof devicesGetLowStockDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDevicesGetLowStockDevicesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/forgot-password
 */
export const authForgotPassword = (
    authForgotPasswordBody?: AuthForgotPasswordBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authForgotPasswordBody, signal
    },
      );
    }
  


export const getAuthForgotPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext> => {

const mutationKey = ['authForgotPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authForgotPassword>>, {data: AuthForgotPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  authForgotPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authForgotPassword>>>
    export type AuthForgotPasswordMutationBody = AuthForgotPasswordBody
    export type AuthForgotPasswordMutationError = unknown

    /**
 * @summary POST /api/forgot-password
 */
export const useAuthForgotPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authForgotPassword>>, TError,{data: AuthForgotPasswordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authForgotPassword>>,
        TError,
        {data: AuthForgotPasswordBody},
        TContext
      > => {

      const mutationOptions = getAuthForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns 200 when read+write ok, 503 when write fails, and 500 when other errors occur.
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */
export const healthCheck = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/health`, method: 'GET', signal
    },
      );
    }
  



export const getHealthCheckQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = unknown


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all inventory items with optional filtering
 */
export const inventoryGetAllInventory = (
    params?: InventoryGetAllInventoryParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InventoryGetAllInventory200>(
      {url: `/api/inventory`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getInventoryGetAllInventoryQueryKey = (params?: InventoryGetAllInventoryParams,) => {
    return [
    `/api/inventory`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInventoryGetAllInventoryQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError = unknown>(params?: InventoryGetAllInventoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetAllInventoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetAllInventory>>> = ({ signal }) => inventoryGetAllInventory(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetAllInventoryQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetAllInventory>>>
export type InventoryGetAllInventoryQueryError = unknown


export function useInventoryGetAllInventory<TData = Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError = unknown>(
 params: undefined |  InventoryGetAllInventoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetAllInventory>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetAllInventory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetAllInventory<TData = Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError = unknown>(
 params?: InventoryGetAllInventoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetAllInventory>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetAllInventory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetAllInventory<TData = Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError = unknown>(
 params?: InventoryGetAllInventoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all inventory items with optional filtering
 */

export function useInventoryGetAllInventory<TData = Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError = unknown>(
 params?: InventoryGetAllInventoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetAllInventory>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetAllInventoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get a single inventory item by ID
 */
export const inventoryGetInventoryItem = (
    itemId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetInventoryItemQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}`
    ] as const;
    }

    
export const getInventoryGetInventoryItemQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = unknown>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryItemQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryItem>>> = ({ signal }) => inventoryGetInventoryItem(itemId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryItemQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryItem>>>
export type InventoryGetInventoryItemQueryError = unknown


export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = unknown>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryItem>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a single inventory item by ID
 */

export function useInventoryGetInventoryItem<TData = Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryItem>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryItemQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update an existing inventory item
 */
export const inventoryUpdateInventoryItem = (
    itemId: string,
    inventoryUpdateInventoryItemBody?: InventoryUpdateInventoryItemBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: inventoryUpdateInventoryItemBody
    },
      );
    }
  


export const getInventoryUpdateInventoryItemMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryUpdateInventoryItemBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryUpdateInventoryItemBody}, TContext> => {

const mutationKey = ['inventoryUpdateInventoryItem'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, {itemId: string;data: InventoryUpdateInventoryItemBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryUpdateInventoryItem(itemId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryUpdateInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>>
    export type InventoryUpdateInventoryItemMutationBody = InventoryUpdateInventoryItemBody
    export type InventoryUpdateInventoryItemMutationError = unknown

    /**
 * @summary Update an existing inventory item
 */
export const useInventoryUpdateInventoryItem = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>, TError,{itemId: string;data: InventoryUpdateInventoryItemBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryUpdateInventoryItem>>,
        TError,
        {itemId: string;data: InventoryUpdateInventoryItemBody},
        TContext
      > => {

      const mutationOptions = getInventoryUpdateInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete an inventory item
 */
export const inventoryDeleteInventoryItem = (
    itemId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}`, method: 'DELETE'
    },
      );
    }
  


export const getInventoryDeleteInventoryItemMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['inventoryDeleteInventoryItem'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  inventoryDeleteInventoryItem(itemId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryDeleteInventoryItemMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>>
    
    export type InventoryDeleteInventoryItemMutationError = unknown

    /**
 * @summary Delete an inventory item
 */
export const useInventoryDeleteInventoryItem = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>, TError,{itemId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryDeleteInventoryItem>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getInventoryDeleteInventoryItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Log an activity for an inventory item
 */
export const inventoryLogInventoryActivity = (
    itemId: string,
    inventoryLogInventoryActivityBody?: InventoryLogInventoryActivityBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}/activity`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: inventoryLogInventoryActivityBody, signal
    },
      );
    }
  


export const getInventoryLogInventoryActivityMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryLogInventoryActivity>>, TError,{itemId: string;data: InventoryLogInventoryActivityBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof inventoryLogInventoryActivity>>, TError,{itemId: string;data: InventoryLogInventoryActivityBody}, TContext> => {

const mutationKey = ['inventoryLogInventoryActivity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryLogInventoryActivity>>, {itemId: string;data: InventoryLogInventoryActivityBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryLogInventoryActivity(itemId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryLogInventoryActivityMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryLogInventoryActivity>>>
    export type InventoryLogInventoryActivityMutationBody = InventoryLogInventoryActivityBody
    export type InventoryLogInventoryActivityMutationError = unknown

    /**
 * @summary Log an activity for an inventory item
 */
export const useInventoryLogInventoryActivity = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryLogInventoryActivity>>, TError,{itemId: string;data: InventoryLogInventoryActivityBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryLogInventoryActivity>>,
        TError,
        {itemId: string;data: InventoryLogInventoryActivityBody},
        TContext
      > => {

      const mutationOptions = getInventoryLogInventoryActivityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get activity log for an inventory item
 */
export const inventoryGetInventoryActivities = (
    itemId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}/activity`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetInventoryActivitiesQueryKey = (itemId?: string,) => {
    return [
    `/api/inventory/${itemId}/activity`
    ] as const;
    }

    
export const getInventoryGetInventoryActivitiesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = unknown>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryActivitiesQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>> = ({ signal }) => inventoryGetInventoryActivities(itemId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryActivitiesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>>
export type InventoryGetInventoryActivitiesQueryError = unknown


export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = unknown>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryActivities>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get activity log for an inventory item
 */

export function useInventoryGetInventoryActivities<TData = Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError = unknown>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryActivities>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryActivitiesQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const inventoryAssignToPatient = (
    itemId: string,
    inventoryAssignToPatientBody?: InventoryAssignToPatientBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}/assign`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: inventoryAssignToPatientBody, signal
    },
      );
    }
  


export const getInventoryAssignToPatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext> => {

const mutationKey = ['inventoryAssignToPatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAssignToPatient>>, {itemId: string;data: InventoryAssignToPatientBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAssignToPatient(itemId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAssignToPatientMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAssignToPatient>>>
    export type InventoryAssignToPatientMutationBody = InventoryAssignToPatientBody
    export type InventoryAssignToPatientMutationError = unknown

    /**
 * @summary Assign inventory item to a patient (reduces stock)
 */
export const useInventoryAssignToPatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAssignToPatient>>, TError,{itemId: string;data: InventoryAssignToPatientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAssignToPatient>>,
        TError,
        {itemId: string;data: InventoryAssignToPatientBody},
        TContext
      > => {

      const mutationOptions = getInventoryAssignToPatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Add serial numbers to an inventory item
 */
export const inventoryAddSerialNumbers = (
    itemId: string,
    inventoryAddSerialNumbersBody?: InventoryAddSerialNumbersBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/${itemId}/serials`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: inventoryAddSerialNumbersBody, signal
    },
      );
    }
  


export const getInventoryAddSerialNumbersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext> => {

const mutationKey = ['inventoryAddSerialNumbers'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, {itemId: string;data: InventoryAddSerialNumbersBody}> = (props) => {
          const {itemId,data} = props ?? {};

          return  inventoryAddSerialNumbers(itemId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InventoryAddSerialNumbersMutationResult = NonNullable<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>>
    export type InventoryAddSerialNumbersMutationBody = InventoryAddSerialNumbersBody
    export type InventoryAddSerialNumbersMutationError = unknown

    /**
 * @summary Add serial numbers to an inventory item
 */
export const useInventoryAddSerialNumbers = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof inventoryAddSerialNumbers>>, TError,{itemId: string;data: InventoryAddSerialNumbersBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof inventoryAddSerialNumbers>>,
        TError,
        {itemId: string;data: InventoryAddSerialNumbersBody},
        TContext
      > => {

      const mutationOptions = getInventoryAddSerialNumbersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all items with low stock levels
 */
export const inventoryGetLowStockItems = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/low-stock`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetLowStockItemsQueryKey = () => {
    return [
    `/api/inventory/low-stock`
    ] as const;
    }

    
export const getInventoryGetLowStockItemsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetLowStockItemsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetLowStockItems>>> = ({ signal }) => inventoryGetLowStockItems(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetLowStockItemsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetLowStockItems>>>
export type InventoryGetLowStockItemsQueryError = unknown


export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetLowStockItems>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all items with low stock levels
 */

export function useInventoryGetLowStockItems<TData = Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetLowStockItems>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetLowStockItemsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get inventory statistics
 */
export const inventoryGetInventoryStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/inventory/stats`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetInventoryStatsQueryKey = () => {
    return [
    `/api/inventory/stats`
    ] as const;
    }

    
export const getInventoryGetInventoryStatsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetInventoryStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetInventoryStats>>> = ({ signal }) => inventoryGetInventoryStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetInventoryStatsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetInventoryStats>>>
export type InventoryGetInventoryStatsQueryError = unknown


export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetInventoryStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get inventory statistics
 */

export function useInventoryGetInventoryStats<TData = Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetInventoryStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetInventoryStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Advanced product search with filters
 */
export const inventoryAdvancedSearch = (
    params?: InventoryAdvancedSearchParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InventoryAdvancedSearch200>(
      {url: `/api/inventory/search`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getInventoryAdvancedSearchQueryKey = (params?: InventoryAdvancedSearchParams,) => {
    return [
    `/api/inventory/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInventoryAdvancedSearchQueryOptions = <TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = void>(params?: InventoryAdvancedSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryAdvancedSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryAdvancedSearch>>> = ({ signal }) => inventoryAdvancedSearch(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryAdvancedSearchQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryAdvancedSearch>>>
export type InventoryAdvancedSearchQueryError = void


export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = void>(
 params: undefined |  InventoryAdvancedSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
          TError,
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = void>(
 params?: InventoryAdvancedSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>,
          TError,
          Awaited<ReturnType<typeof inventoryAdvancedSearch>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = void>(
 params?: InventoryAdvancedSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Advanced product search with filters
 */

export function useInventoryAdvancedSearch<TData = Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError = void>(
 params?: InventoryAdvancedSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryAdvancedSearch>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryAdvancedSearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all available product categories
 */
export const inventoryGetCategories = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<InventoryGetCategories200>(
      {url: `/api/inventory/categories`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetCategoriesQueryKey = () => {
    return [
    `/api/inventory/categories`
    ] as const;
    }

    
export const getInventoryGetCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetCategories>>> = ({ signal }) => inventoryGetCategories(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetCategories>>>
export type InventoryGetCategoriesQueryError = unknown


export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetCategories>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetCategories>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product categories
 */

export function useInventoryGetCategories<TData = Awaited<ReturnType<typeof inventoryGetCategories>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetCategories>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all available product brands
 */
export const inventoryGetBrands = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<InventoryGetBrands200>(
      {url: `/api/inventory/brands`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetBrandsQueryKey = () => {
    return [
    `/api/inventory/brands`
    ] as const;
    }

    
export const getInventoryGetBrandsQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetBrandsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetBrands>>> = ({ signal }) => inventoryGetBrands(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetBrandsQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetBrands>>>
export type InventoryGetBrandsQueryError = unknown


export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrands>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrands>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetBrands>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetBrands>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product brands
 */

export function useInventoryGetBrands<TData = Awaited<ReturnType<typeof inventoryGetBrands>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetBrands>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all available product features
 */
export const inventoryGetFeatures = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<InventoryGetFeatures200>(
      {url: `/api/inventory/features`, method: 'GET', signal
    },
      );
    }
  



export const getInventoryGetFeaturesQueryKey = () => {
    return [
    `/api/inventory/features`
    ] as const;
    }

    
export const getInventoryGetFeaturesQueryOptions = <TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInventoryGetFeaturesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inventoryGetFeatures>>> = ({ signal }) => inventoryGetFeatures(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InventoryGetFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof inventoryGetFeatures>>>
export type InventoryGetFeaturesQueryError = unknown


export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetFeatures>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inventoryGetFeatures>>,
          TError,
          Awaited<ReturnType<typeof inventoryGetFeatures>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all available product features
 */

export function useInventoryGetFeatures<TData = Awaited<ReturnType<typeof inventoryGetFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inventoryGetFeatures>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInventoryGetFeaturesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new invoice
 */
export const invoicesCreateInvoice = (
    invoicesCreateInvoiceBody?: InvoicesCreateInvoiceBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesCreateInvoiceBody, signal
    },
      );
    }
  


export const getInvoicesCreateInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext> => {

const mutationKey = ['invoicesCreateInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateInvoice>>, {data: InvoicesCreateInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateInvoice>>>
    export type InvoicesCreateInvoiceMutationBody = InvoicesCreateInvoiceBody
    export type InvoicesCreateInvoiceMutationError = unknown

    /**
 * @summary Create a new invoice
 */
export const useInvoicesCreateInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateInvoice>>, TError,{data: InvoicesCreateInvoiceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateInvoice>>,
        TError,
        {data: InvoicesCreateInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific invoice
 */
export const invoicesGetInvoice = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices/${invoiceId}`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetInvoiceQueryKey = (invoiceId?: string,) => {
    return [
    `/api/invoices/${invoiceId}`
    ] as const;
    }

    
export const getInvoicesGetInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = unknown>(invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetInvoiceQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetInvoice>>> = ({ signal }) => invoicesGetInvoice(invoiceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetInvoice>>>
export type InvoicesGetInvoiceQueryError = unknown


export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = unknown>(
 invoiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = unknown>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = unknown>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific invoice
 */

export function useInvoicesGetInvoice<TData = Awaited<ReturnType<typeof invoicesGetInvoice>>, TError = unknown>(
 invoiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetInvoiceQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Delete an invoice
 */
export const invoicesDeleteInvoice = (
    invoiceId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices/${invoiceId}`, method: 'DELETE'
    },
      );
    }
  


export const getInvoicesDeleteInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['invoicesDeleteInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  invoicesDeleteInvoice(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesDeleteInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesDeleteInvoice>>>
    
    export type InvoicesDeleteInvoiceMutationError = unknown

    /**
 * @summary Delete an invoice
 */
export const useInvoicesDeleteInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesDeleteInvoice>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesDeleteInvoice>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getInvoicesDeleteInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Generate PDF for invoice
 */
export const invoicesGenerateInvoicePdf = (
    invoiceId: number,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesGenerateInvoicePdf200>(
      {url: `/api/invoices/${invoiceId}/pdf`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGenerateInvoicePdfQueryKey = (invoiceId?: number,) => {
    return [
    `/api/invoices/${invoiceId}/pdf`
    ] as const;
    }

    
export const getInvoicesGenerateInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = void>(invoiceId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGenerateInvoicePdfQueryKey(invoiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>> = ({ signal }) => invoicesGenerateInvoicePdf(invoiceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(invoiceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGenerateInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>>
export type InvoicesGenerateInvoicePdfQueryError = void


export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = void>(
 invoiceId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = void>(
 invoiceId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = void>(
 invoiceId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate PDF for invoice
 */

export function useInvoicesGenerateInvoicePdf<TData = Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError = void>(
 invoiceId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGenerateInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGenerateInvoicePdfQueryOptions(invoiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Mark invoice as sent to GÄ°B
 */
export const invoicesSendInvoiceToGib = (
    invoiceId: string,
    invoicesSendInvoiceToGibBody?: InvoicesSendInvoiceToGibBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices/${invoiceId}/send-to-gib`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesSendInvoiceToGibBody, signal
    },
      );
    }
  


export const getInvoicesSendInvoiceToGibMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>, TError,{invoiceId: string;data: InvoicesSendInvoiceToGibBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>, TError,{invoiceId: string;data: InvoicesSendInvoiceToGibBody}, TContext> => {

const mutationKey = ['invoicesSendInvoiceToGib'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>, {invoiceId: string;data: InvoicesSendInvoiceToGibBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  invoicesSendInvoiceToGib(invoiceId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesSendInvoiceToGibMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>>
    export type InvoicesSendInvoiceToGibMutationBody = InvoicesSendInvoiceToGibBody
    export type InvoicesSendInvoiceToGibMutationError = unknown

    /**
 * @summary Mark invoice as sent to GÄ°B
 */
export const useInvoicesSendInvoiceToGib = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>, TError,{invoiceId: string;data: InvoicesSendInvoiceToGibBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesSendInvoiceToGib>>,
        TError,
        {invoiceId: string;data: InvoicesSendInvoiceToGibBody},
        TContext
      > => {

      const mutationOptions = getInvoicesSendInvoiceToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Generate multiple invoices in batch
 */
export const invoicesBatchGenerate = (
    invoicesBatchGenerateBody: InvoicesBatchGenerateBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesBatchGenerate201>(
      {url: `/api/invoices/batch-generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesBatchGenerateBody, signal
    },
      );
    }
  


export const getInvoicesBatchGenerateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerate>>, TError,{data: InvoicesBatchGenerateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerate>>, TError,{data: InvoicesBatchGenerateBody}, TContext> => {

const mutationKey = ['invoicesBatchGenerate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesBatchGenerate>>, {data: InvoicesBatchGenerateBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesBatchGenerate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesBatchGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesBatchGenerate>>>
    export type InvoicesBatchGenerateMutationBody = InvoicesBatchGenerateBody
    export type InvoicesBatchGenerateMutationError = void

    /**
 * @summary Generate multiple invoices in batch
 */
export const useInvoicesBatchGenerate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesBatchGenerate>>, TError,{data: InvoicesBatchGenerateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesBatchGenerate>>,
        TError,
        {data: InvoicesBatchGenerateBody},
        TContext
      > => {

      const mutationOptions = getInvoicesBatchGenerateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get available invoice templates
 */
export const invoicesGetTemplates = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesGetTemplates200>(
      {url: `/api/invoices/templates`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetTemplatesQueryKey = () => {
    return [
    `/api/invoices/templates`
    ] as const;
    }

    
export const getInvoicesGetTemplatesQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetTemplates>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetTemplatesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetTemplates>>> = ({ signal }) => invoicesGetTemplates(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetTemplates>>>
export type InvoicesGetTemplatesQueryError = unknown


export function useInvoicesGetTemplates<TData = Awaited<ReturnType<typeof invoicesGetTemplates>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetTemplates>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetTemplates<TData = Awaited<ReturnType<typeof invoicesGetTemplates>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetTemplates>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetTemplates<TData = Awaited<ReturnType<typeof invoicesGetTemplates>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get available invoice templates
 */

export function useInvoicesGetTemplates<TData = Awaited<ReturnType<typeof invoicesGetTemplates>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetTemplatesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create custom invoice template
 */
export const invoicesCreateTemplate = (
    invoicesCreateTemplateBody: InvoicesCreateTemplateBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices/templates`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesCreateTemplateBody, signal
    },
      );
    }
  


export const getInvoicesCreateTemplateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateTemplate>>, TError,{data: InvoicesCreateTemplateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateTemplate>>, TError,{data: InvoicesCreateTemplateBody}, TContext> => {

const mutationKey = ['invoicesCreateTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateTemplate>>, {data: InvoicesCreateTemplateBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesCreateTemplate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateTemplate>>>
    export type InvoicesCreateTemplateMutationBody = InvoicesCreateTemplateBody
    export type InvoicesCreateTemplateMutationError = void

    /**
 * @summary Create custom invoice template
 */
export const useInvoicesCreateTemplate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateTemplate>>, TError,{data: InvoicesCreateTemplateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateTemplate>>,
        TError,
        {data: InvoicesCreateTemplateBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get invoice print queue status
 */
export const invoicesGetPrintQueue = (
    params?: InvoicesGetPrintQueueParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<InvoicesGetPrintQueue200>(
      {url: `/api/invoices/print-queue`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getInvoicesGetPrintQueueQueryKey = (params?: InvoicesGetPrintQueueParams,) => {
    return [
    `/api/invoices/print-queue`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getInvoicesGetPrintQueueQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError = unknown>(params?: InvoicesGetPrintQueueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetPrintQueueQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetPrintQueue>>> = ({ signal }) => invoicesGetPrintQueue(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetPrintQueueQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetPrintQueue>>>
export type InvoicesGetPrintQueueQueryError = unknown


export function useInvoicesGetPrintQueue<TData = Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError = unknown>(
 params: undefined |  InvoicesGetPrintQueueParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPrintQueue>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPrintQueue>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPrintQueue<TData = Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError = unknown>(
 params?: InvoicesGetPrintQueueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPrintQueue>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPrintQueue>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPrintQueue<TData = Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError = unknown>(
 params?: InvoicesGetPrintQueueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice print queue status
 */

export function useInvoicesGetPrintQueue<TData = Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError = unknown>(
 params?: InvoicesGetPrintQueueParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPrintQueue>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetPrintQueueQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Add invoices to print queue
 */
export const invoicesAddToPrintQueue = (
    invoicesAddToPrintQueueBody: InvoicesAddToPrintQueueBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/invoices/print-queue`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesAddToPrintQueueBody, signal
    },
      );
    }
  


export const getInvoicesAddToPrintQueueMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext> => {

const mutationKey = ['invoicesAddToPrintQueue'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, {data: InvoicesAddToPrintQueueBody}> = (props) => {
          const {data} = props ?? {};

          return  invoicesAddToPrintQueue(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesAddToPrintQueueMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>>
    export type InvoicesAddToPrintQueueMutationBody = InvoicesAddToPrintQueueBody
    export type InvoicesAddToPrintQueueMutationError = void

    /**
 * @summary Add invoices to print queue
 */
export const useInvoicesAddToPrintQueue = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesAddToPrintQueue>>, TError,{data: InvoicesAddToPrintQueueBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesAddToPrintQueue>>,
        TError,
        {data: InvoicesAddToPrintQueueBody},
        TContext
      > => {

      const mutationOptions = getInvoicesAddToPrintQueueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/login
 */
export const authLogin = (
    authLoginBody?: AuthLoginBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authLoginBody, signal
    },
      );
    }
  


export const getAuthLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext> => {

const mutationKey = ['authLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authLogin>>, {data: AuthLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  authLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authLogin>>>
    export type AuthLoginMutationBody = AuthLoginBody
    export type AuthLoginMutationError = unknown

    /**
 * @summary POST /api/login
 */
export const useAuthLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authLogin>>,
        TError,
        {data: AuthLoginBody},
        TContext
      > => {

      const mutationOptions = getAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Notifications
 */
export const getApiNotifications = (
    params: GetApiNotificationsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiNotifications200>(
      {url: `/api/notifications`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetApiNotificationsQueryKey = (params?: GetApiNotificationsParams,) => {
    return [
    `/api/notifications`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getApiNotifications>>, TError = unknown>(params: GetApiNotificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiNotificationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiNotifications>>> = ({ signal }) => getApiNotifications(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiNotifications>>>
export type GetApiNotificationsQueryError = unknown


export function useGetApiNotifications<TData = Awaited<ReturnType<typeof getApiNotifications>>, TError = unknown>(
 params: GetApiNotificationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiNotifications>>,
          TError,
          Awaited<ReturnType<typeof getApiNotifications>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiNotifications<TData = Awaited<ReturnType<typeof getApiNotifications>>, TError = unknown>(
 params: GetApiNotificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiNotifications>>,
          TError,
          Awaited<ReturnType<typeof getApiNotifications>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiNotifications<TData = Awaited<ReturnType<typeof getApiNotifications>>, TError = unknown>(
 params: GetApiNotificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Notifications
 */

export function useGetApiNotifications<TData = Awaited<ReturnType<typeof getApiNotifications>>, TError = unknown>(
 params: GetApiNotificationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotifications>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiNotificationsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary DELETE /api/notifications/{notification_id}
 */
export const notificationsDeleteNotification = (
    notificationId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/notifications/${notificationId}`, method: 'DELETE'
    },
      );
    }
  


export const getNotificationsDeleteNotificationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext> => {

const mutationKey = ['notificationsDeleteNotification'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsDeleteNotification>>, {notificationId: string}> = (props) => {
          const {notificationId} = props ?? {};

          return  notificationsDeleteNotification(notificationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsDeleteNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsDeleteNotification>>>
    
    export type NotificationsDeleteNotificationMutationError = unknown

    /**
 * @summary DELETE /api/notifications/{notification_id}
 */
export const useNotificationsDeleteNotification = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsDeleteNotification>>, TError,{notificationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsDeleteNotification>>,
        TError,
        {notificationId: string},
        TContext
      > => {

      const mutationOptions = getNotificationsDeleteNotificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Mark Notification Read
 */
export const putApiNotificationsNotificationIdRead = (
    notificationId: string,
 ) => {
      
      
      return adminApi<Notification>(
      {url: `/api/notifications/${notificationId}/read`, method: 'PUT'
    },
      );
    }
  


export const getPutApiNotificationsNotificationIdReadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>, TError,{notificationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>, TError,{notificationId: string}, TContext> => {

const mutationKey = ['putApiNotificationsNotificationIdRead'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>, {notificationId: string}> = (props) => {
          const {notificationId} = props ?? {};

          return  putApiNotificationsNotificationIdRead(notificationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiNotificationsNotificationIdReadMutationResult = NonNullable<Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>>
    
    export type PutApiNotificationsNotificationIdReadMutationError = unknown

    /**
 * @summary Mark Notification Read
 */
export const usePutApiNotificationsNotificationIdRead = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>, TError,{notificationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiNotificationsNotificationIdRead>>,
        TError,
        {notificationId: string},
        TContext
      > => {

      const mutationOptions = getPutApiNotificationsNotificationIdReadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/notifications/settings
 */
export const notificationsGetUserNotificationSettings = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/notifications/settings`, method: 'GET', signal
    },
      );
    }
  



export const getNotificationsGetUserNotificationSettingsQueryKey = () => {
    return [
    `/api/notifications/settings`
    ] as const;
    }

    
export const getNotificationsGetUserNotificationSettingsQueryOptions = <TData = Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNotificationsGetUserNotificationSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>> = ({ signal }) => notificationsGetUserNotificationSettings(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type NotificationsGetUserNotificationSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>>
export type NotificationsGetUserNotificationSettingsQueryError = unknown


export function useNotificationsGetUserNotificationSettings<TData = Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>,
          TError,
          Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsGetUserNotificationSettings<TData = Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>,
          TError,
          Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useNotificationsGetUserNotificationSettings<TData = Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/notifications/settings
 */

export function useNotificationsGetUserNotificationSettings<TData = Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof notificationsGetUserNotificationSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getNotificationsGetUserNotificationSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary PUT /api/notifications/settings
 */
export const notificationsSetUserNotificationSettings = (
    notificationsSetUserNotificationSettingsBody?: NotificationsSetUserNotificationSettingsBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/notifications/settings`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: notificationsSetUserNotificationSettingsBody
    },
      );
    }
  


export const getNotificationsSetUserNotificationSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext> => {

const mutationKey = ['notificationsSetUserNotificationSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, {data: NotificationsSetUserNotificationSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  notificationsSetUserNotificationSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NotificationsSetUserNotificationSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>>
    export type NotificationsSetUserNotificationSettingsMutationBody = NotificationsSetUserNotificationSettingsBody
    export type NotificationsSetUserNotificationSettingsMutationError = unknown

    /**
 * @summary PUT /api/notifications/settings
 */
export const useNotificationsSetUserNotificationSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>, TError,{data: NotificationsSetUserNotificationSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof notificationsSetUserNotificationSettings>>,
        TError,
        {data: NotificationsSetUserNotificationSettingsBody},
        TContext
      > => {

      const mutationOptions = getNotificationsSetUserNotificationSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Notification Stats
 */
export const getApiNotificationsStats = (
    params: GetApiNotificationsStatsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiNotificationsStats200>(
      {url: `/api/notifications/stats`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetApiNotificationsStatsQueryKey = (params?: GetApiNotificationsStatsParams,) => {
    return [
    `/api/notifications/stats`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiNotificationsStatsQueryOptions = <TData = Awaited<ReturnType<typeof getApiNotificationsStats>>, TError = unknown>(params: GetApiNotificationsStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiNotificationsStatsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiNotificationsStats>>> = ({ signal }) => getApiNotificationsStats(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiNotificationsStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiNotificationsStats>>>
export type GetApiNotificationsStatsQueryError = unknown


export function useGetApiNotificationsStats<TData = Awaited<ReturnType<typeof getApiNotificationsStats>>, TError = unknown>(
 params: GetApiNotificationsStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getApiNotificationsStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiNotificationsStats<TData = Awaited<ReturnType<typeof getApiNotificationsStats>>, TError = unknown>(
 params: GetApiNotificationsStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getApiNotificationsStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiNotificationsStats<TData = Awaited<ReturnType<typeof getApiNotificationsStats>>, TError = unknown>(
 params: GetApiNotificationsStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Notification Stats
 */

export function useGetApiNotificationsStats<TData = Awaited<ReturnType<typeof getApiNotificationsStats>>, TError = unknown>(
 params: GetApiNotificationsStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiNotificationsStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiNotificationsStatsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Process Document OCR
 */
export const processDocumentOcr = (
    processDocumentOcrBody: ProcessDocumentOcrBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ProcessDocumentOcr200>(
      {url: `/api/ocr/process`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: processDocumentOcrBody, signal
    },
      );
    }
  


export const getProcessDocumentOcrMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDocumentOcr>>, TError,{data: ProcessDocumentOcrBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof processDocumentOcr>>, TError,{data: ProcessDocumentOcrBody}, TContext> => {

const mutationKey = ['processDocumentOcr'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processDocumentOcr>>, {data: ProcessDocumentOcrBody}> = (props) => {
          const {data} = props ?? {};

          return  processDocumentOcr(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessDocumentOcrMutationResult = NonNullable<Awaited<ReturnType<typeof processDocumentOcr>>>
    export type ProcessDocumentOcrMutationBody = ProcessDocumentOcrBody
    export type ProcessDocumentOcrMutationError = unknown

    /**
 * @summary Process Document OCR
 */
export const useProcessDocumentOcr = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDocumentOcr>>, TError,{data: ProcessDocumentOcrBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processDocumentOcr>>,
        TError,
        {data: ProcessDocumentOcrBody},
        TContext
      > => {

      const mutationOptions = getProcessDocumentOcrMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns CORS headers so the static Swagger UI served from a different origin (e.g. localhost:8080)
can fetch the YAML without browser CORS errors.
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */
export const serveOpenapiYaml = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/openapi.yaml`, method: 'GET', signal
    },
      );
    }
  



export const getServeOpenapiYamlQueryKey = () => {
    return [
    `/api/openapi.yaml`
    ] as const;
    }

    
export const getServeOpenapiYamlQueryOptions = <TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeOpenapiYamlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveOpenapiYaml>>> = ({ signal }) => serveOpenapiYaml(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeOpenapiYamlQueryResult = NonNullable<Awaited<ReturnType<typeof serveOpenapiYaml>>>
export type ServeOpenapiYamlQueryError = unknown


export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveOpenapiYaml>>,
          TError,
          Awaited<ReturnType<typeof serveOpenapiYaml>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */

export function useServeOpenapiYaml<TData = Awaited<ReturnType<typeof serveOpenapiYaml>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveOpenapiYaml>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeOpenapiYamlQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/patients
 */
export const patientsListPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsListPatientsQueryKey = () => {
    return [
    `/api/patients`
    ] as const;
    }

    
export const getPatientsListPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsListPatients>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsListPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsListPatients>>> = ({ signal }) => patientsListPatients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsListPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsListPatients>>>
export type PatientsListPatientsQueryError = unknown


export function usePatientsListPatients<TData = Awaited<ReturnType<typeof patientsListPatients>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsListPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsListPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsListPatients<TData = Awaited<ReturnType<typeof patientsListPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsListPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsListPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsListPatients<TData = Awaited<ReturnType<typeof patientsListPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients
 */

export function usePatientsListPatients<TData = Awaited<ReturnType<typeof patientsListPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsListPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsListPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsCreatePatientBody, signal
    },
      );
    }
  


export const getPatientsCreatePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = unknown

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/patients/{patient_id}
 */
export const patientsGetPatient = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = unknown


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary PATCH /api/patients/{patient_id}
 */
export const patientsUpdatePatient = (
    patientId: string,
    patientsUpdatePatientBody?: PatientsUpdatePatientBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patientsUpdatePatientBody
    },
      );
    }
  


export const getPatientsUpdatePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: PatientsUpdatePatientBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = PatientsUpdatePatientBody
    export type PatientsUpdatePatientMutationError = unknown

    /**
 * @summary PATCH /api/patients/{patient_id}
 */
export const usePatientsUpdatePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: PatientsUpdatePatientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: PatientsUpdatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/patients/{patient_id}
 */
export const patientsUpdatePatientPut = (
    patientId: string,
    patientsUpdatePatientPutBody?: PatientsUpdatePatientPutBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientsUpdatePatientPutBody
    },
      );
    }
  


export const getPatientsUpdatePatientPutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatientPut>>, TError,{patientId: string;data: PatientsUpdatePatientPutBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatientPut>>, TError,{patientId: string;data: PatientsUpdatePatientPutBody}, TContext> => {

const mutationKey = ['patientsUpdatePatientPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatientPut>>, {patientId: string;data: PatientsUpdatePatientPutBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatientPut(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientPutMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatientPut>>>
    export type PatientsUpdatePatientPutMutationBody = PatientsUpdatePatientPutBody
    export type PatientsUpdatePatientPutMutationError = unknown

    /**
 * @summary PUT /api/patients/{patient_id}
 */
export const usePatientsUpdatePatientPut = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatientPut>>, TError,{patientId: string;data: PatientsUpdatePatientPutBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatientPut>>,
        TError,
        {patientId: string;data: PatientsUpdatePatientPutBody},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientsDeletePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const timelineLogPatientActivity = (
    patientId: string,
    timelineLogPatientActivityBody?: TimelineLogPatientActivityBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/activities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timelineLogPatientActivityBody, signal
    },
      );
    }
  


export const getTimelineLogPatientActivityMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext> => {

const mutationKey = ['timelineLogPatientActivity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineLogPatientActivity>>, {patientId: string;data: TimelineLogPatientActivityBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineLogPatientActivity(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineLogPatientActivityMutationResult = NonNullable<Awaited<ReturnType<typeof timelineLogPatientActivity>>>
    export type TimelineLogPatientActivityMutationBody = TimelineLogPatientActivityBody
    export type TimelineLogPatientActivityMutationError = unknown

    /**
 * @summary Log an activity for a patient (alias for timeline event)
 */
export const useTimelineLogPatientActivity = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineLogPatientActivity>>, TError,{patientId: string;data: TimelineLogPatientActivityBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineLogPatientActivity>>,
        TError,
        {patientId: string;data: TimelineLogPatientActivityBody},
        TContext
      > => {

      const mutationOptions = getTimelineLogPatientActivityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/assign-devices-extended`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesAssignDevicesExtendedBody, signal
    },
      );
    }
  


export const getSalesAssignDevicesExtendedMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all devices assigned to a specific patient
 */
export const patientsGetPatientDevices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientsGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatientDevices>>> = ({ signal }) => patientsGetPatientDevices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatientDevices>>>
export type PatientsGetPatientDevicesQueryError = unknown


export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientsGetPatientDevices<TData = Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all documents for a patient
 */
export const documentsGetPatientDocuments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/documents`, method: 'GET', signal
    },
      );
    }
  



export const getDocumentsGetPatientDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/documents`
    ] as const;
    }

    
export const getDocumentsGetPatientDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentsGetPatientDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentsGetPatientDocuments>>> = ({ signal }) => documentsGetPatientDocuments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DocumentsGetPatientDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof documentsGetPatientDocuments>>>
export type DocumentsGetPatientDocumentsQueryError = unknown


export function useDocumentsGetPatientDocuments<TData = Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsGetPatientDocuments>>,
          TError,
          Awaited<ReturnType<typeof documentsGetPatientDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDocumentsGetPatientDocuments<TData = Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsGetPatientDocuments>>,
          TError,
          Awaited<ReturnType<typeof documentsGetPatientDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDocumentsGetPatientDocuments<TData = Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all documents for a patient
 */

export function useDocumentsGetPatientDocuments<TData = Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDocumentsGetPatientDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Add a new document to patient
 */
export const documentsAddPatientDocument = (
    patientId: string,
    documentsAddPatientDocumentBody?: DocumentsAddPatientDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentsAddPatientDocumentBody, signal
    },
      );
    }
  


export const getDocumentsAddPatientDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsAddPatientDocument>>, TError,{patientId: string;data: DocumentsAddPatientDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentsAddPatientDocument>>, TError,{patientId: string;data: DocumentsAddPatientDocumentBody}, TContext> => {

const mutationKey = ['documentsAddPatientDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsAddPatientDocument>>, {patientId: string;data: DocumentsAddPatientDocumentBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  documentsAddPatientDocument(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsAddPatientDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof documentsAddPatientDocument>>>
    export type DocumentsAddPatientDocumentMutationBody = DocumentsAddPatientDocumentBody
    export type DocumentsAddPatientDocumentMutationError = unknown

    /**
 * @summary Add a new document to patient
 */
export const useDocumentsAddPatientDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsAddPatientDocument>>, TError,{patientId: string;data: DocumentsAddPatientDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof documentsAddPatientDocument>>,
        TError,
        {patientId: string;data: DocumentsAddPatientDocumentBody},
        TContext
      > => {

      const mutationOptions = getDocumentsAddPatientDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific document
 */
export const documentsGetPatientDocument = (
    patientId: string,
    documentId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/documents/${documentId}`, method: 'GET', signal
    },
      );
    }
  



export const getDocumentsGetPatientDocumentQueryKey = (patientId?: string,
    documentId?: string,) => {
    return [
    `/api/patients/${patientId}/documents/${documentId}`
    ] as const;
    }

    
export const getDocumentsGetPatientDocumentQueryOptions = <TData = Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError = unknown>(patientId: string,
    documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentsGetPatientDocumentQueryKey(patientId,documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentsGetPatientDocument>>> = ({ signal }) => documentsGetPatientDocument(patientId,documentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId && documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type DocumentsGetPatientDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof documentsGetPatientDocument>>>
export type DocumentsGetPatientDocumentQueryError = unknown


export function useDocumentsGetPatientDocument<TData = Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError = unknown>(
 patientId: string,
    documentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsGetPatientDocument>>,
          TError,
          Awaited<ReturnType<typeof documentsGetPatientDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDocumentsGetPatientDocument<TData = Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError = unknown>(
 patientId: string,
    documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsGetPatientDocument>>,
          TError,
          Awaited<ReturnType<typeof documentsGetPatientDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useDocumentsGetPatientDocument<TData = Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError = unknown>(
 patientId: string,
    documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific document
 */

export function useDocumentsGetPatientDocument<TData = Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError = unknown>(
 patientId: string,
    documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsGetPatientDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getDocumentsGetPatientDocumentQueryOptions(patientId,documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Delete a document
 */
export const documentsDeletePatientDocument = (
    patientId: string,
    documentId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/documents/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDocumentsDeletePatientDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsDeletePatientDocument>>, TError,{patientId: string;documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentsDeletePatientDocument>>, TError,{patientId: string;documentId: string}, TContext> => {

const mutationKey = ['documentsDeletePatientDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsDeletePatientDocument>>, {patientId: string;documentId: string}> = (props) => {
          const {patientId,documentId} = props ?? {};

          return  documentsDeletePatientDocument(patientId,documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsDeletePatientDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof documentsDeletePatientDocument>>>
    
    export type DocumentsDeletePatientDocumentMutationError = unknown

    /**
 * @summary Delete a document
 */
export const useDocumentsDeletePatientDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsDeletePatientDocument>>, TError,{patientId: string;documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof documentsDeletePatientDocument>>,
        TError,
        {patientId: string;documentId: string},
        TContext
      > => {

      const mutationOptions = getDocumentsDeletePatientDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesGetPatientEreceipts = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'GET', signal
    },
      );
    }
  



export const getPatientSubresourcesGetPatientEreceiptsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/ereceipts`
    ] as const;
    }

    
export const getPatientSubresourcesGetPatientEreceiptsQueryOptions = <TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientSubresourcesGetPatientEreceiptsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>> = ({ signal }) => patientSubresourcesGetPatientEreceipts(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientSubresourcesGetPatientEreceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>>
export type PatientSubresourcesGetPatientEreceiptsQueryError = unknown


export function usePatientSubresourcesGetPatientEreceipts<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientEreceipts<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientEreceipts<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/ereceipts
 */

export function usePatientSubresourcesGetPatientEreceipts<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientEreceipts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientSubresourcesGetPatientEreceiptsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesCreatePatientEreceiptBody, signal
    },
      );
    }
  


export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesUpdatePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
    patientSubresourcesUpdatePatientEreceiptBody?: PatientSubresourcesUpdatePatientEreceiptBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesUpdatePatientEreceiptBody
    },
      );
    }
  


export const getPatientSubresourcesUpdatePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: PatientSubresourcesUpdatePatientEreceiptBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: PatientSubresourcesUpdatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesUpdatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>, {patientId: string;ereceiptId: string;data: PatientSubresourcesUpdatePatientEreceiptBody}> = (props) => {
          const {patientId,ereceiptId,data} = props ?? {};

          return  patientSubresourcesUpdatePatientEreceipt(patientId,ereceiptId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesUpdatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>>
    export type PatientSubresourcesUpdatePatientEreceiptMutationBody = PatientSubresourcesUpdatePatientEreceiptBody
    export type PatientSubresourcesUpdatePatientEreceiptMutationError = unknown

    /**
 * @summary PUT /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesUpdatePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>, TError,{patientId: string;ereceiptId: string;data: PatientSubresourcesUpdatePatientEreceiptBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesUpdatePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string;data: PatientSubresourcesUpdatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesUpdatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesGetPatientHearingTests = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'GET', signal
    },
      );
    }
  



export const getPatientSubresourcesGetPatientHearingTestsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/hearing-tests`
    ] as const;
    }

    
export const getPatientSubresourcesGetPatientHearingTestsQueryOptions = <TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientSubresourcesGetPatientHearingTestsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>> = ({ signal }) => patientSubresourcesGetPatientHearingTests(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientSubresourcesGetPatientHearingTestsQueryResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>>
export type PatientSubresourcesGetPatientHearingTestsQueryError = unknown


export function usePatientSubresourcesGetPatientHearingTests<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientHearingTests<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientHearingTests<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/hearing-tests
 */

export function usePatientSubresourcesGetPatientHearingTests<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientHearingTests>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientSubresourcesGetPatientHearingTestsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesAddPatientHearingTestBody, signal
    },
      );
    }
  


export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesUpdatePatientHearingTest = (
    patientId: string,
    testId: string,
    patientSubresourcesUpdatePatientHearingTestBody?: PatientSubresourcesUpdatePatientHearingTestBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesUpdatePatientHearingTestBody
    },
      );
    }
  


export const getPatientSubresourcesUpdatePatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>, TError,{patientId: string;testId: string;data: PatientSubresourcesUpdatePatientHearingTestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>, TError,{patientId: string;testId: string;data: PatientSubresourcesUpdatePatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesUpdatePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>, {patientId: string;testId: string;data: PatientSubresourcesUpdatePatientHearingTestBody}> = (props) => {
          const {patientId,testId,data} = props ?? {};

          return  patientSubresourcesUpdatePatientHearingTest(patientId,testId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesUpdatePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>>
    export type PatientSubresourcesUpdatePatientHearingTestMutationBody = PatientSubresourcesUpdatePatientHearingTestBody
    export type PatientSubresourcesUpdatePatientHearingTestMutationError = unknown

    /**
 * @summary PUT /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesUpdatePatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>, TError,{patientId: string;testId: string;data: PatientSubresourcesUpdatePatientHearingTestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesUpdatePatientHearingTest>>,
        TError,
        {patientId: string;testId: string;data: PatientSubresourcesUpdatePatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesUpdatePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all invoices for a patient
 */
export const invoicesGetPatientInvoices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/invoices`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetPatientInvoicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/invoices`
    ] as const;
    }

    
export const getInvoicesGetPatientInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetPatientInvoicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>> = ({ signal }) => invoicesGetPatientInvoices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetPatientInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>>
export type InvoicesGetPatientInvoicesQueryError = unknown


export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all invoices for a patient
 */

export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetPatientInvoicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/patients/{patient_id}/notes
 */
export const patientSubresourcesGetPatientNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes`, method: 'GET', signal
    },
      );
    }
  



export const getPatientSubresourcesGetPatientNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/notes`
    ] as const;
    }

    
export const getPatientSubresourcesGetPatientNotesQueryOptions = <TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientSubresourcesGetPatientNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>> = ({ signal }) => patientSubresourcesGetPatientNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientSubresourcesGetPatientNotesQueryResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>>
export type PatientSubresourcesGetPatientNotesQueryError = unknown


export function usePatientSubresourcesGetPatientNotes<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientNotes<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientSubresourcesGetPatientNotes<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/notes
 */

export function usePatientSubresourcesGetPatientNotes<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientSubresourcesGetPatientNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const patientSubresourcesCreatePatientNote = (
    patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesCreatePatientNoteBody, signal
    },
      );
    }
  


export const getPatientSubresourcesCreatePatientNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, {patientId: string;data: PatientSubresourcesCreatePatientNoteBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientNote(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>>
    export type PatientSubresourcesCreatePatientNoteMutationBody = PatientSubresourcesCreatePatientNoteBody
    export type PatientSubresourcesCreatePatientNoteMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/notes
 */
export const usePatientSubresourcesCreatePatientNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientNoteBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientNote>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesUpdatePatientNote = (
    patientId: string,
    noteId: string,
    patientSubresourcesUpdatePatientNoteBody?: PatientSubresourcesUpdatePatientNoteBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesUpdatePatientNoteBody
    },
      );
    }
  


export const getPatientSubresourcesUpdatePatientNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientSubresourcesUpdatePatientNoteBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientSubresourcesUpdatePatientNoteBody}, TContext> => {

const mutationKey = ['patientSubresourcesUpdatePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>, {patientId: string;noteId: string;data: PatientSubresourcesUpdatePatientNoteBody}> = (props) => {
          const {patientId,noteId,data} = props ?? {};

          return  patientSubresourcesUpdatePatientNote(patientId,noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesUpdatePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>>
    export type PatientSubresourcesUpdatePatientNoteMutationBody = PatientSubresourcesUpdatePatientNoteBody
    export type PatientSubresourcesUpdatePatientNoteMutationError = unknown

    /**
 * @summary PUT /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesUpdatePatientNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>, TError,{patientId: string;noteId: string;data: PatientSubresourcesUpdatePatientNoteBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesUpdatePatientNote>>,
        TError,
        {patientId: string;noteId: string;data: PatientSubresourcesUpdatePatientNoteBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesUpdatePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const patientSubresourcesDeletePatientNote = (
    patientId: string,
    noteId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/notes/${noteId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, {patientId: string;noteId: string}> = (props) => {
          const {patientId,noteId} = props ?? {};

          return  patientSubresourcesDeletePatientNote(patientId,noteId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientNoteMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>>
    
    export type PatientSubresourcesDeletePatientNoteMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export const usePatientSubresourcesDeletePatientNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>, TError,{patientId: string;noteId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientNote>>,
        TError,
        {patientId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all payment records for a patient
 */
export const paymentsGetPatientPaymentRecords = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/payment-records`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetPatientPaymentRecordsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/payment-records`
    ] as const;
    }

    
export const getPaymentsGetPatientPaymentRecordsQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPaymentRecordsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>> = ({ signal }) => paymentsGetPatientPaymentRecords(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPaymentRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>>
export type PaymentsGetPatientPaymentRecordsQueryError = unknown


export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all payment records for a patient
 */

export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPaymentRecordsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new product sale from inventory
 */
export const salesCreateProductSale = (
    patientId: string,
    salesCreateProductSaleBody?: SalesCreateProductSaleBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/product-sales`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesCreateProductSaleBody, signal
    },
      );
    }
  


export const getSalesCreateProductSaleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext> => {

const mutationKey = ['salesCreateProductSale'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateProductSale>>, {patientId: string;data: SalesCreateProductSaleBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesCreateProductSale(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateProductSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateProductSale>>>
    export type SalesCreateProductSaleMutationBody = SalesCreateProductSaleBody
    export type SalesCreateProductSaleMutationError = unknown

    /**
 * @summary Create a new product sale from inventory
 */
export const useSalesCreateProductSale = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateProductSale>>,
        TError,
        {patientId: string;data: SalesCreateProductSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateProductSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all proformas for a patient
 */
export const proformasGetPatientProformas = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/proformas`, method: 'GET', signal
    },
      );
    }
  



export const getProformasGetPatientProformasQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/proformas`
    ] as const;
    }

    
export const getProformasGetPatientProformasQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetPatientProformasQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetPatientProformas>>> = ({ signal }) => proformasGetPatientProformas(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ProformasGetPatientProformasQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetPatientProformas>>>
export type ProformasGetPatientProformasQueryError = unknown


export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all proformas for a patient
 */

export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getProformasGetPatientProformasQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/promissory-notes`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = unknown


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all device replacements for a patient
 */
export const replacementsGetPatientReplacements = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/replacements`, method: 'GET', signal
    },
      );
    }
  



export const getReplacementsGetPatientReplacementsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/replacements`
    ] as const;
    }

    
export const getReplacementsGetPatientReplacementsQueryOptions = <TData = Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReplacementsGetPatientReplacementsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>> = ({ signal }) => replacementsGetPatientReplacements(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReplacementsGetPatientReplacementsQueryResult = NonNullable<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>>
export type ReplacementsGetPatientReplacementsQueryError = unknown


export function useReplacementsGetPatientReplacements<TData = Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof replacementsGetPatientReplacements>>,
          TError,
          Awaited<ReturnType<typeof replacementsGetPatientReplacements>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReplacementsGetPatientReplacements<TData = Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof replacementsGetPatientReplacements>>,
          TError,
          Awaited<ReturnType<typeof replacementsGetPatientReplacements>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReplacementsGetPatientReplacements<TData = Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all device replacements for a patient
 */

export function useReplacementsGetPatientReplacements<TData = Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof replacementsGetPatientReplacements>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReplacementsGetPatientReplacementsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new device replacement
 */
export const replacementsCreateReplacement = (
    patientId: string,
    replacementsCreateReplacementBody?: ReplacementsCreateReplacementBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/replacements`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: replacementsCreateReplacementBody, signal
    },
      );
    }
  


export const getReplacementsCreateReplacementMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReplacement>>, TError,{patientId: string;data: ReplacementsCreateReplacementBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReplacement>>, TError,{patientId: string;data: ReplacementsCreateReplacementBody}, TContext> => {

const mutationKey = ['replacementsCreateReplacement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreateReplacement>>, {patientId: string;data: ReplacementsCreateReplacementBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  replacementsCreateReplacement(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreateReplacementMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreateReplacement>>>
    export type ReplacementsCreateReplacementMutationBody = ReplacementsCreateReplacementBody
    export type ReplacementsCreateReplacementMutationError = unknown

    /**
 * @summary Create a new device replacement
 */
export const useReplacementsCreateReplacement = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReplacement>>, TError,{patientId: string;data: ReplacementsCreateReplacementBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreateReplacement>>,
        TError,
        {patientId: string;data: ReplacementsCreateReplacementBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreateReplacementMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/sales`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = unknown


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Expected payload: { "status": "cancelled", "total_amount": 1000.0, "paid_amount": 500.0, "notes": "Updated notes" }
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const salesUpdateSalePartial = (
    patientId: string,
    saleId: string,
    salesUpdateSalePartialBody?: SalesUpdateSalePartialBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/sales/${saleId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: salesUpdateSalePartialBody
    },
      );
    }
  


export const getSalesUpdateSalePartialMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string;data: SalesUpdateSalePartialBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string;data: SalesUpdateSalePartialBody}, TContext> => {

const mutationKey = ['salesUpdateSalePartial'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSalePartial>>, {patientId: string;saleId: string;data: SalesUpdateSalePartialBody}> = (props) => {
          const {patientId,saleId,data} = props ?? {};

          return  salesUpdateSalePartial(patientId,saleId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSalePartialMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSalePartial>>>
    export type SalesUpdateSalePartialMutationBody = SalesUpdateSalePartialBody
    export type SalesUpdateSalePartialMutationError = unknown

    /**
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const useSalesUpdateSalePartial = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string;data: SalesUpdateSalePartialBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSalePartial>>,
        TError,
        {patientId: string;saleId: string;data: SalesUpdateSalePartialBody},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSalePartialMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/sgk-documents`, method: 'GET', signal
    },
      );
    }
  



export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = unknown


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get timeline events for a patient
 */
export const timelineGetPatientTimeline = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/timeline`, method: 'GET', signal
    },
      );
    }
  



export const getTimelineGetPatientTimelineQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/timeline`
    ] as const;
    }

    
export const getTimelineGetPatientTimelineQueryOptions = <TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimelineGetPatientTimelineQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timelineGetPatientTimeline>>> = ({ signal }) => timelineGetPatientTimeline(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type TimelineGetPatientTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof timelineGetPatientTimeline>>>
export type TimelineGetPatientTimelineQueryError = unknown


export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>,
          TError,
          Awaited<ReturnType<typeof timelineGetPatientTimeline>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get timeline events for a patient
 */

export function useTimelineGetPatientTimeline<TData = Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timelineGetPatientTimeline>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getTimelineGetPatientTimelineQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Add a new timeline event for a patient
 */
export const timelineAddTimelineEvent = (
    patientId: string,
    timelineAddTimelineEventBody?: TimelineAddTimelineEventBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/timeline`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: timelineAddTimelineEventBody, signal
    },
      );
    }
  


export const getTimelineAddTimelineEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext> => {

const mutationKey = ['timelineAddTimelineEvent'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, {patientId: string;data: TimelineAddTimelineEventBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  timelineAddTimelineEvent(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineAddTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineAddTimelineEvent>>>
    export type TimelineAddTimelineEventMutationBody = TimelineAddTimelineEventBody
    export type TimelineAddTimelineEventMutationError = unknown

    /**
 * @summary Add a new timeline event for a patient
 */
export const useTimelineAddTimelineEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineAddTimelineEvent>>, TError,{patientId: string;data: TimelineAddTimelineEventBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineAddTimelineEvent>>,
        TError,
        {patientId: string;data: TimelineAddTimelineEventBody},
        TContext
      > => {

      const mutationOptions = getTimelineAddTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a timeline event
 */
export const timelineDeleteTimelineEvent = (
    patientId: string,
    eventId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/${patientId}/timeline/${eventId}`, method: 'DELETE'
    },
      );
    }
  


export const getTimelineDeleteTimelineEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext> => {

const mutationKey = ['timelineDeleteTimelineEvent'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, {patientId: string;eventId: string}> = (props) => {
          const {patientId,eventId} = props ?? {};

          return  timelineDeleteTimelineEvent(patientId,eventId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TimelineDeleteTimelineEventMutationResult = NonNullable<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>>
    
    export type TimelineDeleteTimelineEventMutationError = unknown

    /**
 * @summary Delete a timeline event
 */
export const useTimelineDeleteTimelineEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>, TError,{patientId: string;eventId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof timelineDeleteTimelineEvent>>,
        TError,
        {patientId: string;eventId: string},
        TContext
      > => {

      const mutationOptions = getTimelineDeleteTimelineEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/bulk_upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsBulkUploadPatientsBody, signal
    },
      );
    }
  


export const getPatientsBulkUploadPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = unknown

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/export`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = unknown


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/patients/search`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = unknown


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new payment record
 */
export const paymentsCreatePaymentRecord = (
    paymentsCreatePaymentRecordBody?: PaymentsCreatePaymentRecordBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/payment-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentsCreatePaymentRecordBody, signal
    },
      );
    }
  


export const getPaymentsCreatePaymentRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext> => {

const mutationKey = ['paymentsCreatePaymentRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, {data: PaymentsCreatePaymentRecordBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePaymentRecord(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePaymentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>>
    export type PaymentsCreatePaymentRecordMutationBody = PaymentsCreatePaymentRecordBody
    export type PaymentsCreatePaymentRecordMutationError = unknown

    /**
 * @summary Create a new payment record
 */
export const usePaymentsCreatePaymentRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>, TError,{data: PaymentsCreatePaymentRecordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePaymentRecord>>,
        TError,
        {data: PaymentsCreatePaymentRecordBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePaymentRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a payment record
 */
export const paymentsUpdatePaymentRecord = (
    recordId: string,
    paymentsUpdatePaymentRecordBody?: PaymentsUpdatePaymentRecordBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/payment-records/${recordId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: paymentsUpdatePaymentRecordBody
    },
      );
    }
  


export const getPaymentsUpdatePaymentRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string;data: PaymentsUpdatePaymentRecordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string;data: PaymentsUpdatePaymentRecordBody}, TContext> => {

const mutationKey = ['paymentsUpdatePaymentRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, {recordId: string;data: PaymentsUpdatePaymentRecordBody}> = (props) => {
          const {recordId,data} = props ?? {};

          return  paymentsUpdatePaymentRecord(recordId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePaymentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>>
    export type PaymentsUpdatePaymentRecordMutationBody = PaymentsUpdatePaymentRecordBody
    export type PaymentsUpdatePaymentRecordMutationError = unknown

    /**
 * @summary Update a payment record
 */
export const usePaymentsUpdatePaymentRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>, TError,{recordId: string;data: PaymentsUpdatePaymentRecordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePaymentRecord>>,
        TError,
        {recordId: string;data: PaymentsUpdatePaymentRecordBody},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePaymentRecordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List all permissions grouped by category
 */
export const permissionsListPermissions = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<PermissionsListPermissions200>(
      {url: `/api/permissions`, method: 'GET', signal
    },
      );
    }
  



export const getPermissionsListPermissionsQueryKey = () => {
    return [
    `/api/permissions`
    ] as const;
    }

    
export const getPermissionsListPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsListPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsListPermissions>>> = ({ signal }) => permissionsListPermissions(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsListPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsListPermissions>>>
export type PermissionsListPermissionsQueryError = unknown


export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsListPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsListPermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsListPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsListPermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all permissions grouped by category
 */

export function usePermissionsListPermissions<TData = Awaited<ReturnType<typeof permissionsListPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsListPermissions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsListPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/permissions
 */
export const permissionsCreatePermission = (
    permissionsCreatePermissionBody?: PermissionsCreatePermissionBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/permissions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: permissionsCreatePermissionBody, signal
    },
      );
    }
  


export const getPermissionsCreatePermissionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext> => {

const mutationKey = ['permissionsCreatePermission'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof permissionsCreatePermission>>, {data: PermissionsCreatePermissionBody}> = (props) => {
          const {data} = props ?? {};

          return  permissionsCreatePermission(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PermissionsCreatePermissionMutationResult = NonNullable<Awaited<ReturnType<typeof permissionsCreatePermission>>>
    export type PermissionsCreatePermissionMutationBody = PermissionsCreatePermissionBody
    export type PermissionsCreatePermissionMutationError = unknown

    /**
 * @summary POST /api/permissions
 */
export const usePermissionsCreatePermission = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsCreatePermission>>, TError,{data: PermissionsCreatePermissionBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof permissionsCreatePermission>>,
        TError,
        {data: PermissionsCreatePermissionBody},
        TContext
      > => {

      const mutationOptions = getPermissionsCreatePermissionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current user permissions based on their role
 */
export const permissionsGetMyPermissions = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<PermissionsGetMyPermissions200>(
      {url: `/api/permissions/my`, method: 'GET', signal
    },
      );
    }
  



export const getPermissionsGetMyPermissionsQueryKey = () => {
    return [
    `/api/permissions/my`
    ] as const;
    }

    
export const getPermissionsGetMyPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsGetMyPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsGetMyPermissions>>> = ({ signal }) => permissionsGetMyPermissions(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsGetMyPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsGetMyPermissions>>>
export type PermissionsGetMyPermissionsQueryError = unknown


export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetMyPermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current user permissions based on their role
 */

export function usePermissionsGetMyPermissions<TData = Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetMyPermissions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsGetMyPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get permissions for a specific role
 */
export const permissionsGetRolePermissions = (
    roleName: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<PermissionsGetRolePermissions200>(
      {url: `/api/permissions/role/${roleName}`, method: 'GET', signal
    },
      );
    }
  



export const getPermissionsGetRolePermissionsQueryKey = (roleName?: string,) => {
    return [
    `/api/permissions/role/${roleName}`
    ] as const;
    }

    
export const getPermissionsGetRolePermissionsQueryOptions = <TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = unknown>(roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPermissionsGetRolePermissionsQueryKey(roleName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof permissionsGetRolePermissions>>> = ({ signal }) => permissionsGetRolePermissions(roleName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PermissionsGetRolePermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof permissionsGetRolePermissions>>>
export type PermissionsGetRolePermissionsQueryError = unknown


export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = unknown>(
 roleName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = unknown>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsGetRolePermissions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = unknown>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get permissions for a specific role
 */

export function usePermissionsGetRolePermissions<TData = Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError = unknown>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof permissionsGetRolePermissions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPermissionsGetRolePermissionsQueryOptions(roleName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update permissions for a role
 */
export const permissionsUpdateRolePermissions = (
    roleName: string,
    permissionsUpdateRolePermissionsBody: PermissionsUpdateRolePermissionsBody,
 ) => {
      
      
      return adminApi<PermissionsUpdateRolePermissions200>(
      {url: `/api/permissions/role/${roleName}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: permissionsUpdateRolePermissionsBody
    },
      );
    }
  


export const getPermissionsUpdateRolePermissionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext> => {

const mutationKey = ['permissionsUpdateRolePermissions'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, {roleName: string;data: PermissionsUpdateRolePermissionsBody}> = (props) => {
          const {roleName,data} = props ?? {};

          return  permissionsUpdateRolePermissions(roleName,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PermissionsUpdateRolePermissionsMutationResult = NonNullable<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>>
    export type PermissionsUpdateRolePermissionsMutationBody = PermissionsUpdateRolePermissionsBody
    export type PermissionsUpdateRolePermissionsMutationError = unknown

    /**
 * @summary Update permissions for a role
 */
export const usePermissionsUpdateRolePermissions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>, TError,{roleName: string;data: PermissionsUpdateRolePermissionsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof permissionsUpdateRolePermissions>>,
        TError,
        {roleName: string;data: PermissionsUpdateRolePermissionsBody},
        TContext
      > => {

      const mutationOptions = getPermissionsUpdateRolePermissionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/pricing-preview
 */
export const salesPricingPreview = (
    salesPricingPreviewBody?: SalesPricingPreviewBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/pricing-preview`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesPricingPreviewBody, signal
    },
      );
    }
  


export const getSalesPricingPreviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext> => {

const mutationKey = ['salesPricingPreview'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesPricingPreview>>, {data: SalesPricingPreviewBody}> = (props) => {
          const {data} = props ?? {};

          return  salesPricingPreview(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesPricingPreviewMutationResult = NonNullable<Awaited<ReturnType<typeof salesPricingPreview>>>
    export type SalesPricingPreviewMutationBody = SalesPricingPreviewBody
    export type SalesPricingPreviewMutationError = unknown

    /**
 * @summary POST /api/pricing-preview
 */
export const useSalesPricingPreview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPricingPreview>>, TError,{data: SalesPricingPreviewBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesPricingPreview>>,
        TError,
        {data: SalesPricingPreviewBody},
        TContext
      > => {

      const mutationOptions = getSalesPricingPreviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a product-supplier relationship
 */
export const suppliersUpdateProductSupplier = (
    psId: string,
    suppliersUpdateProductSupplierBody?: SuppliersUpdateProductSupplierBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/product-suppliers/${psId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: suppliersUpdateProductSupplierBody
    },
      );
    }
  


export const getSuppliersUpdateProductSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>, TError,{psId: string;data: SuppliersUpdateProductSupplierBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>, TError,{psId: string;data: SuppliersUpdateProductSupplierBody}, TContext> => {

const mutationKey = ['suppliersUpdateProductSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>, {psId: string;data: SuppliersUpdateProductSupplierBody}> = (props) => {
          const {psId,data} = props ?? {};

          return  suppliersUpdateProductSupplier(psId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersUpdateProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>>
    export type SuppliersUpdateProductSupplierMutationBody = SuppliersUpdateProductSupplierBody
    export type SuppliersUpdateProductSupplierMutationError = unknown

    /**
 * @summary Update a product-supplier relationship
 */
export const useSuppliersUpdateProductSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>, TError,{psId: string;data: SuppliersUpdateProductSupplierBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersUpdateProductSupplier>>,
        TError,
        {psId: string;data: SuppliersUpdateProductSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersUpdateProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a product-supplier relationship
 */
export const suppliersDeleteProductSupplier = (
    psId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/product-suppliers/${psId}`, method: 'DELETE'
    },
      );
    }
  


export const getSuppliersDeleteProductSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext> => {

const mutationKey = ['suppliersDeleteProductSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, {psId: string}> = (props) => {
          const {psId} = props ?? {};

          return  suppliersDeleteProductSupplier(psId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>>
    
    export type SuppliersDeleteProductSupplierMutationError = unknown

    /**
 * @summary Delete a product-supplier relationship
 */
export const useSuppliersDeleteProductSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>, TError,{psId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteProductSupplier>>,
        TError,
        {psId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all suppliers for a specific product
 */
export const suppliersGetProductSuppliers = (
    productId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/products/${productId}/suppliers`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersGetProductSuppliersQueryKey = (productId?: string,) => {
    return [
    `/api/products/${productId}/suppliers`
    ] as const;
    }

    
export const getSuppliersGetProductSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError = unknown>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetProductSuppliersQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>> = ({ signal }) => suppliersGetProductSuppliers(productId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetProductSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>>
export type SuppliersGetProductSuppliersQueryError = unknown


export function useSuppliersGetProductSuppliers<TData = Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError = unknown>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetProductSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetProductSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetProductSuppliers<TData = Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError = unknown>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetProductSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetProductSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetProductSuppliers<TData = Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError = unknown>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all suppliers for a specific product
 */

export function useSuppliersGetProductSuppliers<TData = Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError = unknown>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetProductSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetProductSuppliersQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Add a supplier to a product
 */
export const suppliersAddProductSupplier = (
    productId: string,
    suppliersAddProductSupplierBody?: SuppliersAddProductSupplierBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/products/${productId}/suppliers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: suppliersAddProductSupplierBody, signal
    },
      );
    }
  


export const getSuppliersAddProductSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext> => {

const mutationKey = ['suppliersAddProductSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, {productId: string;data: SuppliersAddProductSupplierBody}> = (props) => {
          const {productId,data} = props ?? {};

          return  suppliersAddProductSupplier(productId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersAddProductSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersAddProductSupplier>>>
    export type SuppliersAddProductSupplierMutationBody = SuppliersAddProductSupplierBody
    export type SuppliersAddProductSupplierMutationError = unknown

    /**
 * @summary Add a supplier to a product
 */
export const useSuppliersAddProductSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersAddProductSupplier>>, TError,{productId: string;data: SuppliersAddProductSupplierBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersAddProductSupplier>>,
        TError,
        {productId: string;data: SuppliersAddProductSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersAddProductSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create a new proforma
 */
export const proformasCreateProforma = (
    proformasCreateProformaBody?: ProformasCreateProformaBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/proformas`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proformasCreateProformaBody, signal
    },
      );
    }
  


export const getProformasCreateProformaMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext> => {

const mutationKey = ['proformasCreateProforma'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proformasCreateProforma>>, {data: ProformasCreateProformaBody}> = (props) => {
          const {data} = props ?? {};

          return  proformasCreateProforma(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProformasCreateProformaMutationResult = NonNullable<Awaited<ReturnType<typeof proformasCreateProforma>>>
    export type ProformasCreateProformaMutationBody = ProformasCreateProformaBody
    export type ProformasCreateProformaMutationError = unknown

    /**
 * @summary Create a new proforma
 */
export const useProformasCreateProforma = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasCreateProforma>>, TError,{data: ProformasCreateProformaBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof proformasCreateProforma>>,
        TError,
        {data: ProformasCreateProformaBody},
        TContext
      > => {

      const mutationOptions = getProformasCreateProformaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a specific proforma
 */
export const proformasGetProforma = (
    proformaId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/proformas/${proformaId}`, method: 'GET', signal
    },
      );
    }
  



export const getProformasGetProformaQueryKey = (proformaId?: string,) => {
    return [
    `/api/proformas/${proformaId}`
    ] as const;
    }

    
export const getProformasGetProformaQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = unknown>(proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetProformaQueryKey(proformaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetProforma>>> = ({ signal }) => proformasGetProforma(proformaId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(proformaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ProformasGetProformaQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetProforma>>>
export type ProformasGetProformaQueryError = unknown


export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = unknown>(
 proformaId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetProforma>>,
          TError,
          Awaited<ReturnType<typeof proformasGetProforma>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = unknown>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetProforma>>,
          TError,
          Awaited<ReturnType<typeof proformasGetProforma>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = unknown>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a specific proforma
 */

export function useProformasGetProforma<TData = Awaited<ReturnType<typeof proformasGetProforma>>, TError = unknown>(
 proformaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetProforma>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getProformasGetProformaQueryOptions(proformaId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const proformasConvertProformaToSale = (
    proformaId: string,
    proformasConvertProformaToSaleBody?: ProformasConvertProformaToSaleBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/proformas/${proformaId}/convert`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: proformasConvertProformaToSaleBody, signal
    },
      );
    }
  


export const getProformasConvertProformaToSaleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext> => {

const mutationKey = ['proformasConvertProformaToSale'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, {proformaId: string;data: ProformasConvertProformaToSaleBody}> = (props) => {
          const {proformaId,data} = props ?? {};

          return  proformasConvertProformaToSale(proformaId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProformasConvertProformaToSaleMutationResult = NonNullable<Awaited<ReturnType<typeof proformasConvertProformaToSale>>>
    export type ProformasConvertProformaToSaleMutationBody = ProformasConvertProformaToSaleBody
    export type ProformasConvertProformaToSaleMutationError = unknown

    /**
 * @summary Convert a proforma into a sale: create Sale and DeviceAssignment records and mark proforma converted.
 */
export const useProformasConvertProformaToSale = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof proformasConvertProformaToSale>>, TError,{proformaId: string;data: ProformasConvertProformaToSaleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof proformasConvertProformaToSale>>,
        TError,
        {proformaId: string;data: ProformasConvertProformaToSaleBody},
        TContext
      > => {

      const mutationOptions = getProformasConvertProformaToSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create multiple promissory notes
 */
export const paymentsCreatePromissoryNotes = (
    paymentsCreatePromissoryNotesBody?: PaymentsCreatePromissoryNotesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/promissory-notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentsCreatePromissoryNotesBody, signal
    },
      );
    }
  


export const getPaymentsCreatePromissoryNotesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext> => {

const mutationKey = ['paymentsCreatePromissoryNotes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, {data: PaymentsCreatePromissoryNotesBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentsCreatePromissoryNotes(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCreatePromissoryNotesMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>>
    export type PaymentsCreatePromissoryNotesMutationBody = PaymentsCreatePromissoryNotesBody
    export type PaymentsCreatePromissoryNotesMutationError = unknown

    /**
 * @summary Create multiple promissory notes
 */
export const usePaymentsCreatePromissoryNotes = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>, TError,{data: PaymentsCreatePromissoryNotesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCreatePromissoryNotes>>,
        TError,
        {data: PaymentsCreatePromissoryNotesBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCreatePromissoryNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update a promissory note
 */
export const paymentsUpdatePromissoryNote = (
    noteId: string,
    paymentsUpdatePromissoryNoteBody?: PaymentsUpdatePromissoryNoteBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/promissory-notes/${noteId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: paymentsUpdatePromissoryNoteBody
    },
      );
    }
  


export const getPaymentsUpdatePromissoryNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsUpdatePromissoryNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, {noteId: string;data: PaymentsUpdatePromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsUpdatePromissoryNote(noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsUpdatePromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>>
    export type PaymentsUpdatePromissoryNoteMutationBody = PaymentsUpdatePromissoryNoteBody
    export type PaymentsUpdatePromissoryNoteMutationError = unknown

    /**
 * @summary Update a promissory note
 */
export const usePaymentsUpdatePromissoryNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>, TError,{noteId: string;data: PaymentsUpdatePromissoryNoteBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsUpdatePromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsUpdatePromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsUpdatePromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const paymentsCollectPromissoryNote = (
    noteId: string,
    paymentsCollectPromissoryNoteBody?: PaymentsCollectPromissoryNoteBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/promissory-notes/${noteId}/collect`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentsCollectPromissoryNoteBody, signal
    },
      );
    }
  


export const getPaymentsCollectPromissoryNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext> => {

const mutationKey = ['paymentsCollectPromissoryNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, {noteId: string;data: PaymentsCollectPromissoryNoteBody}> = (props) => {
          const {noteId,data} = props ?? {};

          return  paymentsCollectPromissoryNote(noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentsCollectPromissoryNoteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>>
    export type PaymentsCollectPromissoryNoteMutationBody = PaymentsCollectPromissoryNoteBody
    export type PaymentsCollectPromissoryNoteMutationError = unknown

    /**
 * @summary Collect payment for a promissory note (full or partial)
 */
export const usePaymentsCollectPromissoryNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>, TError,{noteId: string;data: PaymentsCollectPromissoryNoteBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentsCollectPromissoryNote>>,
        TError,
        {noteId: string;data: PaymentsCollectPromissoryNoteBody},
        TContext
      > => {

      const mutationOptions = getPaymentsCollectPromissoryNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/register-phone
 */
export const registrationRegisterPhone = (
    registrationRegisterPhoneBody?: RegistrationRegisterPhoneBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/register-phone`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registrationRegisterPhoneBody, signal
    },
      );
    }
  


export const getRegistrationRegisterPhoneMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext> => {

const mutationKey = ['registrationRegisterPhone'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationRegisterPhone>>, {data: RegistrationRegisterPhoneBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationRegisterPhone(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationRegisterPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof registrationRegisterPhone>>>
    export type RegistrationRegisterPhoneMutationBody = RegistrationRegisterPhoneBody
    export type RegistrationRegisterPhoneMutationError = unknown

    /**
 * @summary POST /api/register-phone
 */
export const useRegistrationRegisterPhone = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationRegisterPhone>>, TError,{data: RegistrationRegisterPhoneBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationRegisterPhone>>,
        TError,
        {data: RegistrationRegisterPhoneBody},
        TContext
      > => {

      const mutationOptions = getRegistrationRegisterPhoneMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create return invoice for a replacement
 */
export const replacementsCreateReturnInvoice = (
    replacementId: string,
    replacementsCreateReturnInvoiceBody?: ReplacementsCreateReturnInvoiceBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/replacements/${replacementId}/invoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: replacementsCreateReturnInvoiceBody, signal
    },
      );
    }
  


export const getReplacementsCreateReturnInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext> => {

const mutationKey = ['replacementsCreateReturnInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, {replacementId: string;data: ReplacementsCreateReturnInvoiceBody}> = (props) => {
          const {replacementId,data} = props ?? {};

          return  replacementsCreateReturnInvoice(replacementId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreateReturnInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>>
    export type ReplacementsCreateReturnInvoiceMutationBody = ReplacementsCreateReturnInvoiceBody
    export type ReplacementsCreateReturnInvoiceMutationError = unknown

    /**
 * @summary Create return invoice for a replacement
 */
export const useReplacementsCreateReturnInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>, TError,{replacementId: string;data: ReplacementsCreateReturnInvoiceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreateReturnInvoice>>,
        TError,
        {replacementId: string;data: ReplacementsCreateReturnInvoiceBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreateReturnInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/reports/appointments
 */
export const reportsReportAppointments = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportAppointmentsQueryKey = () => {
    return [
    `/api/reports/appointments`
    ] as const;
    }

    
export const getReportsReportAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportAppointmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportAppointments>>> = ({ signal }) => reportsReportAppointments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportAppointments>>>
export type ReportsReportAppointmentsQueryError = unknown


export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportAppointments>>,
          TError,
          Awaited<ReturnType<typeof reportsReportAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/appointments
 */

export function useReportsReportAppointments<TData = Awaited<ReturnType<typeof reportsReportAppointments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportAppointmentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Kampanya raporu
 */
export const reportsReportCampaigns = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/campaigns`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportCampaignsQueryKey = () => {
    return [
    `/api/reports/campaigns`
    ] as const;
    }

    
export const getReportsReportCampaignsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportCampaignsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportCampaigns>>> = ({ signal }) => reportsReportCampaigns(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportCampaigns>>>
export type ReportsReportCampaignsQueryError = unknown


export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportCampaigns>>,
          TError,
          Awaited<ReturnType<typeof reportsReportCampaigns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Kampanya raporu
 */

export function useReportsReportCampaigns<TData = Awaited<ReturnType<typeof reportsReportCampaigns>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportCampaigns>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportCampaignsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Mali rapor
 */
export const reportsReportFinancial = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/financial`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportFinancialQueryKey = () => {
    return [
    `/api/reports/financial`
    ] as const;
    }

    
export const getReportsReportFinancialQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportFinancialQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportFinancial>>> = ({ signal }) => reportsReportFinancial(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportFinancialQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportFinancial>>>
export type ReportsReportFinancialQueryError = unknown


export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportFinancial>>,
          TError,
          Awaited<ReturnType<typeof reportsReportFinancial>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Mali rapor
 */

export function useReportsReportFinancial<TData = Awaited<ReturnType<typeof reportsReportFinancial>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportFinancial>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportFinancialQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Genel rapor Ã¶zeti
 */
export const reportsReportOverview = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/overview`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportOverviewQueryKey = () => {
    return [
    `/api/reports/overview`
    ] as const;
    }

    
export const getReportsReportOverviewQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportOverviewQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportOverview>>> = ({ signal }) => reportsReportOverview(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportOverviewQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportOverview>>>
export type ReportsReportOverviewQueryError = unknown


export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportOverview>>,
          TError,
          Awaited<ReturnType<typeof reportsReportOverview>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Genel rapor Ã¶zeti
 */

export function useReportsReportOverview<TData = Awaited<ReturnType<typeof reportsReportOverview>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportOverview>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportOverviewQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Hasta analizi raporu
 */
export const reportsReportPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/patients`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportPatientsQueryKey = () => {
    return [
    `/api/reports/patients`
    ] as const;
    }

    
export const getReportsReportPatientsQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportPatients>>> = ({ signal }) => reportsReportPatients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportPatients>>>
export type ReportsReportPatientsQueryError = unknown


export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportPatients>>,
          TError,
          Awaited<ReturnType<typeof reportsReportPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Hasta analizi raporu
 */

export function useReportsReportPatients<TData = Awaited<ReturnType<typeof reportsReportPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/reports/revenue
 */
export const reportsReportRevenue = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/reports/revenue`, method: 'GET', signal
    },
      );
    }
  



export const getReportsReportRevenueQueryKey = () => {
    return [
    `/api/reports/revenue`
    ] as const;
    }

    
export const getReportsReportRevenueQueryOptions = <TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReportsReportRevenueQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof reportsReportRevenue>>> = ({ signal }) => reportsReportRevenue(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ReportsReportRevenueQueryResult = NonNullable<Awaited<ReturnType<typeof reportsReportRevenue>>>
export type ReportsReportRevenueQueryError = unknown


export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportsReportRevenue>>,
          TError,
          Awaited<ReturnType<typeof reportsReportRevenue>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/reports/revenue
 */

export function useReportsReportRevenue<TData = Awaited<ReturnType<typeof reportsReportRevenue>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof reportsReportRevenue>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getReportsReportRevenueQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Mark invoice as sent to GIB
 */
export const replacementsSendInvoiceToGib = (
    invoiceId: string,
    replacementsSendInvoiceToGibBody?: ReplacementsSendInvoiceToGibBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/return-invoices/${invoiceId}/send-to-gib`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: replacementsSendInvoiceToGibBody, signal
    },
      );
    }
  


export const getReplacementsSendInvoiceToGibMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext> => {

const mutationKey = ['replacementsSendInvoiceToGib'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, {invoiceId: string;data: ReplacementsSendInvoiceToGibBody}> = (props) => {
          const {invoiceId,data} = props ?? {};

          return  replacementsSendInvoiceToGib(invoiceId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsSendInvoiceToGibMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>>
    export type ReplacementsSendInvoiceToGibMutationBody = ReplacementsSendInvoiceToGibBody
    export type ReplacementsSendInvoiceToGibMutationError = unknown

    /**
 * @summary Mark invoice as sent to GIB
 */
export const useReplacementsSendInvoiceToGib = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>, TError,{invoiceId: string;data: ReplacementsSendInvoiceToGibBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsSendInvoiceToGib>>,
        TError,
        {invoiceId: string;data: ReplacementsSendInvoiceToGibBody},
        TContext
      > => {

      const mutationOptions = getReplacementsSendInvoiceToGibMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/roles
 */
export const rolesListRoles = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/roles`, method: 'GET', signal
    },
      );
    }
  



export const getRolesListRolesQueryKey = () => {
    return [
    `/api/roles`
    ] as const;
    }

    
export const getRolesListRolesQueryOptions = <TData = Awaited<ReturnType<typeof rolesListRoles>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRolesListRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rolesListRoles>>> = ({ signal }) => rolesListRoles(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type RolesListRolesQueryResult = NonNullable<Awaited<ReturnType<typeof rolesListRoles>>>
export type RolesListRolesQueryError = unknown


export function useRolesListRoles<TData = Awaited<ReturnType<typeof rolesListRoles>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rolesListRoles>>,
          TError,
          Awaited<ReturnType<typeof rolesListRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRolesListRoles<TData = Awaited<ReturnType<typeof rolesListRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rolesListRoles>>,
          TError,
          Awaited<ReturnType<typeof rolesListRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRolesListRoles<TData = Awaited<ReturnType<typeof rolesListRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/roles
 */

export function useRolesListRoles<TData = Awaited<ReturnType<typeof rolesListRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rolesListRoles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getRolesListRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/roles
 */
export const rolesCreateRole = (
    rolesCreateRoleBody?: RolesCreateRoleBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rolesCreateRoleBody, signal
    },
      );
    }
  


export const getRolesCreateRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext> => {

const mutationKey = ['rolesCreateRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesCreateRole>>, {data: RolesCreateRoleBody}> = (props) => {
          const {data} = props ?? {};

          return  rolesCreateRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesCreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesCreateRole>>>
    export type RolesCreateRoleMutationBody = RolesCreateRoleBody
    export type RolesCreateRoleMutationError = unknown

    /**
 * @summary POST /api/roles
 */
export const useRolesCreateRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesCreateRole>>, TError,{data: RolesCreateRoleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesCreateRole>>,
        TError,
        {data: RolesCreateRoleBody},
        TContext
      > => {

      const mutationOptions = getRolesCreateRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const rolesAddPermissionToRole = (
    roleId: string,
    rolesAddPermissionToRoleBody?: RolesAddPermissionToRoleBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/roles/${roleId}/permissions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rolesAddPermissionToRoleBody, signal
    },
      );
    }
  


export const getRolesAddPermissionToRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext> => {

const mutationKey = ['rolesAddPermissionToRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, {roleId: string;data: RolesAddPermissionToRoleBody}> = (props) => {
          const {roleId,data} = props ?? {};

          return  rolesAddPermissionToRole(roleId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesAddPermissionToRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesAddPermissionToRole>>>
    export type RolesAddPermissionToRoleMutationBody = RolesAddPermissionToRoleBody
    export type RolesAddPermissionToRoleMutationError = unknown

    /**
 * @summary POST /api/roles/{role_id}/permissions
 */
export const useRolesAddPermissionToRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesAddPermissionToRole>>, TError,{roleId: string;data: RolesAddPermissionToRoleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesAddPermissionToRole>>,
        TError,
        {roleId: string;data: RolesAddPermissionToRoleBody},
        TContext
      > => {

      const mutationOptions = getRolesAddPermissionToRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const rolesRemovePermissionFromRole = (
    roleId: string,
    permissionId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/roles/${roleId}/permissions/${permissionId}`, method: 'DELETE'
    },
      );
    }
  


export const getRolesRemovePermissionFromRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext> => {

const mutationKey = ['rolesRemovePermissionFromRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, {roleId: string;permissionId: string}> = (props) => {
          const {roleId,permissionId} = props ?? {};

          return  rolesRemovePermissionFromRole(roleId,permissionId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RolesRemovePermissionFromRoleMutationResult = NonNullable<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>>
    
    export type RolesRemovePermissionFromRoleMutationError = unknown

    /**
 * @summary DELETE /api/roles/{role_id}/permissions/{permission_id}
 */
export const useRolesRemovePermissionFromRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>, TError,{roleId: string;permissionId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rolesRemovePermissionFromRole>>,
        TError,
        {roleId: string;permissionId: string},
        TContext
      > => {

      const mutationOptions = getRolesRemovePermissionFromRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all sales with pagination and filtering
 */
export const salesGetSales = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetSalesQueryKey = () => {
    return [
    `/api/sales`
    ] as const;
    }

    
export const getSalesGetSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSales>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSalesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSales>>> = ({ signal }) => salesGetSales(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSales>>>
export type SalesGetSalesQueryError = unknown


export function useSalesGetSales<TData = Awaited<ReturnType<typeof salesGetSales>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSales<TData = Awaited<ReturnType<typeof salesGetSales>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSales<TData = Awaited<ReturnType<typeof salesGetSales>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all sales with pagination and filtering
 */

export function useSalesGetSales<TData = Awaited<ReturnType<typeof salesGetSales>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSalesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create invoice for a sale
 */
export const invoicesCreateSaleInvoice = (
    saleId: string,
    invoicesCreateSaleInvoiceBody?: InvoicesCreateSaleInvoiceBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales/${saleId}/invoice`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoicesCreateSaleInvoiceBody, signal
    },
      );
    }
  


export const getInvoicesCreateSaleInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>, TError,{saleId: string;data: InvoicesCreateSaleInvoiceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>, TError,{saleId: string;data: InvoicesCreateSaleInvoiceBody}, TContext> => {

const mutationKey = ['invoicesCreateSaleInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>, {saleId: string;data: InvoicesCreateSaleInvoiceBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  invoicesCreateSaleInvoice(saleId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvoicesCreateSaleInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>>
    export type InvoicesCreateSaleInvoiceMutationBody = InvoicesCreateSaleInvoiceBody
    export type InvoicesCreateSaleInvoiceMutationError = unknown

    /**
 * @summary Create invoice for a sale
 */
export const useInvoicesCreateSaleInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>, TError,{saleId: string;data: InvoicesCreateSaleInvoiceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invoicesCreateSaleInvoice>>,
        TError,
        {saleId: string;data: InvoicesCreateSaleInvoiceBody},
        TContext
      > => {

      const mutationOptions = getInvoicesCreateSaleInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get invoice for a sale
 */
export const invoicesGetSaleInvoice = (
    saleId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales/${saleId}/invoice`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetSaleInvoiceQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice`
    ] as const;
    }

    
export const getInvoicesGetSaleInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError = unknown>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetSaleInvoiceQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>> = ({ signal }) => invoicesGetSaleInvoice(saleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InvoicesGetSaleInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>>
export type InvoicesGetSaleInvoiceQueryError = unknown


export function useInvoicesGetSaleInvoice<TData = Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError = unknown>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetSaleInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetSaleInvoice<TData = Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetSaleInvoice>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetSaleInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInvoicesGetSaleInvoice<TData = Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get invoice for a sale
 */

export function useInvoicesGetSaleInvoice<TData = Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetSaleInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInvoicesGetSaleInvoiceQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Generate PDF for sale invoice
 */
export const salesGenerateSaleInvoicePdf = (
    saleId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesGenerateSaleInvoicePdf200>(
      {url: `/api/sales/${saleId}/invoice/pdf`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGenerateSaleInvoicePdfQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/invoice/pdf`
    ] as const;
    }

    
export const getSalesGenerateSaleInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = void>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGenerateSaleInvoicePdfQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>> = ({ signal }) => salesGenerateSaleInvoicePdf(saleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGenerateSaleInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>>
export type SalesGenerateSaleInvoicePdfQueryError = void


export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = void>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Generate PDF for sale invoice
 */

export function useSalesGenerateSaleInvoicePdf<TData = Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGenerateSaleInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGenerateSaleInvoicePdfQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create payment plan for a sale
 */
export const salesCreateSalePaymentPlan = (
    saleId: string,
    salesCreateSalePaymentPlanBody: SalesCreateSalePaymentPlanBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesCreateSalePaymentPlan201>(
      {url: `/api/sales/${saleId}/payment-plan`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesCreateSalePaymentPlanBody, signal
    },
      );
    }
  


export const getSalesCreateSalePaymentPlanMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext> => {

const mutationKey = ['salesCreateSalePaymentPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, {saleId: string;data: SalesCreateSalePaymentPlanBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSalePaymentPlan(saleId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalePaymentPlanMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>>
    export type SalesCreateSalePaymentPlanMutationBody = SalesCreateSalePaymentPlanBody
    export type SalesCreateSalePaymentPlanMutationError = void

    /**
 * @summary Create payment plan for a sale
 */
export const useSalesCreateSalePaymentPlan = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>, TError,{saleId: string;data: SalesCreateSalePaymentPlanBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalePaymentPlan>>,
        TError,
        {saleId: string;data: SalesCreateSalePaymentPlanBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalePaymentPlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get payment plan for a sale
 */
export const salesGetSalePaymentPlan = (
    saleId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesGetSalePaymentPlan200>(
      {url: `/api/sales/${saleId}/payment-plan`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetSalePaymentPlanQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/payment-plan`
    ] as const;
    }

    
export const getSalesGetSalePaymentPlanQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError = void>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSalePaymentPlanQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>> = ({ signal }) => salesGetSalePaymentPlan(saleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSalePaymentPlanQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>>
export type SalesGetSalePaymentPlanQueryError = void


export function useSalesGetSalePaymentPlan<TData = Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError = void>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSalePaymentPlan>>,
          TError,
          Awaited<ReturnType<typeof salesGetSalePaymentPlan>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSalePaymentPlan<TData = Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSalePaymentPlan>>,
          TError,
          Awaited<ReturnType<typeof salesGetSalePaymentPlan>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSalePaymentPlan<TData = Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get payment plan for a sale
 */

export function useSalesGetSalePaymentPlan<TData = Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError = void>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePaymentPlan>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSalePaymentPlanQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all payments for a sale
 */
export const salesGetSalePayments = (
    saleId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesGetSalePayments200>(
      {url: `/api/sales/${saleId}/payments`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetSalePaymentsQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/payments`
    ] as const;
    }

    
export const getSalesGetSalePaymentsQueryOptions = <TData = Awaited<ReturnType<typeof salesGetSalePayments>>, TError = unknown>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetSalePaymentsQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetSalePayments>>> = ({ signal }) => salesGetSalePayments(saleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SalesGetSalePaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetSalePayments>>>
export type SalesGetSalePaymentsQueryError = unknown


export function useSalesGetSalePayments<TData = Awaited<ReturnType<typeof salesGetSalePayments>>, TError = unknown>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSalePayments>>,
          TError,
          Awaited<ReturnType<typeof salesGetSalePayments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSalePayments<TData = Awaited<ReturnType<typeof salesGetSalePayments>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetSalePayments>>,
          TError,
          Awaited<ReturnType<typeof salesGetSalePayments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSalesGetSalePayments<TData = Awaited<ReturnType<typeof salesGetSalePayments>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all payments for a sale
 */

export function useSalesGetSalePayments<TData = Awaited<ReturnType<typeof salesGetSalePayments>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetSalePayments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSalesGetSalePaymentsQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Record a payment for a sale
 */
export const salesCreateSalePayment = (
    saleId: string,
    salesCreateSalePaymentBody: SalesCreateSalePaymentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesCreateSalePayment201>(
      {url: `/api/sales/${saleId}/payments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesCreateSalePaymentBody, signal
    },
      );
    }
  


export const getSalesCreateSalePaymentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePayment>>, TError,{saleId: string;data: SalesCreateSalePaymentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePayment>>, TError,{saleId: string;data: SalesCreateSalePaymentBody}, TContext> => {

const mutationKey = ['salesCreateSalePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalePayment>>, {saleId: string;data: SalesCreateSalePaymentBody}> = (props) => {
          const {saleId,data} = props ?? {};

          return  salesCreateSalePayment(saleId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalePayment>>>
    export type SalesCreateSalePaymentMutationBody = SalesCreateSalePaymentBody
    export type SalesCreateSalePaymentMutationError = void

    /**
 * @summary Record a payment for a sale
 */
export const useSalesCreateSalePayment = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalePayment>>, TError,{saleId: string;data: SalesCreateSalePaymentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalePayment>>,
        TError,
        {saleId: string;data: SalesCreateSalePaymentBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalePaymentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Pay a specific installment
 */
export const salesPayInstallment = (
    saleId: string,
    installmentId: string,
    salesPayInstallmentBody: SalesPayInstallmentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SalesPayInstallment200>(
      {url: `/api/sales/${saleId}/installments/${installmentId}/pay`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesPayInstallmentBody, signal
    },
      );
    }
  


export const getSalesPayInstallmentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext> => {

const mutationKey = ['salesPayInstallment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesPayInstallment>>, {saleId: string;installmentId: string;data: SalesPayInstallmentBody}> = (props) => {
          const {saleId,installmentId,data} = props ?? {};

          return  salesPayInstallment(saleId,installmentId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesPayInstallmentMutationResult = NonNullable<Awaited<ReturnType<typeof salesPayInstallment>>>
    export type SalesPayInstallmentMutationBody = SalesPayInstallmentBody
    export type SalesPayInstallmentMutationError = void

    /**
 * @summary Pay a specific installment
 */
export const useSalesPayInstallment = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesPayInstallment>>, TError,{saleId: string;installmentId: string;data: SalesPayInstallmentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesPayInstallment>>,
        TError,
        {saleId: string;installmentId: string;data: SalesPayInstallmentBody},
        TContext
      > => {

      const mutationOptions = getSalesPayInstallmentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all promissory notes for a specific sale
 */
export const paymentsGetSalePromissoryNotes = (
    saleId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales/${saleId}/promissory-notes`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetSalePromissoryNotesQueryKey = (saleId?: string,) => {
    return [
    `/api/sales/${saleId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetSalePromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = unknown>(saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetSalePromissoryNotesQueryKey(saleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>> = ({ signal }) => paymentsGetSalePromissoryNotes(saleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(saleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type PaymentsGetSalePromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>>
export type PaymentsGetSalePromissoryNotesQueryError = unknown


export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = unknown>(
 saleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all promissory notes for a specific sale
 */

export function usePaymentsGetSalePromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError = unknown>(
 saleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetSalePromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getPaymentsGetSalePromissoryNotesQueryOptions(saleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a sales log entry for cashflow.html page
 */
export const salesCreateSalesLog = (
    salesCreateSalesLogBody?: SalesCreateSalesLogBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales/logs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesCreateSalesLogBody, signal
    },
      );
    }
  


export const getSalesCreateSalesLogMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext> => {

const mutationKey = ['salesCreateSalesLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateSalesLog>>, {data: SalesCreateSalesLogBody}> = (props) => {
          const {data} = props ?? {};

          return  salesCreateSalesLog(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateSalesLogMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateSalesLog>>>
    export type SalesCreateSalesLogMutationBody = SalesCreateSalesLogBody
    export type SalesCreateSalesLogMutationError = unknown

    /**
 * @summary Create a sales log entry for cashflow.html page
 */
export const useSalesCreateSalesLog = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateSalesLog>>, TError,{data: SalesCreateSalesLogBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateSalesLog>>,
        TError,
        {data: SalesCreateSalesLogBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateSalesLogMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Ä°steÄŸe baÄŸlÄ± filtreler: body veya query iÃ§inde `patientId`, `saleId`, `limit`.
 * @summary SatÄ±ÅŸ kayÄ±tlarÄ±nÄ±n SGK ve hasta Ã¶deme tutarlarÄ±nÄ± yeniden hesaplarken kalÄ±cÄ± olarak gÃ¼nceller.
 */
export const salesRecalcSales = (
    salesRecalcSalesBody?: SalesRecalcSalesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sales/recalc`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesRecalcSalesBody, signal
    },
      );
    }
  


export const getSalesRecalcSalesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext> => {

const mutationKey = ['salesRecalcSales'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesRecalcSales>>, {data: SalesRecalcSalesBody}> = (props) => {
          const {data} = props ?? {};

          return  salesRecalcSales(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesRecalcSalesMutationResult = NonNullable<Awaited<ReturnType<typeof salesRecalcSales>>>
    export type SalesRecalcSalesMutationBody = SalesRecalcSalesBody
    export type SalesRecalcSalesMutationError = unknown

    /**
 * @summary SatÄ±ÅŸ kayÄ±tlarÄ±nÄ±n SGK ve hasta Ã¶deme tutarlarÄ±nÄ± yeniden hesaplarken kalÄ±cÄ± olarak gÃ¼nceller.
 */
export const useSalesRecalcSales = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesRecalcSales>>, TError,{data: SalesRecalcSalesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesRecalcSales>>,
        TError,
        {data: SalesRecalcSalesBody},
        TContext
      > => {

      const mutationOptions = getSalesRecalcSalesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get system settings from database
 */
export const getSettings = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/settings`, method: 'GET', signal
    },
      );
    }
  



export const getGetSettingsQueryKey = () => {
    return [
    `/api/settings`
    ] as const;
    }

    
export const getGetSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getSettings>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettings>>> = ({ signal }) => getSettings(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getSettings>>>
export type GetSettingsQueryError = unknown


export function useGetSettings<TData = Awaited<ReturnType<typeof getSettings>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSettings>>,
          TError,
          Awaited<ReturnType<typeof getSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSettings<TData = Awaited<ReturnType<typeof getSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSettings>>,
          TError,
          Awaited<ReturnType<typeof getSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSettings<TData = Awaited<ReturnType<typeof getSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get system settings from database
 */

export function useGetSettings<TData = Awaited<ReturnType<typeof getSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update system settings
 */
export const updateSettings = (
    updateSettingsBody?: UpdateSettingsBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/settings`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSettingsBody
    },
      );
    }
  


export const getUpdateSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext> => {

const mutationKey = ['updateSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSettings>>, {data: UpdateSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  updateSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateSettings>>>
    export type UpdateSettingsMutationBody = UpdateSettingsBody
    export type UpdateSettingsMutationError = unknown

    /**
 * @summary Update system settings
 */
export const useUpdateSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSettings>>, TError,{data: UpdateSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSettings>>,
        TError,
        {data: UpdateSettingsBody},
        TContext
      > => {

      const mutationOptions = getUpdateSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Save system settings
 */
export const saveSettings = (
    saveSettingsBody?: SaveSettingsBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: saveSettingsBody, signal
    },
      );
    }
  


export const getSaveSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSettings>>, TError,{data: SaveSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof saveSettings>>, TError,{data: SaveSettingsBody}, TContext> => {

const mutationKey = ['saveSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveSettings>>, {data: SaveSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  saveSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof saveSettings>>>
    export type SaveSettingsMutationBody = SaveSettingsBody
    export type SaveSettingsMutationError = unknown

    /**
 * @summary Save system settings
 */
export const useSaveSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSettings>>, TError,{data: SaveSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveSettings>>,
        TError,
        {data: SaveSettingsBody},
        TContext
      > => {

      const mutationOptions = getSaveSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Request body: { "updates": { "company.name": "New", "system.timezone": "Europe/London" } }
 * @summary Apply partial updates to system settings using dot-path notation.
 */
export const patchSettings = (
    patchSettingsBody?: PatchSettingsBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/settings`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchSettingsBody
    },
      );
    }
  


export const getPatchSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchSettings>>, TError,{data: PatchSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchSettings>>, TError,{data: PatchSettingsBody}, TContext> => {

const mutationKey = ['patchSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchSettings>>, {data: PatchSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  patchSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof patchSettings>>>
    export type PatchSettingsMutationBody = PatchSettingsBody
    export type PatchSettingsMutationError = unknown

    /**
 * @summary Apply partial updates to system settings using dot-path notation.
 */
export const usePatchSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchSettings>>, TError,{data: PatchSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchSettings>>,
        TError,
        {data: PatchSettingsBody},
        TContext
      > => {

      const mutationOptions = getPatchSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get pricing settings specifically
 */
export const getPricingSettings = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/settings/pricing`, method: 'GET', signal
    },
      );
    }
  



export const getGetPricingSettingsQueryKey = () => {
    return [
    `/api/settings/pricing`
    ] as const;
    }

    
export const getGetPricingSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPricingSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPricingSettings>>> = ({ signal }) => getPricingSettings(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPricingSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getPricingSettings>>>
export type GetPricingSettingsQueryError = unknown


export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPricingSettings>>,
          TError,
          Awaited<ReturnType<typeof getPricingSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPricingSettings>>,
          TError,
          Awaited<ReturnType<typeof getPricingSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get pricing settings specifically
 */

export function useGetPricingSettings<TData = Awaited<ReturnType<typeof getPricingSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPricingSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPricingSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/sgk/documents
 */
export const sgkListSgkDocuments = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/documents`, method: 'GET', signal
    },
      );
    }
  



export const getSgkListSgkDocumentsQueryKey = () => {
    return [
    `/api/sgk/documents`
    ] as const;
    }

    
export const getSgkListSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkListSgkDocumentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkListSgkDocuments>>> = ({ signal }) => sgkListSgkDocuments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkListSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkListSgkDocuments>>>
export type SgkListSgkDocumentsQueryError = unknown


export function useSgkListSgkDocuments<TData = Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkListSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkListSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkListSgkDocuments<TData = Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkListSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkListSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkListSgkDocuments<TData = Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sgk/documents
 */

export function useSgkListSgkDocuments<TData = Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkListSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkListSgkDocumentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
    sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkUploadSgkDocumentBody, signal
    },
      );
    }
  


export const getSgkUploadSgkDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext> => {

const mutationKey = ['sgkUploadSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, {data: SgkUploadSgkDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadSgkDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadSgkDocument>>>
    export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody
    export type SgkUploadSgkDocumentMutationError = unknown

    /**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
        TError,
        {data: SgkUploadSgkDocumentBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/sgk/documents/{document_id}
 */
export const sgkGetSgkDocument = (
    documentId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/documents/${documentId}`, method: 'GET', signal
    },
      );
    }
  



export const getSgkGetSgkDocumentQueryKey = (documentId?: string,) => {
    return [
    `/api/sgk/documents/${documentId}`
    ] as const;
    }

    
export const getSgkGetSgkDocumentQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError = unknown>(documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetSgkDocumentQueryKey(documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetSgkDocument>>> = ({ signal }) => sgkGetSgkDocument(documentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SgkGetSgkDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetSgkDocument>>>
export type SgkGetSgkDocumentQueryError = unknown


export function useSgkGetSgkDocument<TData = Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError = unknown>(
 documentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkDocument<TData = Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError = unknown>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSgkGetSgkDocument<TData = Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError = unknown>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sgk/documents/{document_id}
 */

export function useSgkGetSgkDocument<TData = Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError = unknown>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSgkGetSgkDocumentQueryOptions(documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (
    documentId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/documents/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getSgkDeleteSgkDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['sgkDeleteSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  sgkDeleteSgkDocument(documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkDeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>>
    
    export type SgkDeleteSgkDocumentMutationError = unknown

    /**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const sgkSeedTestPatients = (
    sgkSeedTestPatientsBody?: SgkSeedTestPatientsBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/seed-test-patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkSeedTestPatientsBody, signal
    },
      );
    }
  


export const getSgkSeedTestPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext> => {

const mutationKey = ['sgkSeedTestPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkSeedTestPatients>>, {data: SgkSeedTestPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkSeedTestPatients(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkSeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkSeedTestPatients>>>
    export type SgkSeedTestPatientsMutationBody = SgkSeedTestPatientsBody
    export type SgkSeedTestPatientsMutationError = unknown

    /**
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const useSgkSeedTestPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkSeedTestPatients>>,
        TError,
        {data: SgkSeedTestPatientsBody},
        TContext
      > => {

      const mutationOptions = getSgkSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Saves files to a secure temporary path, runs OCR (worker-first) with auto_crop=True
and returns per-file OCR results including patient_info.
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const sgkUploadAndProcessFiles = (
    sgkUploadAndProcessFilesBody?: SgkUploadAndProcessFilesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sgk/upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkUploadAndProcessFilesBody, signal
    },
      );
    }
  


export const getSgkUploadAndProcessFilesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext> => {

const mutationKey = ['sgkUploadAndProcessFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, {data: SgkUploadAndProcessFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadAndProcessFiles(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadAndProcessFilesMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>>
    export type SgkUploadAndProcessFilesMutationBody = SgkUploadAndProcessFilesBody
    export type SgkUploadAndProcessFilesMutationError = unknown

    /**
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const useSgkUploadAndProcessFiles = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
        TError,
        {data: SgkUploadAndProcessFilesBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadAndProcessFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary GET /api/sms/monitoring
 */
export const smsMonitoring = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/sms/monitoring`, method: 'GET', signal
    },
      );
    }
  



export const getSmsMonitoringQueryKey = () => {
    return [
    `/api/sms/monitoring`
    ] as const;
    }

    
export const getSmsMonitoringQueryOptions = <TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsMonitoringQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsMonitoring>>> = ({ signal }) => smsMonitoring(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsMonitoringQueryResult = NonNullable<Awaited<ReturnType<typeof smsMonitoring>>>
export type SmsMonitoringQueryError = unknown


export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsMonitoring>>,
          TError,
          Awaited<ReturnType<typeof smsMonitoring>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/sms/monitoring
 */

export function useSmsMonitoring<TData = Awaited<ReturnType<typeof smsMonitoring>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsMonitoring>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsMonitoringQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get all suppliers with optional filtering and pagination
 */
export const suppliersGetSuppliers = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersGetSuppliersQueryKey = () => {
    return [
    `/api/suppliers`
    ] as const;
    }

    
export const getSuppliersGetSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSuppliersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSuppliers>>> = ({ signal }) => suppliersGetSuppliers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSuppliers>>>
export type SuppliersGetSuppliersQueryError = unknown


export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all suppliers with optional filtering and pagination
 */

export function useSuppliersGetSuppliers<TData = Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSuppliersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new supplier
 */
export const suppliersCreateSupplier = (
    suppliersCreateSupplierBody?: SuppliersCreateSupplierBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: suppliersCreateSupplierBody, signal
    },
      );
    }
  


export const getSuppliersCreateSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext> => {

const mutationKey = ['suppliersCreateSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersCreateSupplier>>, {data: SuppliersCreateSupplierBody}> = (props) => {
          const {data} = props ?? {};

          return  suppliersCreateSupplier(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersCreateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersCreateSupplier>>>
    export type SuppliersCreateSupplierMutationBody = SuppliersCreateSupplierBody
    export type SuppliersCreateSupplierMutationError = unknown

    /**
 * @summary Create a new supplier
 */
export const useSuppliersCreateSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersCreateSupplier>>, TError,{data: SuppliersCreateSupplierBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersCreateSupplier>>,
        TError,
        {data: SuppliersCreateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersCreateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get a single supplier by ID
 */
export const suppliersGetSupplier = (
    supplierId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/${supplierId}`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersGetSupplierQueryKey = (supplierId?: string,) => {
    return [
    `/api/suppliers/${supplierId}`
    ] as const;
    }

    
export const getSuppliersGetSupplierQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplier>>, TError = unknown>(supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierQueryKey(supplierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplier>>> = ({ signal }) => suppliersGetSupplier(supplierId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplier>>>
export type SuppliersGetSupplierQueryError = unknown


export function useSuppliersGetSupplier<TData = Awaited<ReturnType<typeof suppliersGetSupplier>>, TError = unknown>(
 supplierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplier>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplier>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplier<TData = Awaited<ReturnType<typeof suppliersGetSupplier>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplier>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplier>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplier<TData = Awaited<ReturnType<typeof suppliersGetSupplier>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a single supplier by ID
 */

export function useSuppliersGetSupplier<TData = Awaited<ReturnType<typeof suppliersGetSupplier>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplier>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierQueryOptions(supplierId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update an existing supplier
 */
export const suppliersUpdateSupplier = (
    supplierId: string,
    suppliersUpdateSupplierBody?: SuppliersUpdateSupplierBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/${supplierId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: suppliersUpdateSupplierBody
    },
      );
    }
  


export const getSuppliersUpdateSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersUpdateSupplierBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersUpdateSupplierBody}, TContext> => {

const mutationKey = ['suppliersUpdateSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, {supplierId: string;data: SuppliersUpdateSupplierBody}> = (props) => {
          const {supplierId,data} = props ?? {};

          return  suppliersUpdateSupplier(supplierId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersUpdateSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersUpdateSupplier>>>
    export type SuppliersUpdateSupplierMutationBody = SuppliersUpdateSupplierBody
    export type SuppliersUpdateSupplierMutationError = unknown

    /**
 * @summary Update an existing supplier
 */
export const useSuppliersUpdateSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersUpdateSupplier>>, TError,{supplierId: string;data: SuppliersUpdateSupplierBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersUpdateSupplier>>,
        TError,
        {supplierId: string;data: SuppliersUpdateSupplierBody},
        TContext
      > => {

      const mutationOptions = getSuppliersUpdateSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const suppliersDeleteSupplier = (
    supplierId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/${supplierId}`, method: 'DELETE'
    },
      );
    }
  


export const getSuppliersDeleteSupplierMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext> => {

const mutationKey = ['suppliersDeleteSupplier'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, {supplierId: string}> = (props) => {
          const {supplierId} = props ?? {};

          return  suppliersDeleteSupplier(supplierId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuppliersDeleteSupplierMutationResult = NonNullable<Awaited<ReturnType<typeof suppliersDeleteSupplier>>>
    
    export type SuppliersDeleteSupplierMutationError = unknown

    /**
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export const useSuppliersDeleteSupplier = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof suppliersDeleteSupplier>>, TError,{supplierId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof suppliersDeleteSupplier>>,
        TError,
        {supplierId: string},
        TContext
      > => {

      const mutationOptions = getSuppliersDeleteSupplierMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get all products for a specific supplier
 */
export const suppliersGetSupplierProducts = (
    supplierId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/${supplierId}/products`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersGetSupplierProductsQueryKey = (supplierId?: string,) => {
    return [
    `/api/suppliers/${supplierId}/products`
    ] as const;
    }

    
export const getSuppliersGetSupplierProductsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = unknown>(supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierProductsQueryKey(supplierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>> = ({ signal }) => suppliersGetSupplierProducts(supplierId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(supplierId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierProductsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>>
export type SuppliersGetSupplierProductsQueryError = unknown


export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = unknown>(
 supplierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierProducts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all products for a specific supplier
 */

export function useSuppliersGetSupplierProducts<TData = Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError = unknown>(
 supplierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierProducts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierProductsQueryOptions(supplierId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Fast supplier search for autocomplete
 */
export const suppliersSearchSuppliers = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/search`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersSearchSuppliersQueryKey = () => {
    return [
    `/api/suppliers/search`
    ] as const;
    }

    
export const getSuppliersSearchSuppliersQueryOptions = <TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersSearchSuppliersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersSearchSuppliers>>> = ({ signal }) => suppliersSearchSuppliers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersSearchSuppliersQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersSearchSuppliers>>>
export type SuppliersSearchSuppliersQueryError = unknown


export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>,
          TError,
          Awaited<ReturnType<typeof suppliersSearchSuppliers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Fast supplier search for autocomplete
 */

export function useSuppliersSearchSuppliers<TData = Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersSearchSuppliers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersSearchSuppliersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get supplier statistics
 */
export const suppliersGetSupplierStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/suppliers/stats`, method: 'GET', signal
    },
      );
    }
  



export const getSuppliersGetSupplierStatsQueryKey = () => {
    return [
    `/api/suppliers/stats`
    ] as const;
    }

    
export const getSuppliersGetSupplierStatsQueryOptions = <TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuppliersGetSupplierStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof suppliersGetSupplierStats>>> = ({ signal }) => suppliersGetSupplierStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SuppliersGetSupplierStatsQueryResult = NonNullable<Awaited<ReturnType<typeof suppliersGetSupplierStats>>>
export type SuppliersGetSupplierStatsQueryError = unknown


export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>,
          TError,
          Awaited<ReturnType<typeof suppliersGetSupplierStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get supplier statistics
 */

export function useSuppliersGetSupplierStats<TData = Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof suppliersGetSupplierStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSuppliersGetSupplierStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Åžu kaynak tÃ¼rlerini birleÅŸtirir:
- Sales (satÄ±ÅŸlar)
- PaymentRecords (Ã¶deme kayÄ±tlarÄ±)
- Cash Records (nakit kayÄ±tlarÄ±)
Query parametreleri:
- limit: maksimum kayÄ±t sayÄ±sÄ± (varsayÄ±lan: 200)
- start_date, end_date: tarih filtreleri (ISO format)
- record_type: kayÄ±t tÃ¼rÃ¼ filtresi (sale, payment, cash)
- patient_id: hasta ID filtresi
- status: durum filtresi (paid, pending, partial)
 * @summary BirleÅŸik cash records endpoint'i - tÃ¼m finansal kayÄ±tlarÄ± tek yerden dÃ¶ndÃ¼rÃ¼r.
 */
export const unifiedCashGetUnifiedCashRecords = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/unified-cash-records`, method: 'GET', signal
    },
      );
    }
  



export const getUnifiedCashGetUnifiedCashRecordsQueryKey = () => {
    return [
    `/api/unified-cash-records`
    ] as const;
    }

    
export const getUnifiedCashGetUnifiedCashRecordsQueryOptions = <TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUnifiedCashGetUnifiedCashRecordsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>> = ({ signal }) => unifiedCashGetUnifiedCashRecords(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UnifiedCashGetUnifiedCashRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>>
export type UnifiedCashGetUnifiedCashRecordsQueryError = unknown


export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary BirleÅŸik cash records endpoint'i - tÃ¼m finansal kayÄ±tlarÄ± tek yerden dÃ¶ndÃ¼rÃ¼r.
 */

export function useUnifiedCashGetUnifiedCashRecords<TData = Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetUnifiedCashRecords>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUnifiedCashGetUnifiedCashRecordsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Query parametreleri:
- period: Ã¶zet dÃ¶nemi (today, week, month, year)
- start_date, end_date: Ã¶zel tarih aralÄ±ÄŸÄ±
 * @summary Finansal Ã¶zet bilgileri dÃ¶ndÃ¼rÃ¼r.
 */
export const unifiedCashGetCashSummary = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/unified-cash-records/summary`, method: 'GET', signal
    },
      );
    }
  



export const getUnifiedCashGetCashSummaryQueryKey = () => {
    return [
    `/api/unified-cash-records/summary`
    ] as const;
    }

    
export const getUnifiedCashGetCashSummaryQueryOptions = <TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUnifiedCashGetCashSummaryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>> = ({ signal }) => unifiedCashGetCashSummary(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UnifiedCashGetCashSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>>
export type UnifiedCashGetCashSummaryQueryError = unknown


export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>,
          TError,
          Awaited<ReturnType<typeof unifiedCashGetCashSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Finansal Ã¶zet bilgileri dÃ¶ndÃ¼rÃ¼r.
 */

export function useUnifiedCashGetCashSummary<TData = Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof unifiedCashGetCashSummary>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUnifiedCashGetCashSummaryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary GET /api/users
 */
export const usersListUsers = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/users`, method: 'GET', signal
    },
      );
    }
  



export const getUsersListUsersQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getUsersListUsersQueryOptions = <TData = Awaited<ReturnType<typeof usersListUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersListUsers>>> = ({ signal }) => usersListUsers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersListUsers>>>
export type UsersListUsersQueryError = unknown


export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersListUsers>>,
          TError,
          Awaited<ReturnType<typeof usersListUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary GET /api/users
 */

export function useUsersListUsers<TData = Awaited<ReturnType<typeof usersListUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersListUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary POST /api/users
 */
export const usersCreateUser = (
    usersCreateUserBody?: UsersCreateUserBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: usersCreateUserBody, signal
    },
      );
    }
  


export const getUsersCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext> => {

const mutationKey = ['usersCreateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreateUser>>, {data: UsersCreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  usersCreateUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreateUser>>>
    export type UsersCreateUserMutationBody = UsersCreateUserBody
    export type UsersCreateUserMutationError = unknown

    /**
 * @summary POST /api/users
 */
export const useUsersCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UsersCreateUserBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersCreateUser>>,
        TError,
        {data: UsersCreateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary PUT /api/users/{user_id}
 */
export const usersUpdateUser = (
    userId: string,
    usersUpdateUserBody?: UsersUpdateUserBody,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: usersUpdateUserBody
    },
      );
    }
  


export const getUsersUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext> => {

const mutationKey = ['usersUpdateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateUser>>, {userId: string;data: UsersUpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersUpdateUser(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateUser>>>
    export type UsersUpdateUserMutationBody = UsersUpdateUserBody
    export type UsersUpdateUserMutationError = unknown

    /**
 * @summary PUT /api/users/{user_id}
 */
export const useUsersUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UsersUpdateUserBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateUser>>,
        TError,
        {userId: string;data: UsersUpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary DELETE /api/users/{user_id}
 */
export const usersDeleteUser = (
    userId: string,
 ) => {
      
      
      return adminApi<void>(
      {url: `/api/users/${userId}`, method: 'DELETE'
    },
      );
    }
  


export const getUsersDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['usersDeleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  usersDeleteUser(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUser>>>
    
    export type UsersDeleteUserMutationError = unknown

    /**
 * @summary DELETE /api/users/{user_id}
 */
export const useUsersDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getUsersDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update My Profile
 */
export const usersUpdateMe = (
    usersUpdateMeBody: UsersUpdateMeBody,
 ) => {
      
      
      return adminApi<UsersUpdateMe200>(
      {url: `/api/users/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: usersUpdateMeBody
    },
      );
    }
  


export const getUsersUpdateMeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext> => {

const mutationKey = ['usersUpdateMe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateMe>>, {data: UsersUpdateMeBody}> = (props) => {
          const {data} = props ?? {};

          return  usersUpdateMe(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateMe>>>
    export type UsersUpdateMeMutationBody = UsersUpdateMeBody
    export type UsersUpdateMeMutationError = unknown

    /**
 * @summary Update My Profile
 */
export const useUsersUpdateMe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateMe>>, TError,{data: UsersUpdateMeBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateMe>>,
        TError,
        {data: UsersUpdateMeBody},
        TContext
      > => {

      const mutationOptions = getUsersUpdateMeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/verify-otp
 */
export const authVerifyOtp = (
    authVerifyOtpBody?: AuthVerifyOtpBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/verify-otp`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authVerifyOtpBody, signal
    },
      );
    }
  


export const getAuthVerifyOtpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext> => {

const mutationKey = ['authVerifyOtp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authVerifyOtp>>, {data: AuthVerifyOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  authVerifyOtp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthVerifyOtpMutationResult = NonNullable<Awaited<ReturnType<typeof authVerifyOtp>>>
    export type AuthVerifyOtpMutationBody = AuthVerifyOtpBody
    export type AuthVerifyOtpMutationError = unknown

    /**
 * @summary POST /api/verify-otp
 */
export const useAuthVerifyOtp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authVerifyOtp>>, TError,{data: AuthVerifyOtpBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authVerifyOtp>>,
        TError,
        {data: AuthVerifyOtpBody},
        TContext
      > => {

      const mutationOptions = getAuthVerifyOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary POST /api/verify-registration-otp
 */
export const registrationVerifyRegistrationOtp = (
    registrationVerifyRegistrationOtpBody?: RegistrationVerifyRegistrationOtpBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/verify-registration-otp`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registrationVerifyRegistrationOtpBody, signal
    },
      );
    }
  


export const getRegistrationVerifyRegistrationOtpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext> => {

const mutationKey = ['registrationVerifyRegistrationOtp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, {data: RegistrationVerifyRegistrationOtpBody}> = (props) => {
          const {data} = props ?? {};

          return  registrationVerifyRegistrationOtp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegistrationVerifyRegistrationOtpMutationResult = NonNullable<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>>
    export type RegistrationVerifyRegistrationOtpMutationBody = RegistrationVerifyRegistrationOtpBody
    export type RegistrationVerifyRegistrationOtpMutationError = unknown

    /**
 * @summary POST /api/verify-registration-otp
 */
export const useRegistrationVerifyRegistrationOtp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>, TError,{data: RegistrationVerifyRegistrationOtpBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registrationVerifyRegistrationOtp>>,
        TError,
        {data: RegistrationVerifyRegistrationOtpBody},
        TContext
      > => {

      const mutationOptions = getRegistrationVerifyRegistrationOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Request JSON: { "text": "..." }
Returns: { hf_ner: [...], spacy_entities: [...], tokens: [...] }
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const ocrDebugNer = (
    ocrDebugNerBody?: OcrDebugNerBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/debug_ner`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrDebugNerBody, signal
    },
      );
    }
  


export const getOcrDebugNerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext> => {

const mutationKey = ['ocrDebugNer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrDebugNer>>, {data: OcrDebugNerBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrDebugNer(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrDebugNerMutationResult = NonNullable<Awaited<ReturnType<typeof ocrDebugNer>>>
    export type OcrDebugNerMutationBody = OcrDebugNerBody
    export type OcrDebugNerMutationError = unknown

    /**
 * @summary Debug endpoint to run HF NER and spaCy on provided text and return detailed outputs.
 */
export const useOcrDebugNer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrDebugNer>>, TError,{data: OcrDebugNerBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrDebugNer>>,
        TError,
        {data: OcrDebugNerBody},
        TContext
      > => {

      const mutationOptions = getOcrDebugNerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Extract entities from image using OCR
 */
export const ocrExtractEntities = (
    ocrExtractEntitiesBody?: OcrExtractEntitiesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/entities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrExtractEntitiesBody, signal
    },
      );
    }
  


export const getOcrExtractEntitiesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext> => {

const mutationKey = ['ocrExtractEntities'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractEntities>>, {data: OcrExtractEntitiesBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractEntities(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractEntitiesMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractEntities>>>
    export type OcrExtractEntitiesMutationBody = OcrExtractEntitiesBody
    export type OcrExtractEntitiesMutationError = unknown

    /**
 * @summary Extract entities from image using OCR
 */
export const useOcrExtractEntities = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractEntities>>, TError,{data: OcrExtractEntitiesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractEntities>>,
        TError,
        {data: OcrExtractEntitiesBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractEntitiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Extract patient name from image using OCR
 */
export const ocrExtractPatientName = (
    ocrExtractPatientNameBody?: OcrExtractPatientNameBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/extract_patient`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrExtractPatientNameBody, signal
    },
      );
    }
  


export const getOcrExtractPatientNameMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext> => {

const mutationKey = ['ocrExtractPatientName'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrExtractPatientName>>, {data: OcrExtractPatientNameBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrExtractPatientName(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrExtractPatientNameMutationResult = NonNullable<Awaited<ReturnType<typeof ocrExtractPatientName>>>
    export type OcrExtractPatientNameMutationBody = OcrExtractPatientNameBody
    export type OcrExtractPatientNameMutationError = unknown

    /**
 * @summary Extract patient name from image using OCR
 */
export const useOcrExtractPatientName = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrExtractPatientName>>, TError,{data: OcrExtractPatientNameBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrExtractPatientName>>,
        TError,
        {data: OcrExtractPatientNameBody},
        TContext
      > => {

      const mutationOptions = getOcrExtractPatientNameMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Health check endpoint (moved from app.py)
 */
export const ocrHealthCheck = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  



export const getOcrHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getOcrHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOcrHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ocrHealthCheck>>> = ({ signal }) => ocrHealthCheck(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type OcrHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof ocrHealthCheck>>>
export type OcrHealthCheckQueryError = unknown


export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ocrHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof ocrHealthCheck>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health check endpoint (moved from app.py)
 */

export function useOcrHealthCheck<TData = Awaited<ReturnType<typeof ocrHealthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ocrHealthCheck>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getOcrHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initialize database and create tables
 */
export const ocrInitDatabase = (
    ocrInitDatabaseBody?: OcrInitDatabaseBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/init-db`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrInitDatabaseBody, signal
    },
      );
    }
  


export const getOcrInitDatabaseMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext> => {

const mutationKey = ['ocrInitDatabase'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitDatabase>>, {data: OcrInitDatabaseBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitDatabase(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitDatabase>>>
    export type OcrInitDatabaseMutationBody = OcrInitDatabaseBody
    export type OcrInitDatabaseMutationError = unknown

    /**
 * @summary Initialize database and create tables
 */
export const useOcrInitDatabase = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitDatabase>>, TError,{data: OcrInitDatabaseBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitDatabase>>,
        TError,
        {data: OcrInitDatabaseBody},
        TContext
      > => {

      const mutationOptions = getOcrInitDatabaseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Starts model initialization in a background thread so the HTTP request
can return quickly and heavy imports/downloads happen asynchronously.
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const ocrInitializeNlpEndpoint = (
    ocrInitializeNlpEndpointBody?: OcrInitializeNlpEndpointBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/initialize`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrInitializeNlpEndpointBody, signal
    },
      );
    }
  


export const getOcrInitializeNlpEndpointMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext> => {

const mutationKey = ['ocrInitializeNlpEndpoint'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, {data: OcrInitializeNlpEndpointBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrInitializeNlpEndpoint(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrInitializeNlpEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>>
    export type OcrInitializeNlpEndpointMutationBody = OcrInitializeNlpEndpointBody
    export type OcrInitializeNlpEndpointMutationError = unknown

    /**
 * @summary Initialize NLP/OCR service (non-blocking).
 */
export const useOcrInitializeNlpEndpoint = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>, TError,{data: OcrInitializeNlpEndpointBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrInitializeNlpEndpoint>>,
        TError,
        {data: OcrInitializeNlpEndpointBody},
        TContext
      > => {

      const mutationOptions = getOcrInitializeNlpEndpointMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Accepts either JSON with {'image_path': '/abs/path/to/file'} or
{'text': 'raw extracted text'} so frontend clients can send text-only
NLP requests without uploading images to the backend.
 * @summary Process document with OCR
 */
export const ocrProcessDocument = (
    ocrProcessDocumentBody?: OcrProcessDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/process`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrProcessDocumentBody, signal
    },
      );
    }
  


export const getOcrProcessDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext> => {

const mutationKey = ['ocrProcessDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrProcessDocument>>, {data: OcrProcessDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrProcessDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrProcessDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof ocrProcessDocument>>>
    export type OcrProcessDocumentMutationBody = OcrProcessDocumentBody
    export type OcrProcessDocumentMutationError = unknown

    /**
 * @summary Process document with OCR
 */
export const useOcrProcessDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrProcessDocument>>, TError,{data: OcrProcessDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrProcessDocument>>,
        TError,
        {data: OcrProcessDocumentBody},
        TContext
      > => {

      const mutationOptions = getOcrProcessDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Accepts either {'image_path1':..., 'image_path2':...} or {'text1':..., 'text2':...}
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const ocrCalculateSimilarity = (
    ocrCalculateSimilarityBody?: OcrCalculateSimilarityBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/similarity`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrCalculateSimilarityBody, signal
    },
      );
    }
  


export const getOcrCalculateSimilarityMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext> => {

const mutationKey = ['ocrCalculateSimilarity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, {data: OcrCalculateSimilarityBody}> = (props) => {
          const {data} = props ?? {};

          return  ocrCalculateSimilarity(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OcrCalculateSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof ocrCalculateSimilarity>>>
    export type OcrCalculateSimilarityMutationBody = OcrCalculateSimilarityBody
    export type OcrCalculateSimilarityMutationError = unknown

    /**
 * @summary Calculate similarity between two images or between two pieces of text
 */
export const useOcrCalculateSimilarity = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ocrCalculateSimilarity>>, TError,{data: OcrCalculateSimilarityBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ocrCalculateSimilarity>>,
        TError,
        {data: OcrCalculateSimilarityBody},
        TContext
      > => {

      const mutationOptions = getOcrCalculateSimilarityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This helps local development: visit http://<backend-host>:<port>/swagger.html so the
Swagger UI and `/api/openapi.yaml` are on the same origin and no CORS overrides are needed.
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */
export const serveSwaggerUi = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/swagger.html`, method: 'GET', signal
    },
      );
    }
  



export const getServeSwaggerUiQueryKey = () => {
    return [
    `/swagger.html`
    ] as const;
    }

    
export const getServeSwaggerUiQueryOptions = <TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeSwaggerUiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveSwaggerUi>>> = ({ signal }) => serveSwaggerUi(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ServeSwaggerUiQueryResult = NonNullable<Awaited<ReturnType<typeof serveSwaggerUi>>>
export type ServeSwaggerUiQueryError = unknown


export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSwaggerUi>>,
          TError,
          Awaited<ReturnType<typeof serveSwaggerUi>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */

export function useServeSwaggerUi<TData = Awaited<ReturnType<typeof serveSwaggerUi>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSwaggerUi>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getServeSwaggerUiQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get SMS Provider Configuration
 */
export const getApiSmsConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiSmsConfig200>(
      {url: `/api/sms/config`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiSmsConfigQueryKey = () => {
    return [
    `/api/sms/config`
    ] as const;
    }

    
export const getGetApiSmsConfigQueryOptions = <TData = Awaited<ReturnType<typeof getApiSmsConfig>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSmsConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSmsConfig>>> = ({ signal }) => getApiSmsConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiSmsConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSmsConfig>>>
export type GetApiSmsConfigQueryError = unknown


export function useGetApiSmsConfig<TData = Awaited<ReturnType<typeof getApiSmsConfig>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsConfig>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsConfig<TData = Awaited<ReturnType<typeof getApiSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsConfig>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsConfig<TData = Awaited<ReturnType<typeof getApiSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get SMS Provider Configuration
 */

export function useGetApiSmsConfig<TData = Awaited<ReturnType<typeof getApiSmsConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiSmsConfigQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update SMS Provider Configuration
 */
export const putApiSmsConfig = (
    putApiSmsConfigBody: PutApiSmsConfigBody,
 ) => {
      
      
      return adminApi<SMSProviderConfig>(
      {url: `/api/sms/config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putApiSmsConfigBody
    },
      );
    }
  


export const getPutApiSmsConfigMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiSmsConfig>>, TError,{data: PutApiSmsConfigBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiSmsConfig>>, TError,{data: PutApiSmsConfigBody}, TContext> => {

const mutationKey = ['putApiSmsConfig'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiSmsConfig>>, {data: PutApiSmsConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  putApiSmsConfig(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiSmsConfigMutationResult = NonNullable<Awaited<ReturnType<typeof putApiSmsConfig>>>
    export type PutApiSmsConfigMutationBody = PutApiSmsConfigBody
    export type PutApiSmsConfigMutationError = unknown

    /**
 * @summary Update SMS Provider Configuration
 */
export const usePutApiSmsConfig = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiSmsConfig>>, TError,{data: PutApiSmsConfigBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiSmsConfig>>,
        TError,
        {data: PutApiSmsConfigBody},
        TContext
      > => {

      const mutationOptions = getPutApiSmsConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List SMS Headers
 */
export const getApiSmsHeaders = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<SMSHeaderRequest[]>(
      {url: `/api/sms/headers`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiSmsHeadersQueryKey = () => {
    return [
    `/api/sms/headers`
    ] as const;
    }

    
export const getGetApiSmsHeadersQueryOptions = <TData = Awaited<ReturnType<typeof getApiSmsHeaders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSmsHeadersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSmsHeaders>>> = ({ signal }) => getApiSmsHeaders(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiSmsHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSmsHeaders>>>
export type GetApiSmsHeadersQueryError = unknown


export function useGetApiSmsHeaders<TData = Awaited<ReturnType<typeof getApiSmsHeaders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsHeaders<TData = Awaited<ReturnType<typeof getApiSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsHeaders<TData = Awaited<ReturnType<typeof getApiSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List SMS Headers
 */

export function useGetApiSmsHeaders<TData = Awaited<ReturnType<typeof getApiSmsHeaders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiSmsHeadersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Request SMS Header
 */
export const postApiSmsHeaders = (
    postApiSmsHeadersBody: PostApiSmsHeadersBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SMSHeaderRequest>(
      {url: `/api/sms/headers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postApiSmsHeadersBody, signal
    },
      );
    }
  


export const getPostApiSmsHeadersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsHeaders>>, TError,{data: PostApiSmsHeadersBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiSmsHeaders>>, TError,{data: PostApiSmsHeadersBody}, TContext> => {

const mutationKey = ['postApiSmsHeaders'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSmsHeaders>>, {data: PostApiSmsHeadersBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiSmsHeaders(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSmsHeadersMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSmsHeaders>>>
    export type PostApiSmsHeadersMutationBody = PostApiSmsHeadersBody
    export type PostApiSmsHeadersMutationError = unknown

    /**
 * @summary Request SMS Header
 */
export const usePostApiSmsHeaders = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsHeaders>>, TError,{data: PostApiSmsHeadersBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSmsHeaders>>,
        TError,
        {data: PostApiSmsHeadersBody},
        TContext
      > => {

      const mutationOptions = getPostApiSmsHeadersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List SMS Packages
 */
export const getApiSmsPackages = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<SMSPackage[]>(
      {url: `/api/sms/packages`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiSmsPackagesQueryKey = () => {
    return [
    `/api/sms/packages`
    ] as const;
    }

    
export const getGetApiSmsPackagesQueryOptions = <TData = Awaited<ReturnType<typeof getApiSmsPackages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSmsPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSmsPackages>>> = ({ signal }) => getApiSmsPackages(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiSmsPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSmsPackages>>>
export type GetApiSmsPackagesQueryError = unknown


export function useGetApiSmsPackages<TData = Awaited<ReturnType<typeof getApiSmsPackages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsPackages<TData = Awaited<ReturnType<typeof getApiSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsPackages<TData = Awaited<ReturnType<typeof getApiSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List SMS Packages
 */

export function useGetApiSmsPackages<TData = Awaited<ReturnType<typeof getApiSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiSmsPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Tenant SMS Credit
 */
export const getApiSmsCredit = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<TenantSMSCredit>(
      {url: `/api/sms/credit`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiSmsCreditQueryKey = () => {
    return [
    `/api/sms/credit`
    ] as const;
    }

    
export const getGetApiSmsCreditQueryOptions = <TData = Awaited<ReturnType<typeof getApiSmsCredit>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSmsCreditQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSmsCredit>>> = ({ signal }) => getApiSmsCredit(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiSmsCreditQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSmsCredit>>>
export type GetApiSmsCreditQueryError = unknown


export function useGetApiSmsCredit<TData = Awaited<ReturnType<typeof getApiSmsCredit>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsCredit>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsCredit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsCredit<TData = Awaited<ReturnType<typeof getApiSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsCredit>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsCredit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsCredit<TData = Awaited<ReturnType<typeof getApiSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Tenant SMS Credit
 */

export function useGetApiSmsCredit<TData = Awaited<ReturnType<typeof getApiSmsCredit>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsCredit>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiSmsCreditQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin List SMS Packages
 */
export const getApiAdminSmsPackages = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiAdminSmsPackages200>(
      {url: `/api/admin/sms/packages`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiAdminSmsPackagesQueryKey = () => {
    return [
    `/api/admin/sms/packages`
    ] as const;
    }

    
export const getGetApiAdminSmsPackagesQueryOptions = <TData = Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiAdminSmsPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiAdminSmsPackages>>> = ({ signal }) => getApiAdminSmsPackages(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiAdminSmsPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiAdminSmsPackages>>>
export type GetApiAdminSmsPackagesQueryError = unknown


export function useGetApiAdminSmsPackages<TData = Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiAdminSmsPackages<TData = Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminSmsPackages>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminSmsPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiAdminSmsPackages<TData = Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Packages
 */

export function useGetApiAdminSmsPackages<TData = Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsPackages>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiAdminSmsPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin Create SMS Package
 */
export const postApiAdminSmsPackages = (
    postApiAdminSmsPackagesBody: PostApiAdminSmsPackagesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SMSPackage>(
      {url: `/api/admin/sms/packages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postApiAdminSmsPackagesBody, signal
    },
      );
    }
  


export const getPostApiAdminSmsPackagesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAdminSmsPackages>>, TError,{data: PostApiAdminSmsPackagesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiAdminSmsPackages>>, TError,{data: PostApiAdminSmsPackagesBody}, TContext> => {

const mutationKey = ['postApiAdminSmsPackages'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAdminSmsPackages>>, {data: PostApiAdminSmsPackagesBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiAdminSmsPackages(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAdminSmsPackagesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAdminSmsPackages>>>
    export type PostApiAdminSmsPackagesMutationBody = PostApiAdminSmsPackagesBody
    export type PostApiAdminSmsPackagesMutationError = unknown

    /**
 * @summary Admin Create SMS Package
 */
export const usePostApiAdminSmsPackages = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAdminSmsPackages>>, TError,{data: PostApiAdminSmsPackagesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAdminSmsPackages>>,
        TError,
        {data: PostApiAdminSmsPackagesBody},
        TContext
      > => {

      const mutationOptions = getPostApiAdminSmsPackagesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin Update SMS Package
 */
export const putApiAdminSmsPackagesPkgId = (
    pkgId: string,
    putApiAdminSmsPackagesPkgIdBody: PutApiAdminSmsPackagesPkgIdBody,
 ) => {
      
      
      return adminApi<SMSPackage>(
      {url: `/api/admin/sms/packages/${pkgId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putApiAdminSmsPackagesPkgIdBody
    },
      );
    }
  


export const getPutApiAdminSmsPackagesPkgIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>, TError,{pkgId: string;data: PutApiAdminSmsPackagesPkgIdBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>, TError,{pkgId: string;data: PutApiAdminSmsPackagesPkgIdBody}, TContext> => {

const mutationKey = ['putApiAdminSmsPackagesPkgId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>, {pkgId: string;data: PutApiAdminSmsPackagesPkgIdBody}> = (props) => {
          const {pkgId,data} = props ?? {};

          return  putApiAdminSmsPackagesPkgId(pkgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiAdminSmsPackagesPkgIdMutationResult = NonNullable<Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>>
    export type PutApiAdminSmsPackagesPkgIdMutationBody = PutApiAdminSmsPackagesPkgIdBody
    export type PutApiAdminSmsPackagesPkgIdMutationError = unknown

    /**
 * @summary Admin Update SMS Package
 */
export const usePutApiAdminSmsPackagesPkgId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>, TError,{pkgId: string;data: PutApiAdminSmsPackagesPkgIdBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiAdminSmsPackagesPkgId>>,
        TError,
        {pkgId: string;data: PutApiAdminSmsPackagesPkgIdBody},
        TContext
      > => {

      const mutationOptions = getPutApiAdminSmsPackagesPkgIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin List SMS Headers
 */
export const getApiAdminSmsHeaders = (
    params?: GetApiAdminSmsHeadersParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiAdminSmsHeaders200>(
      {url: `/api/admin/sms/headers`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetApiAdminSmsHeadersQueryKey = (params?: GetApiAdminSmsHeadersParams,) => {
    return [
    `/api/admin/sms/headers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiAdminSmsHeadersQueryOptions = <TData = Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError = unknown>(params?: GetApiAdminSmsHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiAdminSmsHeadersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>> = ({ signal }) => getApiAdminSmsHeaders(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiAdminSmsHeadersQueryResult = NonNullable<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>>
export type GetApiAdminSmsHeadersQueryError = unknown


export function useGetApiAdminSmsHeaders<TData = Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError = unknown>(
 params: undefined |  GetApiAdminSmsHeadersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiAdminSmsHeaders<TData = Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError = unknown>(
 params?: GetApiAdminSmsHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminSmsHeaders>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminSmsHeaders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiAdminSmsHeaders<TData = Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError = unknown>(
 params?: GetApiAdminSmsHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Admin List SMS Headers
 */

export function useGetApiAdminSmsHeaders<TData = Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError = unknown>(
 params?: GetApiAdminSmsHeadersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminSmsHeaders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiAdminSmsHeadersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Admin Update SMS Header Status
 */
export const putApiAdminSmsHeadersHeaderIdStatus = (
    headerId: string,
    putApiAdminSmsHeadersHeaderIdStatusBody: PutApiAdminSmsHeadersHeaderIdStatusBody,
 ) => {
      
      
      return adminApi<SMSHeaderRequest>(
      {url: `/api/admin/sms/headers/${headerId}/status`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putApiAdminSmsHeadersHeaderIdStatusBody
    },
      );
    }
  


export const getPutApiAdminSmsHeadersHeaderIdStatusMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>, TError,{headerId: string;data: PutApiAdminSmsHeadersHeaderIdStatusBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>, TError,{headerId: string;data: PutApiAdminSmsHeadersHeaderIdStatusBody}, TContext> => {

const mutationKey = ['putApiAdminSmsHeadersHeaderIdStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>, {headerId: string;data: PutApiAdminSmsHeadersHeaderIdStatusBody}> = (props) => {
          const {headerId,data} = props ?? {};

          return  putApiAdminSmsHeadersHeaderIdStatus(headerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiAdminSmsHeadersHeaderIdStatusMutationResult = NonNullable<Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>>
    export type PutApiAdminSmsHeadersHeaderIdStatusMutationBody = PutApiAdminSmsHeadersHeaderIdStatusBody
    export type PutApiAdminSmsHeadersHeaderIdStatusMutationError = unknown

    /**
 * @summary Admin Update SMS Header Status
 */
export const usePutApiAdminSmsHeadersHeaderIdStatus = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>, TError,{headerId: string;data: PutApiAdminSmsHeadersHeaderIdStatusBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiAdminSmsHeadersHeaderIdStatus>>,
        TError,
        {headerId: string;data: PutApiAdminSmsHeadersHeaderIdStatusBody},
        TContext
      > => {

      const mutationOptions = getPutApiAdminSmsHeadersHeaderIdStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Upload SMS Document
 */
export const postApiSmsUpload = (
    postApiSmsUploadBody: PostApiSmsUploadBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(postApiSmsUploadBody.file !== undefined) {
 formData.append(`file`, postApiSmsUploadBody.file)
 }

      return adminApi<PostApiSmsUpload200>(
      {url: `/api/sms/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getPostApiSmsUploadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsUpload>>, TError,{data: PostApiSmsUploadBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiSmsUpload>>, TError,{data: PostApiSmsUploadBody}, TContext> => {

const mutationKey = ['postApiSmsUpload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSmsUpload>>, {data: PostApiSmsUploadBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiSmsUpload(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSmsUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSmsUpload>>>
    export type PostApiSmsUploadMutationBody = PostApiSmsUploadBody
    export type PostApiSmsUploadMutationError = unknown

    /**
 * @summary Upload SMS Document
 */
export const usePostApiSmsUpload = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsUpload>>, TError,{data: PostApiSmsUploadBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSmsUpload>>,
        TError,
        {data: PostApiSmsUploadBody},
        TContext
      > => {

      const mutationOptions = getPostApiSmsUploadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Target Audiences
 */
export const getApiSmsAudiences = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiSmsAudiences200>(
      {url: `/api/sms/audiences`, method: 'GET', signal
    },
      );
    }
  



export const getGetApiSmsAudiencesQueryKey = () => {
    return [
    `/api/sms/audiences`
    ] as const;
    }

    
export const getGetApiSmsAudiencesQueryOptions = <TData = Awaited<ReturnType<typeof getApiSmsAudiences>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSmsAudiencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSmsAudiences>>> = ({ signal }) => getApiSmsAudiences(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiSmsAudiencesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSmsAudiences>>>
export type GetApiSmsAudiencesQueryError = unknown


export function useGetApiSmsAudiences<TData = Awaited<ReturnType<typeof getApiSmsAudiences>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsAudiences>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsAudiences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsAudiences<TData = Awaited<ReturnType<typeof getApiSmsAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSmsAudiences>>,
          TError,
          Awaited<ReturnType<typeof getApiSmsAudiences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiSmsAudiences<TData = Awaited<ReturnType<typeof getApiSmsAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Target Audiences
 */

export function useGetApiSmsAudiences<TData = Awaited<ReturnType<typeof getApiSmsAudiences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSmsAudiences>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiSmsAudiencesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Target Audience
 */
export const postApiSmsAudiences = (
    postApiSmsAudiencesBody: PostApiSmsAudiencesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<TargetAudience>(
      {url: `/api/sms/audiences`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postApiSmsAudiencesBody, signal
    },
      );
    }
  


export const getPostApiSmsAudiencesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiences>>, TError,{data: PostApiSmsAudiencesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiences>>, TError,{data: PostApiSmsAudiencesBody}, TContext> => {

const mutationKey = ['postApiSmsAudiences'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSmsAudiences>>, {data: PostApiSmsAudiencesBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiSmsAudiences(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSmsAudiencesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSmsAudiences>>>
    export type PostApiSmsAudiencesMutationBody = PostApiSmsAudiencesBody
    export type PostApiSmsAudiencesMutationError = unknown

    /**
 * @summary Create Target Audience
 */
export const usePostApiSmsAudiences = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiences>>, TError,{data: PostApiSmsAudiencesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSmsAudiences>>,
        TError,
        {data: PostApiSmsAudiencesBody},
        TContext
      > => {

      const mutationOptions = getPostApiSmsAudiencesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Upload Audience Excel
 */
export const postApiSmsAudiencesUpload = (
    postApiSmsAudiencesUploadBody: PostApiSmsAudiencesUploadBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(postApiSmsAudiencesUploadBody.file !== undefined) {
 formData.append(`file`, postApiSmsAudiencesUploadBody.file)
 }

      return adminApi<PostApiSmsAudiencesUpload201>(
      {url: `/api/sms/audiences/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getPostApiSmsAudiencesUploadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>, TError,{data: PostApiSmsAudiencesUploadBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>, TError,{data: PostApiSmsAudiencesUploadBody}, TContext> => {

const mutationKey = ['postApiSmsAudiencesUpload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>, {data: PostApiSmsAudiencesUploadBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiSmsAudiencesUpload(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSmsAudiencesUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>>
    export type PostApiSmsAudiencesUploadMutationBody = PostApiSmsAudiencesUploadBody
    export type PostApiSmsAudiencesUploadMutationError = unknown

    /**
 * @summary Upload Audience Excel
 */
export const usePostApiSmsAudiencesUpload = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>, TError,{data: PostApiSmsAudiencesUploadBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSmsAudiencesUpload>>,
        TError,
        {data: PostApiSmsAudiencesUploadBody},
        TContext
      > => {

      const mutationOptions = getPostApiSmsAudiencesUploadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Activity Logs
 */
export const getApiActivityLogs = (
    params?: GetApiActivityLogsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetApiActivityLogs200>(
      {url: `/api/activity-logs`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetApiActivityLogsQueryKey = (params?: GetApiActivityLogsParams,) => {
    return [
    `/api/activity-logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiActivityLogsQueryOptions = <TData = Awaited<ReturnType<typeof getApiActivityLogs>>, TError = unknown>(params?: GetApiActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiActivityLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiActivityLogs>>> = ({ signal }) => getApiActivityLogs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiActivityLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiActivityLogs>>>
export type GetApiActivityLogsQueryError = unknown


export function useGetApiActivityLogs<TData = Awaited<ReturnType<typeof getApiActivityLogs>>, TError = unknown>(
 params: undefined |  GetApiActivityLogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof getApiActivityLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiActivityLogs<TData = Awaited<ReturnType<typeof getApiActivityLogs>>, TError = unknown>(
 params?: GetApiActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiActivityLogs>>,
          TError,
          Awaited<ReturnType<typeof getApiActivityLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiActivityLogs<TData = Awaited<ReturnType<typeof getApiActivityLogs>>, TError = unknown>(
 params?: GetApiActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Activity Logs
 */

export function useGetApiActivityLogs<TData = Awaited<ReturnType<typeof getApiActivityLogs>>, TError = unknown>(
 params?: GetApiActivityLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiActivityLogs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetApiActivityLogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Change Password
 */
export const usersChangePassword = (
    usersChangePasswordBody: UsersChangePasswordBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<UsersChangePassword200>(
      {url: `/api/users/me/password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: usersChangePasswordBody, signal
    },
      );
    }
  


export const getUsersChangePasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext> => {

const mutationKey = ['usersChangePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersChangePassword>>, {data: UsersChangePasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  usersChangePassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersChangePassword>>>
    export type UsersChangePasswordMutationBody = UsersChangePasswordBody
    export type UsersChangePasswordMutationError = unknown

    /**
 * @summary Change Password
 */
export const useUsersChangePassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersChangePassword>>, TError,{data: UsersChangePasswordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersChangePassword>>,
        TError,
        {data: UsersChangePasswordBody},
        TContext
      > => {

      const mutationOptions = getUsersChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Sync invoices from BirFatura
 */
export const birfaturaSyncInvoices = (
    birfaturaSyncInvoicesBody?: BirfaturaSyncInvoicesBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/birfatura/sync-invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: birfaturaSyncInvoicesBody, signal
    },
      );
    }
  


export const getBirfaturaSyncInvoicesMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext> => {

const mutationKey = ['birfaturaSyncInvoices'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, {data: BirfaturaSyncInvoicesBody}> = (props) => {
          const {data} = props ?? {};

          return  birfaturaSyncInvoices(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BirfaturaSyncInvoicesMutationResult = NonNullable<Awaited<ReturnType<typeof birfaturaSyncInvoices>>>
    export type BirfaturaSyncInvoicesMutationBody = BirfaturaSyncInvoicesBody
    export type BirfaturaSyncInvoicesMutationError = void

    /**
 * @summary Sync invoices from BirFatura
 */
export const useBirfaturaSyncInvoices = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof birfaturaSyncInvoices>>, TError,{data: BirfaturaSyncInvoicesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof birfaturaSyncInvoices>>,
        TError,
        {data: BirfaturaSyncInvoicesBody},
        TContext
      > => {

      const mutationOptions = getBirfaturaSyncInvoicesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Communication Templates
 */
export const communicationsListTemplates = (
    params?: CommunicationsListTemplatesParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<CommunicationsListTemplates200>(
      {url: `/api/communications/templates`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCommunicationsListTemplatesQueryKey = (params?: CommunicationsListTemplatesParams,) => {
    return [
    `/api/communications/templates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCommunicationsListTemplatesQueryOptions = <TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = unknown>(params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsListTemplatesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsListTemplates>>> = ({ signal }) => communicationsListTemplates(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsListTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsListTemplates>>>
export type CommunicationsListTemplatesQueryError = unknown


export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = unknown>(
 params: undefined |  CommunicationsListTemplatesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = unknown>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsListTemplates>>,
          TError,
          Awaited<ReturnType<typeof communicationsListTemplates>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = unknown>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Communication Templates
 */

export function useCommunicationsListTemplates<TData = Awaited<ReturnType<typeof communicationsListTemplates>>, TError = unknown>(
 params?: CommunicationsListTemplatesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsListTemplates>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsListTemplatesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Communication Template
 */
export const communicationsCreateTemplate = (
    communicationTemplateCreateBody: CommunicationTemplateCreateBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<CommunicationTemplate>(
      {url: `/api/communications/templates`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: communicationTemplateCreateBody, signal
    },
      );
    }
  


export const getCommunicationsCreateTemplateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreateBody}, TContext> => {

const mutationKey = ['communicationsCreateTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsCreateTemplate>>, {data: CommunicationTemplateCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  communicationsCreateTemplate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsCreateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsCreateTemplate>>>
    export type CommunicationsCreateTemplateMutationBody = CommunicationTemplateCreateBody
    export type CommunicationsCreateTemplateMutationError = unknown

    /**
 * @summary Create Communication Template
 */
export const useCommunicationsCreateTemplate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsCreateTemplate>>, TError,{data: CommunicationTemplateCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsCreateTemplate>>,
        TError,
        {data: CommunicationTemplateCreateBody},
        TContext
      > => {

      const mutationOptions = getCommunicationsCreateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Communication Template
 */
export const communicationsGetTemplate = (
    templateId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<CommunicationTemplate>(
      {url: `/api/communications/templates/${templateId}`, method: 'GET', signal
    },
      );
    }
  



export const getCommunicationsGetTemplateQueryKey = (templateId?: string,) => {
    return [
    `/api/communications/templates/${templateId}`
    ] as const;
    }

    
export const getCommunicationsGetTemplateQueryOptions = <TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = unknown>(templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCommunicationsGetTemplateQueryKey(templateId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof communicationsGetTemplate>>> = ({ signal }) => communicationsGetTemplate(templateId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(templateId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CommunicationsGetTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof communicationsGetTemplate>>>
export type CommunicationsGetTemplateQueryError = unknown


export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = unknown>(
 templateId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = unknown>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof communicationsGetTemplate>>,
          TError,
          Awaited<ReturnType<typeof communicationsGetTemplate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = unknown>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Communication Template
 */

export function useCommunicationsGetTemplate<TData = Awaited<ReturnType<typeof communicationsGetTemplate>>, TError = unknown>(
 templateId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof communicationsGetTemplate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCommunicationsGetTemplateQueryOptions(templateId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Communication Template
 */
export const communicationsUpdateTemplate = (
    templateId: string,
    communicationTemplateCreateBody: CommunicationTemplateCreateBody,
 ) => {
      
      
      return adminApi<CommunicationTemplate>(
      {url: `/api/communications/templates/${templateId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: communicationTemplateCreateBody
    },
      );
    }
  


export const getCommunicationsUpdateTemplateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateCreateBody}, TContext> => {

const mutationKey = ['communicationsUpdateTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, {templateId: string;data: CommunicationTemplateCreateBody}> = (props) => {
          const {templateId,data} = props ?? {};

          return  communicationsUpdateTemplate(templateId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsUpdateTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsUpdateTemplate>>>
    export type CommunicationsUpdateTemplateMutationBody = CommunicationTemplateCreateBody
    export type CommunicationsUpdateTemplateMutationError = unknown

    /**
 * @summary Update Communication Template
 */
export const useCommunicationsUpdateTemplate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsUpdateTemplate>>, TError,{templateId: string;data: CommunicationTemplateCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsUpdateTemplate>>,
        TError,
        {templateId: string;data: CommunicationTemplateCreateBody},
        TContext
      > => {

      const mutationOptions = getCommunicationsUpdateTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete Communication Template
 */
export const communicationsDeleteTemplate = (
    templateId: string,
 ) => {
      
      
      return adminApi<CommunicationsDeleteTemplate200>(
      {url: `/api/communications/templates/${templateId}`, method: 'DELETE'
    },
      );
    }
  


export const getCommunicationsDeleteTemplateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext> => {

const mutationKey = ['communicationsDeleteTemplate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, {templateId: string}> = (props) => {
          const {templateId} = props ?? {};

          return  communicationsDeleteTemplate(templateId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommunicationsDeleteTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof communicationsDeleteTemplate>>>
    
    export type CommunicationsDeleteTemplateMutationError = unknown

    /**
 * @summary Delete Communication Template
 */
export const useCommunicationsDeleteTemplate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof communicationsDeleteTemplate>>, TError,{templateId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof communicationsDeleteTemplate>>,
        TError,
        {templateId: string},
        TContext
      > => {

      const mutationOptions = getCommunicationsDeleteTemplateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Upload SMS Document to S3
 */
export const smsUploadDocument = (
    smsUploadDocumentBody: SmsUploadDocumentBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, smsUploadDocumentBody.file)
formData.append(`documentType`, smsUploadDocumentBody.documentType)

      return adminApi<SmsUploadDocument200>(
      {url: `/api/sms/documents/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getSmsUploadDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext> => {

const mutationKey = ['smsUploadDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsUploadDocument>>, {data: SmsUploadDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  smsUploadDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsUploadDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsUploadDocument>>>
    export type SmsUploadDocumentMutationBody = SmsUploadDocumentBody
    export type SmsUploadDocumentMutationError = unknown

    /**
 * @summary Upload SMS Document to S3
 */
export const useSmsUploadDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsUploadDocument>>, TError,{data: SmsUploadDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsUploadDocument>>,
        TError,
        {data: SmsUploadDocumentBody},
        TContext
      > => {

      const mutationOptions = getSmsUploadDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get presigned URL for document download
 */
export const smsDownloadDocument = (
    documentType: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SmsDownloadDocument200>(
      {url: `/api/sms/documents/${documentType}/download`, method: 'GET', signal
    },
      );
    }
  



export const getSmsDownloadDocumentQueryKey = (documentType?: string,) => {
    return [
    `/api/sms/documents/${documentType}/download`
    ] as const;
    }

    
export const getSmsDownloadDocumentQueryOptions = <TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = unknown>(documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSmsDownloadDocumentQueryKey(documentType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof smsDownloadDocument>>> = ({ signal }) => smsDownloadDocument(documentType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SmsDownloadDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof smsDownloadDocument>>>
export type SmsDownloadDocumentQueryError = unknown


export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = unknown>(
 documentType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof smsDownloadDocument>>,
          TError,
          Awaited<ReturnType<typeof smsDownloadDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get presigned URL for document download
 */

export function useSmsDownloadDocument<TData = Awaited<ReturnType<typeof smsDownloadDocument>>, TError = unknown>(
 documentType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof smsDownloadDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSmsDownloadDocumentQueryOptions(documentType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Delete SMS Document
 */
export const smsDeleteDocument = (
    documentType: string,
 ) => {
      
      
      return adminApi<SmsDeleteDocument200>(
      {url: `/api/sms/documents/${documentType}`, method: 'DELETE'
    },
      );
    }
  


export const getSmsDeleteDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext> => {

const mutationKey = ['smsDeleteDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof smsDeleteDocument>>, {documentType: string}> = (props) => {
          const {documentType} = props ?? {};

          return  smsDeleteDocument(documentType,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SmsDeleteDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof smsDeleteDocument>>>
    
    export type SmsDeleteDocumentMutationError = unknown

    /**
 * @summary Delete SMS Document
 */
export const useSmsDeleteDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof smsDeleteDocument>>, TError,{documentType: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof smsDeleteDocument>>,
        TError,
        {documentType: string},
        TContext
      > => {

      const mutationOptions = getSmsDeleteDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Tenants
 */
export const getAdminTenants = (
    params?: GetAdminTenantsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminTenants200>(
      {url: `/api/admin/tenants`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminTenantsQueryKey = (params?: GetAdminTenantsParams,) => {
    return [
    `/api/admin/tenants`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminTenantsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminTenants>>, TError = unknown>(params?: GetAdminTenantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminTenantsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminTenants>>> = ({ signal }) => getAdminTenants(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminTenantsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminTenants>>>
export type GetAdminTenantsQueryError = unknown


export function useGetAdminTenants<TData = Awaited<ReturnType<typeof getAdminTenants>>, TError = unknown>(
 params: undefined |  GetAdminTenantsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTenants>>,
          TError,
          Awaited<ReturnType<typeof getAdminTenants>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTenants<TData = Awaited<ReturnType<typeof getAdminTenants>>, TError = unknown>(
 params?: GetAdminTenantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTenants>>,
          TError,
          Awaited<ReturnType<typeof getAdminTenants>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTenants<TData = Awaited<ReturnType<typeof getAdminTenants>>, TError = unknown>(
 params?: GetAdminTenantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Tenants
 */

export function useGetAdminTenants<TData = Awaited<ReturnType<typeof getAdminTenants>>, TError = unknown>(
 params?: GetAdminTenantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTenants>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminTenantsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Tenant
 */
export const createTenant = (
    tenant: Tenant,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Tenant>(
      {url: `/api/admin/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenant, signal
    },
      );
    }
  


export const getCreateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: Tenant}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: Tenant}, TContext> => {

const mutationKey = ['createTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: Tenant}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = Tenant
    export type CreateTenantMutationError = unknown

    /**
 * @summary Create Tenant
 */
export const useCreateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: Tenant}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTenant>>,
        TError,
        {data: Tenant},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Tenant
 */
export const getTenant = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetTenant200>(
      {url: `/api/admin/tenants/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetTenantQueryKey = (id?: string,) => {
    return [
    `/api/admin/tenants/${id}`
    ] as const;
    }

    
export const getGetTenantQueryOptions = <TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({ signal }) => getTenant(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantQueryResult = NonNullable<Awaited<ReturnType<typeof getTenant>>>
export type GetTenantQueryError = unknown


export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Tenant
 */

export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Tenant
 */
export const updateTenant = (
    id: string,
    tenant: Tenant,
 ) => {
      
      
      return adminApi<Tenant>(
      {url: `/api/admin/tenants/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: tenant
    },
      );
    }
  


export const getUpdateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{id: string;data: Tenant}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{id: string;data: Tenant}, TContext> => {

const mutationKey = ['updateTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenant>>, {id: string;data: Tenant}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTenant(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenant>>>
    export type UpdateTenantMutationBody = Tenant
    export type UpdateTenantMutationError = unknown

    /**
 * @summary Update Tenant
 */
export const useUpdateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{id: string;data: Tenant}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTenant>>,
        TError,
        {id: string;data: Tenant},
        TContext
      > => {

      const mutationOptions = getUpdateTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update Tenant Status
 */
export const updateTenantStatus = (
    id: string,
    updateTenantStatusBody: UpdateTenantStatusBody,
 ) => {
      
      
      return adminApi<Tenant>(
      {url: `/api/admin/tenants/${id}/status`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateTenantStatusBody
    },
      );
    }
  


export const getUpdateTenantStatusMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantStatus>>, TError,{id: string;data: UpdateTenantStatusBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenantStatus>>, TError,{id: string;data: UpdateTenantStatusBody}, TContext> => {

const mutationKey = ['updateTenantStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenantStatus>>, {id: string;data: UpdateTenantStatusBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTenantStatus(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenantStatus>>>
    export type UpdateTenantStatusMutationBody = UpdateTenantStatusBody
    export type UpdateTenantStatusMutationError = unknown

    /**
 * @summary Update Tenant Status
 */
export const useUpdateTenantStatus = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantStatus>>, TError,{id: string;data: UpdateTenantStatusBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTenantStatus>>,
        TError,
        {id: string;data: UpdateTenantStatusBody},
        TContext
      > => {

      const mutationOptions = getUpdateTenantStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Tenant Users
 */
export const getTenantUsers = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetTenantUsers200>(
      {url: `/api/admin/tenants/${id}/users`, method: 'GET', signal
    },
      );
    }
  



export const getGetTenantUsersQueryKey = (id?: string,) => {
    return [
    `/api/admin/tenants/${id}/users`
    ] as const;
    }

    
export const getGetTenantUsersQueryOptions = <TData = Awaited<ReturnType<typeof getTenantUsers>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantUsersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantUsers>>> = ({ signal }) => getTenantUsers(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantUsers>>>
export type GetTenantUsersQueryError = unknown


export function useGetTenantUsers<TData = Awaited<ReturnType<typeof getTenantUsers>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantUsers<TData = Awaited<ReturnType<typeof getTenantUsers>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantUsers<TData = Awaited<ReturnType<typeof getTenantUsers>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Tenant Users
 */

export function useGetTenantUsers<TData = Awaited<ReturnType<typeof getTenantUsers>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantUsersQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Tenant User
 */
export const createTenantUser = (
    id: string,
    user: User,
 signal?: AbortSignal
) => {
      
      
      return adminApi<User>(
      {url: `/api/admin/tenants/${id}/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: user, signal
    },
      );
    }
  


export const getCreateTenantUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenantUser>>, TError,{id: string;data: User}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTenantUser>>, TError,{id: string;data: User}, TContext> => {

const mutationKey = ['createTenantUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenantUser>>, {id: string;data: User}> = (props) => {
          const {id,data} = props ?? {};

          return  createTenantUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof createTenantUser>>>
    export type CreateTenantUserMutationBody = User
    export type CreateTenantUserMutationError = unknown

    /**
 * @summary Create Tenant User
 */
export const useCreateTenantUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenantUser>>, TError,{id: string;data: User}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTenantUser>>,
        TError,
        {id: string;data: User},
        TContext
      > => {

      const mutationOptions = getCreateTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Subscribe Tenant
 */
export const subscribeTenant = (
    id: string,
    subscribeTenantBody: SubscribeTenantBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Tenant>(
      {url: `/api/admin/tenants/${id}/subscribe`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subscribeTenantBody, signal
    },
      );
    }
  


export const getSubscribeTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscribeTenant>>, TError,{id: string;data: SubscribeTenantBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscribeTenant>>, TError,{id: string;data: SubscribeTenantBody}, TContext> => {

const mutationKey = ['subscribeTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscribeTenant>>, {id: string;data: SubscribeTenantBody}> = (props) => {
          const {id,data} = props ?? {};

          return  subscribeTenant(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscribeTenantMutationResult = NonNullable<Awaited<ReturnType<typeof subscribeTenant>>>
    export type SubscribeTenantMutationBody = SubscribeTenantBody
    export type SubscribeTenantMutationError = unknown

    /**
 * @summary Subscribe Tenant
 */
export const useSubscribeTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscribeTenant>>, TError,{id: string;data: SubscribeTenantBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscribeTenant>>,
        TError,
        {id: string;data: SubscribeTenantBody},
        TContext
      > => {

      const mutationOptions = getSubscribeTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Add Addon to Tenant
 */
export const addTenantAddon = (
    id: string,
    addTenantAddonBody: AddTenantAddonBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Tenant>(
      {url: `/api/admin/tenants/${id}/addons`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addTenantAddonBody, signal
    },
      );
    }
  


export const getAddTenantAddonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTenantAddon>>, TError,{id: string;data: AddTenantAddonBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addTenantAddon>>, TError,{id: string;data: AddTenantAddonBody}, TContext> => {

const mutationKey = ['addTenantAddon'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTenantAddon>>, {id: string;data: AddTenantAddonBody}> = (props) => {
          const {id,data} = props ?? {};

          return  addTenantAddon(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddTenantAddonMutationResult = NonNullable<Awaited<ReturnType<typeof addTenantAddon>>>
    export type AddTenantAddonMutationBody = AddTenantAddonBody
    export type AddTenantAddonMutationError = unknown

    /**
 * @summary Add Addon to Tenant
 */
export const useAddTenantAddon = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTenantAddon>>, TError,{id: string;data: AddTenantAddonBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addTenantAddon>>,
        TError,
        {id: string;data: AddTenantAddonBody},
        TContext
      > => {

      const mutationOptions = getAddTenantAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Plans
 */
export const getAdminPlans = (
    params?: GetAdminPlansParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminPlans200>(
      {url: `/api/admin/plans`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminPlansQueryKey = (params?: GetAdminPlansParams,) => {
    return [
    `/api/admin/plans`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminPlansQueryOptions = <TData = Awaited<ReturnType<typeof getAdminPlans>>, TError = unknown>(params?: GetAdminPlansParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminPlansQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminPlans>>> = ({ signal }) => getAdminPlans(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminPlansQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminPlans>>>
export type GetAdminPlansQueryError = unknown


export function useGetAdminPlans<TData = Awaited<ReturnType<typeof getAdminPlans>>, TError = unknown>(
 params: undefined |  GetAdminPlansParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminPlans>>,
          TError,
          Awaited<ReturnType<typeof getAdminPlans>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminPlans<TData = Awaited<ReturnType<typeof getAdminPlans>>, TError = unknown>(
 params?: GetAdminPlansParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminPlans>>,
          TError,
          Awaited<ReturnType<typeof getAdminPlans>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminPlans<TData = Awaited<ReturnType<typeof getAdminPlans>>, TError = unknown>(
 params?: GetAdminPlansParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Plans
 */

export function useGetAdminPlans<TData = Awaited<ReturnType<typeof getAdminPlans>>, TError = unknown>(
 params?: GetAdminPlansParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminPlans>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminPlansQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Plan
 */
export const createPlan = (
    planInput: PlanInput,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Plan>(
      {url: `/api/admin/plans`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: planInput, signal
    },
      );
    }
  


export const getCreatePlanMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlan>>, TError,{data: PlanInput}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPlan>>, TError,{data: PlanInput}, TContext> => {

const mutationKey = ['createPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPlan>>, {data: PlanInput}> = (props) => {
          const {data} = props ?? {};

          return  createPlan(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePlanMutationResult = NonNullable<Awaited<ReturnType<typeof createPlan>>>
    export type CreatePlanMutationBody = PlanInput
    export type CreatePlanMutationError = unknown

    /**
 * @summary Create Plan
 */
export const useCreatePlan = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlan>>, TError,{data: PlanInput}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPlan>>,
        TError,
        {data: PlanInput},
        TContext
      > => {

      const mutationOptions = getCreatePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Plan
 */
export const getPlan = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Plan>(
      {url: `/api/admin/plans/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetPlanQueryKey = (id?: string,) => {
    return [
    `/api/admin/plans/${id}`
    ] as const;
    }

    
export const getGetPlanQueryOptions = <TData = Awaited<ReturnType<typeof getPlan>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPlanQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlan>>> = ({ signal }) => getPlan(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPlanQueryResult = NonNullable<Awaited<ReturnType<typeof getPlan>>>
export type GetPlanQueryError = unknown


export function useGetPlan<TData = Awaited<ReturnType<typeof getPlan>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlan>>,
          TError,
          Awaited<ReturnType<typeof getPlan>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlan<TData = Awaited<ReturnType<typeof getPlan>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlan>>,
          TError,
          Awaited<ReturnType<typeof getPlan>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlan<TData = Awaited<ReturnType<typeof getPlan>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Plan
 */

export function useGetPlan<TData = Awaited<ReturnType<typeof getPlan>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlan>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPlanQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Plan
 */
export const updatePlan = (
    id: string,
    planInput: PlanInput,
 ) => {
      
      
      return adminApi<Plan>(
      {url: `/api/admin/plans/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: planInput
    },
      );
    }
  


export const getUpdatePlanMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePlan>>, TError,{id: string;data: PlanInput}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePlan>>, TError,{id: string;data: PlanInput}, TContext> => {

const mutationKey = ['updatePlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePlan>>, {id: string;data: PlanInput}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePlan(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePlanMutationResult = NonNullable<Awaited<ReturnType<typeof updatePlan>>>
    export type UpdatePlanMutationBody = PlanInput
    export type UpdatePlanMutationError = unknown

    /**
 * @summary Update Plan
 */
export const useUpdatePlan = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePlan>>, TError,{id: string;data: PlanInput}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePlan>>,
        TError,
        {id: string;data: PlanInput},
        TContext
      > => {

      const mutationOptions = getUpdatePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete Plan
 */
export const deletePlan = (
    id: string,
 ) => {
      
      
      return adminApi<DeletePlan200>(
      {url: `/api/admin/plans/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePlanMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePlan>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePlan>>, TError,{id: string}, TContext> => {

const mutationKey = ['deletePlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePlan>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deletePlan(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePlanMutationResult = NonNullable<Awaited<ReturnType<typeof deletePlan>>>
    
    export type DeletePlanMutationError = unknown

    /**
 * @summary Delete Plan
 */
export const useDeletePlan = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePlan>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePlan>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeletePlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Addons
 */
export const getAdminAddons = (
    params?: GetAdminAddonsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminAddons200>(
      {url: `/api/admin/addons`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminAddonsQueryKey = (params?: GetAdminAddonsParams,) => {
    return [
    `/api/admin/addons`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminAddonsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAddons>>, TError = unknown>(params?: GetAdminAddonsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAddonsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAddons>>> = ({ signal }) => getAdminAddons(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAddonsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAddons>>>
export type GetAdminAddonsQueryError = unknown


export function useGetAdminAddons<TData = Awaited<ReturnType<typeof getAdminAddons>>, TError = unknown>(
 params: undefined |  GetAdminAddonsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAddons>>,
          TError,
          Awaited<ReturnType<typeof getAdminAddons>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAddons<TData = Awaited<ReturnType<typeof getAdminAddons>>, TError = unknown>(
 params?: GetAdminAddonsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAddons>>,
          TError,
          Awaited<ReturnType<typeof getAdminAddons>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAddons<TData = Awaited<ReturnType<typeof getAdminAddons>>, TError = unknown>(
 params?: GetAdminAddonsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Addons
 */

export function useGetAdminAddons<TData = Awaited<ReturnType<typeof getAdminAddons>>, TError = unknown>(
 params?: GetAdminAddonsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddons>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAddonsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Addon
 */
export const createAdminAddon = (
    addOn: AddOn,
 signal?: AbortSignal
) => {
      
      
      return adminApi<AddOn>(
      {url: `/api/admin/addons`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addOn, signal
    },
      );
    }
  


export const getCreateAdminAddonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminAddon>>, TError,{data: AddOn}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminAddon>>, TError,{data: AddOn}, TContext> => {

const mutationKey = ['createAdminAddon'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminAddon>>, {data: AddOn}> = (props) => {
          const {data} = props ?? {};

          return  createAdminAddon(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminAddonMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminAddon>>>
    export type CreateAdminAddonMutationBody = AddOn
    export type CreateAdminAddonMutationError = unknown

    /**
 * @summary Create Addon
 */
export const useCreateAdminAddon = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminAddon>>, TError,{data: AddOn}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminAddon>>,
        TError,
        {data: AddOn},
        TContext
      > => {

      const mutationOptions = getCreateAdminAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Admin Users
 */
export const getAdminUsers = (
    params?: GetAdminUsersParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminUsers200>(
      {url: `/api/admin/users`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminUsersQueryKey = (params?: GetAdminUsersParams,) => {
    return [
    `/api/admin/users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = unknown>(params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminUsers>>> = ({ signal }) => getAdminUsers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminUsers>>>
export type GetAdminUsersQueryError = unknown


export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = unknown>(
 params: undefined |  GetAdminUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = unknown>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof getAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = unknown>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Admin Users
 */

export function useGetAdminUsers<TData = Awaited<ReturnType<typeof getAdminUsers>>, TError = unknown>(
 params?: GetAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Admin User
 */
export const createAdminUser = (
    adminUser: AdminUser,
 signal?: AbortSignal
) => {
      
      
      return adminApi<AdminUser>(
      {url: `/api/admin/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminUser, signal
    },
      );
    }
  


export const getCreateAdminUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: AdminUser}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: AdminUser}, TContext> => {

const mutationKey = ['createAdminUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminUser>>, {data: AdminUser}> = (props) => {
          const {data} = props ?? {};

          return  createAdminUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminUserMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminUser>>>
    export type CreateAdminUserMutationBody = AdminUser
    export type CreateAdminUserMutationError = unknown

    /**
 * @summary Create Admin User
 */
export const useCreateAdminUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUser>>, TError,{data: AdminUser}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminUser>>,
        TError,
        {data: AdminUser},
        TContext
      > => {

      const mutationOptions = getCreateAdminUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List All Tenant Users
 */
export const getAllTenantUsers = (
    params?: GetAllTenantUsersParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAllTenantUsers200>(
      {url: `/api/admin/users/all`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAllTenantUsersQueryKey = (params?: GetAllTenantUsersParams,) => {
    return [
    `/api/admin/users/all`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllTenantUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllTenantUsers>>, TError = unknown>(params?: GetAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTenantUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTenantUsers>>> = ({ signal }) => getAllTenantUsers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllTenantUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTenantUsers>>>
export type GetAllTenantUsersQueryError = unknown


export function useGetAllTenantUsers<TData = Awaited<ReturnType<typeof getAllTenantUsers>>, TError = unknown>(
 params: undefined |  GetAllTenantUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllTenantUsers<TData = Awaited<ReturnType<typeof getAllTenantUsers>>, TError = unknown>(
 params?: GetAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTenantUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllTenantUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllTenantUsers<TData = Awaited<ReturnType<typeof getAllTenantUsers>>, TError = unknown>(
 params?: GetAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List All Tenant Users
 */

export function useGetAllTenantUsers<TData = Awaited<ReturnType<typeof getAllTenantUsers>>, TError = unknown>(
 params?: GetAllTenantUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTenantUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAllTenantUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Any Tenant User
 */
export const updateAnyTenantUser = (
    id: string,
    updateAnyTenantUserBody: UpdateAnyTenantUserBody,
 ) => {
      
      
      return adminApi<AdminUser>(
      {url: `/api/admin/users/all/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAnyTenantUserBody
    },
      );
    }
  


export const getUpdateAnyTenantUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnyTenantUser>>, TError,{id: string;data: UpdateAnyTenantUserBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAnyTenantUser>>, TError,{id: string;data: UpdateAnyTenantUserBody}, TContext> => {

const mutationKey = ['updateAnyTenantUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAnyTenantUser>>, {id: string;data: UpdateAnyTenantUserBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAnyTenantUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAnyTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateAnyTenantUser>>>
    export type UpdateAnyTenantUserMutationBody = UpdateAnyTenantUserBody
    export type UpdateAnyTenantUserMutationError = unknown

    /**
 * @summary Update Any Tenant User
 */
export const useUpdateAnyTenantUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnyTenantUser>>, TError,{id: string;data: UpdateAnyTenantUserBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAnyTenantUser>>,
        TError,
        {id: string;data: UpdateAnyTenantUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateAnyTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Addon
 */
export const getAdminAddon = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminAddon200>(
      {url: `/api/admin/addons/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAdminAddonQueryKey = (id?: string,) => {
    return [
    `/api/admin/addons/${id}`
    ] as const;
    }

    
export const getGetAdminAddonQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAddon>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAddonQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAddon>>> = ({ signal }) => getAdminAddon(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAddonQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAddon>>>
export type GetAdminAddonQueryError = unknown


export function useGetAdminAddon<TData = Awaited<ReturnType<typeof getAdminAddon>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAddon>>,
          TError,
          Awaited<ReturnType<typeof getAdminAddon>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAddon<TData = Awaited<ReturnType<typeof getAdminAddon>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAddon>>,
          TError,
          Awaited<ReturnType<typeof getAdminAddon>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAddon<TData = Awaited<ReturnType<typeof getAdminAddon>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Addon
 */

export function useGetAdminAddon<TData = Awaited<ReturnType<typeof getAdminAddon>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAddon>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAddonQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Addon
 */
export const updateAdminAddon = (
    id: string,
    addOn: AddOn,
 ) => {
      
      
      return adminApi<UpdateAdminAddon200>(
      {url: `/api/admin/addons/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: addOn
    },
      );
    }
  


export const getUpdateAdminAddonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminAddon>>, TError,{id: string;data: AddOn}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminAddon>>, TError,{id: string;data: AddOn}, TContext> => {

const mutationKey = ['updateAdminAddon'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminAddon>>, {id: string;data: AddOn}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdminAddon(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminAddonMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminAddon>>>
    export type UpdateAdminAddonMutationBody = AddOn
    export type UpdateAdminAddonMutationError = unknown

    /**
 * @summary Update Addon
 */
export const useUpdateAdminAddon = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminAddon>>, TError,{id: string;data: AddOn}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminAddon>>,
        TError,
        {id: string;data: AddOn},
        TContext
      > => {

      const mutationOptions = getUpdateAdminAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete Addon
 */
export const deleteAdminAddon = (
    id: string,
 ) => {
      
      
      return adminApi<DeleteAdminAddon200>(
      {url: `/api/admin/addons/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdminAddonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdminAddon>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdminAddon>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteAdminAddon'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdminAddon>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdminAddon(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdminAddonMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdminAddon>>>
    
    export type DeleteAdminAddonMutationError = unknown

    /**
 * @summary Delete Addon
 */
export const useDeleteAdminAddon = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdminAddon>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdminAddon>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteAdminAddonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Support Tickets
 */
export const getAdminTickets = (
    params?: GetAdminTicketsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminTickets200>(
      {url: `/api/admin/tickets`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminTicketsQueryKey = (params?: GetAdminTicketsParams,) => {
    return [
    `/api/admin/tickets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminTicketsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = unknown>(params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminTicketsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminTickets>>> = ({ signal }) => getAdminTickets(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminTicketsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminTickets>>>
export type GetAdminTicketsQueryError = unknown


export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = unknown>(
 params: undefined |  GetAdminTicketsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof getAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = unknown>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof getAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = unknown>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Support Tickets
 */

export function useGetAdminTickets<TData = Awaited<ReturnType<typeof getAdminTickets>>, TError = unknown>(
 params?: GetAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminTicketsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Support Ticket
 */
export const createAdminTicket = (
    createAdminTicketBody: CreateAdminTicketBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<CreateAdminTicket201>(
      {url: `/api/admin/tickets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAdminTicketBody, signal
    },
      );
    }
  


export const getCreateAdminTicketMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateAdminTicketBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateAdminTicketBody}, TContext> => {

const mutationKey = ['createAdminTicket'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminTicket>>, {data: CreateAdminTicketBody}> = (props) => {
          const {data} = props ?? {};

          return  createAdminTicket(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminTicket>>>
    export type CreateAdminTicketMutationBody = CreateAdminTicketBody
    export type CreateAdminTicketMutationError = unknown

    /**
 * @summary Create Support Ticket
 */
export const useCreateAdminTicket = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicket>>, TError,{data: CreateAdminTicketBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminTicket>>,
        TError,
        {data: CreateAdminTicketBody},
        TContext
      > => {

      const mutationOptions = getCreateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update Support Ticket
 */
export const updateAdminTicket = (
    id: string,
    updateAdminTicketBody: UpdateAdminTicketBody,
 ) => {
      
      
      return adminApi<UpdateAdminTicket200>(
      {url: `/api/admin/tickets/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAdminTicketBody
    },
      );
    }
  


export const getUpdateAdminTicketMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{id: string;data: UpdateAdminTicketBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{id: string;data: UpdateAdminTicketBody}, TContext> => {

const mutationKey = ['updateAdminTicket'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminTicket>>, {id: string;data: UpdateAdminTicketBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdminTicket(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminTicket>>>
    export type UpdateAdminTicketMutationBody = UpdateAdminTicketBody
    export type UpdateAdminTicketMutationError = unknown

    /**
 * @summary Update Support Ticket
 */
export const useUpdateAdminTicket = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{id: string;data: UpdateAdminTicketBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminTicket>>,
        TError,
        {id: string;data: UpdateAdminTicketBody},
        TContext
      > => {

      const mutationOptions = getUpdateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get System Settings
 */
export const getAdminSettings = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminSettings200>(
      {url: `/api/admin/settings`, method: 'GET', signal
    },
      );
    }
  



export const getGetAdminSettingsQueryKey = () => {
    return [
    `/api/admin/settings`
    ] as const;
    }

    
export const getGetAdminSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminSettings>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminSettings>>> = ({ signal }) => getAdminSettings(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminSettings>>>
export type GetAdminSettingsQueryError = unknown


export function useGetAdminSettings<TData = Awaited<ReturnType<typeof getAdminSettings>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminSettings>>,
          TError,
          Awaited<ReturnType<typeof getAdminSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminSettings<TData = Awaited<ReturnType<typeof getAdminSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminSettings>>,
          TError,
          Awaited<ReturnType<typeof getAdminSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminSettings<TData = Awaited<ReturnType<typeof getAdminSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get System Settings
 */

export function useGetAdminSettings<TData = Awaited<ReturnType<typeof getAdminSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update System Settings
 */
export const updateAdminSettings = (
    systemSettings: SystemSettings,
 signal?: AbortSignal
) => {
      
      
      return adminApi<UpdateAdminSettings200>(
      {url: `/api/admin/settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: systemSettings, signal
    },
      );
    }
  


export const getUpdateAdminSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminSettings>>, TError,{data: SystemSettings}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminSettings>>, TError,{data: SystemSettings}, TContext> => {

const mutationKey = ['updateAdminSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminSettings>>, {data: SystemSettings}> = (props) => {
          const {data} = props ?? {};

          return  updateAdminSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminSettings>>>
    export type UpdateAdminSettingsMutationBody = SystemSettings
    export type UpdateAdminSettingsMutationError = unknown

    /**
 * @summary Update System Settings
 */
export const useUpdateAdminSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminSettings>>, TError,{data: SystemSettings}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminSettings>>,
        TError,
        {data: SystemSettings},
        TContext
      > => {

      const mutationOptions = getUpdateAdminSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Patch System Settings
 */
export const patchAdminSettings = (
    patchAdminSettingsBody: PatchAdminSettingsBody,
 ) => {
      
      
      return adminApi<PatchAdminSettings200>(
      {url: `/api/admin/settings`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchAdminSettingsBody
    },
      );
    }
  


export const getPatchAdminSettingsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAdminSettings>>, TError,{data: PatchAdminSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchAdminSettings>>, TError,{data: PatchAdminSettingsBody}, TContext> => {

const mutationKey = ['patchAdminSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchAdminSettings>>, {data: PatchAdminSettingsBody}> = (props) => {
          const {data} = props ?? {};

          return  patchAdminSettings(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchAdminSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof patchAdminSettings>>>
    export type PatchAdminSettingsMutationBody = PatchAdminSettingsBody
    export type PatchAdminSettingsMutationError = unknown

    /**
 * @summary Patch System Settings
 */
export const usePatchAdminSettings = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAdminSettings>>, TError,{data: PatchAdminSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchAdminSettings>>,
        TError,
        {data: PatchAdminSettingsBody},
        TContext
      > => {

      const mutationOptions = getPatchAdminSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Dashboard Metrics
 */
export const getAdminDashboardMetrics = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminDashboardMetrics200>(
      {url: `/api/admin/dashboard/metrics`, method: 'GET', signal
    },
      );
    }
  



export const getGetAdminDashboardMetricsQueryKey = () => {
    return [
    `/api/admin/dashboard/metrics`
    ] as const;
    }

    
export const getGetAdminDashboardMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminDashboardMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminDashboardMetrics>>> = ({ signal }) => getAdminDashboardMetrics(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminDashboardMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminDashboardMetrics>>>
export type GetAdminDashboardMetricsQueryError = unknown


export function useGetAdminDashboardMetrics<TData = Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminDashboardMetrics>>,
          TError,
          Awaited<ReturnType<typeof getAdminDashboardMetrics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminDashboardMetrics<TData = Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminDashboardMetrics>>,
          TError,
          Awaited<ReturnType<typeof getAdminDashboardMetrics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminDashboardMetrics<TData = Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Dashboard Metrics
 */

export function useGetAdminDashboardMetrics<TData = Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDashboardMetrics>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminDashboardMetricsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List Invoices
 */
export const getAdminInvoices = (
    params?: GetAdminInvoicesParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminInvoices200>(
      {url: `/api/admin/invoices`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminInvoicesQueryKey = (params?: GetAdminInvoicesParams,) => {
    return [
    `/api/admin/invoices`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof getAdminInvoices>>, TError = unknown>(params?: GetAdminInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminInvoicesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminInvoices>>> = ({ signal }) => getAdminInvoices(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminInvoices>>>
export type GetAdminInvoicesQueryError = unknown


export function useGetAdminInvoices<TData = Awaited<ReturnType<typeof getAdminInvoices>>, TError = unknown>(
 params: undefined |  GetAdminInvoicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoices>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoices<TData = Awaited<ReturnType<typeof getAdminInvoices>>, TError = unknown>(
 params?: GetAdminInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoices>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoices<TData = Awaited<ReturnType<typeof getAdminInvoices>>, TError = unknown>(
 params?: GetAdminInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Invoices
 */

export function useGetAdminInvoices<TData = Awaited<ReturnType<typeof getAdminInvoices>>, TError = unknown>(
 params?: GetAdminInvoicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminInvoicesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create Invoice
 */
export const createAdminInvoice = (
    invoice: Invoice,
 signal?: AbortSignal
) => {
      
      
      return adminApi<CreateAdminInvoice201>(
      {url: `/api/admin/invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoice, signal
    },
      );
    }
  


export const getCreateAdminInvoiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminInvoice>>, TError,{data: Invoice}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminInvoice>>, TError,{data: Invoice}, TContext> => {

const mutationKey = ['createAdminInvoice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminInvoice>>, {data: Invoice}> = (props) => {
          const {data} = props ?? {};

          return  createAdminInvoice(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminInvoice>>>
    export type CreateAdminInvoiceMutationBody = Invoice
    export type CreateAdminInvoiceMutationError = unknown

    /**
 * @summary Create Invoice
 */
export const useCreateAdminInvoice = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminInvoice>>, TError,{data: Invoice}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminInvoice>>,
        TError,
        {data: Invoice},
        TContext
      > => {

      const mutationOptions = getCreateAdminInvoiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Invoice
 */
export const getAdminInvoice = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminInvoice200>(
      {url: `/api/admin/invoices/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAdminInvoiceQueryKey = (id?: string,) => {
    return [
    `/api/admin/invoices/${id}`
    ] as const;
    }

    
export const getGetAdminInvoiceQueryOptions = <TData = Awaited<ReturnType<typeof getAdminInvoice>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminInvoiceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminInvoice>>> = ({ signal }) => getAdminInvoice(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminInvoiceQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminInvoice>>>
export type GetAdminInvoiceQueryError = unknown


export function useGetAdminInvoice<TData = Awaited<ReturnType<typeof getAdminInvoice>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoice>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoice<TData = Awaited<ReturnType<typeof getAdminInvoice>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoice>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoice<TData = Awaited<ReturnType<typeof getAdminInvoice>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Invoice
 */

export function useGetAdminInvoice<TData = Awaited<ReturnType<typeof getAdminInvoice>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminInvoiceQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Record Payment
 */
export const recordAdminInvoicePayment = (
    id: string,
    recordAdminInvoicePaymentBody: RecordAdminInvoicePaymentBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<RecordAdminInvoicePayment200>(
      {url: `/api/admin/invoices/${id}/payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: recordAdminInvoicePaymentBody, signal
    },
      );
    }
  


export const getRecordAdminInvoicePaymentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recordAdminInvoicePayment>>, TError,{id: string;data: RecordAdminInvoicePaymentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof recordAdminInvoicePayment>>, TError,{id: string;data: RecordAdminInvoicePaymentBody}, TContext> => {

const mutationKey = ['recordAdminInvoicePayment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recordAdminInvoicePayment>>, {id: string;data: RecordAdminInvoicePaymentBody}> = (props) => {
          const {id,data} = props ?? {};

          return  recordAdminInvoicePayment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecordAdminInvoicePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof recordAdminInvoicePayment>>>
    export type RecordAdminInvoicePaymentMutationBody = RecordAdminInvoicePaymentBody
    export type RecordAdminInvoicePaymentMutationError = unknown

    /**
 * @summary Record Payment
 */
export const useRecordAdminInvoicePayment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recordAdminInvoicePayment>>, TError,{id: string;data: RecordAdminInvoicePaymentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recordAdminInvoicePayment>>,
        TError,
        {id: string;data: RecordAdminInvoicePaymentBody},
        TContext
      > => {

      const mutationOptions = getRecordAdminInvoicePaymentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Invoice PDF
 */
export const getAdminInvoicePdf = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<Blob>(
      {url: `/api/admin/invoices/${id}/pdf`, method: 'GET',
        responseType: 'blob', signal
    },
      );
    }
  



export const getGetAdminInvoicePdfQueryKey = (id?: string,) => {
    return [
    `/api/admin/invoices/${id}/pdf`
    ] as const;
    }

    
export const getGetAdminInvoicePdfQueryOptions = <TData = Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminInvoicePdfQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminInvoicePdf>>> = ({ signal }) => getAdminInvoicePdf(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminInvoicePdfQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminInvoicePdf>>>
export type GetAdminInvoicePdfQueryError = unknown


export function useGetAdminInvoicePdf<TData = Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoicePdf<TData = Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminInvoicePdf>>,
          TError,
          Awaited<ReturnType<typeof getAdminInvoicePdf>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminInvoicePdf<TData = Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Invoice PDF
 */

export function useGetAdminInvoicePdf<TData = Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminInvoicePdf>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminInvoicePdfQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Analytics Data
 */
export const getAdminAnalytics = (
    params?: GetAdminAnalyticsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetAdminAnalytics200>(
      {url: `/api/admin/analytics`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetAdminAnalyticsQueryKey = (params?: GetAdminAnalyticsParams,) => {
    return [
    `/api/admin/analytics`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAdminAnalyticsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAnalytics>>, TError = unknown>(params?: GetAdminAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAnalyticsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAnalytics>>> = ({ signal }) => getAdminAnalytics(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAnalyticsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAnalytics>>>
export type GetAdminAnalyticsQueryError = unknown


export function useGetAdminAnalytics<TData = Awaited<ReturnType<typeof getAdminAnalytics>>, TError = unknown>(
 params: undefined |  GetAdminAnalyticsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAnalytics>>,
          TError,
          Awaited<ReturnType<typeof getAdminAnalytics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAnalytics<TData = Awaited<ReturnType<typeof getAdminAnalytics>>, TError = unknown>(
 params?: GetAdminAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAnalytics>>,
          TError,
          Awaited<ReturnType<typeof getAdminAnalytics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAnalytics<TData = Awaited<ReturnType<typeof getAdminAnalytics>>, TError = unknown>(
 params?: GetAdminAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Analytics Data
 */

export function useGetAdminAnalytics<TData = Awaited<ReturnType<typeof getAdminAnalytics>>, TError = unknown>(
 params?: GetAdminAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAnalytics>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAnalyticsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Presigned Upload URL
 */
export const getPresignedUploadUrl = (
    getPresignedUploadUrlBody: GetPresignedUploadUrlBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<GetPresignedUploadUrl200>(
      {url: `/api/upload/presigned`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getPresignedUploadUrlBody, signal
    },
      );
    }
  


export const getGetPresignedUploadUrlMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPresignedUploadUrl>>, TError,{data: GetPresignedUploadUrlBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getPresignedUploadUrl>>, TError,{data: GetPresignedUploadUrlBody}, TContext> => {

const mutationKey = ['getPresignedUploadUrl'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPresignedUploadUrl>>, {data: GetPresignedUploadUrlBody}> = (props) => {
          const {data} = props ?? {};

          return  getPresignedUploadUrl(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetPresignedUploadUrlMutationResult = NonNullable<Awaited<ReturnType<typeof getPresignedUploadUrl>>>
    export type GetPresignedUploadUrlMutationBody = GetPresignedUploadUrlBody
    export type GetPresignedUploadUrlMutationError = unknown

    /**
 * @summary Get Presigned Upload URL
 */
export const useGetPresignedUploadUrl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPresignedUploadUrl>>, TError,{data: GetPresignedUploadUrlBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getPresignedUploadUrl>>,
        TError,
        {data: GetPresignedUploadUrlBody},
        TContext
      > => {

      const mutationOptions = getGetPresignedUploadUrlMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Files
 */
export const listFiles = (
    params?: ListFilesParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ListFiles200>(
      {url: `/api/upload/files`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListFilesQueryKey = (params?: ListFilesParams,) => {
    return [
    `/api/upload/files`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListFilesQueryOptions = <TData = Awaited<ReturnType<typeof listFiles>>, TError = unknown>(params?: ListFilesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListFilesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listFiles>>> = ({ signal }) => listFiles(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListFilesQueryResult = NonNullable<Awaited<ReturnType<typeof listFiles>>>
export type ListFilesQueryError = unknown


export function useListFiles<TData = Awaited<ReturnType<typeof listFiles>>, TError = unknown>(
 params: undefined |  ListFilesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFiles>>,
          TError,
          Awaited<ReturnType<typeof listFiles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListFiles<TData = Awaited<ReturnType<typeof listFiles>>, TError = unknown>(
 params?: ListFilesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFiles>>,
          TError,
          Awaited<ReturnType<typeof listFiles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListFiles<TData = Awaited<ReturnType<typeof listFiles>>, TError = unknown>(
 params?: ListFilesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Files
 */

export function useListFiles<TData = Awaited<ReturnType<typeof listFiles>>, TError = unknown>(
 params?: ListFilesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFiles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListFilesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update Tenant User
 */
export const updateTenantUser = (
    id: string,
    userId: string,
    user: User,
 ) => {
      
      
      return adminApi<UpdateTenantUser200>(
      {url: `/api/admin/tenants/${id}/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: user
    },
      );
    }
  


export const getUpdateTenantUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantUser>>, TError,{id: string;userId: string;data: User}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenantUser>>, TError,{id: string;userId: string;data: User}, TContext> => {

const mutationKey = ['updateTenantUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenantUser>>, {id: string;userId: string;data: User}> = (props) => {
          const {id,userId,data} = props ?? {};

          return  updateTenantUser(id,userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenantUser>>>
    export type UpdateTenantUserMutationBody = User
    export type UpdateTenantUserMutationError = unknown

    /**
 * @summary Update Tenant User
 */
export const useUpdateTenantUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantUser>>, TError,{id: string;userId: string;data: User}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTenantUser>>,
        TError,
        {id: string;userId: string;data: User},
        TContext
      > => {

      const mutationOptions = getUpdateTenantUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Create Ticket Response
 */
export const createTicketResponse = (
    id: string,
    createTicketResponseBody: CreateTicketResponseBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<void>(
      {url: `/api/admin/tickets/${id}/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTicketResponseBody, signal
    },
      );
    }
  


export const getCreateTicketResponseMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTicketResponse>>, TError,{id: string;data: CreateTicketResponseBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTicketResponse>>, TError,{id: string;data: CreateTicketResponseBody}, TContext> => {

const mutationKey = ['createTicketResponse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTicketResponse>>, {id: string;data: CreateTicketResponseBody}> = (props) => {
          const {id,data} = props ?? {};

          return  createTicketResponse(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTicketResponseMutationResult = NonNullable<Awaited<ReturnType<typeof createTicketResponse>>>
    export type CreateTicketResponseMutationBody = CreateTicketResponseBody
    export type CreateTicketResponseMutationError = void

    /**
 * @summary Create Ticket Response
 */
export const useCreateTicketResponse = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTicketResponse>>, TError,{id: string;data: CreateTicketResponseBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTicketResponse>>,
        TError,
        {id: string;data: CreateTicketResponseBody},
        TContext
      > => {

      const mutationOptions = getCreateTicketResponseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Admin Login
 */
export const adminLogin = (
    adminLoginBody: AdminLoginBody,
 signal?: AbortSignal
) => {
      
      
      return adminApi<AdminLogin200>(
      {url: `/api/admin/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminLoginBody, signal
    },
      );
    }
  


export const getAdminLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginBody}, TContext> => {

const mutationKey = ['adminLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLogin>>, {data: AdminLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  adminLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminLoginMutationResult = NonNullable<Awaited<ReturnType<typeof adminLogin>>>
    export type AdminLoginMutationBody = AdminLoginBody
    export type AdminLoginMutationError = unknown

    /**
 * @summary Admin Login
 */
export const useAdminLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError,{data: AdminLoginBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminLogin>>,
        TError,
        {data: AdminLoginBody},
        TContext
      > => {

      const mutationOptions = getAdminLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
