/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdminLoginRequest,
  ApprovalActionRequest,
  CheckDeliverabilityAlertsParams,
  CreateAdminUserRequest,
  CreateTicketRequest,
  GetDeliverabilityMetricsParams,
  GetDeliverabilityTrendParams,
  HTTPValidationError,
  ListAdminTicketsParams,
  ListAdminUserAllParams,
  ListAdminUsersParams,
  ListBouncesParams,
  ListComplaintsParams,
  ListEmailApprovalsParams,
  ListUnsubscribesParams,
  ProcessFBLRequest,
  ResponseEnvelope,
  ResponseEnvelopeAdminLoginResponse,
  ResponseEnvelopeAlertCheckResponse,
  ResponseEnvelopeApprovalListResponse,
  ResponseEnvelopeApprovalStatsResponse,
  ResponseEnvelopeAvailableRolesResponse,
  ResponseEnvelopeBounceListResponse,
  ResponseEnvelopeBounceStatsResponse,
  ResponseEnvelopeComplaintListResponse,
  ResponseEnvelopeComplaintStatsResponse,
  ResponseEnvelopeDebugPagePermissionResponse,
  ResponseEnvelopeDeliverabilityMetricsResponse,
  ResponseEnvelopeListAdminUserRead,
  ResponseEnvelopeListTicketRead,
  ResponseEnvelopeSpamPreviewResponse,
  ResponseEnvelopeTrendResponse,
  ResponseEnvelopeUnsubscribeListResponse,
  ResponseEnvelopeUnsubscribeStatsResponse,
  ResponseEnvelopeUserRead,
  RoutersAdminUpdateTenantUserRequest,
  SchemasBaseResponseEnvelopeDict,
  SchemasResponseResponseEnvelopeDict,
  SpamPreviewRequest,
  SwitchRoleRequest,
  SwitchTenantRequest,
  TicketResponseRequest,
  UpdateTicketRequest
} from '.././schemas';

import { adminApi } from '../../orval-mutator';




/**
 * Admin login endpoint
 * @summary Admin Login
 */
export const createAdminAuthLogin = (
    adminLoginRequest: AdminLoginRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeAdminLoginResponse>(
      {url: `/api/admin/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminLoginRequest, signal
    },
      );
    }
  


export const getCreateAdminAuthLoginMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminAuthLogin>>, TError,{data: AdminLoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminAuthLogin>>, TError,{data: AdminLoginRequest}, TContext> => {

const mutationKey = ['createAdminAuthLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminAuthLogin>>, {data: AdminLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminAuthLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminAuthLogin>>>
    export type CreateAdminAuthLoginMutationBody = AdminLoginRequest
    export type CreateAdminAuthLoginMutationError = HTTPValidationError

    /**
 * @summary Admin Login
 */
export const useCreateAdminAuthLogin = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminAuthLogin>>, TError,{data: AdminLoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminAuthLogin>>,
        TError,
        {data: AdminLoginRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create admin user or tenant user
 * @summary Create Admin User
 */
export const createAdminUsers = (
    createAdminUserRequest: CreateAdminUserRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelope>(
      {url: `/api/admin/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAdminUserRequest, signal
    },
      );
    }
  


export const getCreateAdminUsersMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUsers>>, TError,{data: CreateAdminUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminUsers>>, TError,{data: CreateAdminUserRequest}, TContext> => {

const mutationKey = ['createAdminUsers'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminUsers>>, {data: CreateAdminUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminUsers(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminUsersMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminUsers>>>
    export type CreateAdminUsersMutationBody = CreateAdminUserRequest
    export type CreateAdminUsersMutationError = HTTPValidationError

    /**
 * @summary Create Admin User
 */
export const useCreateAdminUsers = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminUsers>>, TError,{data: CreateAdminUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminUsers>>,
        TError,
        {data: CreateAdminUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminUsersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get list of admin users
 * @summary Get Admin Users
 */
export const listAdminUsers = (
    params?: ListAdminUsersParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListAdminUserRead>(
      {url: `/api/admin/users`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAdminUsersQueryKey = (params?: ListAdminUsersParams,) => {
    return [
    `/api/admin/users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAdminUsersQueryOptions = <TData = Awaited<ReturnType<typeof listAdminUsers>>, TError = HTTPValidationError>(params?: ListAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAdminUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAdminUsers>>> = ({ signal }) => listAdminUsers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAdminUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listAdminUsers>>>
export type ListAdminUsersQueryError = HTTPValidationError


export function useListAdminUsers<TData = Awaited<ReturnType<typeof listAdminUsers>>, TError = HTTPValidationError>(
 params: undefined |  ListAdminUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof listAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminUsers<TData = Awaited<ReturnType<typeof listAdminUsers>>, TError = HTTPValidationError>(
 params?: ListAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminUsers>>,
          TError,
          Awaited<ReturnType<typeof listAdminUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminUsers<TData = Awaited<ReturnType<typeof listAdminUsers>>, TError = HTTPValidationError>(
 params?: ListAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Admin Users
 */

export function useListAdminUsers<TData = Awaited<ReturnType<typeof listAdminUsers>>, TError = HTTPValidationError>(
 params?: ListAdminUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAdminUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of ALL users from ALL tenants
 * @summary Get All Tenant Users
 */
export const listAdminUserAll = (
    params?: ListAdminUserAllParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelope>(
      {url: `/api/admin/users/all`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAdminUserAllQueryKey = (params?: ListAdminUserAllParams,) => {
    return [
    `/api/admin/users/all`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAdminUserAllQueryOptions = <TData = Awaited<ReturnType<typeof listAdminUserAll>>, TError = HTTPValidationError>(params?: ListAdminUserAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAdminUserAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAdminUserAll>>> = ({ signal }) => listAdminUserAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAdminUserAllQueryResult = NonNullable<Awaited<ReturnType<typeof listAdminUserAll>>>
export type ListAdminUserAllQueryError = HTTPValidationError


export function useListAdminUserAll<TData = Awaited<ReturnType<typeof listAdminUserAll>>, TError = HTTPValidationError>(
 params: undefined |  ListAdminUserAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminUserAll>>,
          TError,
          Awaited<ReturnType<typeof listAdminUserAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminUserAll<TData = Awaited<ReturnType<typeof listAdminUserAll>>, TError = HTTPValidationError>(
 params?: ListAdminUserAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminUserAll>>,
          TError,
          Awaited<ReturnType<typeof listAdminUserAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminUserAll<TData = Awaited<ReturnType<typeof listAdminUserAll>>, TError = HTTPValidationError>(
 params?: ListAdminUserAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get All Tenant Users
 */

export function useListAdminUserAll<TData = Awaited<ReturnType<typeof listAdminUserAll>>, TError = HTTPValidationError>(
 params?: ListAdminUserAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminUserAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAdminUserAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update any tenant user (Admin Panel)
 * @summary Update Any Tenant User
 */
export const updateAdminUserAll = (
    userId: string,
    routersAdminUpdateTenantUserRequest: RoutersAdminUpdateTenantUserRequest,
 ) => {
      
      
      return adminApi<ResponseEnvelopeUserRead>(
      {url: `/api/admin/users/all/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: routersAdminUpdateTenantUserRequest
    },
      );
    }
  


export const getUpdateAdminUserAllMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminUserAll>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminUserAll>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext> => {

const mutationKey = ['updateAdminUserAll'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminUserAll>>, {userId: string;data: RoutersAdminUpdateTenantUserRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateAdminUserAll(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminUserAllMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminUserAll>>>
    export type UpdateAdminUserAllMutationBody = RoutersAdminUpdateTenantUserRequest
    export type UpdateAdminUserAllMutationError = HTTPValidationError

    /**
 * @summary Update Any Tenant User
 */
export const useUpdateAdminUserAll = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminUserAll>>, TError,{userId: string;data: RoutersAdminUpdateTenantUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminUserAll>>,
        TError,
        {userId: string;data: RoutersAdminUpdateTenantUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAdminUserAllMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get support tickets
 * @summary Get Admin Tickets
 */
export const listAdminTickets = (
    params?: ListAdminTicketsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListTicketRead>(
      {url: `/api/admin/tickets`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAdminTicketsQueryKey = (params?: ListAdminTicketsParams,) => {
    return [
    `/api/admin/tickets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAdminTicketsQueryOptions = <TData = Awaited<ReturnType<typeof listAdminTickets>>, TError = HTTPValidationError>(params?: ListAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAdminTicketsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAdminTickets>>> = ({ signal }) => listAdminTickets(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAdminTicketsQueryResult = NonNullable<Awaited<ReturnType<typeof listAdminTickets>>>
export type ListAdminTicketsQueryError = HTTPValidationError


export function useListAdminTickets<TData = Awaited<ReturnType<typeof listAdminTickets>>, TError = HTTPValidationError>(
 params: undefined |  ListAdminTicketsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof listAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminTickets<TData = Awaited<ReturnType<typeof listAdminTickets>>, TError = HTTPValidationError>(
 params?: ListAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminTickets>>,
          TError,
          Awaited<ReturnType<typeof listAdminTickets>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminTickets<TData = Awaited<ReturnType<typeof listAdminTickets>>, TError = HTTPValidationError>(
 params?: ListAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Admin Tickets
 */

export function useListAdminTickets<TData = Awaited<ReturnType<typeof listAdminTickets>>, TError = HTTPValidationError>(
 params?: ListAdminTicketsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminTickets>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAdminTicketsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create support ticket
 * @summary Create Admin Ticket
 */
export const createAdminTickets = (
    createTicketRequest: CreateTicketRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/tickets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTicketRequest, signal
    },
      );
    }
  


export const getCreateAdminTicketsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTickets>>, TError,{data: CreateTicketRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminTickets>>, TError,{data: CreateTicketRequest}, TContext> => {

const mutationKey = ['createAdminTickets'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminTickets>>, {data: CreateTicketRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminTickets(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminTicketsMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminTickets>>>
    export type CreateAdminTicketsMutationBody = CreateTicketRequest
    export type CreateAdminTicketsMutationError = HTTPValidationError

    /**
 * @summary Create Admin Ticket
 */
export const useCreateAdminTickets = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTickets>>, TError,{data: CreateTicketRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminTickets>>,
        TError,
        {data: CreateTicketRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminTicketsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update support ticket
 * @summary Update Admin Ticket
 */
export const updateAdminTicket = (
    ticketId: string,
    updateTicketRequest: UpdateTicketRequest,
 ) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/tickets/${ticketId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateTicketRequest
    },
      );
    }
  


export const getUpdateAdminTicketMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext> => {

const mutationKey = ['updateAdminTicket'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdminTicket>>, {ticketId: string;data: UpdateTicketRequest}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  updateAdminTicket(ticketId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdminTicketMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdminTicket>>>
    export type UpdateAdminTicketMutationBody = UpdateTicketRequest
    export type UpdateAdminTicketMutationError = HTTPValidationError

    /**
 * @summary Update Admin Ticket
 */
export const useUpdateAdminTicket = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdminTicket>>, TError,{ticketId: string;data: UpdateTicketRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdminTicket>>,
        TError,
        {ticketId: string;data: UpdateTicketRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAdminTicketMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create response for support ticket
 * @summary Create Ticket Response
 */
export const createAdminTicketResponses = (
    ticketId: string,
    ticketResponseRequest: TicketResponseRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/tickets/${ticketId}/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ticketResponseRequest, signal
    },
      );
    }
  


export const getCreateAdminTicketResponsesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponses>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponses>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext> => {

const mutationKey = ['createAdminTicketResponses'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminTicketResponses>>, {ticketId: string;data: TicketResponseRequest}> = (props) => {
          const {ticketId,data} = props ?? {};

          return  createAdminTicketResponses(ticketId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminTicketResponsesMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminTicketResponses>>>
    export type CreateAdminTicketResponsesMutationBody = TicketResponseRequest
    export type CreateAdminTicketResponsesMutationError = HTTPValidationError

    /**
 * @summary Create Ticket Response
 */
export const useCreateAdminTicketResponses = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminTicketResponses>>, TError,{ticketId: string;data: TicketResponseRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminTicketResponses>>,
        TError,
        {ticketId: string;data: TicketResponseRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminTicketResponsesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Switch to a different role for debugging
 * @summary Debug Switch Role
 */
export const createAdminDebugSwitchRole = (
    switchRoleRequest: SwitchRoleRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/debug/switch-role`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: switchRoleRequest, signal
    },
      );
    }
  


export const getCreateAdminDebugSwitchRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext> => {

const mutationKey = ['createAdminDebugSwitchRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminDebugSwitchRole>>, {data: SwitchRoleRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminDebugSwitchRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminDebugSwitchRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminDebugSwitchRole>>>
    export type CreateAdminDebugSwitchRoleMutationBody = SwitchRoleRequest
    export type CreateAdminDebugSwitchRoleMutationError = HTTPValidationError

    /**
 * @summary Debug Switch Role
 */
export const useCreateAdminDebugSwitchRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchRole>>, TError,{data: SwitchRoleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminDebugSwitchRole>>,
        TError,
        {data: SwitchRoleRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminDebugSwitchRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all available roles for debugging
 * @summary Debug Available Roles
 */
export const listAdminDebugAvailableRoles = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeAvailableRolesResponse>(
      {url: `/api/admin/debug/available-roles`, method: 'GET', signal
    },
      );
    }
  



export const getListAdminDebugAvailableRolesQueryKey = () => {
    return [
    `/api/admin/debug/available-roles`
    ] as const;
    }

    
export const getListAdminDebugAvailableRolesQueryOptions = <TData = Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAdminDebugAvailableRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>> = ({ signal }) => listAdminDebugAvailableRoles(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAdminDebugAvailableRolesQueryResult = NonNullable<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>>
export type ListAdminDebugAvailableRolesQueryError = unknown


export function useListAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>,
          TError,
          Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Debug Available Roles
 */

export function useListAdminDebugAvailableRoles<TData = Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAdminDebugAvailableRoles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAdminDebugAvailableRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Switch to a different tenant context for debugging
 * @summary Debug Switch Tenant
 */
export const createAdminDebugSwitchTenant = (
    switchTenantRequest: SwitchTenantRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/debug/switch-tenant`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: switchTenantRequest, signal
    },
      );
    }
  


export const getCreateAdminDebugSwitchTenantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext> => {

const mutationKey = ['createAdminDebugSwitchTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>, {data: SwitchTenantRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAdminDebugSwitchTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminDebugSwitchTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>>
    export type CreateAdminDebugSwitchTenantMutationBody = SwitchTenantRequest
    export type CreateAdminDebugSwitchTenantMutationError = HTTPValidationError

    /**
 * @summary Debug Switch Tenant
 */
export const useCreateAdminDebugSwitchTenant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>, TError,{data: SwitchTenantRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminDebugSwitchTenant>>,
        TError,
        {data: SwitchTenantRequest},
        TContext
      > => {

      const mutationOptions = getCreateAdminDebugSwitchTenantMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Exit tenant/role impersonation
 * @summary Debug Exit Impersonation
 */
export const createAdminDebugExitImpersonation = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<unknown>(
      {url: `/api/admin/debug/exit-impersonation`, method: 'POST', signal
    },
      );
    }
  


export const getCreateAdminDebugExitImpersonationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>, TError,void, TContext> => {

const mutationKey = ['createAdminDebugExitImpersonation'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>, void> = () => {
          

          return  createAdminDebugExitImpersonation()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdminDebugExitImpersonationMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>>
    
    export type CreateAdminDebugExitImpersonationMutationError = unknown

    /**
 * @summary Debug Exit Impersonation
 */
export const useCreateAdminDebugExitImpersonation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdminDebugExitImpersonation>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateAdminDebugExitImpersonationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get permissions required for a specific page
 * @summary Debug Page Permissions
 */
export const getAdminDebugPagePermission = (
    pageKey: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeDebugPagePermissionResponse>(
      {url: `/api/admin/debug/page-permissions/${pageKey}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAdminDebugPagePermissionQueryKey = (pageKey?: string,) => {
    return [
    `/api/admin/debug/page-permissions/${pageKey}`
    ] as const;
    }

    
export const getGetAdminDebugPagePermissionQueryOptions = <TData = Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError = HTTPValidationError>(pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminDebugPagePermissionQueryKey(pageKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminDebugPagePermission>>> = ({ signal }) => getAdminDebugPagePermission(pageKey, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(pageKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminDebugPagePermissionQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminDebugPagePermission>>>
export type GetAdminDebugPagePermissionQueryError = HTTPValidationError


export function useGetAdminDebugPagePermission<TData = Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError = HTTPValidationError>(
 pageKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminDebugPagePermission>>,
          TError,
          Awaited<ReturnType<typeof getAdminDebugPagePermission>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminDebugPagePermission<TData = Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminDebugPagePermission>>,
          TError,
          Awaited<ReturnType<typeof getAdminDebugPagePermission>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminDebugPagePermission<TData = Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Debug Page Permissions
 */

export function useGetAdminDebugPagePermission<TData = Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError = HTTPValidationError>(
 pageKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminDebugPagePermission>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminDebugPagePermissionQueryOptions(pageKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get email deliverability metrics for time window
 * @summary Get deliverability metrics
 */
export const getDeliverabilityMetrics = (
    params?: GetDeliverabilityMetricsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeDeliverabilityMetricsResponse>(
      {url: `/api/deliverability/metrics`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetDeliverabilityMetricsQueryKey = (params?: GetDeliverabilityMetricsParams,) => {
    return [
    `/api/deliverability/metrics`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetDeliverabilityMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError = HTTPValidationError>(params?: GetDeliverabilityMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeliverabilityMetricsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliverabilityMetrics>>> = ({ signal }) => getDeliverabilityMetrics(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDeliverabilityMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliverabilityMetrics>>>
export type GetDeliverabilityMetricsQueryError = HTTPValidationError


export function useGetDeliverabilityMetrics<TData = Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError = HTTPValidationError>(
 params: undefined |  GetDeliverabilityMetricsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliverabilityMetrics>>,
          TError,
          Awaited<ReturnType<typeof getDeliverabilityMetrics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDeliverabilityMetrics<TData = Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliverabilityMetrics>>,
          TError,
          Awaited<ReturnType<typeof getDeliverabilityMetrics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDeliverabilityMetrics<TData = Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get deliverability metrics
 */

export function useGetDeliverabilityMetrics<TData = Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityMetrics>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDeliverabilityMetricsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Check if metrics exceed alert thresholds
 * @summary Check deliverability alerts
 */
export const checkDeliverabilityAlerts = (
    params?: CheckDeliverabilityAlertsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeAlertCheckResponse>(
      {url: `/api/deliverability/alerts/check`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCheckDeliverabilityAlertsQueryKey = (params?: CheckDeliverabilityAlertsParams,) => {
    return [
    `/api/deliverability/alerts/check`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCheckDeliverabilityAlertsQueryOptions = <TData = Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError = HTTPValidationError>(params?: CheckDeliverabilityAlertsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckDeliverabilityAlertsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>> = ({ signal }) => checkDeliverabilityAlerts(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CheckDeliverabilityAlertsQueryResult = NonNullable<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>>
export type CheckDeliverabilityAlertsQueryError = HTTPValidationError


export function useCheckDeliverabilityAlerts<TData = Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError = HTTPValidationError>(
 params: undefined |  CheckDeliverabilityAlertsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkDeliverabilityAlerts>>,
          TError,
          Awaited<ReturnType<typeof checkDeliverabilityAlerts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCheckDeliverabilityAlerts<TData = Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError = HTTPValidationError>(
 params?: CheckDeliverabilityAlertsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkDeliverabilityAlerts>>,
          TError,
          Awaited<ReturnType<typeof checkDeliverabilityAlerts>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCheckDeliverabilityAlerts<TData = Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError = HTTPValidationError>(
 params?: CheckDeliverabilityAlertsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Check deliverability alerts
 */

export function useCheckDeliverabilityAlerts<TData = Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError = HTTPValidationError>(
 params?: CheckDeliverabilityAlertsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkDeliverabilityAlerts>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCheckDeliverabilityAlertsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get deliverability metrics trend over time
 * @summary Get deliverability trend
 */
export const getDeliverabilityTrend = (
    params?: GetDeliverabilityTrendParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeTrendResponse>(
      {url: `/api/deliverability/trend`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetDeliverabilityTrendQueryKey = (params?: GetDeliverabilityTrendParams,) => {
    return [
    `/api/deliverability/trend`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetDeliverabilityTrendQueryOptions = <TData = Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError = HTTPValidationError>(params?: GetDeliverabilityTrendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeliverabilityTrendQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliverabilityTrend>>> = ({ signal }) => getDeliverabilityTrend(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDeliverabilityTrendQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliverabilityTrend>>>
export type GetDeliverabilityTrendQueryError = HTTPValidationError


export function useGetDeliverabilityTrend<TData = Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError = HTTPValidationError>(
 params: undefined |  GetDeliverabilityTrendParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliverabilityTrend>>,
          TError,
          Awaited<ReturnType<typeof getDeliverabilityTrend>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDeliverabilityTrend<TData = Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityTrendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliverabilityTrend>>,
          TError,
          Awaited<ReturnType<typeof getDeliverabilityTrend>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDeliverabilityTrend<TData = Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityTrendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get deliverability trend
 */

export function useGetDeliverabilityTrend<TData = Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError = HTTPValidationError>(
 params?: GetDeliverabilityTrendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliverabilityTrend>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDeliverabilityTrendQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Store daily deliverability metrics snapshot
 * @summary Create daily metrics snapshot
 */
export const createDeliverabilitySnapshot = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<SchemasBaseResponseEnvelopeDict>(
      {url: `/api/deliverability/snapshot`, method: 'POST', signal
    },
      );
    }
  


export const getCreateDeliverabilitySnapshotMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDeliverabilitySnapshot>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDeliverabilitySnapshot>>, TError,void, TContext> => {

const mutationKey = ['createDeliverabilitySnapshot'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDeliverabilitySnapshot>>, void> = () => {
          

          return  createDeliverabilitySnapshot()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDeliverabilitySnapshotMutationResult = NonNullable<Awaited<ReturnType<typeof createDeliverabilitySnapshot>>>
    
    export type CreateDeliverabilitySnapshotMutationError = unknown

    /**
 * @summary Create daily metrics snapshot
 */
export const useCreateDeliverabilitySnapshot = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDeliverabilitySnapshot>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDeliverabilitySnapshot>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateDeliverabilitySnapshotMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get paginated list of email bounces with filters
 * @summary List email bounces
 */
export const listBounces = (
    params?: ListBouncesParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeBounceListResponse>(
      {url: `/api/admin/bounces`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListBouncesQueryKey = (params?: ListBouncesParams,) => {
    return [
    `/api/admin/bounces`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListBouncesQueryOptions = <TData = Awaited<ReturnType<typeof listBounces>>, TError = HTTPValidationError>(params?: ListBouncesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBouncesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBounces>>> = ({ signal }) => listBounces(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListBouncesQueryResult = NonNullable<Awaited<ReturnType<typeof listBounces>>>
export type ListBouncesQueryError = HTTPValidationError


export function useListBounces<TData = Awaited<ReturnType<typeof listBounces>>, TError = HTTPValidationError>(
 params: undefined |  ListBouncesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBounces>>,
          TError,
          Awaited<ReturnType<typeof listBounces>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListBounces<TData = Awaited<ReturnType<typeof listBounces>>, TError = HTTPValidationError>(
 params?: ListBouncesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBounces>>,
          TError,
          Awaited<ReturnType<typeof listBounces>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListBounces<TData = Awaited<ReturnType<typeof listBounces>>, TError = HTTPValidationError>(
 params?: ListBouncesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List email bounces
 */

export function useListBounces<TData = Awaited<ReturnType<typeof listBounces>>, TError = HTTPValidationError>(
 params?: ListBouncesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBounces>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListBouncesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get overall bounce statistics for tenant
 * @summary Get bounce statistics
 */
export const getBounceStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeBounceStatsResponse>(
      {url: `/api/admin/bounces/stats`, method: 'GET', signal
    },
      );
    }
  



export const getGetBounceStatsQueryKey = () => {
    return [
    `/api/admin/bounces/stats`
    ] as const;
    }

    
export const getGetBounceStatsQueryOptions = <TData = Awaited<ReturnType<typeof getBounceStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBounceStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBounceStats>>> = ({ signal }) => getBounceStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBounceStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getBounceStats>>>
export type GetBounceStatsQueryError = unknown


export function useGetBounceStats<TData = Awaited<ReturnType<typeof getBounceStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBounceStats>>,
          TError,
          Awaited<ReturnType<typeof getBounceStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBounceStats<TData = Awaited<ReturnType<typeof getBounceStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBounceStats>>,
          TError,
          Awaited<ReturnType<typeof getBounceStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBounceStats<TData = Awaited<ReturnType<typeof getBounceStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get bounce statistics
 */

export function useGetBounceStats<TData = Awaited<ReturnType<typeof getBounceStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBounceStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBounceStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Manually unblacklist a recipient
 * @summary Remove recipient from blacklist
 */
export const unblacklistRecipient = (
    bounceId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SchemasBaseResponseEnvelopeDict>(
      {url: `/api/admin/bounces/${bounceId}/unblacklist`, method: 'POST', signal
    },
      );
    }
  


export const getUnblacklistRecipientMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unblacklistRecipient>>, TError,{bounceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unblacklistRecipient>>, TError,{bounceId: string}, TContext> => {

const mutationKey = ['unblacklistRecipient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unblacklistRecipient>>, {bounceId: string}> = (props) => {
          const {bounceId} = props ?? {};

          return  unblacklistRecipient(bounceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnblacklistRecipientMutationResult = NonNullable<Awaited<ReturnType<typeof unblacklistRecipient>>>
    
    export type UnblacklistRecipientMutationError = HTTPValidationError

    /**
 * @summary Remove recipient from blacklist
 */
export const useUnblacklistRecipient = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unblacklistRecipient>>, TError,{bounceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unblacklistRecipient>>,
        TError,
        {bounceId: string},
        TContext
      > => {

      const mutationOptions = getUnblacklistRecipientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Analyze email content and preview spam score before sending
 * @summary Preview spam score
 */
export const previewSpamScore = (
    spamPreviewRequest: SpamPreviewRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeSpamPreviewResponse>(
      {url: `/api/admin/spam-preview`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: spamPreviewRequest, signal
    },
      );
    }
  


export const getPreviewSpamScoreMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof previewSpamScore>>, TError,{data: SpamPreviewRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof previewSpamScore>>, TError,{data: SpamPreviewRequest}, TContext> => {

const mutationKey = ['previewSpamScore'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof previewSpamScore>>, {data: SpamPreviewRequest}> = (props) => {
          const {data} = props ?? {};

          return  previewSpamScore(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PreviewSpamScoreMutationResult = NonNullable<Awaited<ReturnType<typeof previewSpamScore>>>
    export type PreviewSpamScoreMutationBody = SpamPreviewRequest
    export type PreviewSpamScoreMutationError = HTTPValidationError

    /**
 * @summary Preview spam score
 */
export const usePreviewSpamScore = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof previewSpamScore>>, TError,{data: SpamPreviewRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof previewSpamScore>>,
        TError,
        {data: SpamPreviewRequest},
        TContext
      > => {

      const mutationOptions = getPreviewSpamScoreMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get paginated list of email unsubscribes with filters
 * @summary List email unsubscribes
 */
export const listUnsubscribes = (
    params?: ListUnsubscribesParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeUnsubscribeListResponse>(
      {url: `/api/admin/unsubscribes`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListUnsubscribesQueryKey = (params?: ListUnsubscribesParams,) => {
    return [
    `/api/admin/unsubscribes`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListUnsubscribesQueryOptions = <TData = Awaited<ReturnType<typeof listUnsubscribes>>, TError = HTTPValidationError>(params?: ListUnsubscribesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUnsubscribesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUnsubscribes>>> = ({ signal }) => listUnsubscribes(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListUnsubscribesQueryResult = NonNullable<Awaited<ReturnType<typeof listUnsubscribes>>>
export type ListUnsubscribesQueryError = HTTPValidationError


export function useListUnsubscribes<TData = Awaited<ReturnType<typeof listUnsubscribes>>, TError = HTTPValidationError>(
 params: undefined |  ListUnsubscribesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUnsubscribes>>,
          TError,
          Awaited<ReturnType<typeof listUnsubscribes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUnsubscribes<TData = Awaited<ReturnType<typeof listUnsubscribes>>, TError = HTTPValidationError>(
 params?: ListUnsubscribesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUnsubscribes>>,
          TError,
          Awaited<ReturnType<typeof listUnsubscribes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUnsubscribes<TData = Awaited<ReturnType<typeof listUnsubscribes>>, TError = HTTPValidationError>(
 params?: ListUnsubscribesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List email unsubscribes
 */

export function useListUnsubscribes<TData = Awaited<ReturnType<typeof listUnsubscribes>>, TError = HTTPValidationError>(
 params?: ListUnsubscribesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUnsubscribes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListUnsubscribesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get overall unsubscribe statistics for tenant
 * @summary Get unsubscribe statistics
 */
export const getUnsubscribeStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeUnsubscribeStatsResponse>(
      {url: `/api/admin/unsubscribes/stats`, method: 'GET', signal
    },
      );
    }
  



export const getGetUnsubscribeStatsQueryKey = () => {
    return [
    `/api/admin/unsubscribes/stats`
    ] as const;
    }

    
export const getGetUnsubscribeStatsQueryOptions = <TData = Awaited<ReturnType<typeof getUnsubscribeStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnsubscribeStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnsubscribeStats>>> = ({ signal }) => getUnsubscribeStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUnsubscribeStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getUnsubscribeStats>>>
export type GetUnsubscribeStatsQueryError = unknown


export function useGetUnsubscribeStats<TData = Awaited<ReturnType<typeof getUnsubscribeStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnsubscribeStats>>,
          TError,
          Awaited<ReturnType<typeof getUnsubscribeStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnsubscribeStats<TData = Awaited<ReturnType<typeof getUnsubscribeStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnsubscribeStats>>,
          TError,
          Awaited<ReturnType<typeof getUnsubscribeStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUnsubscribeStats<TData = Awaited<ReturnType<typeof getUnsubscribeStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get unsubscribe statistics
 */

export function useGetUnsubscribeStats<TData = Awaited<ReturnType<typeof getUnsubscribeStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnsubscribeStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUnsubscribeStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove unsubscribe preference (allows sending emails again)
 * @summary Delete unsubscribe record
 */
export const deleteUnsubscribe = (
    unsubscribeId: string,
 ) => {
      
      
      return adminApi<SchemasBaseResponseEnvelopeDict>(
      {url: `/api/admin/unsubscribes/${unsubscribeId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUnsubscribeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUnsubscribe>>, TError,{unsubscribeId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUnsubscribe>>, TError,{unsubscribeId: string}, TContext> => {

const mutationKey = ['deleteUnsubscribe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUnsubscribe>>, {unsubscribeId: string}> = (props) => {
          const {unsubscribeId} = props ?? {};

          return  deleteUnsubscribe(unsubscribeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUnsubscribeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUnsubscribe>>>
    
    export type DeleteUnsubscribeMutationError = HTTPValidationError

    /**
 * @summary Delete unsubscribe record
 */
export const useDeleteUnsubscribe = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUnsubscribe>>, TError,{unsubscribeId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUnsubscribe>>,
        TError,
        {unsubscribeId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUnsubscribeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get paginated list of email approval requests with filters
 * @summary List email approval requests
 */
export const listEmailApprovals = (
    params?: ListEmailApprovalsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeApprovalListResponse>(
      {url: `/api/admin/email-approvals`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListEmailApprovalsQueryKey = (params?: ListEmailApprovalsParams,) => {
    return [
    `/api/admin/email-approvals`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListEmailApprovalsQueryOptions = <TData = Awaited<ReturnType<typeof listEmailApprovals>>, TError = HTTPValidationError>(params?: ListEmailApprovalsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEmailApprovalsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEmailApprovals>>> = ({ signal }) => listEmailApprovals(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListEmailApprovalsQueryResult = NonNullable<Awaited<ReturnType<typeof listEmailApprovals>>>
export type ListEmailApprovalsQueryError = HTTPValidationError


export function useListEmailApprovals<TData = Awaited<ReturnType<typeof listEmailApprovals>>, TError = HTTPValidationError>(
 params: undefined |  ListEmailApprovalsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEmailApprovals>>,
          TError,
          Awaited<ReturnType<typeof listEmailApprovals>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEmailApprovals<TData = Awaited<ReturnType<typeof listEmailApprovals>>, TError = HTTPValidationError>(
 params?: ListEmailApprovalsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEmailApprovals>>,
          TError,
          Awaited<ReturnType<typeof listEmailApprovals>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEmailApprovals<TData = Awaited<ReturnType<typeof listEmailApprovals>>, TError = HTTPValidationError>(
 params?: ListEmailApprovalsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List email approval requests
 */

export function useListEmailApprovals<TData = Awaited<ReturnType<typeof listEmailApprovals>>, TError = HTTPValidationError>(
 params?: ListEmailApprovalsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEmailApprovals>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListEmailApprovalsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get overall email approval statistics for tenant
 * @summary Get email approval statistics
 */
export const getEmailApprovalStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeApprovalStatsResponse>(
      {url: `/api/admin/email-approvals/stats`, method: 'GET', signal
    },
      );
    }
  



export const getGetEmailApprovalStatsQueryKey = () => {
    return [
    `/api/admin/email-approvals/stats`
    ] as const;
    }

    
export const getGetEmailApprovalStatsQueryOptions = <TData = Awaited<ReturnType<typeof getEmailApprovalStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmailApprovalStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmailApprovalStats>>> = ({ signal }) => getEmailApprovalStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmailApprovalStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getEmailApprovalStats>>>
export type GetEmailApprovalStatsQueryError = unknown


export function useGetEmailApprovalStats<TData = Awaited<ReturnType<typeof getEmailApprovalStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmailApprovalStats>>,
          TError,
          Awaited<ReturnType<typeof getEmailApprovalStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmailApprovalStats<TData = Awaited<ReturnType<typeof getEmailApprovalStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmailApprovalStats>>,
          TError,
          Awaited<ReturnType<typeof getEmailApprovalStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmailApprovalStats<TData = Awaited<ReturnType<typeof getEmailApprovalStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get email approval statistics
 */

export function useGetEmailApprovalStats<TData = Awaited<ReturnType<typeof getEmailApprovalStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailApprovalStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmailApprovalStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Approve HIGH/CRITICAL risk email for sending
 * @summary Approve email for sending
 */
export const approveEmail = (
    approvalId: string,
    approvalActionRequest: ApprovalActionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SchemasBaseResponseEnvelopeDict>(
      {url: `/api/admin/email-approvals/${approvalId}/approve`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: approvalActionRequest, signal
    },
      );
    }
  


export const getApproveEmailMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof approveEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext> => {

const mutationKey = ['approveEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approveEmail>>, {approvalId: string;data: ApprovalActionRequest}> = (props) => {
          const {approvalId,data} = props ?? {};

          return  approveEmail(approvalId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApproveEmailMutationResult = NonNullable<Awaited<ReturnType<typeof approveEmail>>>
    export type ApproveEmailMutationBody = ApprovalActionRequest
    export type ApproveEmailMutationError = HTTPValidationError

    /**
 * @summary Approve email for sending
 */
export const useApproveEmail = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof approveEmail>>,
        TError,
        {approvalId: string;data: ApprovalActionRequest},
        TContext
      > => {

      const mutationOptions = getApproveEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Reject HIGH/CRITICAL risk email (will not be sent)
 * @summary Reject email
 */
export const rejectEmail = (
    approvalId: string,
    approvalActionRequest: ApprovalActionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SchemasBaseResponseEnvelopeDict>(
      {url: `/api/admin/email-approvals/${approvalId}/reject`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: approvalActionRequest, signal
    },
      );
    }
  


export const getRejectEmailMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rejectEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext> => {

const mutationKey = ['rejectEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectEmail>>, {approvalId: string;data: ApprovalActionRequest}> = (props) => {
          const {approvalId,data} = props ?? {};

          return  rejectEmail(approvalId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RejectEmailMutationResult = NonNullable<Awaited<ReturnType<typeof rejectEmail>>>
    export type RejectEmailMutationBody = ApprovalActionRequest
    export type RejectEmailMutationError = HTTPValidationError

    /**
 * @summary Reject email
 */
export const useRejectEmail = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectEmail>>, TError,{approvalId: string;data: ApprovalActionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rejectEmail>>,
        TError,
        {approvalId: string;data: ApprovalActionRequest},
        TContext
      > => {

      const mutationOptions = getRejectEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get paginated list of email complaints with filters
 * @summary List email complaints
 */
export const listComplaints = (
    params?: ListComplaintsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeComplaintListResponse>(
      {url: `/api/admin/complaints`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListComplaintsQueryKey = (params?: ListComplaintsParams,) => {
    return [
    `/api/admin/complaints`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListComplaintsQueryOptions = <TData = Awaited<ReturnType<typeof listComplaints>>, TError = HTTPValidationError>(params?: ListComplaintsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListComplaintsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listComplaints>>> = ({ signal }) => listComplaints(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListComplaintsQueryResult = NonNullable<Awaited<ReturnType<typeof listComplaints>>>
export type ListComplaintsQueryError = HTTPValidationError


export function useListComplaints<TData = Awaited<ReturnType<typeof listComplaints>>, TError = HTTPValidationError>(
 params: undefined |  ListComplaintsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComplaints>>,
          TError,
          Awaited<ReturnType<typeof listComplaints>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListComplaints<TData = Awaited<ReturnType<typeof listComplaints>>, TError = HTTPValidationError>(
 params?: ListComplaintsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComplaints>>,
          TError,
          Awaited<ReturnType<typeof listComplaints>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListComplaints<TData = Awaited<ReturnType<typeof listComplaints>>, TError = HTTPValidationError>(
 params?: ListComplaintsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List email complaints
 */

export function useListComplaints<TData = Awaited<ReturnType<typeof listComplaints>>, TError = HTTPValidationError>(
 params?: ListComplaintsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComplaints>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListComplaintsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get overall complaint statistics for tenant
 * @summary Get complaint statistics
 */
export const getComplaintStats = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeComplaintStatsResponse>(
      {url: `/api/admin/complaints/stats`, method: 'GET', signal
    },
      );
    }
  



export const getGetComplaintStatsQueryKey = () => {
    return [
    `/api/admin/complaints/stats`
    ] as const;
    }

    
export const getGetComplaintStatsQueryOptions = <TData = Awaited<ReturnType<typeof getComplaintStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetComplaintStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComplaintStats>>> = ({ signal }) => getComplaintStats(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetComplaintStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getComplaintStats>>>
export type GetComplaintStatsQueryError = unknown


export function useGetComplaintStats<TData = Awaited<ReturnType<typeof getComplaintStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComplaintStats>>,
          TError,
          Awaited<ReturnType<typeof getComplaintStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetComplaintStats<TData = Awaited<ReturnType<typeof getComplaintStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComplaintStats>>,
          TError,
          Awaited<ReturnType<typeof getComplaintStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetComplaintStats<TData = Awaited<ReturnType<typeof getComplaintStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get complaint statistics
 */

export function useGetComplaintStats<TData = Awaited<ReturnType<typeof getComplaintStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComplaintStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetComplaintStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Process Feedback Loop report from email provider
 * @summary Process FBL report
 */
export const processFBLReport = (
    processFBLRequest: ProcessFBLRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<SchemasResponseResponseEnvelopeDict>(
      {url: `/api/admin/complaints/process-fbl`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: processFBLRequest, signal
    },
      );
    }
  


export const getProcessFBLReportMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processFBLReport>>, TError,{data: ProcessFBLRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof processFBLReport>>, TError,{data: ProcessFBLRequest}, TContext> => {

const mutationKey = ['processFBLReport'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processFBLReport>>, {data: ProcessFBLRequest}> = (props) => {
          const {data} = props ?? {};

          return  processFBLReport(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessFBLReportMutationResult = NonNullable<Awaited<ReturnType<typeof processFBLReport>>>
    export type ProcessFBLReportMutationBody = ProcessFBLRequest
    export type ProcessFBLReportMutationError = HTTPValidationError

    /**
 * @summary Process FBL report
 */
export const useProcessFBLReport = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processFBLReport>>, TError,{data: ProcessFBLRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processFBLReport>>,
        TError,
        {data: ProcessFBLRequest},
        TContext
      > => {

      const mutationOptions = getProcessFBLReportMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    