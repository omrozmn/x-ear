/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateJobRequest,
  DebugNERRequest,
  EntityExtractionRequest,
  HTTPValidationError,
  ListOcrJobsParams,
  OcrProcessRequest,
  PatientExtractionRequest,
  ResponseEnvelopeListOcrJobRead,
  ResponseEnvelopeOcrDebugResponse,
  ResponseEnvelopeOcrEntitiesResponse,
  ResponseEnvelopeOcrHealthResponse,
  ResponseEnvelopeOcrInitResponse,
  ResponseEnvelopeOcrJobRead,
  ResponseEnvelopeOcrPatientResponse,
  ResponseEnvelopeOcrProcessResponse,
  ResponseEnvelopeOcrSimilarityResponse,
  SimilarityRequest
} from '.././schemas';

import { adminApi } from '../../orval-mutator';




/**
 * Health check endpoint (Public)
 * @summary Health Check
 */
export const listOcrHealth = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrHealthResponse>(
      {url: `/api/ocr/health`, method: 'GET', signal
    },
      );
    }
  



export const getListOcrHealthQueryKey = () => {
    return [
    `/api/ocr/health`
    ] as const;
    }

    
export const getListOcrHealthQueryOptions = <TData = Awaited<ReturnType<typeof listOcrHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOcrHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOcrHealth>>> = ({ signal }) => listOcrHealth(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListOcrHealthQueryResult = NonNullable<Awaited<ReturnType<typeof listOcrHealth>>>
export type ListOcrHealthQueryError = unknown


export function useListOcrHealth<TData = Awaited<ReturnType<typeof listOcrHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOcrHealth>>,
          TError,
          Awaited<ReturnType<typeof listOcrHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOcrHealth<TData = Awaited<ReturnType<typeof listOcrHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOcrHealth>>,
          TError,
          Awaited<ReturnType<typeof listOcrHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOcrHealth<TData = Awaited<ReturnType<typeof listOcrHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Health Check
 */

export function useListOcrHealth<TData = Awaited<ReturnType<typeof listOcrHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrHealth>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListOcrHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Initialize database and create tables (System Admin)
 * @summary Init Database
 */
export const createOcrInitDb = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrInitResponse>(
      {url: `/api/ocr/init-db`, method: 'POST', signal
    },
      );
    }
  


export const getCreateOcrInitDbMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrInitDb>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrInitDb>>, TError,void, TContext> => {

const mutationKey = ['createOcrInitDb'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrInitDb>>, void> = () => {
          

          return  createOcrInitDb()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrInitDbMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrInitDb>>>
    
    export type CreateOcrInitDbMutationError = unknown

    /**
 * @summary Init Database
 */
export const useCreateOcrInitDb = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrInitDb>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrInitDb>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateOcrInitDbMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Initialize NLP/OCR service (System Admin)
 * @summary Initialize Nlp Endpoint
 */
export const createOcrInitialize = (
    
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrInitResponse>(
      {url: `/api/ocr/initialize`, method: 'POST', signal
    },
      );
    }
  


export const getCreateOcrInitializeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrInitialize>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrInitialize>>, TError,void, TContext> => {

const mutationKey = ['createOcrInitialize'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrInitialize>>, void> = () => {
          

          return  createOcrInitialize()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrInitializeMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrInitialize>>>
    
    export type CreateOcrInitializeMutationError = unknown

    /**
 * @summary Initialize Nlp Endpoint
 */
export const useCreateOcrInitialize = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrInitialize>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrInitialize>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateOcrInitializeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Process document with OCR
 * @summary Process Document
 */
export const createOcrProcess = (
    ocrProcessRequest: OcrProcessRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrProcessResponse>(
      {url: `/api/ocr/process`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ocrProcessRequest, signal
    },
      );
    }
  


export const getCreateOcrProcessMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrProcess>>, TError,{data: OcrProcessRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrProcess>>, TError,{data: OcrProcessRequest}, TContext> => {

const mutationKey = ['createOcrProcess'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrProcess>>, {data: OcrProcessRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrProcess(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrProcessMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrProcess>>>
    export type CreateOcrProcessMutationBody = OcrProcessRequest
    export type CreateOcrProcessMutationError = HTTPValidationError

    /**
 * @summary Process Document
 */
export const useCreateOcrProcess = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrProcess>>, TError,{data: OcrProcessRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrProcess>>,
        TError,
        {data: OcrProcessRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrProcessMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Calculate similarity between documents
 * @summary Calculate Similarity
 */
export const createOcrSimilarity = (
    similarityRequest: SimilarityRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrSimilarityResponse>(
      {url: `/api/ocr/similarity`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: similarityRequest, signal
    },
      );
    }
  


export const getCreateOcrSimilarityMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrSimilarity>>, TError,{data: SimilarityRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrSimilarity>>, TError,{data: SimilarityRequest}, TContext> => {

const mutationKey = ['createOcrSimilarity'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrSimilarity>>, {data: SimilarityRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrSimilarity(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrSimilarity>>>
    export type CreateOcrSimilarityMutationBody = SimilarityRequest
    export type CreateOcrSimilarityMutationError = HTTPValidationError

    /**
 * @summary Calculate Similarity
 */
export const useCreateOcrSimilarity = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrSimilarity>>, TError,{data: SimilarityRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrSimilarity>>,
        TError,
        {data: SimilarityRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrSimilarityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract entities from image using OCR
 * @summary Extract Entities
 */
export const createOcrEntities = (
    entityExtractionRequest: EntityExtractionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrEntitiesResponse>(
      {url: `/api/ocr/entities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: entityExtractionRequest, signal
    },
      );
    }
  


export const getCreateOcrEntitiesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrEntities>>, TError,{data: EntityExtractionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrEntities>>, TError,{data: EntityExtractionRequest}, TContext> => {

const mutationKey = ['createOcrEntities'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrEntities>>, {data: EntityExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrEntities(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrEntitiesMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrEntities>>>
    export type CreateOcrEntitiesMutationBody = EntityExtractionRequest
    export type CreateOcrEntitiesMutationError = HTTPValidationError

    /**
 * @summary Extract Entities
 */
export const useCreateOcrEntities = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrEntities>>, TError,{data: EntityExtractionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrEntities>>,
        TError,
        {data: EntityExtractionRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrEntitiesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract patient name from image using OCR
 * @summary Extract Patient Name
 */
export const createOcrExtractPatient = (
    patientExtractionRequest: PatientExtractionRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrPatientResponse>(
      {url: `/api/ocr/extract_patient`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientExtractionRequest, signal
    },
      );
    }
  


export const getCreateOcrExtractPatientMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrExtractPatient>>, TError,{data: PatientExtractionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrExtractPatient>>, TError,{data: PatientExtractionRequest}, TContext> => {

const mutationKey = ['createOcrExtractPatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrExtractPatient>>, {data: PatientExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrExtractPatient(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrExtractPatientMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrExtractPatient>>>
    export type CreateOcrExtractPatientMutationBody = PatientExtractionRequest
    export type CreateOcrExtractPatientMutationError = HTTPValidationError

    /**
 * @summary Extract Patient Name
 */
export const useCreateOcrExtractPatient = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrExtractPatient>>, TError,{data: PatientExtractionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrExtractPatient>>,
        TError,
        {data: PatientExtractionRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrExtractPatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Debug endpoint for NER (System Admin)
 * @summary Debug Ner
 */
export const createOcrDebugNer = (
    debugNERRequest: DebugNERRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrDebugResponse>(
      {url: `/api/ocr/debug_ner`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: debugNERRequest, signal
    },
      );
    }
  


export const getCreateOcrDebugNerMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrDebugNer>>, TError,{data: DebugNERRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrDebugNer>>, TError,{data: DebugNERRequest}, TContext> => {

const mutationKey = ['createOcrDebugNer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrDebugNer>>, {data: DebugNERRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrDebugNer(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrDebugNerMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrDebugNer>>>
    export type CreateOcrDebugNerMutationBody = DebugNERRequest
    export type CreateOcrDebugNerMutationError = HTTPValidationError

    /**
 * @summary Debug Ner
 */
export const useCreateOcrDebugNer = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrDebugNer>>, TError,{data: DebugNERRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrDebugNer>>,
        TError,
        {data: DebugNERRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrDebugNerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List OCR jobs
 * @summary List Jobs
 */
export const listOcrJobs = (
    params?: ListOcrJobsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListOcrJobRead>(
      {url: `/api/ocr/jobs`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListOcrJobsQueryKey = (params?: ListOcrJobsParams,) => {
    return [
    `/api/ocr/jobs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListOcrJobsQueryOptions = <TData = Awaited<ReturnType<typeof listOcrJobs>>, TError = HTTPValidationError>(params?: ListOcrJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOcrJobsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOcrJobs>>> = ({ signal }) => listOcrJobs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListOcrJobsQueryResult = NonNullable<Awaited<ReturnType<typeof listOcrJobs>>>
export type ListOcrJobsQueryError = HTTPValidationError


export function useListOcrJobs<TData = Awaited<ReturnType<typeof listOcrJobs>>, TError = HTTPValidationError>(
 params: undefined |  ListOcrJobsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOcrJobs>>,
          TError,
          Awaited<ReturnType<typeof listOcrJobs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOcrJobs<TData = Awaited<ReturnType<typeof listOcrJobs>>, TError = HTTPValidationError>(
 params?: ListOcrJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOcrJobs>>,
          TError,
          Awaited<ReturnType<typeof listOcrJobs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOcrJobs<TData = Awaited<ReturnType<typeof listOcrJobs>>, TError = HTTPValidationError>(
 params?: ListOcrJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Jobs
 */

export function useListOcrJobs<TData = Awaited<ReturnType<typeof listOcrJobs>>, TError = HTTPValidationError>(
 params?: ListOcrJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOcrJobs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListOcrJobsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new OCR job
 * @summary Create Job
 */
export const createOcrJobs = (
    createJobRequest: CreateJobRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrJobRead>(
      {url: `/api/ocr/jobs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createJobRequest, signal
    },
      );
    }
  


export const getCreateOcrJobsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrJobs>>, TError,{data: CreateJobRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOcrJobs>>, TError,{data: CreateJobRequest}, TContext> => {

const mutationKey = ['createOcrJobs'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOcrJobs>>, {data: CreateJobRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOcrJobs(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOcrJobsMutationResult = NonNullable<Awaited<ReturnType<typeof createOcrJobs>>>
    export type CreateOcrJobsMutationBody = CreateJobRequest
    export type CreateOcrJobsMutationError = HTTPValidationError

    /**
 * @summary Create Job
 */
export const useCreateOcrJobs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOcrJobs>>, TError,{data: CreateJobRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOcrJobs>>,
        TError,
        {data: CreateJobRequest},
        TContext
      > => {

      const mutationOptions = getCreateOcrJobsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get OCR job status
 * @summary Get Job
 */
export const getOcrJob = (
    jobId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeOcrJobRead>(
      {url: `/api/ocr/jobs/${jobId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetOcrJobQueryKey = (jobId?: string,) => {
    return [
    `/api/ocr/jobs/${jobId}`
    ] as const;
    }

    
export const getGetOcrJobQueryOptions = <TData = Awaited<ReturnType<typeof getOcrJob>>, TError = HTTPValidationError>(jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOcrJobQueryKey(jobId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOcrJob>>> = ({ signal }) => getOcrJob(jobId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(jobId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOcrJobQueryResult = NonNullable<Awaited<ReturnType<typeof getOcrJob>>>
export type GetOcrJobQueryError = HTTPValidationError


export function useGetOcrJob<TData = Awaited<ReturnType<typeof getOcrJob>>, TError = HTTPValidationError>(
 jobId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOcrJob>>,
          TError,
          Awaited<ReturnType<typeof getOcrJob>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOcrJob<TData = Awaited<ReturnType<typeof getOcrJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOcrJob>>,
          TError,
          Awaited<ReturnType<typeof getOcrJob>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOcrJob<TData = Awaited<ReturnType<typeof getOcrJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Job
 */

export function useGetOcrJob<TData = Awaited<ReturnType<typeof getOcrJob>>, TError = HTTPValidationError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcrJob>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOcrJobQueryOptions(jobId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




