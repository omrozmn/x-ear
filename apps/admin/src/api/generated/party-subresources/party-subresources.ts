/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  PatientNoteCreate,
  PatientNoteUpdate,
  ResponseEnvelope,
  ResponseEnvelopeListAppointmentRead,
  ResponseEnvelopeListDeviceAssignmentRead,
  ResponseEnvelopeListPartyNoteRead,
  ResponseEnvelopeListSaleRead,
  ResponseEnvelopePartyNoteRead
} from '.././schemas';

import { adminApi } from '../../orval-mutator';




/**
 * Get all devices assigned to a specific party
 * @summary Get Party Devices
 */
export const listPartyDevices = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListDeviceAssignmentRead>(
      {url: `/api/parties/${partyId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getListPartyDevicesQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/devices`
    ] as const;
    }

    
export const getListPartyDevicesQueryOptions = <TData = Awaited<ReturnType<typeof listPartyDevices>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartyDevicesQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartyDevices>>> = ({ signal }) => listPartyDevices(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartyDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof listPartyDevices>>>
export type ListPartyDevicesQueryError = HTTPValidationError


export function useListPartyDevices<TData = Awaited<ReturnType<typeof listPartyDevices>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyDevices>>,
          TError,
          Awaited<ReturnType<typeof listPartyDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyDevices<TData = Awaited<ReturnType<typeof listPartyDevices>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyDevices>>,
          TError,
          Awaited<ReturnType<typeof listPartyDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyDevices<TData = Awaited<ReturnType<typeof listPartyDevices>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Party Devices
 */

export function useListPartyDevices<TData = Awaited<ReturnType<typeof listPartyDevices>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartyDevicesQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all notes for a party
 * @summary Get Party Notes
 */
export const listPartyNotes = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListPartyNoteRead>(
      {url: `/api/parties/${partyId}/notes`, method: 'GET', signal
    },
      );
    }
  



export const getListPartyNotesQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/notes`
    ] as const;
    }

    
export const getListPartyNotesQueryOptions = <TData = Awaited<ReturnType<typeof listPartyNotes>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartyNotesQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartyNotes>>> = ({ signal }) => listPartyNotes(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartyNotesQueryResult = NonNullable<Awaited<ReturnType<typeof listPartyNotes>>>
export type ListPartyNotesQueryError = HTTPValidationError


export function useListPartyNotes<TData = Awaited<ReturnType<typeof listPartyNotes>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyNotes>>,
          TError,
          Awaited<ReturnType<typeof listPartyNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyNotes<TData = Awaited<ReturnType<typeof listPartyNotes>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyNotes>>,
          TError,
          Awaited<ReturnType<typeof listPartyNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyNotes<TData = Awaited<ReturnType<typeof listPartyNotes>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Party Notes
 */

export function useListPartyNotes<TData = Awaited<ReturnType<typeof listPartyNotes>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartyNotesQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new note for party
 * @summary Create Party Note
 */
export const createPartyNotes = (
    partyId: string,
    patientNoteCreate: PatientNoteCreate,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopePartyNoteRead>(
      {url: `/api/parties/${partyId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteCreate, signal
    },
      );
    }
  


export const getCreatePartyNotesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartyNotes>>, TError,{partyId: string;data: PatientNoteCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createPartyNotes>>, TError,{partyId: string;data: PatientNoteCreate}, TContext> => {

const mutationKey = ['createPartyNotes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPartyNotes>>, {partyId: string;data: PatientNoteCreate}> = (props) => {
          const {partyId,data} = props ?? {};

          return  createPartyNotes(partyId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePartyNotesMutationResult = NonNullable<Awaited<ReturnType<typeof createPartyNotes>>>
    export type CreatePartyNotesMutationBody = PatientNoteCreate
    export type CreatePartyNotesMutationError = HTTPValidationError

    /**
 * @summary Create Party Note
 */
export const useCreatePartyNotes = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartyNotes>>, TError,{partyId: string;data: PatientNoteCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPartyNotes>>,
        TError,
        {partyId: string;data: PatientNoteCreate},
        TContext
      > => {

      const mutationOptions = getCreatePartyNotesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update a party note
 * @summary Update Party Note
 */
export const updatePartyNote = (
    partyId: string,
    noteId: string,
    patientNoteUpdate: PatientNoteUpdate,
 ) => {
      
      
      return adminApi<ResponseEnvelopePartyNoteRead>(
      {url: `/api/parties/${partyId}/notes/${noteId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patientNoteUpdate
    },
      );
    }
  


export const getUpdatePartyNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePartyNote>>, TError,{partyId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePartyNote>>, TError,{partyId: string;noteId: string;data: PatientNoteUpdate}, TContext> => {

const mutationKey = ['updatePartyNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePartyNote>>, {partyId: string;noteId: string;data: PatientNoteUpdate}> = (props) => {
          const {partyId,noteId,data} = props ?? {};

          return  updatePartyNote(partyId,noteId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePartyNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updatePartyNote>>>
    export type UpdatePartyNoteMutationBody = PatientNoteUpdate
    export type UpdatePartyNoteMutationError = HTTPValidationError

    /**
 * @summary Update Party Note
 */
export const useUpdatePartyNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePartyNote>>, TError,{partyId: string;noteId: string;data: PatientNoteUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePartyNote>>,
        TError,
        {partyId: string;noteId: string;data: PatientNoteUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePartyNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a party note
 * @summary Delete Party Note
 */
export const deletePartyNote = (
    partyId: string,
    noteId: string,
 ) => {
      
      
      return adminApi<ResponseEnvelope>(
      {url: `/api/parties/${partyId}/notes/${noteId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePartyNoteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePartyNote>>, TError,{partyId: string;noteId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePartyNote>>, TError,{partyId: string;noteId: string}, TContext> => {

const mutationKey = ['deletePartyNote'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePartyNote>>, {partyId: string;noteId: string}> = (props) => {
          const {partyId,noteId} = props ?? {};

          return  deletePartyNote(partyId,noteId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePartyNoteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePartyNote>>>
    
    export type DeletePartyNoteMutationError = HTTPValidationError

    /**
 * @summary Delete Party Note
 */
export const useDeletePartyNote = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePartyNote>>, TError,{partyId: string;noteId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePartyNote>>,
        TError,
        {partyId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getDeletePartyNoteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all sales for a specific party - Flask parity
 * @summary Get Party Sales
 */
export const listPartySales = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListSaleRead>(
      {url: `/api/parties/${partyId}/sales`, method: 'GET', signal
    },
      );
    }
  



export const getListPartySalesQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/sales`
    ] as const;
    }

    
export const getListPartySalesQueryOptions = <TData = Awaited<ReturnType<typeof listPartySales>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartySalesQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartySales>>> = ({ signal }) => listPartySales(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartySalesQueryResult = NonNullable<Awaited<ReturnType<typeof listPartySales>>>
export type ListPartySalesQueryError = HTTPValidationError


export function useListPartySales<TData = Awaited<ReturnType<typeof listPartySales>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartySales>>,
          TError,
          Awaited<ReturnType<typeof listPartySales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartySales<TData = Awaited<ReturnType<typeof listPartySales>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartySales>>,
          TError,
          Awaited<ReturnType<typeof listPartySales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartySales<TData = Awaited<ReturnType<typeof listPartySales>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Party Sales
 */

export function useListPartySales<TData = Awaited<ReturnType<typeof listPartySales>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartySalesQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all appointments for a specific party
 * @summary Get Party Appointments
 */
export const listPartyAppointments = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeListAppointmentRead>(
      {url: `/api/parties/${partyId}/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getListPartyAppointmentsQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/appointments`
    ] as const;
    }

    
export const getListPartyAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof listPartyAppointments>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartyAppointmentsQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartyAppointments>>> = ({ signal }) => listPartyAppointments(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPartyAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof listPartyAppointments>>>
export type ListPartyAppointmentsQueryError = HTTPValidationError


export function useListPartyAppointments<TData = Awaited<ReturnType<typeof listPartyAppointments>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyAppointments>>,
          TError,
          Awaited<ReturnType<typeof listPartyAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyAppointments<TData = Awaited<ReturnType<typeof listPartyAppointments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartyAppointments>>,
          TError,
          Awaited<ReturnType<typeof listPartyAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPartyAppointments<TData = Awaited<ReturnType<typeof listPartyAppointments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Party Appointments
 */

export function useListPartyAppointments<TData = Awaited<ReturnType<typeof listPartyAppointments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartyAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPartyAppointmentsQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




