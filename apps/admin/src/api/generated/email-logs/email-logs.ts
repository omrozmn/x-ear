/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetEmailLogsParams,
  HTTPValidationError,
  ResponseEnvelopeEmailLogListResponse,
  ResponseEnvelopeSendEmailResponse,
  SendEmailRequest
} from '.././schemas';

import { adminApi } from '../../orval-mutator';




/**
 * Get email logs with pagination and filtering.

Returns a paginated list of email logs for the current tenant.
Supports filtering by status, recipient, and date range.

**Permissions Required:** `integrations.smtp.logs.view`

**Query Parameters:**
- page: Page number (default: 1, min: 1)
- perPage: Items per page (default: 25, min: 10, max: 100)
- status: Filter by status (pending, sent, failed, bounced)
- recipient: Filter by recipient email (partial match)
- dateFrom: Filter by date from (ISO-8601 format)
- dateTo: Filter by date to (ISO-8601 format)

**Response:**
- items: List of email logs
- total: Total number of items matching filters
- page: Current page number
- perPage: Items per page
- totalPages: Total number of pages

**Example Response:**
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": "log_123",
        "tenantId": "tenant_456",
        "recipient": "user@example.com",
        "subject": "Password Reset Request",
        "bodyPreview": "You requested a password reset...",
        "status": "sent",
        "sentAt": "2025-01-23T10:00:00Z",
        "errorMessage": null,
        "retryCount": 0,
        "templateName": "password_reset",
        "scenario": "password_reset",
        "createdAt": "2025-01-23T09:59:00Z",
        "updatedAt": "2025-01-23T10:00:00Z"
      }
    ],
    "total": 150,
    "page": 1,
    "perPage": 25,
    "totalPages": 6
  }
}
```
 * @summary Get Email Logs
 */
export const getEmailLogs = (
    params?: GetEmailLogsParams,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeEmailLogListResponse>(
      {url: `/admin/integrations/smtp/logs`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetEmailLogsQueryKey = (params?: GetEmailLogsParams,) => {
    return [
    `/admin/integrations/smtp/logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetEmailLogsQueryOptions = <TData = Awaited<ReturnType<typeof getEmailLogs>>, TError = HTTPValidationError>(params?: GetEmailLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmailLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmailLogs>>> = ({ signal }) => getEmailLogs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEmailLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getEmailLogs>>>
export type GetEmailLogsQueryError = HTTPValidationError


export function useGetEmailLogs<TData = Awaited<ReturnType<typeof getEmailLogs>>, TError = HTTPValidationError>(
 params: undefined |  GetEmailLogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmailLogs>>,
          TError,
          Awaited<ReturnType<typeof getEmailLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmailLogs<TData = Awaited<ReturnType<typeof getEmailLogs>>, TError = HTTPValidationError>(
 params?: GetEmailLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmailLogs>>,
          TError,
          Awaited<ReturnType<typeof getEmailLogs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEmailLogs<TData = Awaited<ReturnType<typeof getEmailLogs>>, TError = HTTPValidationError>(
 params?: GetEmailLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Email Logs
 */

export function useGetEmailLogs<TData = Awaited<ReturnType<typeof getEmailLogs>>, TError = HTTPValidationError>(
 params?: GetEmailLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmailLogs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEmailLogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send manual email to one or more recipients.
    
    Allows administrators to send custom emails using the configured SMTP settings.
    Emails are queued and sent asynchronously in the background.
    
    **Permissions Required:** `emails.send`
    
    **Request Body:**
    - recipients: List of email addresses (1-100)
    - subject: Email subject (1-500 characters)
    - bodyHtml: HTML email body (required)
    - bodyText: Plain text email body (optional, auto-generated if not provided)
    - templateName: Template name if using template (optional)
    - templateVariables: Template variables (optional)
    
    **Response:**
    - emailIds: List of email log IDs for tracking
    - queuedCount: Number of emails queued for sending
    - message: Status message
    - Returns 202 Accepted (emails queued for sending)
    - Returns 404 if no SMTP configuration exists
    
    **Example Request:**
    ```json
    {
      "recipients": ["user1@example.com", "user2@example.com"],
      "subject": "Important Announcement",
      "bodyHtml": "<h1>Hello</h1><p>This is an important announcement.</p>",
      "bodyText": "Hello

This is an important announcement."
    }
    ```
    
    **Example Response:**
    ```json
    {
      "success": true,
      "data": {
        "emailIds": ["log_123", "log_456"],
        "queuedCount": 2,
        "message": "2 emails queued successfully"
      }
    }
    ```
 * @summary Send Manual Email
 */
export const sendManualEmail = (
    sendEmailRequest: SendEmailRequest,
 signal?: AbortSignal
) => {
      
      
      return adminApi<ResponseEnvelopeSendEmailResponse>(
      {url: `/admin/emails/send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendEmailRequest, signal
    },
      );
    }
  


export const getSendManualEmailMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendManualEmail>>, TError,{data: SendEmailRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendManualEmail>>, TError,{data: SendEmailRequest}, TContext> => {

const mutationKey = ['sendManualEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendManualEmail>>, {data: SendEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendManualEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendManualEmailMutationResult = NonNullable<Awaited<ReturnType<typeof sendManualEmail>>>
    export type SendManualEmailMutationBody = SendEmailRequest
    export type SendManualEmailMutationError = HTTPValidationError

    /**
 * @summary Send Manual Email
 */
export const useSendManualEmail = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendManualEmail>>, TError,{data: SendEmailRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendManualEmail>>,
        TError,
        {data: SendEmailRequest},
        TContext
      > => {

      const mutationOptions = getSendManualEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    