/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Merged: manual schemas + auto-generated endpoints
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ErrorResponse,
  Patient,
  PatientSubresourcesAddPatientHearingTestBody,
  PatientSubresourcesCreatePatientEreceiptBody,
  PatientSubresourcesGetPatientDevices200,
  PatientsBulkUploadPatientsBody,
  PatientsCountPatients200,
  PatientsCountPatientsParams,
  PatientsCreatePatientBody,
  PatientsGetPatients200,
  PatientsGetPatientsParams,
  ReplacementsCreatePatientReplacementBody,
  Sale,
  SalesAssignDevicesExtendedBody,
  SalesCreateProductSaleBody,
  SuccessResponse
} from '.././schemas';

import { customInstance } from '../../api-mutator';




/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export const patientsGetPatients = (
    params?: PatientsGetPatientsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PatientsGetPatients200>(
      {url: `/api/patients`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getPatientsGetPatientsQueryKey = (params?: PatientsGetPatientsParams,) => {
    return [
    `/api/patients`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsGetPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse | ErrorResponse>(params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatients>>> = ({ signal }) => patientsGetPatients(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientsGetPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatients>>>
export type PatientsGetPatientsQueryError = ErrorResponse | ErrorResponse


export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse | ErrorResponse>(
 params: undefined |  PatientsGetPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse | ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse | ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get list of patients
 */

export function usePatientsGetPatients<TData = Awaited<ReturnType<typeof patientsGetPatients>>, TError = ErrorResponse | ErrorResponse>(
 params?: PatientsGetPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientsGetPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export const patientsCreatePatient = (
    patientsCreatePatientBody?: PatientsCreatePatientBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Patient>(
      {url: `/api/patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsCreatePatientBody, signal
    },
      );
    }
  


export const getPatientsCreatePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext> => {

const mutationKey = ['patientsCreatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsCreatePatient>>, {data: PatientsCreatePatientBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsCreatePatient(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsCreatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsCreatePatient>>>
    export type PatientsCreatePatientMutationBody = PatientsCreatePatientBody
    export type PatientsCreatePatientMutationError = unknown

    /**
 * @summary POST /api/patients
 */
export const usePatientsCreatePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsCreatePatient>>, TError,{data: PatientsCreatePatientBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsCreatePatient>>,
        TError,
        {data: PatientsCreatePatientBody},
        TContext
      > => {

      const mutationOptions = getPatientsCreatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve detailed information about a specific patient
 * @summary Get a specific patient by ID
 */
export const patientsGetPatient = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Patient>(
      {url: `/api/patients/${patientId}`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsGetPatientQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}`
    ] as const;
    }

    
export const getPatientsGetPatientQueryOptions = <TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsGetPatientQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsGetPatient>>> = ({ signal }) => patientsGetPatient(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientsGetPatientQueryResult = NonNullable<Awaited<ReturnType<typeof patientsGetPatient>>>
export type PatientsGetPatientQueryError = unknown


export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsGetPatient>>,
          TError,
          Awaited<ReturnType<typeof patientsGetPatient>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific patient by ID
 */

export function usePatientsGetPatient<TData = Awaited<ReturnType<typeof patientsGetPatient>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsGetPatient>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientsGetPatientQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an existing patient's information
 * @summary Update a patient
 */
export const patientsUpdatePatient = (
    patientId: string,
    patient: Patient,
 ) => {
      
      
      return customInstance<Patient>(
      {url: `/api/patients/${patientId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: patient
    },
      );
    }
  


export const getPatientsUpdatePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext> => {

const mutationKey = ['patientsUpdatePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsUpdatePatient>>, {patientId: string;data: Patient}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientsUpdatePatient(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsUpdatePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsUpdatePatient>>>
    export type PatientsUpdatePatientMutationBody = Patient
    export type PatientsUpdatePatientMutationError = unknown

    /**
 * @summary Update a patient
 */
export const usePatientsUpdatePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsUpdatePatient>>, TError,{patientId: string;data: Patient}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsUpdatePatient>>,
        TError,
        {patientId: string;data: Patient},
        TContext
      > => {

      const mutationOptions = getPatientsUpdatePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export const patientsDeletePatient = (
    patientId: string,
 ) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/api/patients/${patientId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientsDeletePatientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext> => {

const mutationKey = ['patientsDeletePatient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsDeletePatient>>, {patientId: string}> = (props) => {
          const {patientId} = props ?? {};

          return  patientsDeletePatient(patientId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsDeletePatientMutationResult = NonNullable<Awaited<ReturnType<typeof patientsDeletePatient>>>
    
    export type PatientsDeletePatientMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}
 */
export const usePatientsDeletePatient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsDeletePatient>>, TError,{patientId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsDeletePatient>>,
        TError,
        {patientId: string},
        TContext
      > => {

      const mutationOptions = getPatientsDeletePatientMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const salesAssignDevicesExtended = (
    patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/assign-devices-extended`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesAssignDevicesExtendedBody, signal
    },
      );
    }
  


export const getSalesAssignDevicesExtendedMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext> => {

const mutationKey = ['salesAssignDevicesExtended'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, {patientId: string;data: SalesAssignDevicesExtendedBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesAssignDevicesExtended(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesAssignDevicesExtendedMutationResult = NonNullable<Awaited<ReturnType<typeof salesAssignDevicesExtended>>>
    export type SalesAssignDevicesExtendedMutationBody = SalesAssignDevicesExtendedBody
    export type SalesAssignDevicesExtendedMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export const useSalesAssignDevicesExtended = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesAssignDevicesExtended>>, TError,{patientId: string;data: SalesAssignDevicesExtendedBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesAssignDevicesExtended>>,
        TError,
        {patientId: string;data: SalesAssignDevicesExtendedBody},
        TContext
      > => {

      const mutationOptions = getSalesAssignDevicesExtendedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all devices assigned to a specific patient
 * @summary Get all devices assigned to a specific patient
 */
export const patientSubresourcesGetPatientDevices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PatientSubresourcesGetPatientDevices200>(
      {url: `/api/patients/${patientId}/devices`, method: 'GET', signal
    },
      );
    }
  



export const getPatientSubresourcesGetPatientDevicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/devices`
    ] as const;
    }

    
export const getPatientSubresourcesGetPatientDevicesQueryOptions = <TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientSubresourcesGetPatientDevicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>> = ({ signal }) => patientSubresourcesGetPatientDevices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientSubresourcesGetPatientDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>>
export type PatientSubresourcesGetPatientDevicesQueryError = unknown


export function usePatientSubresourcesGetPatientDevices<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientSubresourcesGetPatientDevices<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientSubresourcesGetPatientDevices<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all devices assigned to a specific patient
 */

export function usePatientSubresourcesGetPatientDevices<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientDevices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientSubresourcesGetPatientDevicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const patientSubresourcesCreatePatientEreceipt = (
    patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/ereceipts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesCreatePatientEreceiptBody, signal
    },
      );
    }
  


export const getPatientSubresourcesCreatePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext> => {

const mutationKey = ['patientSubresourcesCreatePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesCreatePatientEreceipt(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesCreatePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>>
    export type PatientSubresourcesCreatePatientEreceiptMutationBody = PatientSubresourcesCreatePatientEreceiptBody
    export type PatientSubresourcesCreatePatientEreceiptMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export const usePatientSubresourcesCreatePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>, TError,{patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesCreatePatientEreceipt>>,
        TError,
        {patientId: string;data: PatientSubresourcesCreatePatientEreceiptBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesCreatePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const patientSubresourcesDeletePatientEreceipt = (
    patientId: string,
    ereceiptId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/ereceipts/${ereceiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientEreceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientEreceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, {patientId: string;ereceiptId: string}> = (props) => {
          const {patientId,ereceiptId} = props ?? {};

          return  patientSubresourcesDeletePatientEreceipt(patientId,ereceiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientEreceiptMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>>
    
    export type PatientSubresourcesDeletePatientEreceiptMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export const usePatientSubresourcesDeletePatientEreceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>, TError,{patientId: string;ereceiptId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientEreceipt>>,
        TError,
        {patientId: string;ereceiptId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientEreceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const patientSubresourcesAddPatientHearingTest = (
    patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/hearing-tests`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientSubresourcesAddPatientHearingTestBody, signal
    },
      );
    }
  


export const getPatientSubresourcesAddPatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext> => {

const mutationKey = ['patientSubresourcesAddPatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  patientSubresourcesAddPatientHearingTest(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesAddPatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>>
    export type PatientSubresourcesAddPatientHearingTestMutationBody = PatientSubresourcesAddPatientHearingTestBody
    export type PatientSubresourcesAddPatientHearingTestMutationError = unknown

    /**
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export const usePatientSubresourcesAddPatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>, TError,{patientId: string;data: PatientSubresourcesAddPatientHearingTestBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesAddPatientHearingTest>>,
        TError,
        {patientId: string;data: PatientSubresourcesAddPatientHearingTestBody},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesAddPatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const patientSubresourcesDeletePatientHearingTest = (
    patientId: string,
    testId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/hearing-tests/${testId}`, method: 'DELETE'
    },
      );
    }
  


export const getPatientSubresourcesDeletePatientHearingTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext> => {

const mutationKey = ['patientSubresourcesDeletePatientHearingTest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, {patientId: string;testId: string}> = (props) => {
          const {patientId,testId} = props ?? {};

          return  patientSubresourcesDeletePatientHearingTest(patientId,testId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientSubresourcesDeletePatientHearingTestMutationResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>>
    
    export type PatientSubresourcesDeletePatientHearingTestMutationError = unknown

    /**
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export const usePatientSubresourcesDeletePatientHearingTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>, TError,{patientId: string;testId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientSubresourcesDeletePatientHearingTest>>,
        TError,
        {patientId: string;testId: string},
        TContext
      > => {

      const mutationOptions = getPatientSubresourcesDeletePatientHearingTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get all promissory notes for a patient
 */
export const paymentsGetPatientPromissoryNotes = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/promissory-notes`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetPatientPromissoryNotesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/promissory-notes`
    ] as const;
    }

    
export const getPaymentsGetPatientPromissoryNotesQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPromissoryNotesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>> = ({ signal }) => paymentsGetPatientPromissoryNotes(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentsGetPatientPromissoryNotesQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>>
export type PaymentsGetPatientPromissoryNotesQueryError = unknown


export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all promissory notes for a patient
 */

export function usePaymentsGetPatientPromissoryNotes<TData = Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPromissoryNotes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentsGetPatientPromissoryNotesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export const salesGetPatientSales = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Sale[]>(
      {url: `/api/patients/${patientId}/sales`, method: 'GET', signal
    },
      );
    }
  



export const getSalesGetPatientSalesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sales`
    ] as const;
    }

    
export const getSalesGetPatientSalesQueryOptions = <TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSalesGetPatientSalesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof salesGetPatientSales>>> = ({ signal }) => salesGetPatientSales(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SalesGetPatientSalesQueryResult = NonNullable<Awaited<ReturnType<typeof salesGetPatientSales>>>
export type SalesGetPatientSalesQueryError = unknown


export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof salesGetPatientSales>>,
          TError,
          Awaited<ReturnType<typeof salesGetPatientSales>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/patients/{patient_id}/sales
 */

export function useSalesGetPatientSales<TData = Awaited<ReturnType<typeof salesGetPatientSales>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof salesGetPatientSales>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSalesGetPatientSalesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export const sgkGetPatientSgkDocuments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/sgk-documents`, method: 'GET', signal
    },
      );
    }
  



export const getSgkGetPatientSgkDocumentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/sgk-documents`
    ] as const;
    }

    
export const getSgkGetPatientSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetPatientSgkDocumentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>> = ({ signal }) => sgkGetPatientSgkDocuments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SgkGetPatientSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>>
export type SgkGetPatientSgkDocumentsQueryError = unknown


export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */

export function useSgkGetPatientSgkDocuments<TData = Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetPatientSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSgkGetPatientSgkDocumentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const patientsBulkUploadPatients = (
    patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/bulk_upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientsBulkUploadPatientsBody, signal
    },
      );
    }
  


export const getPatientsBulkUploadPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext> => {

const mutationKey = ['patientsBulkUploadPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, {data: PatientsBulkUploadPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  patientsBulkUploadPatients(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatientsBulkUploadPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof patientsBulkUploadPatients>>>
    export type PatientsBulkUploadPatientsMutationBody = PatientsBulkUploadPatientsBody
    export type PatientsBulkUploadPatientsMutationError = unknown

    /**
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export const usePatientsBulkUploadPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patientsBulkUploadPatients>>, TError,{data: PatientsBulkUploadPatientsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patientsBulkUploadPatients>>,
        TError,
        {data: PatientsBulkUploadPatientsBody},
        TContext
      > => {

      const mutationOptions = getPatientsBulkUploadPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Count patients matching the given filters. Only counts patients with valid phone numbers.
Useful for SMS campaign target audience estimation.

 * @summary Count patients with optional filters for SMS campaigns
 */
export const patientsCountPatients = (
    params?: PatientsCountPatientsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PatientsCountPatients200>(
      {url: `/api/patients/count`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getPatientsCountPatientsQueryKey = (params?: PatientsCountPatientsParams,) => {
    return [
    `/api/patients/count`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPatientsCountPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = unknown>(params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsCountPatientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsCountPatients>>> = ({ signal }) => patientsCountPatients(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientsCountPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsCountPatients>>>
export type PatientsCountPatientsQueryError = unknown


export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = unknown>(
 params: undefined |  PatientsCountPatientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = unknown>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsCountPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsCountPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = unknown>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Count patients with optional filters for SMS campaigns
 */

export function usePatientsCountPatients<TData = Awaited<ReturnType<typeof patientsCountPatients>>, TError = unknown>(
 params?: PatientsCountPatientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsCountPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientsCountPatientsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export const patientsExportPatientsCsv = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/export`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsExportPatientsCsvQueryKey = () => {
    return [
    `/api/patients/export`
    ] as const;
    }

    
export const getPatientsExportPatientsCsvQueryOptions = <TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsExportPatientsCsvQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsExportPatientsCsv>>> = ({ signal }) => patientsExportPatientsCsv(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientsExportPatientsCsvQueryResult = NonNullable<Awaited<ReturnType<typeof patientsExportPatientsCsv>>>
export type PatientsExportPatientsCsvQueryError = unknown


export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>,
          TError,
          Awaited<ReturnType<typeof patientsExportPatientsCsv>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */

export function usePatientsExportPatientsCsv<TData = Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsExportPatientsCsv>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientsExportPatientsCsvQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export const patientsSearchPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/search`, method: 'GET', signal
    },
      );
    }
  



export const getPatientsSearchPatientsQueryKey = () => {
    return [
    `/api/patients/search`
    ] as const;
    }

    
export const getPatientsSearchPatientsQueryOptions = <TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientsSearchPatientsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientsSearchPatients>>> = ({ signal }) => patientsSearchPatients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientsSearchPatientsQueryResult = NonNullable<Awaited<ReturnType<typeof patientsSearchPatients>>>
export type PatientsSearchPatientsQueryError = unknown


export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientsSearchPatients>>,
          TError,
          Awaited<ReturnType<typeof patientsSearchPatients>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/patients/search
 */

export function usePatientsSearchPatients<TData = Awaited<ReturnType<typeof patientsSearchPatients>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientsSearchPatients>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientsSearchPatientsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get all invoices for a patient
 */
export const invoicesGetPatientInvoices = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/invoices`, method: 'GET', signal
    },
      );
    }
  



export const getInvoicesGetPatientInvoicesQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/invoices`
    ] as const;
    }

    
export const getInvoicesGetPatientInvoicesQueryOptions = <TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvoicesGetPatientInvoicesQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>> = ({ signal }) => invoicesGetPatientInvoices(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InvoicesGetPatientInvoicesQueryResult = NonNullable<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>>
export type InvoicesGetPatientInvoicesQueryError = unknown


export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>,
          TError,
          Awaited<ReturnType<typeof invoicesGetPatientInvoices>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all invoices for a patient
 */

export function useInvoicesGetPatientInvoices<TData = Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invoicesGetPatientInvoices>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInvoicesGetPatientInvoicesQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Expected payload: { "status": "cancelled", "total_amount": 1000.0, "paid_amount": 500.0, "notes": "Updated notes" }
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const salesUpdateSalePartial = (
    patientId: string,
    saleId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/sales/${saleId}`, method: 'PATCH'
    },
      );
    }
  


export const getSalesUpdateSalePartialMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext> => {

const mutationKey = ['salesUpdateSalePartial'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesUpdateSalePartial>>, {patientId: string;saleId: string}> = (props) => {
          const {patientId,saleId} = props ?? {};

          return  salesUpdateSalePartial(patientId,saleId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesUpdateSalePartialMutationResult = NonNullable<Awaited<ReturnType<typeof salesUpdateSalePartial>>>
    
    export type SalesUpdateSalePartialMutationError = unknown

    /**
 * @summary Partially update a Sale resource. Supports updating status, notes, total_amount, and paid_amount.
 */
export const useSalesUpdateSalePartial = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesUpdateSalePartial>>, TError,{patientId: string;saleId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesUpdateSalePartial>>,
        TError,
        {patientId: string;saleId: string},
        TContext
      > => {

      const mutationOptions = getSalesUpdateSalePartialMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const replacementsCreatePatientReplacement = (
    patientId: string,
    replacementsCreatePatientReplacementBody?: ReplacementsCreatePatientReplacementBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/replacements`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: replacementsCreatePatientReplacementBody, signal
    },
      );
    }
  


export const getReplacementsCreatePatientReplacementMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext> => {

const mutationKey = ['replacementsCreatePatientReplacement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, {patientId: string;data: ReplacementsCreatePatientReplacementBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  replacementsCreatePatientReplacement(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplacementsCreatePatientReplacementMutationResult = NonNullable<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>>
    export type ReplacementsCreatePatientReplacementMutationBody = ReplacementsCreatePatientReplacementBody
    export type ReplacementsCreatePatientReplacementMutationError = unknown

    /**
 * @summary Create a replacement for a patient. Request body mirrors legacy fields.
 */
export const useReplacementsCreatePatientReplacement = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>, TError,{patientId: string;data: ReplacementsCreatePatientReplacementBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replacementsCreatePatientReplacement>>,
        TError,
        {patientId: string;data: ReplacementsCreatePatientReplacementBody},
        TContext
      > => {

      const mutationOptions = getReplacementsCreatePatientReplacementMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get all appointments for a specific patient
 */
export const patientSubresourcesGetPatientAppointments = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/appointments`, method: 'GET', signal
    },
      );
    }
  



export const getPatientSubresourcesGetPatientAppointmentsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/appointments`
    ] as const;
    }

    
export const getPatientSubresourcesGetPatientAppointmentsQueryOptions = <TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPatientSubresourcesGetPatientAppointmentsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>> = ({ signal }) => patientSubresourcesGetPatientAppointments(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PatientSubresourcesGetPatientAppointmentsQueryResult = NonNullable<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>>
export type PatientSubresourcesGetPatientAppointmentsQueryError = unknown


export function usePatientSubresourcesGetPatientAppointments<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientSubresourcesGetPatientAppointments<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>,
          TError,
          Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePatientSubresourcesGetPatientAppointments<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all appointments for a specific patient
 */

export function usePatientSubresourcesGetPatientAppointments<TData = Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof patientSubresourcesGetPatientAppointments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPatientSubresourcesGetPatientAppointmentsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get all proformas for a patient
 */
export const proformasGetPatientProformas = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/proformas`, method: 'GET', signal
    },
      );
    }
  



export const getProformasGetPatientProformasQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/proformas`
    ] as const;
    }

    
export const getProformasGetPatientProformasQueryOptions = <TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProformasGetPatientProformasQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof proformasGetPatientProformas>>> = ({ signal }) => proformasGetPatientProformas(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProformasGetPatientProformasQueryResult = NonNullable<Awaited<ReturnType<typeof proformasGetPatientProformas>>>
export type ProformasGetPatientProformasQueryError = unknown


export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof proformasGetPatientProformas>>,
          TError,
          Awaited<ReturnType<typeof proformasGetPatientProformas>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all proformas for a patient
 */

export function useProformasGetPatientProformas<TData = Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof proformasGetPatientProformas>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProformasGetPatientProformasQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get all payment records for a patient
 */
export const paymentsGetPatientPaymentRecords = (
    patientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/payment-records`, method: 'GET', signal
    },
      );
    }
  



export const getPaymentsGetPatientPaymentRecordsQueryKey = (patientId?: string,) => {
    return [
    `/api/patients/${patientId}/payment-records`
    ] as const;
    }

    
export const getPaymentsGetPatientPaymentRecordsQueryOptions = <TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentsGetPatientPaymentRecordsQueryKey(patientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>> = ({ signal }) => paymentsGetPatientPaymentRecords(patientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(patientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentsGetPatientPaymentRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>>
export type PaymentsGetPatientPaymentRecordsQueryError = unknown


export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>,
          TError,
          Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all payment records for a patient
 */

export function usePaymentsGetPatientPaymentRecords<TData = Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError = unknown>(
 patientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentsGetPatientPaymentRecords>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentsGetPatientPaymentRecordsQueryOptions(patientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create a new product sale from inventory
 */
export const salesCreateProductSale = (
    patientId: string,
    salesCreateProductSaleBody?: SalesCreateProductSaleBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/patients/${patientId}/product-sales`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: salesCreateProductSaleBody, signal
    },
      );
    }
  


export const getSalesCreateProductSaleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext> => {

const mutationKey = ['salesCreateProductSale'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof salesCreateProductSale>>, {patientId: string;data: SalesCreateProductSaleBody}> = (props) => {
          const {patientId,data} = props ?? {};

          return  salesCreateProductSale(patientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SalesCreateProductSaleMutationResult = NonNullable<Awaited<ReturnType<typeof salesCreateProductSale>>>
    export type SalesCreateProductSaleMutationBody = SalesCreateProductSaleBody
    export type SalesCreateProductSaleMutationError = unknown

    /**
 * @summary Create a new product sale from inventory
 */
export const useSalesCreateProductSale = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof salesCreateProductSale>>, TError,{patientId: string;data: SalesCreateProductSaleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof salesCreateProductSale>>,
        TError,
        {patientId: string;data: SalesCreateProductSaleBody},
        TContext
      > => {

      const mutationOptions = getSalesCreateProductSaleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    