/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * FastAPI Backend - Full Migration Complete
 * OpenAPI spec version: 2.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  InvoiceSyncRequest
} from '.././schemas';

import { customInstance } from '../../api-mutator';




/**
 * Send document to BirFatura
 * @summary Send Document
 */
export const sendDocumentApiEFaturaSendDocumentPost = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/sendDocument`, method: 'POST', signal
    },
      );
    }
  


export const getSendDocumentApiEFaturaSendDocumentPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>, TError,void, TContext> => {

const mutationKey = ['sendDocumentApiEFaturaSendDocumentPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>, void> = () => {
          

          return  sendDocumentApiEFaturaSendDocumentPost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendDocumentApiEFaturaSendDocumentPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>>
    
    export type SendDocumentApiEFaturaSendDocumentPostMutationError = unknown

    /**
 * @summary Send Document
 */
export const useSendDocumentApiEFaturaSendDocumentPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendDocumentApiEFaturaSendDocumentPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendDocumentApiEFaturaSendDocumentPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send basic invoice to BirFatura
 * @summary Send Basic Invoice
 */
export const sendBasicInvoiceApiEFaturaSendBasicInvoicePost = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/sendBasicInvoice`, method: 'POST', signal
    },
      );
    }
  


export const getSendBasicInvoiceApiEFaturaSendBasicInvoicePostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>, TError,void, TContext> => {

const mutationKey = ['sendBasicInvoiceApiEFaturaSendBasicInvoicePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>, void> = () => {
          

          return  sendBasicInvoiceApiEFaturaSendBasicInvoicePost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendBasicInvoiceApiEFaturaSendBasicInvoicePostMutationResult = NonNullable<Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>>
    
    export type SendBasicInvoiceApiEFaturaSendBasicInvoicePostMutationError = unknown

    /**
 * @summary Send Basic Invoice
 */
export const useSendBasicInvoiceApiEFaturaSendBasicInvoicePost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendBasicInvoiceApiEFaturaSendBasicInvoicePost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendBasicInvoiceApiEFaturaSendBasicInvoicePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create invoice (draft mode)
 * @summary Create Invoice
 */
export const createInvoiceApiEFaturaCreatePost = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Create`, method: 'POST', signal
    },
      );
    }
  


export const getCreateInvoiceApiEFaturaCreatePostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>, TError,void, TContext> => {

const mutationKey = ['createInvoiceApiEFaturaCreatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>, void> = () => {
          

          return  createInvoiceApiEFaturaCreatePost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateInvoiceApiEFaturaCreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>>
    
    export type CreateInvoiceApiEFaturaCreatePostMutationError = unknown

    /**
 * @summary Create Invoice
 */
export const useCreateInvoiceApiEFaturaCreatePost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createInvoiceApiEFaturaCreatePost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateInvoiceApiEFaturaCreatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retry sending a failed invoice
 * @summary Retry Invoice
 */
export const retryInvoiceApiEFaturaRetryInvoiceIdPost = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Retry/${invoiceId}`, method: 'POST', signal
    },
      );
    }
  


export const getRetryInvoiceApiEFaturaRetryInvoiceIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['retryInvoiceApiEFaturaRetryInvoiceIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  retryInvoiceApiEFaturaRetryInvoiceIdPost(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RetryInvoiceApiEFaturaRetryInvoiceIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>>
    
    export type RetryInvoiceApiEFaturaRetryInvoiceIdPostMutationError = HTTPValidationError

    /**
 * @summary Retry Invoice
 */
export const useRetryInvoiceApiEFaturaRetryInvoiceIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof retryInvoiceApiEFaturaRetryInvoiceIdPost>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getRetryInvoiceApiEFaturaRetryInvoiceIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel an invoice
 * @summary Cancel Invoice
 */
export const cancelInvoiceApiEFaturaCancelInvoiceIdPost = (
    invoiceId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/EFatura/Cancel/${invoiceId}`, method: 'POST', signal
    },
      );
    }
  


export const getCancelInvoiceApiEFaturaCancelInvoiceIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>, TError,{invoiceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>, TError,{invoiceId: string}, TContext> => {

const mutationKey = ['cancelInvoiceApiEFaturaCancelInvoiceIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>, {invoiceId: string}> = (props) => {
          const {invoiceId} = props ?? {};

          return  cancelInvoiceApiEFaturaCancelInvoiceIdPost(invoiceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelInvoiceApiEFaturaCancelInvoiceIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>>
    
    export type CancelInvoiceApiEFaturaCancelInvoiceIdPostMutationError = HTTPValidationError

    /**
 * @summary Cancel Invoice
 */
export const useCancelInvoiceApiEFaturaCancelInvoiceIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>, TError,{invoiceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelInvoiceApiEFaturaCancelInvoiceIdPost>>,
        TError,
        {invoiceId: string},
        TContext
      > => {

      const mutationOptions = getCancelInvoiceApiEFaturaCancelInvoiceIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Sync invoices from BirFatura API
 * @summary Sync Invoices
 */
export const syncInvoicesApiBirfaturaSyncInvoicesPost = (
    invoiceSyncRequest: InvoiceSyncRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/birfatura/sync-invoices`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: invoiceSyncRequest, signal
    },
      );
    }
  


export const getSyncInvoicesApiBirfaturaSyncInvoicesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>, TError,{data: InvoiceSyncRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>, TError,{data: InvoiceSyncRequest}, TContext> => {

const mutationKey = ['syncInvoicesApiBirfaturaSyncInvoicesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>, {data: InvoiceSyncRequest}> = (props) => {
          const {data} = props ?? {};

          return  syncInvoicesApiBirfaturaSyncInvoicesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncInvoicesApiBirfaturaSyncInvoicesPostMutationResult = NonNullable<Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>>
    export type SyncInvoicesApiBirfaturaSyncInvoicesPostMutationBody = InvoiceSyncRequest
    export type SyncInvoicesApiBirfaturaSyncInvoicesPostMutationError = HTTPValidationError

    /**
 * @summary Sync Invoices
 */
export const useSyncInvoicesApiBirfaturaSyncInvoicesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>, TError,{data: InvoiceSyncRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncInvoicesApiBirfaturaSyncInvoicesPost>>,
        TError,
        {data: InvoiceSyncRequest},
        TContext
      > => {

      const mutationOptions = getSyncInvoicesApiBirfaturaSyncInvoicesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    