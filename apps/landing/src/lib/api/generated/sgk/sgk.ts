/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * X-Ear CRM API
 * Merged: manual schemas + auto-generated endpoints
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  SgkCreateSgkWorkflowBody,
  SgkQueryEReceiptBody,
  SgkQueryPatientRightsBody,
  SgkSeedTestPatientsBody,
  SgkUpdateSgkWorkflowBody,
  SgkUpdateWorkflowStatusBody,
  SgkUploadAndProcessFilesBody,
  SgkUploadSgkDocumentBody
} from '.././schemas';

import { customInstance } from '../../api-mutator';




/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export const sgkUploadSgkDocument = (
    sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkUploadSgkDocumentBody, signal
    },
      );
    }
  


export const getSgkUploadSgkDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext> => {

const mutationKey = ['sgkUploadSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, {data: SgkUploadSgkDocumentBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadSgkDocument(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadSgkDocument>>>
    export type SgkUploadSgkDocumentMutationBody = SgkUploadSgkDocumentBody
    export type SgkUploadSgkDocumentMutationError = unknown

    /**
 * @summary POST /api/sgk/documents
 */
export const useSgkUploadSgkDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadSgkDocument>>, TError,{data: SgkUploadSgkDocumentBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadSgkDocument>>,
        TError,
        {data: SgkUploadSgkDocumentBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const sgkDeleteSgkDocument = (
    documentId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/documents/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getSgkDeleteSgkDocumentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['sgkDeleteSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  sgkDeleteSgkDocument(documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkDeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>>
    
    export type SgkDeleteSgkDocumentMutationError = unknown

    /**
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export const useSgkDeleteSgkDocument = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkDeleteSgkDocument>>, TError,{documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkDeleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getSgkDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const sgkUpdateSgkWorkflow = (
    workflowId: string,
    sgkUpdateSgkWorkflowBody?: SgkUpdateSgkWorkflowBody,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/workflow/${workflowId}/update`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: sgkUpdateSgkWorkflowBody
    },
      );
    }
  


export const getSgkUpdateSgkWorkflowMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkUpdateSgkWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, {workflowId: string;data: SgkUpdateSgkWorkflowBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  sgkUpdateSgkWorkflow(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUpdateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>>
    export type SgkUpdateSgkWorkflowMutationBody = SgkUpdateSgkWorkflowBody
    export type SgkUpdateSgkWorkflowMutationError = unknown

    /**
 * @summary SGK workflow g√ºncelleme endpoint'i
 */
export const useSgkUpdateSgkWorkflow = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>, TError,{workflowId: string;data: SgkUpdateSgkWorkflowBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUpdateSgkWorkflow>>,
        TError,
        {workflowId: string;data: SgkUpdateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkUpdateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Required by frontend `sgk.service.ts` > updateWorkflowStatus
 * @summary Mock endpoint to update workflow status.
 */
export const sgkUpdateWorkflowStatus = (
    workflowId: string,
    sgkUpdateWorkflowStatusBody?: SgkUpdateWorkflowStatusBody,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/workflows/${workflowId}/status`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: sgkUpdateWorkflowStatusBody
    },
      );
    }
  


export const getSgkUpdateWorkflowStatusMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>, TError,{workflowId: string;data: SgkUpdateWorkflowStatusBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>, TError,{workflowId: string;data: SgkUpdateWorkflowStatusBody}, TContext> => {

const mutationKey = ['sgkUpdateWorkflowStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>, {workflowId: string;data: SgkUpdateWorkflowStatusBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  sgkUpdateWorkflowStatus(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUpdateWorkflowStatusMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>>
    export type SgkUpdateWorkflowStatusMutationBody = SgkUpdateWorkflowStatusBody
    export type SgkUpdateWorkflowStatusMutationError = unknown

    /**
 * @summary Mock endpoint to update workflow status.
 */
export const useSgkUpdateWorkflowStatus = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>, TError,{workflowId: string;data: SgkUpdateWorkflowStatusBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUpdateWorkflowStatus>>,
        TError,
        {workflowId: string;data: SgkUpdateWorkflowStatusBody},
        TContext
      > => {

      const mutationOptions = getSgkUpdateWorkflowStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const sgkQueryPatientRights = (
    sgkQueryPatientRightsBody?: SgkQueryPatientRightsBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/patient-rights/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkQueryPatientRightsBody, signal
    },
      );
    }
  


export const getSgkQueryPatientRightsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext> => {

const mutationKey = ['sgkQueryPatientRights'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryPatientRights>>, {data: SgkQueryPatientRightsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryPatientRights(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryPatientRightsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryPatientRights>>>
    export type SgkQueryPatientRightsMutationBody = SgkQueryPatientRightsBody
    export type SgkQueryPatientRightsMutationError = unknown

    /**
 * @summary SGK hasta haklarƒ± sorgulama endpoint'i
 */
export const useSgkQueryPatientRights = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryPatientRights>>, TError,{data: SgkQueryPatientRightsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryPatientRights>>,
        TError,
        {data: SgkQueryPatientRightsBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryPatientRightsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Mock endpoint for downloading form
 */
export const sgkDownloadPatientForm = (
    receiptId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/e-receipts/${receiptId}/download-patient-form`, method: 'GET', signal
    },
      );
    }
  



export const getSgkDownloadPatientFormQueryKey = (receiptId?: string,) => {
    return [
    `/api/sgk/e-receipts/${receiptId}/download-patient-form`
    ] as const;
    }

    
export const getSgkDownloadPatientFormQueryOptions = <TData = Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError = unknown>(receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkDownloadPatientFormQueryKey(receiptId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkDownloadPatientForm>>> = ({ signal }) => sgkDownloadPatientForm(receiptId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(receiptId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SgkDownloadPatientFormQueryResult = NonNullable<Awaited<ReturnType<typeof sgkDownloadPatientForm>>>
export type SgkDownloadPatientFormQueryError = unknown


export function useSgkDownloadPatientForm<TData = Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError = unknown>(
 receiptId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkDownloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof sgkDownloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkDownloadPatientForm<TData = Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError = unknown>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkDownloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof sgkDownloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkDownloadPatientForm<TData = Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError = unknown>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Mock endpoint for downloading form
 */

export function useSgkDownloadPatientForm<TData = Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError = unknown>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkDownloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSgkDownloadPatientFormQueryOptions(receiptId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const sgkQueryEReceipt = (
    sgkQueryEReceiptBody?: SgkQueryEReceiptBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/e-receipt/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkQueryEReceiptBody, signal
    },
      );
    }
  


export const getSgkQueryEReceiptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext> => {

const mutationKey = ['sgkQueryEReceipt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkQueryEReceipt>>, {data: SgkQueryEReceiptBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkQueryEReceipt(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkQueryEReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof sgkQueryEReceipt>>>
    export type SgkQueryEReceiptMutationBody = SgkQueryEReceiptBody
    export type SgkQueryEReceiptMutationError = unknown

    /**
 * @summary E-re√ßete sorgulama endpoint'i
 */
export const useSgkQueryEReceipt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkQueryEReceipt>>, TError,{data: SgkQueryEReceiptBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkQueryEReceipt>>,
        TError,
        {data: SgkQueryEReceiptBody},
        TContext
      > => {

      const mutationOptions = getSgkQueryEReceiptMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const sgkSeedTestPatients = (
    sgkSeedTestPatientsBody?: SgkSeedTestPatientsBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/seed-test-patients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkSeedTestPatientsBody, signal
    },
      );
    }
  


export const getSgkSeedTestPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext> => {

const mutationKey = ['sgkSeedTestPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkSeedTestPatients>>, {data: SgkSeedTestPatientsBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkSeedTestPatients(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkSeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof sgkSeedTestPatients>>>
    export type SgkSeedTestPatientsMutationBody = SgkSeedTestPatientsBody
    export type SgkSeedTestPatientsMutationError = unknown

    /**
 * @summary Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
 */
export const useSgkSeedTestPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkSeedTestPatients>>, TError,{data: SgkSeedTestPatientsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkSeedTestPatients>>,
        TError,
        {data: SgkSeedTestPatientsBody},
        TContext
      > => {

      const mutationOptions = getSgkSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const sgkCreateSgkWorkflow = (
    sgkCreateSgkWorkflowBody?: SgkCreateSgkWorkflowBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/workflow/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkCreateSgkWorkflowBody, signal
    },
      );
    }
  


export const getSgkCreateSgkWorkflowMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext> => {

const mutationKey = ['sgkCreateSgkWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, {data: SgkCreateSgkWorkflowBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkCreateSgkWorkflow(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkCreateSgkWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>>
    export type SgkCreateSgkWorkflowMutationBody = SgkCreateSgkWorkflowBody
    export type SgkCreateSgkWorkflowMutationError = unknown

    /**
 * @summary SGK workflow olu≈üturma endpoint'i
 */
export const useSgkCreateSgkWorkflow = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>, TError,{data: SgkCreateSgkWorkflowBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkCreateSgkWorkflow>>,
        TError,
        {data: SgkCreateSgkWorkflowBody},
        TContext
      > => {

      const mutationOptions = getSgkCreateSgkWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */
export const sgkGetSgkWorkflow = (
    workflowId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/workflow/${workflowId}`, method: 'GET', signal
    },
      );
    }
  



export const getSgkGetSgkWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/sgk/workflow/${workflowId}`
    ] as const;
    }

    
export const getSgkGetSgkWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = unknown>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSgkGetSgkWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>> = ({ signal }) => sgkGetSgkWorkflow(workflowId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SgkGetSgkWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>>
export type SgkGetSgkWorkflowQueryError = unknown


export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = unknown>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = unknown>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof sgkGetSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = unknown>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary SGK workflow detaylarƒ± endpoint'i
 */

export function useSgkGetSgkWorkflow<TData = Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError = unknown>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sgkGetSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSgkGetSgkWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Saves files to a secure temporary path, runs OCR (worker-first) with auto_crop=True
and returns per-file OCR results including patient_info.
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const sgkUploadAndProcessFiles = (
    sgkUploadAndProcessFilesBody?: SgkUploadAndProcessFilesBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/sgk/upload`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sgkUploadAndProcessFilesBody, signal
    },
      );
    }
  


export const getSgkUploadAndProcessFilesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext> => {

const mutationKey = ['sgkUploadAndProcessFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, {data: SgkUploadAndProcessFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  sgkUploadAndProcessFiles(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SgkUploadAndProcessFilesMutationResult = NonNullable<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>>
    export type SgkUploadAndProcessFilesMutationBody = SgkUploadAndProcessFilesBody
    export type SgkUploadAndProcessFilesMutationError = unknown

    /**
 * @summary Accept multipart/form-data uploads under the 'files' field (multiple allowed).
 */
export const useSgkUploadAndProcessFiles = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>, TError,{data: SgkUploadAndProcessFilesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sgkUploadAndProcessFiles>>,
        TError,
        {data: SgkUploadAndProcessFilesBody},
        TContext
      > => {

      const mutationOptions = getSgkUploadAndProcessFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    