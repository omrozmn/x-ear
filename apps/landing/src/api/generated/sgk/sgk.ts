/**
 * Generated by orval v7.15.0 ðŸº
 * Do not edit manually.
 * X-Ear CRM API
 * Auto-generated from Flask backend routes
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyCreateSgkUpload,
  EReceiptQueryRequest,
  HTTPValidationError,
  ListSgkEReceiptDeliveredParams,
  PatientRightsQueryRequest,
  UploadSGKDocumentRequest,
  WorkflowCreateRequest,
  WorkflowStatusUpdate,
  WorkflowUpdateRequest
} from '.././schemas';

import { customInstance } from '../../orval-mutator';




/**
 * List SGK documents
 * @summary List Sgk Documents
 */
export const listSgkDocuments = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents`, method: 'GET', signal
    },
      );
    }
  



export const getListSgkDocumentsQueryKey = () => {
    return [
    `/api/sgk/documents`
    ] as const;
    }

    
export const getListSgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSgkDocumentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSgkDocuments>>> = ({ signal }) => listSgkDocuments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof listSgkDocuments>>>
export type ListSgkDocumentsQueryError = unknown


export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listSgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Sgk Documents
 */

export function useListSgkDocuments<TData = Awaited<ReturnType<typeof listSgkDocuments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSgkDocumentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload SGK document
 * @summary Upload Sgk Document
 */
export const createSgkDocuments = (
    uploadSGKDocumentRequest: UploadSGKDocumentRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: uploadSGKDocumentRequest, signal
    },
      );
    }
  


export const getCreateSgkDocumentsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkDocuments>>, TError,{data: UploadSGKDocumentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkDocuments>>, TError,{data: UploadSGKDocumentRequest}, TContext> => {

const mutationKey = ['createSgkDocuments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkDocuments>>, {data: UploadSGKDocumentRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSgkDocuments(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkDocumentsMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkDocuments>>>
    export type CreateSgkDocumentsMutationBody = UploadSGKDocumentRequest
    export type CreateSgkDocumentsMutationError = HTTPValidationError

    /**
 * @summary Upload Sgk Document
 */
export const useCreateSgkDocuments = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkDocuments>>, TError,{data: UploadSGKDocumentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkDocuments>>,
        TError,
        {data: UploadSGKDocumentRequest},
        TContext
      > => {

      const mutationOptions = getCreateSgkDocumentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get SGK document
 * @summary Get Sgk Document
 */
export const getSgkDocument = (
    documentId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents/${documentId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSgkDocumentQueryKey = (documentId?: string,) => {
    return [
    `/api/sgk/documents/${documentId}`
    ] as const;
    }

    
export const getGetSgkDocumentQueryOptions = <TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSgkDocumentQueryKey(documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSgkDocument>>> = ({ signal }) => getSgkDocument(documentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSgkDocumentQueryResult = NonNullable<Awaited<ReturnType<typeof getSgkDocument>>>
export type GetSgkDocumentQueryError = HTTPValidationError


export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof getSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkDocument>>,
          TError,
          Awaited<ReturnType<typeof getSgkDocument>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Sgk Document
 */

export function useGetSgkDocument<TData = Awaited<ReturnType<typeof getSgkDocument>>, TError = HTTPValidationError>(
 documentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkDocument>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSgkDocumentQueryOptions(documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete SGK document
 * @summary Delete Sgk Document
 */
export const deleteSgkDocument = (
    documentId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/documents/${documentId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSgkDocumentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext> => {

const mutationKey = ['deleteSgkDocument'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSgkDocument>>, {documentId: string}> = (props) => {
          const {documentId} = props ?? {};

          return  deleteSgkDocument(documentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSgkDocumentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSgkDocument>>>
    
    export type DeleteSgkDocumentMutationError = HTTPValidationError

    /**
 * @summary Delete Sgk Document
 */
export const useDeleteSgkDocument = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSgkDocument>>, TError,{documentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSgkDocument>>,
        TError,
        {documentId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSgkDocumentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Upload and process SGK files with OCR
 * @summary Upload And Process Files
 */
export const createSgkUpload = (
    bodyCreateSgkUpload: BodyCreateSgkUpload,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
bodyCreateSgkUpload.files.forEach(value => formData.append(`files`, value));

      return customInstance<unknown>(
      {url: `/api/sgk/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreateSgkUploadMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkUpload>>, TError,{data: BodyCreateSgkUpload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkUpload>>, TError,{data: BodyCreateSgkUpload}, TContext> => {

const mutationKey = ['createSgkUpload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkUpload>>, {data: BodyCreateSgkUpload}> = (props) => {
          const {data} = props ?? {};

          return  createSgkUpload(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkUploadMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkUpload>>>
    export type CreateSgkUploadMutationBody = BodyCreateSgkUpload
    export type CreateSgkUploadMutationError = HTTPValidationError

    /**
 * @summary Upload And Process Files
 */
export const useCreateSgkUpload = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkUpload>>, TError,{data: BodyCreateSgkUpload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkUpload>>,
        TError,
        {data: BodyCreateSgkUpload},
        TContext
      > => {

      const mutationOptions = getCreateSgkUploadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get SGK documents for a specific party
 * @summary Get Party Sgk Documents
 */
export const listPartySgkDocuments = (
    partyId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/parties/${partyId}/sgk-documents`, method: 'GET', signal
    },
      );
    }
  



export const getListPartySgkDocumentsQueryKey = (partyId?: string,) => {
    return [
    `/api/parties/${partyId}/sgk-documents`
    ] as const;
    }

    
export const getListPartySgkDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof listPartySgkDocuments>>, TError = HTTPValidationError>(partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPartySgkDocumentsQueryKey(partyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPartySgkDocuments>>> = ({ signal }) => listPartySgkDocuments(partyId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(partyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPartySgkDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof listPartySgkDocuments>>>
export type ListPartySgkDocumentsQueryError = HTTPValidationError


export function useListPartySgkDocuments<TData = Awaited<ReturnType<typeof listPartySgkDocuments>>, TError = HTTPValidationError>(
 partyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartySgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listPartySgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPartySgkDocuments<TData = Awaited<ReturnType<typeof listPartySgkDocuments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPartySgkDocuments>>,
          TError,
          Awaited<ReturnType<typeof listPartySgkDocuments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPartySgkDocuments<TData = Awaited<ReturnType<typeof listPartySgkDocuments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Party Sgk Documents
 */

export function useListPartySgkDocuments<TData = Awaited<ReturnType<typeof listPartySgkDocuments>>, TError = HTTPValidationError>(
 partyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPartySgkDocuments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPartySgkDocumentsQueryOptions(partyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * E-reÃ§ete sorgulama endpoint'i
 * @summary Query E Receipt
 */
export const createSgkEReceiptQuery = (
    eReceiptQueryRequest: EReceiptQueryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipt/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eReceiptQueryRequest, signal
    },
      );
    }
  


export const getCreateSgkEReceiptQueryMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkEReceiptQuery>>, TError,{data: EReceiptQueryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkEReceiptQuery>>, TError,{data: EReceiptQueryRequest}, TContext> => {

const mutationKey = ['createSgkEReceiptQuery'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkEReceiptQuery>>, {data: EReceiptQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSgkEReceiptQuery(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkEReceiptQueryMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkEReceiptQuery>>>
    export type CreateSgkEReceiptQueryMutationBody = EReceiptQueryRequest
    export type CreateSgkEReceiptQueryMutationError = HTTPValidationError

    /**
 * @summary Query E Receipt
 */
export const useCreateSgkEReceiptQuery = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkEReceiptQuery>>, TError,{data: EReceiptQueryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkEReceiptQuery>>,
        TError,
        {data: EReceiptQueryRequest},
        TContext
      > => {

      const mutationOptions = getCreateSgkEReceiptQueryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List delivered e-receipts grouped by patient
 * @summary List Delivered Ereceipts
 */
export const listSgkEReceiptDelivered = (
    params?: ListSgkEReceiptDeliveredParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipts/delivered`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListSgkEReceiptDeliveredQueryKey = (params?: ListSgkEReceiptDeliveredParams,) => {
    return [
    `/api/sgk/e-receipts/delivered`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSgkEReceiptDeliveredQueryOptions = <TData = Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError = HTTPValidationError>(params?: ListSgkEReceiptDeliveredParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSgkEReceiptDeliveredQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>> = ({ signal }) => listSgkEReceiptDelivered(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSgkEReceiptDeliveredQueryResult = NonNullable<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>>
export type ListSgkEReceiptDeliveredQueryError = HTTPValidationError


export function useListSgkEReceiptDelivered<TData = Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError = HTTPValidationError>(
 params: undefined |  ListSgkEReceiptDeliveredParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkEReceiptDelivered>>,
          TError,
          Awaited<ReturnType<typeof listSgkEReceiptDelivered>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkEReceiptDelivered<TData = Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError = HTTPValidationError>(
 params?: ListSgkEReceiptDeliveredParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkEReceiptDelivered>>,
          TError,
          Awaited<ReturnType<typeof listSgkEReceiptDelivered>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkEReceiptDelivered<TData = Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError = HTTPValidationError>(
 params?: ListSgkEReceiptDeliveredParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Delivered Ereceipts
 */

export function useListSgkEReceiptDelivered<TData = Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError = HTTPValidationError>(
 params?: ListSgkEReceiptDeliveredParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDelivered>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSgkEReceiptDeliveredQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * SGK hasta haklarÄ± sorgulama endpoint'i
 * @summary Query Patient Rights
 */
export const createSgkPatientRightQuery = (
    patientRightsQueryRequest: PatientRightsQueryRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/patient-rights/query`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: patientRightsQueryRequest, signal
    },
      );
    }
  


export const getCreateSgkPatientRightQueryMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkPatientRightQuery>>, TError,{data: PatientRightsQueryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkPatientRightQuery>>, TError,{data: PatientRightsQueryRequest}, TContext> => {

const mutationKey = ['createSgkPatientRightQuery'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkPatientRightQuery>>, {data: PatientRightsQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSgkPatientRightQuery(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkPatientRightQueryMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkPatientRightQuery>>>
    export type CreateSgkPatientRightQueryMutationBody = PatientRightsQueryRequest
    export type CreateSgkPatientRightQueryMutationError = HTTPValidationError

    /**
 * @summary Query Patient Rights
 */
export const useCreateSgkPatientRightQuery = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkPatientRightQuery>>, TError,{data: PatientRightsQueryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkPatientRightQuery>>,
        TError,
        {data: PatientRightsQueryRequest},
        TContext
      > => {

      const mutationOptions = getCreateSgkPatientRightQueryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow oluÅŸturma endpoint'i
 * @summary Create Sgk Workflow
 */
export const createSgkWorkflowCreate = (
    workflowCreateRequest: WorkflowCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workflowCreateRequest, signal
    },
      );
    }
  


export const getCreateSgkWorkflowCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflowCreate>>, TError,{data: WorkflowCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflowCreate>>, TError,{data: WorkflowCreateRequest}, TContext> => {

const mutationKey = ['createSgkWorkflowCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkWorkflowCreate>>, {data: WorkflowCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSgkWorkflowCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkWorkflowCreateMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkWorkflowCreate>>>
    export type CreateSgkWorkflowCreateMutationBody = WorkflowCreateRequest
    export type CreateSgkWorkflowCreateMutationError = HTTPValidationError

    /**
 * @summary Create Sgk Workflow
 */
export const useCreateSgkWorkflowCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkWorkflowCreate>>, TError,{data: WorkflowCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkWorkflowCreate>>,
        TError,
        {data: WorkflowCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateSgkWorkflowCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow gÃ¼ncelleme endpoint'i
 * @summary Update Sgk Workflow
 */
export const updateSgkWorkflowUpdate = (
    workflowId: string,
    workflowUpdateRequest: WorkflowUpdateRequest,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/${workflowId}/update`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflowUpdateRequest
    },
      );
    }
  


export const getUpdateSgkWorkflowUpdateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext> => {

const mutationKey = ['updateSgkWorkflowUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>, {workflowId: string;data: WorkflowUpdateRequest}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  updateSgkWorkflowUpdate(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSgkWorkflowUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>>
    export type UpdateSgkWorkflowUpdateMutationBody = WorkflowUpdateRequest
    export type UpdateSgkWorkflowUpdateMutationError = HTTPValidationError

    /**
 * @summary Update Sgk Workflow
 */
export const useUpdateSgkWorkflowUpdate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>, TError,{workflowId: string;data: WorkflowUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSgkWorkflowUpdate>>,
        TError,
        {workflowId: string;data: WorkflowUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateSgkWorkflowUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SGK workflow detaylarÄ± endpoint'i
 * @summary Get Sgk Workflow
 */
export const getSgkWorkflow = (
    workflowId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflow/${workflowId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSgkWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/sgk/workflow/${workflowId}`
    ] as const;
    }

    
export const getGetSgkWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSgkWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSgkWorkflow>>> = ({ signal }) => getSgkWorkflow(workflowId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSgkWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getSgkWorkflow>>>
export type GetSgkWorkflowQueryError = HTTPValidationError


export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSgkWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getSgkWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Sgk Workflow
 */

export function useGetSgkWorkflow<TData = Awaited<ReturnType<typeof getSgkWorkflow>>, TError = HTTPValidationError>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSgkWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSgkWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update workflow status
 * @summary Update Workflow Status
 */
export const updateSgkWorkflowStatus = (
    workflowId: string,
    workflowStatusUpdate: WorkflowStatusUpdate,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/workflows/${workflowId}/status`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflowStatusUpdate
    },
      );
    }
  


export const getUpdateSgkWorkflowStatusMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext> => {

const mutationKey = ['updateSgkWorkflowStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSgkWorkflowStatus>>, {workflowId: string;data: WorkflowStatusUpdate}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  updateSgkWorkflowStatus(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSgkWorkflowStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateSgkWorkflowStatus>>>
    export type UpdateSgkWorkflowStatusMutationBody = WorkflowStatusUpdate
    export type UpdateSgkWorkflowStatusMutationError = HTTPValidationError

    /**
 * @summary Update Workflow Status
 */
export const useUpdateSgkWorkflowStatus = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSgkWorkflowStatus>>, TError,{workflowId: string;data: WorkflowStatusUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSgkWorkflowStatus>>,
        TError,
        {workflowId: string;data: WorkflowStatusUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateSgkWorkflowStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Download patient form as PDF
 * @summary Download Patient Form
 */
export const listSgkEReceiptDownloadPatientForm = (
    receiptId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/e-receipts/${receiptId}/download-patient-form`, method: 'GET', signal
    },
      );
    }
  



export const getListSgkEReceiptDownloadPatientFormQueryKey = (receiptId?: string,) => {
    return [
    `/api/sgk/e-receipts/${receiptId}/download-patient-form`
    ] as const;
    }

    
export const getListSgkEReceiptDownloadPatientFormQueryOptions = <TData = Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError = HTTPValidationError>(receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSgkEReceiptDownloadPatientFormQueryKey(receiptId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>> = ({ signal }) => listSgkEReceiptDownloadPatientForm(receiptId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(receiptId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSgkEReceiptDownloadPatientFormQueryResult = NonNullable<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>>
export type ListSgkEReceiptDownloadPatientFormQueryError = HTTPValidationError


export function useListSgkEReceiptDownloadPatientForm<TData = Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkEReceiptDownloadPatientForm<TData = Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>,
          TError,
          Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSgkEReceiptDownloadPatientForm<TData = Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download Patient Form
 */

export function useListSgkEReceiptDownloadPatientForm<TData = Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError = HTTPValidationError>(
 receiptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSgkEReceiptDownloadPatientForm>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSgkEReceiptDownloadPatientFormQueryOptions(receiptId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Development helper: for each image in the repo images/ folder, run OCR, extract name and tc_partial,
then insert a Patient record with a generated valid TC that contains the partial substring.
This endpoint is intended for local/dev only and makes a best-effort to avoid duplicate inserts.
 * @summary Seed Test Patients
 */
export const createSgkSeedTestPatients = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/sgk/seed-test-patients`, method: 'POST', signal
    },
      );
    }
  


export const getCreateSgkSeedTestPatientsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkSeedTestPatients>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSgkSeedTestPatients>>, TError,void, TContext> => {

const mutationKey = ['createSgkSeedTestPatients'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSgkSeedTestPatients>>, void> = () => {
          

          return  createSgkSeedTestPatients()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSgkSeedTestPatientsMutationResult = NonNullable<Awaited<ReturnType<typeof createSgkSeedTestPatients>>>
    
    export type CreateSgkSeedTestPatientsMutationError = unknown

    /**
 * @summary Seed Test Patients
 */
export const useCreateSgkSeedTestPatients = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSgkSeedTestPatients>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSgkSeedTestPatients>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateSgkSeedTestPatientsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    