/**
 * Generated by orval v7.13.1 ðŸº
 * Do not edit manually.
 * X-Ear CRM API (auto-generated)
 * X-Ear CRM API for managing patients, devices, appointments, sales, and more
 * OpenAPI spec version: 0.0.0-auto
 */
/**
 * Patient's gender
 */
export type PatientGender = typeof PatientGender[keyof typeof PatientGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatientGender = {
  M: 'M',
  F: 'F',
} as const;

/**
 * Patient status
 */
export type PatientStatus = typeof PatientStatus[keyof typeof PatientStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatientStatus = {
  active: 'active',
  inactive: 'inactive',
} as const;

/**
 * SGK information
 */
export type PatientSgkInfo = { [key: string]: unknown };

/**
 * SGK information (snake_case alias)
 */
export type PatientSgkInfo = { [key: string]: unknown };

/**
 * Custom patient data
 */
export type PatientCustomData = { [key: string]: unknown };

/**
 * Custom patient data (snake_case alias)
 */
export type PatientCustomData = { [key: string]: unknown };

export interface Patient {
  /** Unique patient identifier */
  id?: string;
  /** Turkish citizenship number */
  tcNumber: string;
  /** Turkish citizenship number (snake_case alias) */
  tc_number?: string;
  /** Identity number */
  identityNumber?: string;
  /** Identity number (snake_case alias) */
  identity_number?: string;
  /** Patient's first name */
  firstName: string;
  /** Patient's first name (snake_case alias) */
  first_name?: string;
  /** Patient's last name */
  lastName: string;
  /** Patient's last name (snake_case alias) */
  last_name?: string;
  /** Patient's phone number */
  phone: string;
  /** Patient's email address */
  email?: string;
  /** Patient's birth date */
  birthDate?: string;
  /** Patient's birth date (snake_case alias) */
  birth_date?: string;
  /** Patient's gender */
  gender?: PatientGender;
  /** Patient's city */
  addressCity?: string;
  /** Patient's city (snake_case alias) */
  address_city?: string;
  /** Patient's district */
  addressDistrict?: string;
  /** Patient's district (snake_case alias) */
  address_district?: string;
  /** Patient's full address */
  addressFull?: string;
  /** Patient's full address (snake_case alias) */
  address_full?: string;
  /** Patient status */
  status?: PatientStatus;
  /** Patient segment */
  segment?: string;
  /** How patient was acquired */
  acquisitionType?: string;
  /** How patient was acquired (snake_case alias) */
  acquisition_type?: string;
  /** Patient conversion step */
  conversionStep?: string;
  /** Patient conversion step (snake_case alias) */
  conversion_step?: string;
  /** Who referred the patient */
  referredBy?: string;
  /** Who referred the patient (snake_case alias) */
  referred_by?: string;
  /** Patient priority score */
  priorityScore?: number;
  /** Patient priority score (snake_case alias) */
  priority_score?: number;
  /** Patient tags */
  tags?: string[];
  /** SGK information */
  sgkInfo?: PatientSgkInfo;
  /** SGK information (snake_case alias) */
  sgk_info?: PatientSgkInfo;
  /** Custom patient data */
  customData?: PatientCustomData;
  /** Custom patient data (snake_case alias) */
  custom_data?: PatientCustomData;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Appointment status
 */
export type AppointmentStatus = typeof AppointmentStatus[keyof typeof AppointmentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AppointmentStatus = {
  scheduled: 'scheduled',
  confirmed: 'confirmed',
  completed: 'completed',
  cancelled: 'cancelled',
  no_show: 'no_show',
} as const;

export interface Appointment {
  /** Unique appointment identifier */
  id?: string;
  /** Patient ID */
  patientId: string;
  /** Patient ID (snake_case alias) */
  patient_id?: string;
  /** Clinician ID */
  clinicianId?: string;
  /** Clinician ID (snake_case alias) */
  clinician_id?: string;
  /** Branch ID */
  branchId?: string;
  /** Branch ID (snake_case alias) */
  branch_id?: string;
  /** Appointment date */
  date: string;
  /** Appointment time */
  time: string;
  /** Duration in minutes */
  duration?: number;
  /** Type of appointment */
  appointmentType?: string;
  /** Type of appointment (snake_case alias) */
  appointment_type?: string;
  /** Appointment status */
  status?: AppointmentStatus;
  /** Appointment notes */
  notes?: string;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Which ear the device is for
 */
export type DeviceEar = typeof DeviceEar[keyof typeof DeviceEar];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeviceEar = {
  left: 'left',
  right: 'right',
  both: 'both',
} as const;

/**
 * Device status
 */
export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeviceStatus = {
  available: 'available',
  assigned: 'assigned',
  maintenance: 'maintenance',
  retired: 'retired',
} as const;

export interface Device {
  /** Unique device identifier */
  id?: string;
  /** Patient ID */
  patientId?: string;
  /** Patient ID (snake_case alias) */
  patient_id?: string;
  /** Inventory ID */
  inventoryId?: string;
  /** Inventory ID (snake_case alias) */
  inventory_id?: string;
  /** Device serial number */
  serialNumber: string;
  /** Device serial number (snake_case alias) */
  serial_number?: string;
  /** Device brand */
  brand: string;
  /** Device model */
  model: string;
  /** Type of device */
  deviceType?: string;
  /** Type of device (snake_case alias) */
  device_type?: string;
  /** Device category */
  category?: string;
  /** Which ear the device is for */
  ear?: DeviceEar;
  /** Device status */
  status?: DeviceStatus;
  /** Trial start date */
  trialStartDate?: string;
  /** Trial start date (snake_case alias) */
  trial_start_date?: string;
  /** Trial end date */
  trialEndDate?: string;
  /** Trial end date (snake_case alias) */
  trial_end_date?: string;
  /** Trial extended until date */
  trialExtendedUntil?: string;
  /** Trial extended until date (snake_case alias) */
  trial_extended_until?: string;
  /** Warranty start date */
  warrantyStartDate?: string;
  /** Warranty start date (snake_case alias) */
  warranty_start_date?: string;
  /** Warranty end date */
  warrantyEndDate?: string;
  /** Warranty end date (snake_case alias) */
  warranty_end_date?: string;
  /** Warranty terms */
  warrantyTerms?: string;
  /** Warranty terms (snake_case alias) */
  warranty_terms?: string;
  /** Device price */
  price?: number;
  /** Purchase date */
  purchaseDate?: string;
  /** Warranty expiry date */
  warrantyExpiry?: string;
  /** Device notes */
  notes?: string;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Sale status
 */
export type SaleStatus = typeof SaleStatus[keyof typeof SaleStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SaleStatus = {
  pending: 'pending',
  completed: 'completed',
  cancelled: 'cancelled',
} as const;

export interface Sale {
  /** Unique sale identifier */
  id?: string;
  /** Patient ID */
  patientId: string;
  /** Product ID */
  productId?: string;
  /** Sale date */
  saleDate?: string;
  /** Total sale amount */
  totalAmount: number;
  /** List price total */
  listPriceTotal?: number;
  /** Discount amount */
  discountAmount?: number;
  /** SGK coverage amount */
  sgkCoverage?: number;
  /** Patient payment amount */
  patientPayment?: number;
  /** Payment method */
  paymentMethod?: string;
  /** Sale status */
  status?: SaleStatus;
  /** Sale notes */
  notes?: string;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Hearing aid direction
 */
export type InventoryItemDirection = typeof InventoryItemDirection[keyof typeof InventoryItemDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InventoryItemDirection = {
  left: 'left',
  right: 'right',
  both: 'both',
} as const;

/**
 * Legacy field for direction
 */
export type InventoryItemEar = typeof InventoryItemEar[keyof typeof InventoryItemEar];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InventoryItemEar = {
  left: 'left',
  right: 'right',
  both: 'both',
} as const;

export interface InventoryItem {
  /** Unique inventory item identifier */
  id?: string;
  /** Product name */
  name: string;
  /** Product brand */
  brand: string;
  /** Product model */
  model?: string;
  /** Product category */
  category: string;
  /** Product barcode */
  barcode?: string;
  /** Supplier name */
  supplier?: string;
  /** Product description */
  description?: string;
  /** Available inventory count */
  availableInventory?: number;
  /** Total inventory count */
  totalInventory?: number;
  /** Used inventory count */
  usedInventory?: number;
  /** Legacy field for available inventory */
  inventory?: number;
  /** Items currently on trial */
  onTrial?: number;
  /** Minimum stock level for reordering */
  reorderLevel?: number;
  /** Legacy field for reorder level */
  minInventory?: number;
  /** Available serial numbers */
  availableSerials?: string[];
  /** Product features */
  features?: string[];
  /** Unit price */
  price: number;
  /** Hearing aid direction */
  direction?: InventoryItemDirection;
  /** Legacy field for direction */
  ear?: InventoryItemEar;
  /** Warranty period in months */
  warranty?: number;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Supplier status
 */
export type SupplierStatus = typeof SupplierStatus[keyof typeof SupplierStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SupplierStatus = {
  active: 'active',
  inactive: 'inactive',
} as const;

export interface Supplier {
  /** Unique supplier identifier */
  id?: string;
  /** Supplier name */
  name: string;
  /** Contact person name */
  contactPerson: string;
  /** Supplier phone */
  phone?: string;
  /** Supplier email */
  email?: string;
  /** Supplier address */
  address?: string;
  /** Tax number */
  taxNumber?: string;
  /** Supplier status */
  status?: SupplierStatus;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Campaign status
 */
export type CampaignStatus = typeof CampaignStatus[keyof typeof CampaignStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CampaignStatus = {
  draft: 'draft',
  active: 'active',
  paused: 'paused',
  completed: 'completed',
} as const;

export interface Campaign {
  /** Unique campaign identifier */
  id?: string;
  /** Campaign name */
  name: string;
  /** Campaign description */
  description?: string;
  /** Campaign start date */
  startDate: string;
  /** Campaign end date */
  endDate: string;
  /** Campaign budget */
  budget?: number;
  /** Campaign status */
  status?: CampaignStatus;
  /** Target audience */
  targetAudience?: string;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Notification type
 */
export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationType = {
  info: 'info',
  warning: 'warning',
  error: 'error',
  success: 'success',
} as const;

export interface Notification {
  /** Unique notification identifier */
  id?: string;
  /** User ID */
  userId: string;
  /** Notification title */
  title: string;
  /** Notification message */
  message: string;
  /** Notification type */
  type?: NotificationType;
  /** Read status */
  isRead?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Additional error details
 */
export type ErrorResponseDetails = { [key: string]: unknown };

export interface ErrorResponse {
  /** Error message */
  error: string;
  /** Error code */
  code?: number;
  /** Additional error details */
  details?: ErrorResponseDetails;
}

/**
 * Response data
 */
export type SuccessResponseData = { [key: string]: unknown };

export interface SuccessResponse {
  /** Success message */
  message: string;
  /** Response data */
  data?: SuccessResponseData;
}

export interface PaginationInfo {
  /** Current page number */
  page: number;
  /** Items per page */
  perPage: number;
  /** Total number of items */
  total: number;
  /** Total number of pages */
  totalPages: number;
}

/**
 * Payment status
 */
export type PaymentRecordStatus = typeof PaymentRecordStatus[keyof typeof PaymentRecordStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRecordStatus = {
  pending: 'pending',
  completed: 'completed',
  cancelled: 'cancelled',
  overdue: 'overdue',
} as const;

/**
 * Which ear
 */
export type PaymentRecordEar = typeof PaymentRecordEar[keyof typeof PaymentRecordEar];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRecordEar = {
  left: 'left',
  right: 'right',
  both: 'both',
} as const;

export interface PaymentRecord {
  /** Unique payment record identifier */
  id?: string;
  /** Patient ID */
  patientId: string;
  /** Patient ID (snake_case alias) */
  patient_id?: string;
  /** Sale ID */
  saleId?: string;
  /** Sale ID (snake_case alias) */
  sale_id?: string;
  /** Promissory note ID */
  promissoryNoteId?: string;
  /** Promissory note ID (snake_case alias) */
  promissory_note_id?: string;
  /** Payment amount */
  amount: number;
  /** Payment date */
  paymentDate: string;
  /** Payment date (snake_case alias) */
  payment_date?: string;
  /** Due date */
  dueDate?: string;
  /** Due date (snake_case alias) */
  due_date?: string;
  /** Payment method */
  paymentMethod?: string;
  /** Payment method (snake_case alias) */
  payment_method?: string;
  /** Payment type */
  paymentType?: string;
  /** Payment type (snake_case alias) */
  payment_type?: string;
  /** Payment status */
  status?: PaymentRecordStatus;
  /** Reference number */
  referenceNumber?: string;
  /** Reference number (snake_case alias) */
  reference_number?: string;
  /** Payment notes */
  notes?: string;
  /** Device ID */
  deviceId?: string;
  /** Device ID (snake_case alias) */
  device_id?: string;
  /** Which ear */
  ear?: PaymentRecordEar;
  /** Payment reason */
  reason?: string;
  /** From inventory flag */
  fromInventory?: boolean;
  /** From inventory flag (snake_case alias) */
  from_inventory?: boolean;
  /** List price */
  listPrice?: number;
  /** List price (snake_case alias) */
  list_price?: number;
  /** Sale price */
  salePrice?: number;
  /** Sale price (snake_case alias) */
  sale_price?: number;
  /** SGK scheme */
  sgkScheme?: string;
  /** SGK scheme (snake_case alias) */
  sgk_scheme?: string;
  /** SGK support amount */
  sgkSupport?: number;
  /** SGK support amount (snake_case alias) */
  sgk_support?: number;
  /** Discount type */
  discountType?: string;
  /** Discount type (snake_case alias) */
  discount_type?: string;
  /** Discount value */
  discountValue?: number;
  /** Discount value (snake_case alias) */
  discount_value?: number;
  /** Net payable amount */
  netPayable?: number;
  /** Net payable amount (snake_case alias) */
  net_payable?: number;
  /** Product ID */
  productId?: string;
  /** Product ID (snake_case alias) */
  product_id?: string;
  /** Sale date */
  saleDate?: string;
  /** Sale date (snake_case alias) */
  sale_date?: string;
  /** List price total */
  listPriceTotal?: number;
  /** List price total (snake_case alias) */
  list_price_total?: number;
  /** Total amount */
  totalAmount?: number;
  /** Total amount (snake_case alias) */
  total_amount?: number;
  /** Discount amount */
  discountAmount?: number;
  /** Discount amount (snake_case alias) */
  discount_amount?: number;
  /** Final amount */
  finalAmount?: number;
  /** Final amount (snake_case alias) */
  final_amount?: number;
  /** Paid amount */
  paidAmount?: number;
  /** Paid amount (snake_case alias) */
  paid_amount?: number;
  /** Right ear assignment ID */
  rightEarAssignmentId?: string;
  /** Right ear assignment ID (snake_case alias) */
  right_ear_assignment_id?: string;
  /** Left ear assignment ID */
  leftEarAssignmentId?: string;
  /** Left ear assignment ID (snake_case alias) */
  left_ear_assignment_id?: string;
  /** SGK coverage */
  sgkCoverage?: number;
  /** SGK coverage (snake_case alias) */
  sgk_coverage?: number;
  /** Patient payment */
  patientPayment?: number;
  /** Patient payment (snake_case alias) */
  patient_payment?: number;
  /** Payment plan name */
  planName?: string;
  /** Payment plan name (snake_case alias) */
  plan_name?: string;
  /** Number of installments */
  installmentCount?: number;
  /** Number of installments (snake_case alias) */
  installment_count?: number;
  /** Installment amount */
  installmentAmount?: number;
  /** Installment amount (snake_case alias) */
  installment_amount?: number;
  /** Current installment number */
  installmentNumber?: number;
  /** Current installment number (snake_case alias) */
  installment_number?: number;
  /** Remaining balance */
  remainingBalance?: number;
  /** Remaining balance (snake_case alias) */
  remaining_balance?: number;
  /** Interest rate */
  interestRate?: number;
  /** Interest rate (snake_case alias) */
  interest_rate?: number;
  /** Total interest */
  totalInterest?: number;
  /** Total interest (snake_case alias) */
  total_interest?: number;
  /** Processing fee amount */
  processingFee?: number;
  /** Processing fee amount (snake_case alias) */
  processing_fee?: number;
  /** Start date */
  startDate?: string;
  /** Start date (snake_case alias) */
  start_date?: string;
  /** Payment plan ID */
  paymentPlanId?: string;
  /** Payment plan ID (snake_case alias) */
  payment_plan_id?: string;
  /** Paid date */
  paidDate?: string;
  /** Paid date (snake_case alias) */
  paid_date?: string;
  /** Late fee amount */
  lateFee?: number;
  /** Late fee amount (snake_case alias) */
  late_fee?: number;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Additional details
 */
export type UserDetails = { [key: string]: unknown };

export interface User {
  /** Unique user identifier */
  id?: string;
  /** Username */
  username: string;
  /** User email */
  email: string;
  /** User phone number */
  phone?: string;
  /** Password hash */
  passwordHash?: string;
  /** Password hash (snake_case alias) */
  password_hash?: string;
  /** User first name */
  firstName?: string;
  /** User first name (snake_case alias) */
  first_name?: string;
  /** User last name */
  lastName?: string;
  /** User last name (snake_case alias) */
  last_name?: string;
  /** User role */
  role?: string;
  /** User active status */
  isActive?: boolean;
  /** User active status (snake_case alias) */
  is_active?: boolean;
  /** Last login date */
  lastLogin?: string;
  /** Last login date (snake_case alias) */
  last_login?: string;
  /** Password reset token */
  passwordResetToken?: string;
  /** Password reset token (snake_case alias) */
  password_reset_token?: string;
  /** Password reset expiry */
  passwordResetExpires?: string;
  /** Password reset expiry (snake_case alias) */
  password_reset_expires?: string;
  /** User ID for audit */
  userId?: string;
  /** User ID for audit (snake_case alias) */
  user_id?: string;
  /** User action */
  action?: string;
  /** Entity type */
  entityType?: string;
  /** Entity type (snake_case alias) */
  entity_type?: string;
  /** Entity ID */
  entityId?: string;
  /** Entity ID (snake_case alias) */
  entity_id?: string;
  /** IP address */
  ipAddress?: string;
  /** IP address (snake_case alias) */
  ip_address?: string;
  /** User agent */
  userAgent?: string;
  /** User agent (snake_case alias) */
  user_agent?: string;
  /** Additional details */
  details?: UserDetails;
  createdAt?: string;
  updatedAt?: string;
}

export type AppointmentsGetAppointmentsParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
per_page?: number;
/**
 * Filter by patient ID
 */
patient_id?: string;
/**
 * Filter appointments from this date
 */
date_from?: string;
/**
 * Filter appointments to this date
 */
date_to?: string;
/**
 * Filter by appointment status
 */
status?: AppointmentsGetAppointmentsStatus;
/**
 * Filter by branch ID
 */
branch_id?: string;
};

export type AppointmentsGetAppointmentsStatus = typeof AppointmentsGetAppointmentsStatus[keyof typeof AppointmentsGetAppointmentsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AppointmentsGetAppointmentsStatus = {
  scheduled: 'scheduled',
  completed: 'completed',
  cancelled: 'cancelled',
  rescheduled: 'rescheduled',
} as const;

export type AppointmentsGetAppointments200 = {
  data?: Appointment[];
  pagination?: PaginationInfo;
};

export type AppointmentsCreateAppointmentBody = { [key: string]: unknown };

export type AppointmentsCancelAppointmentBody = { [key: string]: unknown };

export type AppointmentsCompleteAppointmentBody = { [key: string]: unknown };

export type AppointmentsRescheduleAppointmentBody = { [key: string]: unknown };

export type AppointmentsListAppointments200 = {
  data?: Appointment[];
  pagination?: PaginationInfo;
};

export type AutomationTriggerBackupBody = { [key: string]: unknown };

export type AutomationTriggerSgkProcessingBody = { [key: string]: unknown };

export type CampaignsCreateCampaignBody = { [key: string]: unknown };

/**
 * Monthly statistics
 */
export type DashboardGetDashboardData200MonthlyStats = {
  patients?: number;
  appointments?: number;
  sales?: number;
};

export type DashboardGetDashboardData200 = {
  /** Total number of patients */
  totalPatients?: number;
  /** Total number of devices */
  totalDevices?: number;
  /** Total number of appointments */
  totalAppointments?: number;
  /** Total sales amount */
  totalSales?: number;
  /** Recent appointments */
  recentAppointments?: Appointment[];
  /** Recent sales */
  recentSales?: Sale[];
  /** Monthly statistics */
  monthlyStats?: DashboardGetDashboardData200MonthlyStats;
};

export type CampaignsSendCampaignBody = { [key: string]: unknown };

export type DevicesGetDevicesParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
per_page?: number;
/**
 * Search term for filtering devices
 */
search?: string;
/**
 * Filter by device brand
 */
brand?: string;
/**
 * Filter by device category
 */
category?: string;
/**
 * Filter by device status
 */
status?: DevicesGetDevicesStatus;
};

export type DevicesGetDevicesStatus = typeof DevicesGetDevicesStatus[keyof typeof DevicesGetDevicesStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DevicesGetDevicesStatus = {
  available: 'available',
  assigned: 'assigned',
  maintenance: 'maintenance',
  retired: 'retired',
} as const;

export type DevicesGetDevices200 = {
  data?: Device[];
  pagination?: PaginationInfo;
};

export type DevicesCreateDeviceBody = { [key: string]: unknown };

export type DevicesUpdateDeviceStockBody = { [key: string]: unknown };

export type InventoryGetInventoryItemsParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
per_page?: number;
/**
 * Search term for filtering items
 */
search?: string;
/**
 * Filter by item category
 */
category?: string;
/**
 * Filter items with low stock
 */
lowStock?: boolean;
/**
 * Filter by item status
 */
status?: InventoryGetInventoryItemsStatus;
};

export type InventoryGetInventoryItemsStatus = typeof InventoryGetInventoryItemsStatus[keyof typeof InventoryGetInventoryItemsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InventoryGetInventoryItemsStatus = {
  available: 'available',
  assigned: 'assigned',
  maintenance: 'maintenance',
  retired: 'retired',
} as const;

export type InventoryGetInventoryItems200 = {
  data?: InventoryItem[];
  pagination?: PaginationInfo;
};

export type InventoryCreateInventoryItemBody = { [key: string]: unknown };

export type InventoryAssignToPatientBody = { [key: string]: unknown };

export type InventoryAddSerialNumbersBody = { [key: string]: unknown };

export type NotificationsMarkNotificationReadBody = { [key: string]: unknown };

export type SgkProcessOcrBody = { [key: string]: unknown };

export type PatientsGetPatientsParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
per_page?: number;
/**
 * Search term for filtering patients
 */
search?: string;
/**
 * Filter by patient status
 */
status?: PatientsGetPatientsStatus;
};

export type PatientsGetPatientsStatus = typeof PatientsGetPatientsStatus[keyof typeof PatientsGetPatientsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatientsGetPatientsStatus = {
  active: 'active',
  inactive: 'inactive',
} as const;

export type PatientsGetPatients200 = {
  data?: Patient[];
  pagination?: PaginationInfo;
};

export type PatientsCreatePatientBody = { [key: string]: unknown };

export type SalesAssignDevicesExtendedBody = { [key: string]: unknown };

export type PatientSubresourcesCreatePatientEreceiptBody = { [key: string]: unknown };

export type PatientSubresourcesAddPatientHearingTestBody = { [key: string]: unknown };

export type PatientSubresourcesCreatePatientNoteBody = { [key: string]: unknown };

export type TimelineGetPatientTimeline200DataItem = {
  id?: string;
  patientId?: string;
  type?: string;
  title?: string;
  description?: string;
  timestamp?: string;
  user?: string;
  source?: string;
};

export type TimelineGetPatientTimeline200Meta = {
  total?: number;
  patient_id?: string;
};

export type TimelineGetPatientTimeline200 = {
  success?: boolean;
  data?: TimelineGetPatientTimeline200DataItem[];
  meta?: TimelineGetPatientTimeline200Meta;
  timestamp?: string;
};

/**
 * Additional event details
 */
export type TimelineAddTimelineEventBodyDetails = { [key: string]: unknown };

export type TimelineAddTimelineEventBody = {
  /** Event type (e.g., 'appointment', 'sale', 'note', 'device_assigned') */
  type: string;
  /** Event title */
  title: string;
  /** Event description */
  description?: string;
  /** Additional event details */
  details?: TimelineAddTimelineEventBodyDetails;
  /** Event timestamp (defaults to current time) */
  timestamp?: string;
  /** Event date in DD.MM.YYYY format */
  date?: string;
  /** Event time in HH:MM format */
  time?: string;
  /** User who created the event (defaults to 'system') */
  user?: string;
  /** FontAwesome icon class (defaults to 'fa-circle') */
  icon?: string;
  /** Event color (defaults to 'blue') */
  color?: string;
  /** Event category (defaults to 'general') */
  category?: string;
};

export type TimelineAddTimelineEvent201Data = {
  id?: string;
  patientId?: string;
  type?: string;
  title?: string;
  description?: string;
  timestamp?: string;
};

export type TimelineAddTimelineEvent201 = {
  success?: boolean;
  data?: TimelineAddTimelineEvent201Data;
  timestamp?: string;
};

export type TimelineDeleteTimelineEvent200 = {
  success?: boolean;
  message?: string;
  timestamp?: string;
};

export type TimelineLogPatientActivityBodyDetails = { [key: string]: unknown };

export type TimelineLogPatientActivityBody = {
  type: string;
  title: string;
  description?: string;
  details?: TimelineLogPatientActivityBodyDetails;
};

export type PatientsBulkUploadPatientsBody = { [key: string]: unknown };

export type SalesPricingPreviewBody = { [key: string]: unknown };

export type SuppliersAddProductSupplierBody = { [key: string]: unknown };

export type RegistrationRegisterPhoneBody = { [key: string]: unknown };

export type SalesCreateSaleBody = { [key: string]: unknown };

export type SalesUpdateSaleBody = { [key: string]: unknown };

export type SalesCreateSalePaymentPlanBody = { [key: string]: unknown };

export type UpdateSettingsBody = { [key: string]: unknown };

export type SgkUploadSgkDocumentBody = { [key: string]: unknown };

export type SuppliersGetSuppliersParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
per_page?: number;
/**
 * Search term for filtering suppliers
 */
search?: string;
/**
 * Filter by supplier status
 */
status?: SuppliersGetSuppliersStatus;
/**
 * Filter by supplier category
 */
category?: string;
};

export type SuppliersGetSuppliersStatus = typeof SuppliersGetSuppliersStatus[keyof typeof SuppliersGetSuppliersStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SuppliersGetSuppliersStatus = {
  active: 'active',
  inactive: 'inactive',
  pending: 'pending',
} as const;

export type SuppliersGetSuppliers200 = {
  data?: Supplier[];
  pagination?: PaginationInfo;
};

export type SuppliersCreateSupplierBody = { [key: string]: unknown };

export type RegistrationVerifyRegistrationOtpBody = { [key: string]: unknown };

export type UsersCreateUserBody = { [key: string]: unknown };

export type UsersUpdateUserBody = { [key: string]: unknown };

export type OcrExtractEntitiesBody = { [key: string]: unknown };

export type OcrExtractPatientNameBody = { [key: string]: unknown };

export type OcrInitDatabaseBody = { [key: string]: unknown };

export type OcrInitializeNlpEndpointBody = { [key: string]: unknown };

export type OcrProcessDocumentBody = { [key: string]: unknown };

export type OcrCalculateSimilarityBody = { [key: string]: unknown };

/**
 * Retrieve a list of appointments with optional filtering and pagination
 * @summary Get list of appointments
 */
export type appointmentsGetAppointmentsResponse200 = {
  data: AppointmentsGetAppointments200
  status: 200
}

export type appointmentsGetAppointmentsResponse401 = {
  data: ErrorResponse
  status: 401
}

export type appointmentsGetAppointmentsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type appointmentsGetAppointmentsResponseSuccess = (appointmentsGetAppointmentsResponse200) & {
  headers: Headers;
};
export type appointmentsGetAppointmentsResponseError = (appointmentsGetAppointmentsResponse401 | appointmentsGetAppointmentsResponse500) & {
  headers: Headers;
};

export type appointmentsGetAppointmentsResponse = (appointmentsGetAppointmentsResponseSuccess | appointmentsGetAppointmentsResponseError)

export const getAppointmentsGetAppointmentsUrl = (params?: AppointmentsGetAppointmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/appointments?${stringifiedParams}` : `/api/appointments`
}

export const appointmentsGetAppointments = async (params?: AppointmentsGetAppointmentsParams, options?: RequestInit): Promise<appointmentsGetAppointmentsResponse> => {
  
  const res = await fetch(getAppointmentsGetAppointmentsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsGetAppointmentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsGetAppointmentsResponse
}



/**
 * Create a new appointment for a patient with specified date, time, and details
 * @summary POST /api/appointments
 */
export type appointmentsCreateAppointmentResponse201 = {
  data: Appointment
  status: 201
}
    
export type appointmentsCreateAppointmentResponseSuccess = (appointmentsCreateAppointmentResponse201) & {
  headers: Headers;
};
;

export type appointmentsCreateAppointmentResponse = (appointmentsCreateAppointmentResponseSuccess)

export const getAppointmentsCreateAppointmentUrl = () => {


  

  return `/api/appointments`
}

export const appointmentsCreateAppointment = async (appointmentsCreateAppointmentBody?: AppointmentsCreateAppointmentBody, options?: RequestInit): Promise<appointmentsCreateAppointmentResponse> => {
  
  const res = await fetch(getAppointmentsCreateAppointmentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appointmentsCreateAppointmentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsCreateAppointmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsCreateAppointmentResponse
}



/**
 * Delete an existing appointment by its unique identifier
 * @summary DELETE /api/appointments/{appointment_id}
 */
export type appointmentsDeleteAppointmentResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type appointmentsDeleteAppointmentResponseSuccess = (appointmentsDeleteAppointmentResponse204) & {
  headers: Headers;
};
;

export type appointmentsDeleteAppointmentResponse = (appointmentsDeleteAppointmentResponseSuccess)

export const getAppointmentsDeleteAppointmentUrl = (appointmentId: string,) => {


  

  return `/api/appointments/${appointmentId}`
}

export const appointmentsDeleteAppointment = async (appointmentId: string, options?: RequestInit): Promise<appointmentsDeleteAppointmentResponse> => {
  
  const res = await fetch(getAppointmentsDeleteAppointmentUrl(appointmentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsDeleteAppointmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsDeleteAppointmentResponse
}



/**
 * Cancel an appointment and optionally provide cancellation reason
 * @summary POST /api/appointments/{appointment_id}/cancel
 */
export type appointmentsCancelAppointmentResponse201 = {
  data: void
  status: 201
}
    
export type appointmentsCancelAppointmentResponseSuccess = (appointmentsCancelAppointmentResponse201) & {
  headers: Headers;
};
;

export type appointmentsCancelAppointmentResponse = (appointmentsCancelAppointmentResponseSuccess)

export const getAppointmentsCancelAppointmentUrl = (appointmentId: string,) => {


  

  return `/api/appointments/${appointmentId}/cancel`
}

export const appointmentsCancelAppointment = async (appointmentId: string,
    appointmentsCancelAppointmentBody?: AppointmentsCancelAppointmentBody, options?: RequestInit): Promise<appointmentsCancelAppointmentResponse> => {
  
  const res = await fetch(getAppointmentsCancelAppointmentUrl(appointmentId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appointmentsCancelAppointmentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsCancelAppointmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsCancelAppointmentResponse
}



/**
 * Mark an appointment as completed and add completion notes
 * @summary POST /api/appointments/{appointment_id}/complete
 */
export type appointmentsCompleteAppointmentResponse201 = {
  data: void
  status: 201
}
    
export type appointmentsCompleteAppointmentResponseSuccess = (appointmentsCompleteAppointmentResponse201) & {
  headers: Headers;
};
;

export type appointmentsCompleteAppointmentResponse = (appointmentsCompleteAppointmentResponseSuccess)

export const getAppointmentsCompleteAppointmentUrl = (appointmentId: string,) => {


  

  return `/api/appointments/${appointmentId}/complete`
}

export const appointmentsCompleteAppointment = async (appointmentId: string,
    appointmentsCompleteAppointmentBody?: AppointmentsCompleteAppointmentBody, options?: RequestInit): Promise<appointmentsCompleteAppointmentResponse> => {
  
  const res = await fetch(getAppointmentsCompleteAppointmentUrl(appointmentId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appointmentsCompleteAppointmentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsCompleteAppointmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsCompleteAppointmentResponse
}



/**
 * Reschedule an existing appointment to a new date and time
 * @summary POST /api/appointments/{appointment_id}/reschedule
 */
export type appointmentsRescheduleAppointmentResponse201 = {
  data: void
  status: 201
}
    
export type appointmentsRescheduleAppointmentResponseSuccess = (appointmentsRescheduleAppointmentResponse201) & {
  headers: Headers;
};
;

export type appointmentsRescheduleAppointmentResponse = (appointmentsRescheduleAppointmentResponseSuccess)

export const getAppointmentsRescheduleAppointmentUrl = (appointmentId: string,) => {


  

  return `/api/appointments/${appointmentId}/reschedule`
}

export const appointmentsRescheduleAppointment = async (appointmentId: string,
    appointmentsRescheduleAppointmentBody?: AppointmentsRescheduleAppointmentBody, options?: RequestInit): Promise<appointmentsRescheduleAppointmentResponse> => {
  
  const res = await fetch(getAppointmentsRescheduleAppointmentUrl(appointmentId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appointmentsRescheduleAppointmentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsRescheduleAppointmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsRescheduleAppointmentResponse
}



/**
 * Get available appointment slots for scheduling
 * @summary GET /api/appointments/availability
 */
export type appointmentsGetAvailabilityResponse200 = {
  data: void
  status: 200
}
    
export type appointmentsGetAvailabilityResponseSuccess = (appointmentsGetAvailabilityResponse200) & {
  headers: Headers;
};
;

export type appointmentsGetAvailabilityResponse = (appointmentsGetAvailabilityResponseSuccess)

export const getAppointmentsGetAvailabilityUrl = () => {


  

  return `/api/appointments/availability`
}

export const appointmentsGetAvailability = async ( options?: RequestInit): Promise<appointmentsGetAvailabilityResponse> => {
  
  const res = await fetch(getAppointmentsGetAvailabilityUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsGetAvailabilityResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsGetAvailabilityResponse
}



/**
 * Retrieve a list of appointments with optional filtering
 * @summary GET /api/appointments/list
 */
export type appointmentsListAppointmentsResponse200 = {
  data: AppointmentsListAppointments200
  status: 200
}
    
export type appointmentsListAppointmentsResponseSuccess = (appointmentsListAppointmentsResponse200) & {
  headers: Headers;
};
;

export type appointmentsListAppointmentsResponse = (appointmentsListAppointmentsResponseSuccess)

export const getAppointmentsListAppointmentsUrl = () => {


  

  return `/api/appointments/list`
}

export const appointmentsListAppointments = async ( options?: RequestInit): Promise<appointmentsListAppointmentsResponse> => {
  
  const res = await fetch(getAppointmentsListAppointmentsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appointmentsListAppointmentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appointmentsListAppointmentsResponse
}



/**
 * Trigger automated system backup process
 * @summary Trigger system backup
 */
export type automationTriggerBackupResponse201 = {
  data: void
  status: 201
}
    
export type automationTriggerBackupResponseSuccess = (automationTriggerBackupResponse201) & {
  headers: Headers;
};
;

export type automationTriggerBackupResponse = (automationTriggerBackupResponseSuccess)

export const getAutomationTriggerBackupUrl = () => {


  

  return `/api/automation/backup`
}

export const automationTriggerBackup = async (automationTriggerBackupBody?: AutomationTriggerBackupBody, options?: RequestInit): Promise<automationTriggerBackupResponse> => {
  
  const res = await fetch(getAutomationTriggerBackupUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      automationTriggerBackupBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: automationTriggerBackupResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as automationTriggerBackupResponse
}



/**
 * Retrieve logs from automated processes and tasks
 * @summary Get automation logs
 */
export type automationGetAutomationLogsResponse200 = {
  data: void
  status: 200
}
    
export type automationGetAutomationLogsResponseSuccess = (automationGetAutomationLogsResponse200) & {
  headers: Headers;
};
;

export type automationGetAutomationLogsResponse = (automationGetAutomationLogsResponseSuccess)

export const getAutomationGetAutomationLogsUrl = () => {


  

  return `/api/automation/logs`
}

export const automationGetAutomationLogs = async ( options?: RequestInit): Promise<automationGetAutomationLogsResponse> => {
  
  const res = await fetch(getAutomationGetAutomationLogsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: automationGetAutomationLogsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as automationGetAutomationLogsResponse
}



/**
 * Trigger automated SGK document processing workflow
 * @summary Trigger SGK document processing
 */
export type automationTriggerSgkProcessingResponse201 = {
  data: void
  status: 201
}
    
export type automationTriggerSgkProcessingResponseSuccess = (automationTriggerSgkProcessingResponse201) & {
  headers: Headers;
};
;

export type automationTriggerSgkProcessingResponse = (automationTriggerSgkProcessingResponseSuccess)

export const getAutomationTriggerSgkProcessingUrl = () => {


  

  return `/api/automation/sgk/process`
}

export const automationTriggerSgkProcessing = async (automationTriggerSgkProcessingBody?: AutomationTriggerSgkProcessingBody, options?: RequestInit): Promise<automationTriggerSgkProcessingResponse> => {
  
  const res = await fetch(getAutomationTriggerSgkProcessingUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      automationTriggerSgkProcessingBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: automationTriggerSgkProcessingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as automationTriggerSgkProcessingResponse
}



/**
 * Retrieve status information
 * @summary Get automation system status
 */
export type automationGetAutomationStatusResponse200 = {
  data: void
  status: 200
}
    
export type automationGetAutomationStatusResponseSuccess = (automationGetAutomationStatusResponse200) & {
  headers: Headers;
};
;

export type automationGetAutomationStatusResponse = (automationGetAutomationStatusResponseSuccess)

export const getAutomationGetAutomationStatusUrl = () => {


  

  return `/api/automation/status`
}

export const automationGetAutomationStatus = async ( options?: RequestInit): Promise<automationGetAutomationStatusResponse> => {
  
  const res = await fetch(getAutomationGetAutomationStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: automationGetAutomationStatusResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as automationGetAutomationStatusResponse
}



/**
 * Create a new marketing campaign with target audience and content
 * @summary POST /api/campaigns
 */
export type campaignsCreateCampaignResponse201 = {
  data: Campaign
  status: 201
}
    
export type campaignsCreateCampaignResponseSuccess = (campaignsCreateCampaignResponse201) & {
  headers: Headers;
};
;

export type campaignsCreateCampaignResponse = (campaignsCreateCampaignResponseSuccess)

export const getCampaignsCreateCampaignUrl = () => {


  

  return `/api/campaigns`
}

export const campaignsCreateCampaign = async (campaignsCreateCampaignBody?: CampaignsCreateCampaignBody, options?: RequestInit): Promise<campaignsCreateCampaignResponse> => {
  
  const res = await fetch(getCampaignsCreateCampaignUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      campaignsCreateCampaignBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: campaignsCreateCampaignResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as campaignsCreateCampaignResponse
}



/**
 * Retrieve dashboard overview data including statistics and recent activities
 * @summary Get dashboard data
 */
export type dashboardGetDashboardDataResponse200 = {
  data: DashboardGetDashboardData200
  status: 200
}

export type dashboardGetDashboardDataResponse401 = {
  data: ErrorResponse
  status: 401
}

export type dashboardGetDashboardDataResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type dashboardGetDashboardDataResponseSuccess = (dashboardGetDashboardDataResponse200) & {
  headers: Headers;
};
export type dashboardGetDashboardDataResponseError = (dashboardGetDashboardDataResponse401 | dashboardGetDashboardDataResponse500) & {
  headers: Headers;
};

export type dashboardGetDashboardDataResponse = (dashboardGetDashboardDataResponseSuccess | dashboardGetDashboardDataResponseError)

export const getDashboardGetDashboardDataUrl = () => {


  

  return `/api/dashboard`
}

export const dashboardGetDashboardData = async ( options?: RequestInit): Promise<dashboardGetDashboardDataResponse> => {
  
  const res = await fetch(getDashboardGetDashboardDataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: dashboardGetDashboardDataResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as dashboardGetDashboardDataResponse
}



/**
 * Create new send
 * @summary POST /api/campaigns/{campaign_id}/send
 */
export type campaignsSendCampaignResponse201 = {
  data: void
  status: 201
}
    
export type campaignsSendCampaignResponseSuccess = (campaignsSendCampaignResponse201) & {
  headers: Headers;
};
;

export type campaignsSendCampaignResponse = (campaignsSendCampaignResponseSuccess)

export const getCampaignsSendCampaignUrl = (campaignId: string,) => {


  

  return `/api/campaigns/${campaignId}/send`
}

export const campaignsSendCampaign = async (campaignId: string,
    campaignsSendCampaignBody?: CampaignsSendCampaignBody, options?: RequestInit): Promise<campaignsSendCampaignResponse> => {
  
  const res = await fetch(getCampaignsSendCampaignUrl(campaignId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      campaignsSendCampaignBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: campaignsSendCampaignResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as campaignsSendCampaignResponse
}



/**
 * Retrieve turnstile information
 * @summary GET /api/config/turnstile
 */
export type registrationGetTurnstileConfigResponse200 = {
  data: void
  status: 200
}
    
export type registrationGetTurnstileConfigResponseSuccess = (registrationGetTurnstileConfigResponse200) & {
  headers: Headers;
};
;

export type registrationGetTurnstileConfigResponse = (registrationGetTurnstileConfigResponseSuccess)

export const getRegistrationGetTurnstileConfigUrl = () => {


  

  return `/api/config/turnstile`
}

export const registrationGetTurnstileConfig = async ( options?: RequestInit): Promise<registrationGetTurnstileConfigResponse> => {
  
  const res = await fetch(getRegistrationGetTurnstileConfigUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registrationGetTurnstileConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registrationGetTurnstileConfigResponse
}



/**
 * Retrieve patient-trends information
 * @summary GET /api/dashboard/charts/patient-trends
 */
export type dashboardPatientTrendsResponse200 = {
  data: void
  status: 200
}
    
export type dashboardPatientTrendsResponseSuccess = (dashboardPatientTrendsResponse200) & {
  headers: Headers;
};
;

export type dashboardPatientTrendsResponse = (dashboardPatientTrendsResponseSuccess)

export const getDashboardPatientTrendsUrl = () => {


  

  return `/api/dashboard/charts/patient-trends`
}

export const dashboardPatientTrends = async ( options?: RequestInit): Promise<dashboardPatientTrendsResponse> => {
  
  const res = await fetch(getDashboardPatientTrendsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: dashboardPatientTrendsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as dashboardPatientTrendsResponse
}



/**
 * Retrieve revenue-trends information
 * @summary GET /api/dashboard/charts/revenue-trends
 */
export type dashboardRevenueTrendsResponse200 = {
  data: void
  status: 200
}
    
export type dashboardRevenueTrendsResponseSuccess = (dashboardRevenueTrendsResponse200) & {
  headers: Headers;
};
;

export type dashboardRevenueTrendsResponse = (dashboardRevenueTrendsResponseSuccess)

export const getDashboardRevenueTrendsUrl = () => {


  

  return `/api/dashboard/charts/revenue-trends`
}

export const dashboardRevenueTrends = async ( options?: RequestInit): Promise<dashboardRevenueTrendsResponse> => {
  
  const res = await fetch(getDashboardRevenueTrendsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: dashboardRevenueTrendsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as dashboardRevenueTrendsResponse
}



/**
 * Retrieve kpis information
 * @summary GET /api/dashboard/kpis
 */
export type dashboardGetKpisResponse200 = {
  data: void
  status: 200
}
    
export type dashboardGetKpisResponseSuccess = (dashboardGetKpisResponse200) & {
  headers: Headers;
};
;

export type dashboardGetKpisResponse = (dashboardGetKpisResponseSuccess)

export const getDashboardGetKpisUrl = () => {


  

  return `/api/dashboard/kpis`
}

export const dashboardGetKpis = async ( options?: RequestInit): Promise<dashboardGetKpisResponse> => {
  
  const res = await fetch(getDashboardGetKpisUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: dashboardGetKpisResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as dashboardGetKpisResponse
}



/**
 * Retrieve recent-activity information
 * @summary GET /api/dashboard/recent-activity
 */
export type dashboardRecentActivityResponse200 = {
  data: void
  status: 200
}
    
export type dashboardRecentActivityResponseSuccess = (dashboardRecentActivityResponse200) & {
  headers: Headers;
};
;

export type dashboardRecentActivityResponse = (dashboardRecentActivityResponseSuccess)

export const getDashboardRecentActivityUrl = () => {


  

  return `/api/dashboard/recent-activity`
}

export const dashboardRecentActivity = async ( options?: RequestInit): Promise<dashboardRecentActivityResponse> => {
  
  const res = await fetch(getDashboardRecentActivityUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: dashboardRecentActivityResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as dashboardRecentActivityResponse
}



/**
 * Retrieve a list of devices with optional filtering and pagination
 * @summary Get list of devices
 */
export type devicesGetDevicesResponse200 = {
  data: DevicesGetDevices200
  status: 200
}

export type devicesGetDevicesResponse401 = {
  data: ErrorResponse
  status: 401
}

export type devicesGetDevicesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type devicesGetDevicesResponseSuccess = (devicesGetDevicesResponse200) & {
  headers: Headers;
};
export type devicesGetDevicesResponseError = (devicesGetDevicesResponse401 | devicesGetDevicesResponse500) & {
  headers: Headers;
};

export type devicesGetDevicesResponse = (devicesGetDevicesResponseSuccess | devicesGetDevicesResponseError)

export const getDevicesGetDevicesUrl = (params?: DevicesGetDevicesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/devices?${stringifiedParams}` : `/api/devices`
}

export const devicesGetDevices = async (params?: DevicesGetDevicesParams, options?: RequestInit): Promise<devicesGetDevicesResponse> => {
  
  const res = await fetch(getDevicesGetDevicesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesGetDevicesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesGetDevicesResponse
}



/**
 * Register a new hearing aid device in the system
 * @summary Create a new device
 */
export type devicesCreateDeviceResponse201 = {
  data: Device
  status: 201
}
    
export type devicesCreateDeviceResponseSuccess = (devicesCreateDeviceResponse201) & {
  headers: Headers;
};
;

export type devicesCreateDeviceResponse = (devicesCreateDeviceResponseSuccess)

export const getDevicesCreateDeviceUrl = () => {


  

  return `/api/devices`
}

export const devicesCreateDevice = async (devicesCreateDeviceBody?: DevicesCreateDeviceBody, options?: RequestInit): Promise<devicesCreateDeviceResponse> => {
  
  const res = await fetch(getDevicesCreateDeviceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      devicesCreateDeviceBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesCreateDeviceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesCreateDeviceResponse
}



/**
 * Remove a device from the system
 * @summary Delete a device
 */
export type devicesDeleteDeviceResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type devicesDeleteDeviceResponseSuccess = (devicesDeleteDeviceResponse204) & {
  headers: Headers;
};
;

export type devicesDeleteDeviceResponse = (devicesDeleteDeviceResponseSuccess)

export const getDevicesDeleteDeviceUrl = (deviceId: string,) => {


  

  return `/api/devices/${deviceId}`
}

export const devicesDeleteDevice = async (deviceId: string, options?: RequestInit): Promise<devicesDeleteDeviceResponse> => {
  
  const res = await fetch(getDevicesDeleteDeviceUrl(deviceId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesDeleteDeviceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesDeleteDeviceResponse
}



/**
 * This endpoint is intentionally permissive for tests â€” real inventory logic
should live in a dedicated inventory table/service.
 * @summary Update device stock levels (simplified).
 */
export type devicesUpdateDeviceStockResponse201 = {
  data: void
  status: 201
}
    
export type devicesUpdateDeviceStockResponseSuccess = (devicesUpdateDeviceStockResponse201) & {
  headers: Headers;
};
;

export type devicesUpdateDeviceStockResponse = (devicesUpdateDeviceStockResponseSuccess)

export const getDevicesUpdateDeviceStockUrl = (deviceId: string,) => {


  

  return `/api/devices/${deviceId}/stock-update`
}

export const devicesUpdateDeviceStock = async (deviceId: string,
    devicesUpdateDeviceStockBody?: DevicesUpdateDeviceStockBody, options?: RequestInit): Promise<devicesUpdateDeviceStockResponse> => {
  
  const res = await fetch(getDevicesUpdateDeviceStockUrl(deviceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      devicesUpdateDeviceStockBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesUpdateDeviceStockResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesUpdateDeviceStockResponse
}



/**
 * Retrieve brands information
 * @summary Get available device brands
 */
export type devicesGetDeviceBrandsResponse200 = {
  data: void
  status: 200
}
    
export type devicesGetDeviceBrandsResponseSuccess = (devicesGetDeviceBrandsResponse200) & {
  headers: Headers;
};
;

export type devicesGetDeviceBrandsResponse = (devicesGetDeviceBrandsResponseSuccess)

export const getDevicesGetDeviceBrandsUrl = () => {


  

  return `/api/devices/brands`
}

export const devicesGetDeviceBrands = async ( options?: RequestInit): Promise<devicesGetDeviceBrandsResponse> => {
  
  const res = await fetch(getDevicesGetDeviceBrandsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesGetDeviceBrandsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesGetDeviceBrandsResponse
}



/**
 * Retrieve categories information
 * @summary Get available device categories
 */
export type devicesGetDeviceCategoriesResponse200 = {
  data: void
  status: 200
}
    
export type devicesGetDeviceCategoriesResponseSuccess = (devicesGetDeviceCategoriesResponse200) & {
  headers: Headers;
};
;

export type devicesGetDeviceCategoriesResponse = (devicesGetDeviceCategoriesResponseSuccess)

export const getDevicesGetDeviceCategoriesUrl = () => {


  

  return `/api/devices/categories`
}

export const devicesGetDeviceCategories = async ( options?: RequestInit): Promise<devicesGetDeviceCategoriesResponse> => {
  
  const res = await fetch(getDevicesGetDeviceCategoriesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesGetDeviceCategoriesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesGetDeviceCategoriesResponse
}



/**
 * Retrieve low-stock information
 * @summary Get devices with low stock levels
 */
export type devicesGetLowStockDevicesResponse200 = {
  data: void
  status: 200
}
    
export type devicesGetLowStockDevicesResponseSuccess = (devicesGetLowStockDevicesResponse200) & {
  headers: Headers;
};
;

export type devicesGetLowStockDevicesResponse = (devicesGetLowStockDevicesResponseSuccess)

export const getDevicesGetLowStockDevicesUrl = () => {


  

  return `/api/devices/low-stock`
}

export const devicesGetLowStockDevices = async ( options?: RequestInit): Promise<devicesGetLowStockDevicesResponse> => {
  
  const res = await fetch(getDevicesGetLowStockDevicesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: devicesGetLowStockDevicesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as devicesGetLowStockDevicesResponse
}



/**
 * Returns 200 when read+write ok, 503 when write fails, and 500 when other errors occur.
 * @summary Health endpoint exposing overall status and DB read/write check results.
 */
export type healthCheckResponse200 = {
  data: void
  status: 200
}
    
export type healthCheckResponseSuccess = (healthCheckResponse200) & {
  headers: Headers;
};
;

export type healthCheckResponse = (healthCheckResponseSuccess)

export const getHealthCheckUrl = () => {


  

  return `/api/health`
}

export const healthCheck = async ( options?: RequestInit): Promise<healthCheckResponse> => {
  
  const res = await fetch(getHealthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthCheckResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthCheckResponse
}



/**
 * Retrieve a list of inventory items with optional filtering and pagination
 * @summary Get list of inventory items
 */
export type inventoryGetInventoryItemsResponse200 = {
  data: InventoryGetInventoryItems200
  status: 200
}

export type inventoryGetInventoryItemsResponse401 = {
  data: ErrorResponse
  status: 401
}

export type inventoryGetInventoryItemsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type inventoryGetInventoryItemsResponseSuccess = (inventoryGetInventoryItemsResponse200) & {
  headers: Headers;
};
export type inventoryGetInventoryItemsResponseError = (inventoryGetInventoryItemsResponse401 | inventoryGetInventoryItemsResponse500) & {
  headers: Headers;
};

export type inventoryGetInventoryItemsResponse = (inventoryGetInventoryItemsResponseSuccess | inventoryGetInventoryItemsResponseError)

export const getInventoryGetInventoryItemsUrl = (params?: InventoryGetInventoryItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/inventory?${stringifiedParams}` : `/api/inventory`
}

export const inventoryGetInventoryItems = async (params?: InventoryGetInventoryItemsParams, options?: RequestInit): Promise<inventoryGetInventoryItemsResponse> => {
  
  const res = await fetch(getInventoryGetInventoryItemsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryGetInventoryItemsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryGetInventoryItemsResponse
}



/**
 * Add a new item to inventory with quantity and details
 * @summary Create a new inventory item
 */
export type inventoryCreateInventoryItemResponse201 = {
  data: InventoryItem
  status: 201
}
    
export type inventoryCreateInventoryItemResponseSuccess = (inventoryCreateInventoryItemResponse201) & {
  headers: Headers;
};
;

export type inventoryCreateInventoryItemResponse = (inventoryCreateInventoryItemResponseSuccess)

export const getInventoryCreateInventoryItemUrl = () => {


  

  return `/api/inventory`
}

export const inventoryCreateInventoryItem = async (inventoryCreateInventoryItemBody?: InventoryCreateInventoryItemBody, options?: RequestInit): Promise<inventoryCreateInventoryItemResponse> => {
  
  const res = await fetch(getInventoryCreateInventoryItemUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inventoryCreateInventoryItemBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryCreateInventoryItemResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryCreateInventoryItemResponse
}



/**
 * Remove an item from inventory
 * @summary Delete an inventory item
 */
export type inventoryDeleteInventoryItemResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type inventoryDeleteInventoryItemResponseSuccess = (inventoryDeleteInventoryItemResponse204) & {
  headers: Headers;
};
;

export type inventoryDeleteInventoryItemResponse = (inventoryDeleteInventoryItemResponseSuccess)

export const getInventoryDeleteInventoryItemUrl = (itemId: string,) => {


  

  return `/api/inventory/${itemId}`
}

export const inventoryDeleteInventoryItem = async (itemId: string, options?: RequestInit): Promise<inventoryDeleteInventoryItemResponse> => {
  
  const res = await fetch(getInventoryDeleteInventoryItemUrl(itemId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryDeleteInventoryItemResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryDeleteInventoryItemResponse
}



/**
 * Retrieve activity information
 * @summary Get activity log for an inventory item
 */
export type inventoryGetInventoryActivitiesResponse200 = {
  data: void
  status: 200
}
    
export type inventoryGetInventoryActivitiesResponseSuccess = (inventoryGetInventoryActivitiesResponse200) & {
  headers: Headers;
};
;

export type inventoryGetInventoryActivitiesResponse = (inventoryGetInventoryActivitiesResponseSuccess)

export const getInventoryGetInventoryActivitiesUrl = (itemId: string,) => {


  

  return `/api/inventory/${itemId}/activity`
}

export const inventoryGetInventoryActivities = async (itemId: string, options?: RequestInit): Promise<inventoryGetInventoryActivitiesResponse> => {
  
  const res = await fetch(getInventoryGetInventoryActivitiesUrl(itemId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryGetInventoryActivitiesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryGetInventoryActivitiesResponse
}



/**
 * Create new assign
 * @summary Assign inventory item to a patient (reduces stock)
 */
export type inventoryAssignToPatientResponse201 = {
  data: void
  status: 201
}
    
export type inventoryAssignToPatientResponseSuccess = (inventoryAssignToPatientResponse201) & {
  headers: Headers;
};
;

export type inventoryAssignToPatientResponse = (inventoryAssignToPatientResponseSuccess)

export const getInventoryAssignToPatientUrl = (itemId: string,) => {


  

  return `/api/inventory/${itemId}/assign`
}

export const inventoryAssignToPatient = async (itemId: string,
    inventoryAssignToPatientBody?: InventoryAssignToPatientBody, options?: RequestInit): Promise<inventoryAssignToPatientResponse> => {
  
  const res = await fetch(getInventoryAssignToPatientUrl(itemId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inventoryAssignToPatientBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryAssignToPatientResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryAssignToPatientResponse
}



/**
 * Create new serials
 * @summary Add serial numbers to an inventory item
 */
export type inventoryAddSerialNumbersResponse201 = {
  data: void
  status: 201
}
    
export type inventoryAddSerialNumbersResponseSuccess = (inventoryAddSerialNumbersResponse201) & {
  headers: Headers;
};
;

export type inventoryAddSerialNumbersResponse = (inventoryAddSerialNumbersResponseSuccess)

export const getInventoryAddSerialNumbersUrl = (itemId: string,) => {


  

  return `/api/inventory/${itemId}/serials`
}

export const inventoryAddSerialNumbers = async (itemId: string,
    inventoryAddSerialNumbersBody?: InventoryAddSerialNumbersBody, options?: RequestInit): Promise<inventoryAddSerialNumbersResponse> => {
  
  const res = await fetch(getInventoryAddSerialNumbersUrl(itemId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inventoryAddSerialNumbersBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryAddSerialNumbersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryAddSerialNumbersResponse
}



/**
 * Retrieve low-stock information
 * @summary Get all items with low stock levels
 */
export type inventoryGetLowStockItemsResponse200 = {
  data: void
  status: 200
}
    
export type inventoryGetLowStockItemsResponseSuccess = (inventoryGetLowStockItemsResponse200) & {
  headers: Headers;
};
;

export type inventoryGetLowStockItemsResponse = (inventoryGetLowStockItemsResponseSuccess)

export const getInventoryGetLowStockItemsUrl = () => {


  

  return `/api/inventory/low-stock`
}

export const inventoryGetLowStockItems = async ( options?: RequestInit): Promise<inventoryGetLowStockItemsResponse> => {
  
  const res = await fetch(getInventoryGetLowStockItemsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryGetLowStockItemsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryGetLowStockItemsResponse
}



/**
 * Get inventory statistics including low stock alerts
 * @summary Get inventory statistics
 */
export type inventoryGetInventoryStatsResponse200 = {
  data: void
  status: 200
}
    
export type inventoryGetInventoryStatsResponseSuccess = (inventoryGetInventoryStatsResponse200) & {
  headers: Headers;
};
;

export type inventoryGetInventoryStatsResponse = (inventoryGetInventoryStatsResponseSuccess)

export const getInventoryGetInventoryStatsUrl = () => {


  

  return `/api/inventory/stats`
}

export const inventoryGetInventoryStats = async ( options?: RequestInit): Promise<inventoryGetInventoryStatsResponse> => {
  
  const res = await fetch(getInventoryGetInventoryStatsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inventoryGetInventoryStatsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inventoryGetInventoryStatsResponse
}



/**
 * Retrieve notifications information
 * @summary GET /api/notifications
 */
export type notificationsListNotificationsResponse200 = {
  data: Notification[]
  status: 200
}
    
export type notificationsListNotificationsResponseSuccess = (notificationsListNotificationsResponse200) & {
  headers: Headers;
};
;

export type notificationsListNotificationsResponse = (notificationsListNotificationsResponseSuccess)

export const getNotificationsListNotificationsUrl = () => {


  

  return `/api/notifications`
}

export const notificationsListNotifications = async ( options?: RequestInit): Promise<notificationsListNotificationsResponse> => {
  
  const res = await fetch(getNotificationsListNotificationsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsListNotificationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsListNotificationsResponse
}



/**
 * Delete a specific notification
 * @summary DELETE /api/notifications/{notification_id}
 */
export type notificationsDeleteNotificationResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type notificationsDeleteNotificationResponseSuccess = (notificationsDeleteNotificationResponse204) & {
  headers: Headers;
};
;

export type notificationsDeleteNotificationResponse = (notificationsDeleteNotificationResponseSuccess)

export const getNotificationsDeleteNotificationUrl = (notificationId: string,) => {


  

  return `/api/notifications/${notificationId}`
}

export const notificationsDeleteNotification = async (notificationId: string, options?: RequestInit): Promise<notificationsDeleteNotificationResponse> => {
  
  const res = await fetch(getNotificationsDeleteNotificationUrl(notificationId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsDeleteNotificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsDeleteNotificationResponse
}



/**
 * Update read information
 * @summary PUT /api/notifications/{notification_id}/read
 */
export type notificationsMarkNotificationReadResponse200 = {
  data: void
  status: 200
}
    
export type notificationsMarkNotificationReadResponseSuccess = (notificationsMarkNotificationReadResponse200) & {
  headers: Headers;
};
;

export type notificationsMarkNotificationReadResponse = (notificationsMarkNotificationReadResponseSuccess)

export const getNotificationsMarkNotificationReadUrl = (notificationId: string,) => {


  

  return `/api/notifications/${notificationId}/read`
}

export const notificationsMarkNotificationRead = async (notificationId: string,
    notificationsMarkNotificationReadBody?: NotificationsMarkNotificationReadBody, options?: RequestInit): Promise<notificationsMarkNotificationReadResponse> => {
  
  const res = await fetch(getNotificationsMarkNotificationReadUrl(notificationId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      notificationsMarkNotificationReadBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsMarkNotificationReadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsMarkNotificationReadResponse
}



/**
 * Retrieve stats information
 * @summary GET /api/notifications/stats
 */
export type notificationsNotificationStatsResponse200 = {
  data: void
  status: 200
}
    
export type notificationsNotificationStatsResponseSuccess = (notificationsNotificationStatsResponse200) & {
  headers: Headers;
};
;

export type notificationsNotificationStatsResponse = (notificationsNotificationStatsResponseSuccess)

export const getNotificationsNotificationStatsUrl = () => {


  

  return `/api/notifications/stats`
}

export const notificationsNotificationStats = async ( options?: RequestInit): Promise<notificationsNotificationStatsResponse> => {
  
  const res = await fetch(getNotificationsNotificationStatsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsNotificationStatsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsNotificationStatsResponse
}



/**
 * Create new process
 * @summary POST /api/ocr/process
 */
export type sgkProcessOcrResponse201 = {
  data: void
  status: 201
}
    
export type sgkProcessOcrResponseSuccess = (sgkProcessOcrResponse201) & {
  headers: Headers;
};
;

export type sgkProcessOcrResponse = (sgkProcessOcrResponseSuccess)

export const getSgkProcessOcrUrl = () => {


  

  return `/api/ocr/process`
}

export const sgkProcessOcr = async (sgkProcessOcrBody?: SgkProcessOcrBody, options?: RequestInit): Promise<sgkProcessOcrResponse> => {
  
  const res = await fetch(getSgkProcessOcrUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sgkProcessOcrBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: sgkProcessOcrResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as sgkProcessOcrResponse
}



/**
 * Returns CORS headers so the static Swagger UI served from a different origin (e.g. localhost:8080)
can fetch the YAML without browser CORS errors.
 * @summary Serve the canonical OpenAPI contract for frontend/back-end sync and respond to CORS preflight.
 */
export type serveOpenapiYamlResponse200 = {
  data: void
  status: 200
}
    
export type serveOpenapiYamlResponseSuccess = (serveOpenapiYamlResponse200) & {
  headers: Headers;
};
;

export type serveOpenapiYamlResponse = (serveOpenapiYamlResponseSuccess)

export const getServeOpenapiYamlUrl = () => {


  

  return `/api/openapi.yaml`
}

export const serveOpenapiYaml = async ( options?: RequestInit): Promise<serveOpenapiYamlResponse> => {
  
  const res = await fetch(getServeOpenapiYamlUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: serveOpenapiYamlResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as serveOpenapiYamlResponse
}



/**
 * Retrieve a list of patients with optional filtering and pagination
 * @summary Get list of patients
 */
export type patientsGetPatientsResponse200 = {
  data: PatientsGetPatients200
  status: 200
}

export type patientsGetPatientsResponse401 = {
  data: ErrorResponse
  status: 401
}

export type patientsGetPatientsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type patientsGetPatientsResponseSuccess = (patientsGetPatientsResponse200) & {
  headers: Headers;
};
export type patientsGetPatientsResponseError = (patientsGetPatientsResponse401 | patientsGetPatientsResponse500) & {
  headers: Headers;
};

export type patientsGetPatientsResponse = (patientsGetPatientsResponseSuccess | patientsGetPatientsResponseError)

export const getPatientsGetPatientsUrl = (params?: PatientsGetPatientsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/patients?${stringifiedParams}` : `/api/patients`
}

export const patientsGetPatients = async (params?: PatientsGetPatientsParams, options?: RequestInit): Promise<patientsGetPatientsResponse> => {
  
  const res = await fetch(getPatientsGetPatientsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsGetPatientsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsGetPatientsResponse
}



/**
 * Register a new patient with personal and medical information
 * @summary POST /api/patients
 */
export type patientsCreatePatientResponse201 = {
  data: Patient
  status: 201
}
    
export type patientsCreatePatientResponseSuccess = (patientsCreatePatientResponse201) & {
  headers: Headers;
};
;

export type patientsCreatePatientResponse = (patientsCreatePatientResponseSuccess)

export const getPatientsCreatePatientUrl = () => {


  

  return `/api/patients`
}

export const patientsCreatePatient = async (patientsCreatePatientBody?: PatientsCreatePatientBody, options?: RequestInit): Promise<patientsCreatePatientResponse> => {
  
  const res = await fetch(getPatientsCreatePatientUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patientsCreatePatientBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsCreatePatientResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsCreatePatientResponse
}



/**
 * Remove a patient record from the system
 * @summary DELETE /api/patients/{patient_id}
 */
export type patientsDeletePatientResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type patientsDeletePatientResponseSuccess = (patientsDeletePatientResponse204) & {
  headers: Headers;
};
;

export type patientsDeletePatientResponse = (patientsDeletePatientResponseSuccess)

export const getPatientsDeletePatientUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}`
}

export const patientsDeletePatient = async (patientId: string, options?: RequestInit): Promise<patientsDeletePatientResponse> => {
  
  const res = await fetch(getPatientsDeletePatientUrl(patientId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsDeletePatientResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsDeletePatientResponse
}



/**
 * Create new assign-devices-extended
 * @summary POST /api/patients/{patient_id}/assign-devices-extended
 */
export type salesAssignDevicesExtendedResponse201 = {
  data: void
  status: 201
}
    
export type salesAssignDevicesExtendedResponseSuccess = (salesAssignDevicesExtendedResponse201) & {
  headers: Headers;
};
;

export type salesAssignDevicesExtendedResponse = (salesAssignDevicesExtendedResponseSuccess)

export const getSalesAssignDevicesExtendedUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/assign-devices-extended`
}

export const salesAssignDevicesExtended = async (patientId: string,
    salesAssignDevicesExtendedBody?: SalesAssignDevicesExtendedBody, options?: RequestInit): Promise<salesAssignDevicesExtendedResponse> => {
  
  const res = await fetch(getSalesAssignDevicesExtendedUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      salesAssignDevicesExtendedBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesAssignDevicesExtendedResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesAssignDevicesExtendedResponse
}



/**
 * Create new ereceipts
 * @summary POST /api/patients/{patient_id}/ereceipts
 */
export type patientSubresourcesCreatePatientEreceiptResponse201 = {
  data: void
  status: 201
}
    
export type patientSubresourcesCreatePatientEreceiptResponseSuccess = (patientSubresourcesCreatePatientEreceiptResponse201) & {
  headers: Headers;
};
;

export type patientSubresourcesCreatePatientEreceiptResponse = (patientSubresourcesCreatePatientEreceiptResponseSuccess)

export const getPatientSubresourcesCreatePatientEreceiptUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/ereceipts`
}

export const patientSubresourcesCreatePatientEreceipt = async (patientId: string,
    patientSubresourcesCreatePatientEreceiptBody?: PatientSubresourcesCreatePatientEreceiptBody, options?: RequestInit): Promise<patientSubresourcesCreatePatientEreceiptResponse> => {
  
  const res = await fetch(getPatientSubresourcesCreatePatientEreceiptUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patientSubresourcesCreatePatientEreceiptBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesCreatePatientEreceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesCreatePatientEreceiptResponse
}



/**
 * Delete {ereceipt_id}
 * @summary DELETE /api/patients/{patient_id}/ereceipts/{ereceipt_id}
 */
export type patientSubresourcesDeletePatientEreceiptResponse204 = {
  data: void
  status: 204
}
    
export type patientSubresourcesDeletePatientEreceiptResponseSuccess = (patientSubresourcesDeletePatientEreceiptResponse204) & {
  headers: Headers;
};
;

export type patientSubresourcesDeletePatientEreceiptResponse = (patientSubresourcesDeletePatientEreceiptResponseSuccess)

export const getPatientSubresourcesDeletePatientEreceiptUrl = (patientId: string,
    ereceiptId: string,) => {


  

  return `/api/patients/${patientId}/ereceipts/${ereceiptId}`
}

export const patientSubresourcesDeletePatientEreceipt = async (patientId: string,
    ereceiptId: string, options?: RequestInit): Promise<patientSubresourcesDeletePatientEreceiptResponse> => {
  
  const res = await fetch(getPatientSubresourcesDeletePatientEreceiptUrl(patientId,ereceiptId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesDeletePatientEreceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesDeletePatientEreceiptResponse
}



/**
 * Create new hearing-tests
 * @summary POST /api/patients/{patient_id}/hearing-tests
 */
export type patientSubresourcesAddPatientHearingTestResponse201 = {
  data: void
  status: 201
}
    
export type patientSubresourcesAddPatientHearingTestResponseSuccess = (patientSubresourcesAddPatientHearingTestResponse201) & {
  headers: Headers;
};
;

export type patientSubresourcesAddPatientHearingTestResponse = (patientSubresourcesAddPatientHearingTestResponseSuccess)

export const getPatientSubresourcesAddPatientHearingTestUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/hearing-tests`
}

export const patientSubresourcesAddPatientHearingTest = async (patientId: string,
    patientSubresourcesAddPatientHearingTestBody?: PatientSubresourcesAddPatientHearingTestBody, options?: RequestInit): Promise<patientSubresourcesAddPatientHearingTestResponse> => {
  
  const res = await fetch(getPatientSubresourcesAddPatientHearingTestUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patientSubresourcesAddPatientHearingTestBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesAddPatientHearingTestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesAddPatientHearingTestResponse
}



/**
 * Delete {test_id}
 * @summary DELETE /api/patients/{patient_id}/hearing-tests/{test_id}
 */
export type patientSubresourcesDeletePatientHearingTestResponse204 = {
  data: void
  status: 204
}
    
export type patientSubresourcesDeletePatientHearingTestResponseSuccess = (patientSubresourcesDeletePatientHearingTestResponse204) & {
  headers: Headers;
};
;

export type patientSubresourcesDeletePatientHearingTestResponse = (patientSubresourcesDeletePatientHearingTestResponseSuccess)

export const getPatientSubresourcesDeletePatientHearingTestUrl = (patientId: string,
    testId: string,) => {


  

  return `/api/patients/${patientId}/hearing-tests/${testId}`
}

export const patientSubresourcesDeletePatientHearingTest = async (patientId: string,
    testId: string, options?: RequestInit): Promise<patientSubresourcesDeletePatientHearingTestResponse> => {
  
  const res = await fetch(getPatientSubresourcesDeletePatientHearingTestUrl(patientId,testId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesDeletePatientHearingTestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesDeletePatientHearingTestResponse
}



/**
 * Create new notes
 * @summary POST /api/patients/{patient_id}/notes
 */
export type patientSubresourcesCreatePatientNoteResponse201 = {
  data: void
  status: 201
}
    
export type patientSubresourcesCreatePatientNoteResponseSuccess = (patientSubresourcesCreatePatientNoteResponse201) & {
  headers: Headers;
};
;

export type patientSubresourcesCreatePatientNoteResponse = (patientSubresourcesCreatePatientNoteResponseSuccess)

export const getPatientSubresourcesCreatePatientNoteUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/notes`
}

export const patientSubresourcesCreatePatientNote = async (patientId: string,
    patientSubresourcesCreatePatientNoteBody?: PatientSubresourcesCreatePatientNoteBody, options?: RequestInit): Promise<patientSubresourcesCreatePatientNoteResponse> => {
  
  const res = await fetch(getPatientSubresourcesCreatePatientNoteUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patientSubresourcesCreatePatientNoteBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesCreatePatientNoteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesCreatePatientNoteResponse
}



/**
 * Delete {note_id}
 * @summary DELETE /api/patients/{patient_id}/notes/{note_id}
 */
export type patientSubresourcesDeletePatientNoteResponse204 = {
  data: void
  status: 204
}
    
export type patientSubresourcesDeletePatientNoteResponseSuccess = (patientSubresourcesDeletePatientNoteResponse204) & {
  headers: Headers;
};
;

export type patientSubresourcesDeletePatientNoteResponse = (patientSubresourcesDeletePatientNoteResponseSuccess)

export const getPatientSubresourcesDeletePatientNoteUrl = (patientId: string,
    noteId: string,) => {


  

  return `/api/patients/${patientId}/notes/${noteId}`
}

export const patientSubresourcesDeletePatientNote = async (patientId: string,
    noteId: string, options?: RequestInit): Promise<patientSubresourcesDeletePatientNoteResponse> => {
  
  const res = await fetch(getPatientSubresourcesDeletePatientNoteUrl(patientId,noteId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientSubresourcesDeletePatientNoteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientSubresourcesDeletePatientNoteResponse
}



/**
 * Retrieve sales information
 * @summary GET /api/patients/{patient_id}/sales
 */
export type salesGetPatientSalesResponse200 = {
  data: void
  status: 200
}
    
export type salesGetPatientSalesResponseSuccess = (salesGetPatientSalesResponse200) & {
  headers: Headers;
};
;

export type salesGetPatientSalesResponse = (salesGetPatientSalesResponseSuccess)

export const getSalesGetPatientSalesUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/sales`
}

export const salesGetPatientSales = async (patientId: string, options?: RequestInit): Promise<salesGetPatientSalesResponse> => {
  
  const res = await fetch(getSalesGetPatientSalesUrl(patientId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesGetPatientSalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesGetPatientSalesResponse
}



/**
 * Retrieve sgk-documents information
 * @summary GET /api/patients/{patient_id}/sgk-documents
 */
export type sgkGetPatientSgkDocumentsResponse200 = {
  data: void
  status: 200
}
    
export type sgkGetPatientSgkDocumentsResponseSuccess = (sgkGetPatientSgkDocumentsResponse200) & {
  headers: Headers;
};
;

export type sgkGetPatientSgkDocumentsResponse = (sgkGetPatientSgkDocumentsResponseSuccess)

export const getSgkGetPatientSgkDocumentsUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/sgk-documents`
}

export const sgkGetPatientSgkDocuments = async (patientId: string, options?: RequestInit): Promise<sgkGetPatientSgkDocumentsResponse> => {
  
  const res = await fetch(getSgkGetPatientSgkDocumentsUrl(patientId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: sgkGetPatientSgkDocumentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as sgkGetPatientSgkDocumentsResponse
}



/**
 * Retrieves all timeline events for a specific patient, including events from both custom data and activity logs
 * @summary Get timeline events for a patient
 */
export type timelineGetPatientTimelineResponse200 = {
  data: TimelineGetPatientTimeline200
  status: 200
}

export type timelineGetPatientTimelineResponse404 = {
  data: void
  status: 404
}

export type timelineGetPatientTimelineResponse500 = {
  data: void
  status: 500
}
    
export type timelineGetPatientTimelineResponseSuccess = (timelineGetPatientTimelineResponse200) & {
  headers: Headers;
};
export type timelineGetPatientTimelineResponseError = (timelineGetPatientTimelineResponse404 | timelineGetPatientTimelineResponse500) & {
  headers: Headers;
};

export type timelineGetPatientTimelineResponse = (timelineGetPatientTimelineResponseSuccess | timelineGetPatientTimelineResponseError)

export const getTimelineGetPatientTimelineUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/timeline`
}

export const timelineGetPatientTimeline = async (patientId: string, options?: RequestInit): Promise<timelineGetPatientTimelineResponse> => {
  
  const res = await fetch(getTimelineGetPatientTimelineUrl(patientId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: timelineGetPatientTimelineResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as timelineGetPatientTimelineResponse
}



/**
 * Creates a new timeline event for a specific patient and logs it to both custom data and activity logs
 * @summary Add a new timeline event for a patient
 */
export type timelineAddTimelineEventResponse201 = {
  data: TimelineAddTimelineEvent201
  status: 201
}

export type timelineAddTimelineEventResponse400 = {
  data: void
  status: 400
}

export type timelineAddTimelineEventResponse404 = {
  data: void
  status: 404
}

export type timelineAddTimelineEventResponse500 = {
  data: void
  status: 500
}
    
export type timelineAddTimelineEventResponseSuccess = (timelineAddTimelineEventResponse201) & {
  headers: Headers;
};
export type timelineAddTimelineEventResponseError = (timelineAddTimelineEventResponse400 | timelineAddTimelineEventResponse404 | timelineAddTimelineEventResponse500) & {
  headers: Headers;
};

export type timelineAddTimelineEventResponse = (timelineAddTimelineEventResponseSuccess | timelineAddTimelineEventResponseError)

export const getTimelineAddTimelineEventUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/timeline`
}

export const timelineAddTimelineEvent = async (patientId: string,
    timelineAddTimelineEventBody: TimelineAddTimelineEventBody, options?: RequestInit): Promise<timelineAddTimelineEventResponse> => {
  
  const res = await fetch(getTimelineAddTimelineEventUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      timelineAddTimelineEventBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: timelineAddTimelineEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as timelineAddTimelineEventResponse
}



/**
 * Removes a specific timeline event from a patient's timeline
 * @summary Delete a timeline event
 */
export type timelineDeleteTimelineEventResponse200 = {
  data: TimelineDeleteTimelineEvent200
  status: 200
}

export type timelineDeleteTimelineEventResponse404 = {
  data: void
  status: 404
}

export type timelineDeleteTimelineEventResponse500 = {
  data: void
  status: 500
}
    
export type timelineDeleteTimelineEventResponseSuccess = (timelineDeleteTimelineEventResponse200) & {
  headers: Headers;
};
export type timelineDeleteTimelineEventResponseError = (timelineDeleteTimelineEventResponse404 | timelineDeleteTimelineEventResponse500) & {
  headers: Headers;
};

export type timelineDeleteTimelineEventResponse = (timelineDeleteTimelineEventResponseSuccess | timelineDeleteTimelineEventResponseError)

export const getTimelineDeleteTimelineEventUrl = (patientId: string,
    eventId: string,) => {


  

  return `/api/patients/${patientId}/timeline/${eventId}`
}

export const timelineDeleteTimelineEvent = async (patientId: string,
    eventId: string, options?: RequestInit): Promise<timelineDeleteTimelineEventResponse> => {
  
  const res = await fetch(getTimelineDeleteTimelineEventUrl(patientId,eventId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: timelineDeleteTimelineEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as timelineDeleteTimelineEventResponse
}



/**
 * Alternative endpoint for adding timeline events, provides the same functionality as POST /api/patients/{patient_id}/timeline
 * @summary Log an activity for a patient (alias for timeline event)
 */
export type timelineLogPatientActivityResponse201 = {
  data: void
  status: 201
}

export type timelineLogPatientActivityResponse400 = {
  data: void
  status: 400
}

export type timelineLogPatientActivityResponse404 = {
  data: void
  status: 404
}

export type timelineLogPatientActivityResponse500 = {
  data: void
  status: 500
}
    
export type timelineLogPatientActivityResponseSuccess = (timelineLogPatientActivityResponse201) & {
  headers: Headers;
};
export type timelineLogPatientActivityResponseError = (timelineLogPatientActivityResponse400 | timelineLogPatientActivityResponse404 | timelineLogPatientActivityResponse500) & {
  headers: Headers;
};

export type timelineLogPatientActivityResponse = (timelineLogPatientActivityResponseSuccess | timelineLogPatientActivityResponseError)

export const getTimelineLogPatientActivityUrl = (patientId: string,) => {


  

  return `/api/patients/${patientId}/activities`
}

export const timelineLogPatientActivity = async (patientId: string,
    timelineLogPatientActivityBody: TimelineLogPatientActivityBody, options?: RequestInit): Promise<timelineLogPatientActivityResponse> => {
  
  const res = await fetch(getTimelineLogPatientActivityUrl(patientId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      timelineLogPatientActivityBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: timelineLogPatientActivityResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as timelineLogPatientActivityResponse
}



/**
 * This endpoint is intentionally forgiving: it returns a summary of created/updated rows
and reports per-row errors without aborting the entire batch.
Authentication is optional for uploads in many workflows; we still log the actor when present.
 * @summary Accept a multipart/form-data CSV file containing patients and upsert them into the DB.
 */
export type patientsBulkUploadPatientsResponse201 = {
  data: void
  status: 201
}
    
export type patientsBulkUploadPatientsResponseSuccess = (patientsBulkUploadPatientsResponse201) & {
  headers: Headers;
};
;

export type patientsBulkUploadPatientsResponse = (patientsBulkUploadPatientsResponseSuccess)

export const getPatientsBulkUploadPatientsUrl = () => {


  

  return `/api/patients/bulk_upload`
}

export const patientsBulkUploadPatients = async (patientsBulkUploadPatientsBody?: PatientsBulkUploadPatientsBody, options?: RequestInit): Promise<patientsBulkUploadPatientsResponse> => {
  
  const res = await fetch(getPatientsBulkUploadPatientsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patientsBulkUploadPatientsBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsBulkUploadPatientsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsBulkUploadPatientsResponse
}



/**
 * Supports optional query params: status, segment, q (search term).
 * @summary Export patients as CSV. Only admin users are allowed to perform exports.
 */
export type patientsExportPatientsCsvResponse200 = {
  data: void
  status: 200
}
    
export type patientsExportPatientsCsvResponseSuccess = (patientsExportPatientsCsvResponse200) & {
  headers: Headers;
};
;

export type patientsExportPatientsCsvResponse = (patientsExportPatientsCsvResponseSuccess)

export const getPatientsExportPatientsCsvUrl = () => {


  

  return `/api/patients/export`
}

export const patientsExportPatientsCsv = async ( options?: RequestInit): Promise<patientsExportPatientsCsvResponse> => {
  
  const res = await fetch(getPatientsExportPatientsCsvUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsExportPatientsCsvResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsExportPatientsCsvResponse
}



/**
 * Retrieve search information
 * @summary GET /api/patients/search
 */
export type patientsSearchPatientsResponse200 = {
  data: void
  status: 200
}
    
export type patientsSearchPatientsResponseSuccess = (patientsSearchPatientsResponse200) & {
  headers: Headers;
};
;

export type patientsSearchPatientsResponse = (patientsSearchPatientsResponseSuccess)

export const getPatientsSearchPatientsUrl = () => {


  

  return `/api/patients/search`
}

export const patientsSearchPatients = async ( options?: RequestInit): Promise<patientsSearchPatientsResponse> => {
  
  const res = await fetch(getPatientsSearchPatientsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patientsSearchPatientsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patientsSearchPatientsResponse
}



/**
 * Create new pricing-preview
 * @summary POST /api/pricing-preview
 */
export type salesPricingPreviewResponse201 = {
  data: void
  status: 201
}
    
export type salesPricingPreviewResponseSuccess = (salesPricingPreviewResponse201) & {
  headers: Headers;
};
;

export type salesPricingPreviewResponse = (salesPricingPreviewResponseSuccess)

export const getSalesPricingPreviewUrl = () => {


  

  return `/api/pricing-preview`
}

export const salesPricingPreview = async (salesPricingPreviewBody?: SalesPricingPreviewBody, options?: RequestInit): Promise<salesPricingPreviewResponse> => {
  
  const res = await fetch(getSalesPricingPreviewUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      salesPricingPreviewBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesPricingPreviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesPricingPreviewResponse
}



/**
 * Delete {ps_id}
 * @summary Delete a product-supplier relationship
 */
export type suppliersDeleteProductSupplierResponse204 = {
  data: void
  status: 204
}
    
export type suppliersDeleteProductSupplierResponseSuccess = (suppliersDeleteProductSupplierResponse204) & {
  headers: Headers;
};
;

export type suppliersDeleteProductSupplierResponse = (suppliersDeleteProductSupplierResponseSuccess)

export const getSuppliersDeleteProductSupplierUrl = (psId: string,) => {


  

  return `/api/product-suppliers/${psId}`
}

export const suppliersDeleteProductSupplier = async (psId: string, options?: RequestInit): Promise<suppliersDeleteProductSupplierResponse> => {
  
  const res = await fetch(getSuppliersDeleteProductSupplierUrl(psId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersDeleteProductSupplierResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersDeleteProductSupplierResponse
}



/**
 * Create new suppliers
 * @summary Add a supplier to a product
 */
export type suppliersAddProductSupplierResponse201 = {
  data: void
  status: 201
}
    
export type suppliersAddProductSupplierResponseSuccess = (suppliersAddProductSupplierResponse201) & {
  headers: Headers;
};
;

export type suppliersAddProductSupplierResponse = (suppliersAddProductSupplierResponseSuccess)

export const getSuppliersAddProductSupplierUrl = (productId: string,) => {


  

  return `/api/products/${productId}/suppliers`
}

export const suppliersAddProductSupplier = async (productId: string,
    suppliersAddProductSupplierBody?: SuppliersAddProductSupplierBody, options?: RequestInit): Promise<suppliersAddProductSupplierResponse> => {
  
  const res = await fetch(getSuppliersAddProductSupplierUrl(productId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      suppliersAddProductSupplierBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersAddProductSupplierResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersAddProductSupplierResponse
}



/**
 * Create new register-phone
 * @summary POST /api/register-phone
 */
export type registrationRegisterPhoneResponse201 = {
  data: void
  status: 201
}
    
export type registrationRegisterPhoneResponseSuccess = (registrationRegisterPhoneResponse201) & {
  headers: Headers;
};
;

export type registrationRegisterPhoneResponse = (registrationRegisterPhoneResponseSuccess)

export const getRegistrationRegisterPhoneUrl = () => {


  

  return `/api/register-phone`
}

export const registrationRegisterPhone = async (registrationRegisterPhoneBody?: RegistrationRegisterPhoneBody, options?: RequestInit): Promise<registrationRegisterPhoneResponse> => {
  
  const res = await fetch(getRegistrationRegisterPhoneUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registrationRegisterPhoneBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registrationRegisterPhoneResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registrationRegisterPhoneResponse
}



/**
 * Retrieve appointments information
 * @summary GET /api/reports/appointments
 */
export type reportsReportAppointmentsResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportAppointmentsResponseSuccess = (reportsReportAppointmentsResponse200) & {
  headers: Headers;
};
;

export type reportsReportAppointmentsResponse = (reportsReportAppointmentsResponseSuccess)

export const getReportsReportAppointmentsUrl = () => {


  

  return `/api/reports/appointments`
}

export const reportsReportAppointments = async ( options?: RequestInit): Promise<reportsReportAppointmentsResponse> => {
  
  const res = await fetch(getReportsReportAppointmentsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportAppointmentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportAppointmentsResponse
}



/**
 * Retrieve campaigns information
 * @summary Kampanya raporu
 */
export type reportsReportCampaignsResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportCampaignsResponseSuccess = (reportsReportCampaignsResponse200) & {
  headers: Headers;
};
;

export type reportsReportCampaignsResponse = (reportsReportCampaignsResponseSuccess)

export const getReportsReportCampaignsUrl = () => {


  

  return `/api/reports/campaigns`
}

export const reportsReportCampaigns = async ( options?: RequestInit): Promise<reportsReportCampaignsResponse> => {
  
  const res = await fetch(getReportsReportCampaignsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportCampaignsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportCampaignsResponse
}



/**
 * Retrieve financial information
 * @summary Mali rapor
 */
export type reportsReportFinancialResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportFinancialResponseSuccess = (reportsReportFinancialResponse200) & {
  headers: Headers;
};
;

export type reportsReportFinancialResponse = (reportsReportFinancialResponseSuccess)

export const getReportsReportFinancialUrl = () => {


  

  return `/api/reports/financial`
}

export const reportsReportFinancial = async ( options?: RequestInit): Promise<reportsReportFinancialResponse> => {
  
  const res = await fetch(getReportsReportFinancialUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportFinancialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportFinancialResponse
}



/**
 * Retrieve overview information
 * @summary Genel rapor Ã¶zeti
 */
export type reportsReportOverviewResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportOverviewResponseSuccess = (reportsReportOverviewResponse200) & {
  headers: Headers;
};
;

export type reportsReportOverviewResponse = (reportsReportOverviewResponseSuccess)

export const getReportsReportOverviewUrl = () => {


  

  return `/api/reports/overview`
}

export const reportsReportOverview = async ( options?: RequestInit): Promise<reportsReportOverviewResponse> => {
  
  const res = await fetch(getReportsReportOverviewUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportOverviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportOverviewResponse
}



/**
 * Retrieve patients information
 * @summary Hasta analizi raporu
 */
export type reportsReportPatientsResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportPatientsResponseSuccess = (reportsReportPatientsResponse200) & {
  headers: Headers;
};
;

export type reportsReportPatientsResponse = (reportsReportPatientsResponseSuccess)

export const getReportsReportPatientsUrl = () => {


  

  return `/api/reports/patients`
}

export const reportsReportPatients = async ( options?: RequestInit): Promise<reportsReportPatientsResponse> => {
  
  const res = await fetch(getReportsReportPatientsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportPatientsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportPatientsResponse
}



/**
 * Retrieve revenue information
 * @summary GET /api/reports/revenue
 */
export type reportsReportRevenueResponse200 = {
  data: void
  status: 200
}
    
export type reportsReportRevenueResponseSuccess = (reportsReportRevenueResponse200) & {
  headers: Headers;
};
;

export type reportsReportRevenueResponse = (reportsReportRevenueResponseSuccess)

export const getReportsReportRevenueUrl = () => {


  

  return `/api/reports/revenue`
}

export const reportsReportRevenue = async ( options?: RequestInit): Promise<reportsReportRevenueResponse> => {
  
  const res = await fetch(getReportsReportRevenueUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reportsReportRevenueResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reportsReportRevenueResponse
}



/**
 * Retrieve a list of all sales
 * @summary GET /api/sales
 */
export type salesListSalesResponse200 = {
  data: Sale[]
  status: 200
}
    
export type salesListSalesResponseSuccess = (salesListSalesResponse200) & {
  headers: Headers;
};
;

export type salesListSalesResponse = (salesListSalesResponseSuccess)

export const getSalesListSalesUrl = () => {


  

  return `/api/sales`
}

export const salesListSales = async ( options?: RequestInit): Promise<salesListSalesResponse> => {
  
  const res = await fetch(getSalesListSalesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesListSalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesListSalesResponse
}



/**
 * Create a new sale
 * @summary POST /api/sales
 */
export type salesCreateSaleResponse201 = {
  data: Sale
  status: 201
}

export type salesCreateSaleResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type salesCreateSaleResponseSuccess = (salesCreateSaleResponse201) & {
  headers: Headers;
};
export type salesCreateSaleResponseError = (salesCreateSaleResponse400) & {
  headers: Headers;
};

export type salesCreateSaleResponse = (salesCreateSaleResponseSuccess | salesCreateSaleResponseError)

export const getSalesCreateSaleUrl = () => {


  

  return `/api/sales`
}

export const salesCreateSale = async (salesCreateSaleBody: SalesCreateSaleBody, options?: RequestInit): Promise<salesCreateSaleResponse> => {
  
  const res = await fetch(getSalesCreateSaleUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      salesCreateSaleBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesCreateSaleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesCreateSaleResponse
}



/**
 * Get sale details by ID
 * @summary GET /api/sales/{sale_id}
 */
export type salesGetSaleResponse200 = {
  data: Sale
  status: 200
}

export type salesGetSaleResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type salesGetSaleResponseSuccess = (salesGetSaleResponse200) & {
  headers: Headers;
};
export type salesGetSaleResponseError = (salesGetSaleResponse404) & {
  headers: Headers;
};

export type salesGetSaleResponse = (salesGetSaleResponseSuccess | salesGetSaleResponseError)

export const getSalesGetSaleUrl = (saleId: string,) => {


  

  return `/api/sales/${saleId}`
}

export const salesGetSale = async (saleId: string, options?: RequestInit): Promise<salesGetSaleResponse> => {
  
  const res = await fetch(getSalesGetSaleUrl(saleId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesGetSaleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesGetSaleResponse
}



/**
 * Update sale information
 * @summary PUT /api/sales/{sale_id}
 */
export type salesUpdateSaleResponse200 = {
  data: Sale
  status: 200
}

export type salesUpdateSaleResponse400 = {
  data: ErrorResponse
  status: 400
}

export type salesUpdateSaleResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type salesUpdateSaleResponseSuccess = (salesUpdateSaleResponse200) & {
  headers: Headers;
};
export type salesUpdateSaleResponseError = (salesUpdateSaleResponse400 | salesUpdateSaleResponse404) & {
  headers: Headers;
};

export type salesUpdateSaleResponse = (salesUpdateSaleResponseSuccess | salesUpdateSaleResponseError)

export const getSalesUpdateSaleUrl = (saleId: string,) => {


  

  return `/api/sales/${saleId}`
}

export const salesUpdateSale = async (saleId: string,
    salesUpdateSaleBody: SalesUpdateSaleBody, options?: RequestInit): Promise<salesUpdateSaleResponse> => {
  
  const res = await fetch(getSalesUpdateSaleUrl(saleId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      salesUpdateSaleBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesUpdateSaleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesUpdateSaleResponse
}



/**
 * Delete a sale
 * @summary DELETE /api/sales/{sale_id}
 */
export type salesDeleteSaleResponse204 = {
  data: void
  status: 204
}

export type salesDeleteSaleResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type salesDeleteSaleResponseSuccess = (salesDeleteSaleResponse204) & {
  headers: Headers;
};
export type salesDeleteSaleResponseError = (salesDeleteSaleResponse404) & {
  headers: Headers;
};

export type salesDeleteSaleResponse = (salesDeleteSaleResponseSuccess | salesDeleteSaleResponseError)

export const getSalesDeleteSaleUrl = (saleId: string,) => {


  

  return `/api/sales/${saleId}`
}

export const salesDeleteSale = async (saleId: string, options?: RequestInit): Promise<salesDeleteSaleResponse> => {
  
  const res = await fetch(getSalesDeleteSaleUrl(saleId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesDeleteSaleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesDeleteSaleResponse
}



/**
 * Create new payment-plan
 * @summary POST /api/sales/{sale_id}/payment-plan
 */
export type salesCreateSalePaymentPlanResponse201 = {
  data: PaymentRecord
  status: 201
}
    
export type salesCreateSalePaymentPlanResponseSuccess = (salesCreateSalePaymentPlanResponse201) & {
  headers: Headers;
};
;

export type salesCreateSalePaymentPlanResponse = (salesCreateSalePaymentPlanResponseSuccess)

export const getSalesCreateSalePaymentPlanUrl = (saleId: string,) => {


  

  return `/api/sales/${saleId}/payment-plan`
}

export const salesCreateSalePaymentPlan = async (saleId: string,
    salesCreateSalePaymentPlanBody?: SalesCreateSalePaymentPlanBody, options?: RequestInit): Promise<salesCreateSalePaymentPlanResponse> => {
  
  const res = await fetch(getSalesCreateSalePaymentPlanUrl(saleId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      salesCreateSalePaymentPlanBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: salesCreateSalePaymentPlanResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as salesCreateSalePaymentPlanResponse
}



/**
 * Update settings information
 * @summary Update system settings
 */
export type updateSettingsResponse200 = {
  data: void
  status: 200
}
    
export type updateSettingsResponseSuccess = (updateSettingsResponse200) & {
  headers: Headers;
};
;

export type updateSettingsResponse = (updateSettingsResponseSuccess)

export const getUpdateSettingsUrl = () => {


  

  return `/api/settings`
}

export const updateSettings = async (updateSettingsBody?: UpdateSettingsBody, options?: RequestInit): Promise<updateSettingsResponse> => {
  
  const res = await fetch(getUpdateSettingsUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateSettingsBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateSettingsResponse
}



/**
 * Create new documents
 * @summary POST /api/sgk/documents
 */
export type sgkUploadSgkDocumentResponse201 = {
  data: void
  status: 201
}
    
export type sgkUploadSgkDocumentResponseSuccess = (sgkUploadSgkDocumentResponse201) & {
  headers: Headers;
};
;

export type sgkUploadSgkDocumentResponse = (sgkUploadSgkDocumentResponseSuccess)

export const getSgkUploadSgkDocumentUrl = () => {


  

  return `/api/sgk/documents`
}

export const sgkUploadSgkDocument = async (sgkUploadSgkDocumentBody?: SgkUploadSgkDocumentBody, options?: RequestInit): Promise<sgkUploadSgkDocumentResponse> => {
  
  const res = await fetch(getSgkUploadSgkDocumentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sgkUploadSgkDocumentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: sgkUploadSgkDocumentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as sgkUploadSgkDocumentResponse
}



/**
 * Delete {document_id}
 * @summary DELETE /api/sgk/documents/{document_id}
 */
export type sgkDeleteSgkDocumentResponse204 = {
  data: void
  status: 204
}
    
export type sgkDeleteSgkDocumentResponseSuccess = (sgkDeleteSgkDocumentResponse204) & {
  headers: Headers;
};
;

export type sgkDeleteSgkDocumentResponse = (sgkDeleteSgkDocumentResponseSuccess)

export const getSgkDeleteSgkDocumentUrl = (documentId: string,) => {


  

  return `/api/sgk/documents/${documentId}`
}

export const sgkDeleteSgkDocument = async (documentId: string, options?: RequestInit): Promise<sgkDeleteSgkDocumentResponse> => {
  
  const res = await fetch(getSgkDeleteSgkDocumentUrl(documentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: sgkDeleteSgkDocumentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as sgkDeleteSgkDocumentResponse
}



/**
 * Retrieve monitoring information
 * @summary GET /api/sms/monitoring
 */
export type smsMonitoringResponse200 = {
  data: void
  status: 200
}
    
export type smsMonitoringResponseSuccess = (smsMonitoringResponse200) & {
  headers: Headers;
};
;

export type smsMonitoringResponse = (smsMonitoringResponseSuccess)

export const getSmsMonitoringUrl = () => {


  

  return `/api/sms/monitoring`
}

export const smsMonitoring = async ( options?: RequestInit): Promise<smsMonitoringResponse> => {
  
  const res = await fetch(getSmsMonitoringUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: smsMonitoringResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as smsMonitoringResponse
}



/**
 * Retrieve a list of suppliers with optional filtering and pagination
 * @summary Get list of suppliers
 */
export type suppliersGetSuppliersResponse200 = {
  data: SuppliersGetSuppliers200
  status: 200
}

export type suppliersGetSuppliersResponse401 = {
  data: ErrorResponse
  status: 401
}

export type suppliersGetSuppliersResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type suppliersGetSuppliersResponseSuccess = (suppliersGetSuppliersResponse200) & {
  headers: Headers;
};
export type suppliersGetSuppliersResponseError = (suppliersGetSuppliersResponse401 | suppliersGetSuppliersResponse500) & {
  headers: Headers;
};

export type suppliersGetSuppliersResponse = (suppliersGetSuppliersResponseSuccess | suppliersGetSuppliersResponseError)

export const getSuppliersGetSuppliersUrl = (params?: SuppliersGetSuppliersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/suppliers?${stringifiedParams}` : `/api/suppliers`
}

export const suppliersGetSuppliers = async (params?: SuppliersGetSuppliersParams, options?: RequestInit): Promise<suppliersGetSuppliersResponse> => {
  
  const res = await fetch(getSuppliersGetSuppliersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersGetSuppliersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersGetSuppliersResponse
}



/**
 * Register a new supplier with contact and business information
 * @summary Create a new supplier
 */
export type suppliersCreateSupplierResponse201 = {
  data: Supplier
  status: 201
}
    
export type suppliersCreateSupplierResponseSuccess = (suppliersCreateSupplierResponse201) & {
  headers: Headers;
};
;

export type suppliersCreateSupplierResponse = (suppliersCreateSupplierResponseSuccess)

export const getSuppliersCreateSupplierUrl = () => {


  

  return `/api/suppliers`
}

export const suppliersCreateSupplier = async (suppliersCreateSupplierBody?: SuppliersCreateSupplierBody, options?: RequestInit): Promise<suppliersCreateSupplierResponse> => {
  
  const res = await fetch(getSuppliersCreateSupplierUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      suppliersCreateSupplierBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersCreateSupplierResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersCreateSupplierResponse
}



/**
 * Remove a supplier from the system
 * @summary Delete a supplier (soft delete by setting is_active=False)
 */
export type suppliersDeleteSupplierResponse204 = {
  data: SuccessResponse
  status: 204
}
    
export type suppliersDeleteSupplierResponseSuccess = (suppliersDeleteSupplierResponse204) & {
  headers: Headers;
};
;

export type suppliersDeleteSupplierResponse = (suppliersDeleteSupplierResponseSuccess)

export const getSuppliersDeleteSupplierUrl = (supplierId: string,) => {


  

  return `/api/suppliers/${supplierId}`
}

export const suppliersDeleteSupplier = async (supplierId: string, options?: RequestInit): Promise<suppliersDeleteSupplierResponse> => {
  
  const res = await fetch(getSuppliersDeleteSupplierUrl(supplierId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersDeleteSupplierResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersDeleteSupplierResponse
}



/**
 * Get list of products available from a specific supplier
 * @summary Get all products for a specific supplier
 */
export type suppliersGetSupplierProductsResponse200 = {
  data: void
  status: 200
}
    
export type suppliersGetSupplierProductsResponseSuccess = (suppliersGetSupplierProductsResponse200) & {
  headers: Headers;
};
;

export type suppliersGetSupplierProductsResponse = (suppliersGetSupplierProductsResponseSuccess)

export const getSuppliersGetSupplierProductsUrl = (supplierId: string,) => {


  

  return `/api/suppliers/${supplierId}/products`
}

export const suppliersGetSupplierProducts = async (supplierId: string, options?: RequestInit): Promise<suppliersGetSupplierProductsResponse> => {
  
  const res = await fetch(getSuppliersGetSupplierProductsUrl(supplierId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersGetSupplierProductsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersGetSupplierProductsResponse
}



/**
 * Get supplier statistics including order history
 * @summary Get supplier statistics
 */
export type suppliersGetSupplierStatsResponse200 = {
  data: void
  status: 200
}
    
export type suppliersGetSupplierStatsResponseSuccess = (suppliersGetSupplierStatsResponse200) & {
  headers: Headers;
};
;

export type suppliersGetSupplierStatsResponse = (suppliersGetSupplierStatsResponseSuccess)

export const getSuppliersGetSupplierStatsUrl = () => {


  

  return `/api/suppliers/stats`
}

export const suppliersGetSupplierStats = async ( options?: RequestInit): Promise<suppliersGetSupplierStatsResponse> => {
  
  const res = await fetch(getSuppliersGetSupplierStatsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: suppliersGetSupplierStatsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as suppliersGetSupplierStatsResponse
}



/**
 * Create new verify-registration-otp
 * @summary POST /api/verify-registration-otp
 */
export type registrationVerifyRegistrationOtpResponse201 = {
  data: void
  status: 201
}
    
export type registrationVerifyRegistrationOtpResponseSuccess = (registrationVerifyRegistrationOtpResponse201) & {
  headers: Headers;
};
;

export type registrationVerifyRegistrationOtpResponse = (registrationVerifyRegistrationOtpResponseSuccess)

export const getRegistrationVerifyRegistrationOtpUrl = () => {


  

  return `/api/verify-registration-otp`
}

export const registrationVerifyRegistrationOtp = async (registrationVerifyRegistrationOtpBody?: RegistrationVerifyRegistrationOtpBody, options?: RequestInit): Promise<registrationVerifyRegistrationOtpResponse> => {
  
  const res = await fetch(getRegistrationVerifyRegistrationOtpUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registrationVerifyRegistrationOtpBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registrationVerifyRegistrationOtpResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registrationVerifyRegistrationOtpResponse
}



/**
 * Retrieve a list of all users
 * @summary GET /api/users
 */
export type usersListUsersResponse200 = {
  data: User[]
  status: 200
}
    
export type usersListUsersResponseSuccess = (usersListUsersResponse200) & {
  headers: Headers;
};
;

export type usersListUsersResponse = (usersListUsersResponseSuccess)

export const getUsersListUsersUrl = () => {


  

  return `/api/users`
}

export const usersListUsers = async ( options?: RequestInit): Promise<usersListUsersResponse> => {
  
  const res = await fetch(getUsersListUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersListUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersListUsersResponse
}



/**
 * Create a new user
 * @summary POST /api/users
 */
export type usersCreateUserResponse201 = {
  data: User
  status: 201
}

export type usersCreateUserResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type usersCreateUserResponseSuccess = (usersCreateUserResponse201) & {
  headers: Headers;
};
export type usersCreateUserResponseError = (usersCreateUserResponse400) & {
  headers: Headers;
};

export type usersCreateUserResponse = (usersCreateUserResponseSuccess | usersCreateUserResponseError)

export const getUsersCreateUserUrl = () => {


  

  return `/api/users`
}

export const usersCreateUser = async (usersCreateUserBody: UsersCreateUserBody, options?: RequestInit): Promise<usersCreateUserResponse> => {
  
  const res = await fetch(getUsersCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      usersCreateUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersCreateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersCreateUserResponse
}



/**
 * Get user details by ID
 * @summary GET /api/users/{user_id}
 */
export type usersGetUserResponse200 = {
  data: User
  status: 200
}

export type usersGetUserResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type usersGetUserResponseSuccess = (usersGetUserResponse200) & {
  headers: Headers;
};
export type usersGetUserResponseError = (usersGetUserResponse404) & {
  headers: Headers;
};

export type usersGetUserResponse = (usersGetUserResponseSuccess | usersGetUserResponseError)

export const getUsersGetUserUrl = (userId: string,) => {


  

  return `/api/users/${userId}`
}

export const usersGetUser = async (userId: string, options?: RequestInit): Promise<usersGetUserResponse> => {
  
  const res = await fetch(getUsersGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersGetUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersGetUserResponse
}



/**
 * Update user information
 * @summary PUT /api/users/{user_id}
 */
export type usersUpdateUserResponse200 = {
  data: User
  status: 200
}

export type usersUpdateUserResponse400 = {
  data: ErrorResponse
  status: 400
}

export type usersUpdateUserResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type usersUpdateUserResponseSuccess = (usersUpdateUserResponse200) & {
  headers: Headers;
};
export type usersUpdateUserResponseError = (usersUpdateUserResponse400 | usersUpdateUserResponse404) & {
  headers: Headers;
};

export type usersUpdateUserResponse = (usersUpdateUserResponseSuccess | usersUpdateUserResponseError)

export const getUsersUpdateUserUrl = (userId: string,) => {


  

  return `/api/users/${userId}`
}

export const usersUpdateUser = async (userId: string,
    usersUpdateUserBody: UsersUpdateUserBody, options?: RequestInit): Promise<usersUpdateUserResponse> => {
  
  const res = await fetch(getUsersUpdateUserUrl(userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      usersUpdateUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersUpdateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersUpdateUserResponse
}



/**
 * Delete a user
 * @summary DELETE /api/users/{user_id}
 */
export type usersDeleteUserResponse204 = {
  data: void
  status: 204
}

export type usersDeleteUserResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type usersDeleteUserResponseSuccess = (usersDeleteUserResponse204) & {
  headers: Headers;
};
export type usersDeleteUserResponseError = (usersDeleteUserResponse404) & {
  headers: Headers;
};

export type usersDeleteUserResponse = (usersDeleteUserResponseSuccess | usersDeleteUserResponseError)

export const getUsersDeleteUserUrl = (userId: string,) => {


  

  return `/api/users/${userId}`
}

export const usersDeleteUser = async (userId: string, options?: RequestInit): Promise<usersDeleteUserResponse> => {
  
  const res = await fetch(getUsersDeleteUserUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersDeleteUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersDeleteUserResponse
}



/**
 * Get current authenticated user information
 * @summary GET /api/users/me
 */
export type usersGetCurrentUserResponse200 = {
  data: User
  status: 200
}

export type usersGetCurrentUserResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type usersGetCurrentUserResponseSuccess = (usersGetCurrentUserResponse200) & {
  headers: Headers;
};
export type usersGetCurrentUserResponseError = (usersGetCurrentUserResponse401) & {
  headers: Headers;
};

export type usersGetCurrentUserResponse = (usersGetCurrentUserResponseSuccess | usersGetCurrentUserResponseError)

export const getUsersGetCurrentUserUrl = () => {


  

  return `/api/users/me`
}

export const usersGetCurrentUser = async ( options?: RequestInit): Promise<usersGetCurrentUserResponse> => {
  
  const res = await fetch(getUsersGetCurrentUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersGetCurrentUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersGetCurrentUserResponse
}



/**
 * Create new entities
 * @summary Extract entities from image using OCR
 */
export type ocrExtractEntitiesResponse201 = {
  data: void
  status: 201
}
    
export type ocrExtractEntitiesResponseSuccess = (ocrExtractEntitiesResponse201) & {
  headers: Headers;
};
;

export type ocrExtractEntitiesResponse = (ocrExtractEntitiesResponseSuccess)

export const getOcrExtractEntitiesUrl = () => {


  

  return `/entities`
}

export const ocrExtractEntities = async (ocrExtractEntitiesBody?: OcrExtractEntitiesBody, options?: RequestInit): Promise<ocrExtractEntitiesResponse> => {
  
  const res = await fetch(getOcrExtractEntitiesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrExtractEntitiesBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrExtractEntitiesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrExtractEntitiesResponse
}



/**
 * Extract patient name from document image using OCR
 * @summary Extract patient name from image using OCR
 */
export type ocrExtractPatientNameResponse201 = {
  data: void
  status: 201
}
    
export type ocrExtractPatientNameResponseSuccess = (ocrExtractPatientNameResponse201) & {
  headers: Headers;
};
;

export type ocrExtractPatientNameResponse = (ocrExtractPatientNameResponseSuccess)

export const getOcrExtractPatientNameUrl = () => {


  

  return `/extract_patient`
}

export const ocrExtractPatientName = async (ocrExtractPatientNameBody?: OcrExtractPatientNameBody, options?: RequestInit): Promise<ocrExtractPatientNameResponse> => {
  
  const res = await fetch(getOcrExtractPatientNameUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrExtractPatientNameBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrExtractPatientNameResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrExtractPatientNameResponse
}



/**
 * Health check for OCR service availability
 * @summary Health check endpoint (moved from app.py)
 */
export type ocrHealthCheckResponse200 = {
  data: void
  status: 200
}
    
export type ocrHealthCheckResponseSuccess = (ocrHealthCheckResponse200) & {
  headers: Headers;
};
;

export type ocrHealthCheckResponse = (ocrHealthCheckResponseSuccess)

export const getOcrHealthCheckUrl = () => {


  

  return `/health`
}

export const ocrHealthCheck = async ( options?: RequestInit): Promise<ocrHealthCheckResponse> => {
  
  const res = await fetch(getOcrHealthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrHealthCheckResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrHealthCheckResponse
}



/**
 * Initialize OCR service database and create required tables
 * @summary Initialize database and create tables
 */
export type ocrInitDatabaseResponse201 = {
  data: void
  status: 201
}
    
export type ocrInitDatabaseResponseSuccess = (ocrInitDatabaseResponse201) & {
  headers: Headers;
};
;

export type ocrInitDatabaseResponse = (ocrInitDatabaseResponseSuccess)

export const getOcrInitDatabaseUrl = () => {


  

  return `/init-db`
}

export const ocrInitDatabase = async (ocrInitDatabaseBody?: OcrInitDatabaseBody, options?: RequestInit): Promise<ocrInitDatabaseResponse> => {
  
  const res = await fetch(getOcrInitDatabaseUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrInitDatabaseBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrInitDatabaseResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrInitDatabaseResponse
}



/**
 * Initialize NLP/OCR processing service
 * @summary Initialize NLP/OCR service
 */
export type ocrInitializeNlpEndpointResponse201 = {
  data: void
  status: 201
}
    
export type ocrInitializeNlpEndpointResponseSuccess = (ocrInitializeNlpEndpointResponse201) & {
  headers: Headers;
};
;

export type ocrInitializeNlpEndpointResponse = (ocrInitializeNlpEndpointResponseSuccess)

export const getOcrInitializeNlpEndpointUrl = () => {


  

  return `/initialize`
}

export const ocrInitializeNlpEndpoint = async (ocrInitializeNlpEndpointBody?: OcrInitializeNlpEndpointBody, options?: RequestInit): Promise<ocrInitializeNlpEndpointResponse> => {
  
  const res = await fetch(getOcrInitializeNlpEndpointUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrInitializeNlpEndpointBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrInitializeNlpEndpointResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrInitializeNlpEndpointResponse
}



/**
 * Process document using OCR to extract text and data
 * @summary Process document with OCR
 */
export type ocrProcessDocumentResponse201 = {
  data: void
  status: 201
}
    
export type ocrProcessDocumentResponseSuccess = (ocrProcessDocumentResponse201) & {
  headers: Headers;
};
;

export type ocrProcessDocumentResponse = (ocrProcessDocumentResponseSuccess)

export const getOcrProcessDocumentUrl = () => {


  

  return `/process`
}

export const ocrProcessDocument = async (ocrProcessDocumentBody?: OcrProcessDocumentBody, options?: RequestInit): Promise<ocrProcessDocumentResponse> => {
  
  const res = await fetch(getOcrProcessDocumentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrProcessDocumentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrProcessDocumentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrProcessDocumentResponse
}



/**
 * Calculate similarity between documents using OCR text analysis
 * @summary Calculate similarity between two images using OCR text
 */
export type ocrCalculateSimilarityResponse201 = {
  data: void
  status: 201
}
    
export type ocrCalculateSimilarityResponseSuccess = (ocrCalculateSimilarityResponse201) & {
  headers: Headers;
};
;

export type ocrCalculateSimilarityResponse = (ocrCalculateSimilarityResponseSuccess)

export const getOcrCalculateSimilarityUrl = () => {


  

  return `/similarity`
}

export const ocrCalculateSimilarity = async (ocrCalculateSimilarityBody?: OcrCalculateSimilarityBody, options?: RequestInit): Promise<ocrCalculateSimilarityResponse> => {
  
  const res = await fetch(getOcrCalculateSimilarityUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ocrCalculateSimilarityBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ocrCalculateSimilarityResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ocrCalculateSimilarityResponse
}



/**
 * This helps local development: visit http://<backend-host>:<port>/swagger.html so the
Swagger UI and `/api/openapi.yaml` are on the same origin and no CORS overrides are needed.
 * @summary Serve the static Swagger UI page from the repository `public/` folder.
 */
export type serveSwaggerUiResponse200 = {
  data: void
  status: 200
}
    
export type serveSwaggerUiResponseSuccess = (serveSwaggerUiResponse200) & {
  headers: Headers;
};
;

export type serveSwaggerUiResponse = (serveSwaggerUiResponseSuccess)

export const getServeSwaggerUiUrl = () => {


  

  return `/swagger.html`
}

export const serveSwaggerUi = async ( options?: RequestInit): Promise<serveSwaggerUiResponse> => {
  
  const res = await fetch(getServeSwaggerUiUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: serveSwaggerUiResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as serveSwaggerUiResponse
}
