{"version":3,"sources":["../src/domain/services/patient-service.ts","../src/hooks/useFuzzySearch.ts","../src/utils/fuzzy-search.ts","../src/hooks/useFileUpload.ts","../src/services/file-parser.ts","../src/utils/type-converter.ts","../src/utils/date-utils.ts","../src/utils/format-utils.ts","../src/utils/validation-utils.ts","../src/utils/storage-utils.ts"],"sourcesContent":["import { \n  Patient, \n  PatientCreateRequest, \n  PatientUpdateRequest, \n  PatientSearchFilters,\n  PaginatedResponse \n} from '../types';\n\nexport class PatientService {\n  /**\n   * Validates Turkish Citizenship Number (TC Kimlik No)\n   */\n  static validateTcNumber(tcNumber: string): boolean {\n    if (!tcNumber || tcNumber.length !== 11) return false;\n    \n    const digits = tcNumber.split('').map(Number);\n    \n    // First digit cannot be 0\n    if (digits[0] === 0) return false;\n    \n    // TC Number algorithm validation\n    const sum1 = digits[0] + digits[2] + digits[4] + digits[6] + digits[8];\n    const sum2 = digits[1] + digits[3] + digits[5] + digits[7];\n    const check1 = (sum1 * 7 - sum2) % 10;\n    const check2 = (sum1 + sum2 + digits[9]) % 10;\n    \n    return digits[9] === check1 && digits[10] === check2;\n  }\n\n  /**\n   * Calculates age from birth date\n   */\n  static calculateAge(birthDate: string): number {\n    const birth = new Date(birthDate);\n    const today = new Date();\n    let age = today.getFullYear() - birth.getFullYear();\n    const monthDiff = today.getMonth() - birth.getMonth();\n    \n    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {\n      age--;\n    }\n    \n    return age;\n  }\n\n  /**\n   * Validates patient data before creation/update\n   */\n  static validatePatientData(data: PatientCreateRequest | PatientUpdateRequest): string[] {\n    const errors: string[] = [];\n\n    if ('tcNumber' in data && data.tcNumber && !this.validateTcNumber(data.tcNumber)) {\n      errors.push('Invalid TC Number format');\n    }\n\n    if ('birthDate' in data && data.birthDate) {\n      const birthDate = new Date(data.birthDate);\n      const today = new Date();\n      \n      if (birthDate > today) {\n        errors.push('Birth date cannot be in the future');\n      }\n      \n      const age = this.calculateAge(data.birthDate);\n      if (age > 150) {\n        errors.push('Invalid birth date - age cannot exceed 150 years');\n      }\n    }\n\n    if ('contactInfo' in data && data.contactInfo?.phone) {\n      const phoneRegex = /^(\\+90|0)?[5][0-9]{9}$/;\n      if (!phoneRegex.test(data.contactInfo.phone.replace(/\\s/g, ''))) {\n        errors.push('Invalid Turkish phone number format');\n      }\n    }\n\n    if ('contactInfo' in data && data.contactInfo?.email) {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(data.contactInfo.email)) {\n        errors.push('Invalid email format');\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Formats patient name for display\n   */\n  static formatPatientName(patient: Patient): string {\n    return `${patient.firstName} ${patient.lastName}`.trim();\n  }\n\n  /**\n   * Generates patient display ID\n   */\n  static generateDisplayId(patient: Patient): string {\n    const initials = `${patient.firstName[0]}${patient.lastName[0]}`.toUpperCase();\n    const idSuffix = patient.id.slice(-4);\n    return `${initials}-${idSuffix}`;\n  }\n\n  /**\n   * Checks if patient data needs verification\n   */\n  static needsVerification(patient: Patient): boolean {\n    return !patient.contactInfo.phone || \n           !patient.contactInfo.email || \n           !patient.tcNumber;\n  }\n}","import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { \n  FuzzySearch, \n  FuzzySearchOptions, \n  FuzzySearchResult, \n  createFuzzySearch,\n  FuzzySearchPreset,\n  FuzzySearchPresets\n} from '../utils/fuzzy-search';\n\nexport interface UseFuzzySearchOptions<T> extends FuzzySearchOptions<T> {\n  debounceMs?: number;\n  minQueryLength?: number;\n  preset?: FuzzySearchPreset;\n}\n\nexport interface UseFuzzySearchReturn<T> {\n  results: FuzzySearchResult<T>[];\n  query: string;\n  setQuery: (query: string) => void;\n  isSearching: boolean;\n  totalResults: number;\n  hasResults: boolean;\n  clearSearch: () => void;\n  setData: (data: T[]) => void;\n  addItems: (items: T[]) => void;\n  removeItems: (predicate: (item: T) => boolean) => void;\n  stats: {\n    totalItems: number;\n    searchKeys: any;\n    threshold: any;\n  };\n}\n\n/**\n * React hook for fuzzy search functionality with debouncing and state management\n */\nexport function useFuzzySearch<T>(\n  initialData: T[],\n  options: UseFuzzySearchOptions<T> = {}\n): UseFuzzySearchReturn<T> {\n  const {\n    debounceMs = 300,\n    minQueryLength = 2,\n    preset,\n    ...fuzzyOptions\n  } = options;\n\n  // Apply preset if specified\n  const finalOptions = useMemo(() => {\n    if (preset && FuzzySearchPresets[preset]) {\n      return { ...FuzzySearchPresets[preset], ...fuzzyOptions };\n    }\n    return fuzzyOptions;\n  }, [preset, fuzzyOptions]);\n\n  // State management\n  const [query, setQueryState] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const [data, setDataState] = useState<T[]>(initialData);\n\n  // Create fuzzy search instance\n  const fuzzySearch = useMemo(() => {\n    return createFuzzySearch(data, finalOptions);\n  }, [data, finalOptions]);\n\n  // Debounce query updates\n  useEffect(() => {\n    if (query.length === 0) {\n      setDebouncedQuery('');\n      setIsSearching(false);\n      return;\n    }\n\n    if (query.length < minQueryLength) {\n      setDebouncedQuery('');\n      setIsSearching(false);\n      return;\n    }\n\n    setIsSearching(true);\n    const timer = setTimeout(() => {\n      setDebouncedQuery(query);\n      setIsSearching(false);\n    }, debounceMs);\n\n    return () => clearTimeout(timer);\n  }, [query, debounceMs, minQueryLength]);\n\n  // Perform search\n  const results = useMemo(() => {\n    if (!debouncedQuery || debouncedQuery.length < minQueryLength) {\n      return data.map(item => ({ item }));\n    }\n    return fuzzySearch.search(debouncedQuery);\n  }, [debouncedQuery, fuzzySearch, data, minQueryLength]);\n\n  // Computed values\n  const totalResults = results.length;\n  const hasResults = totalResults > 0;\n\n  // Callback functions\n  const setQuery = useCallback((newQuery: string) => {\n    setQueryState(newQuery);\n  }, []);\n\n  const clearSearch = useCallback(() => {\n    setQueryState('');\n    setDebouncedQuery('');\n    setIsSearching(false);\n  }, []);\n\n  const setData = useCallback((newData: T[]) => {\n    setDataState(newData);\n  }, []);\n\n  const addItems = useCallback((items: T[]) => {\n    setDataState(prevData => [...prevData, ...items]);\n  }, []);\n\n  const removeItems = useCallback((predicate: (item: T) => boolean) => {\n    setDataState(prevData => prevData.filter(item => !predicate(item)));\n  }, []);\n\n  const stats = useMemo(() => fuzzySearch.getStats(), [fuzzySearch]);\n\n  return {\n    results,\n    query,\n    setQuery,\n    isSearching,\n    totalResults,\n    hasResults,\n    clearSearch,\n    setData,\n    addItems,\n    removeItems,\n    stats,\n  };\n}\n\n/**\n * Simplified hook for basic fuzzy search without advanced features\n */\nexport function useSimpleFuzzySearch<T>(\n  data: T[],\n  query: string,\n  options: FuzzySearchOptions<T> = {}\n): FuzzySearchResult<T>[] {\n  const fuzzySearch = useMemo(() => {\n    return createFuzzySearch(data, options);\n  }, [data, options]);\n\n  return useMemo(() => {\n    if (!query || query.length < 2) {\n      return data.map(item => ({ item }));\n    }\n    return fuzzySearch.search(query);\n  }, [query, fuzzySearch, data]);\n}\n\n/**\n * Hook for fuzzy search with custom filtering and sorting\n */\nexport function useAdvancedFuzzySearch<T>(\n  data: T[],\n  options: UseFuzzySearchOptions<T> & {\n    filter?: (item: T, result: FuzzySearchResult<T>) => boolean;\n    sort?: (a: FuzzySearchResult<T>, b: FuzzySearchResult<T>) => number;\n    limit?: number;\n  } = {}\n): UseFuzzySearchReturn<T> & {\n  filteredResults: FuzzySearchResult<T>[];\n} {\n  const { filter, sort, limit, ...searchOptions } = options;\n  const searchResult = useFuzzySearch(data, searchOptions);\n\n  const filteredResults = useMemo(() => {\n    let results = searchResult.results;\n\n    // Apply custom filter\n    if (filter) {\n      results = results.filter(result => filter(result.item, result));\n    }\n\n    // Apply custom sort\n    if (sort) {\n      results = [...results].sort(sort);\n    }\n\n    // Apply limit\n    if (limit && limit > 0) {\n      results = results.slice(0, limit);\n    }\n\n    return results;\n  }, [searchResult.results, filter, sort, limit]);\n\n  return {\n    ...searchResult,\n    filteredResults,\n  };\n}","import Fuse, { IFuseOptions, FuseResult } from 'fuse.js';\n\nexport interface FuzzySearchOptions<T> extends IFuseOptions<T> {\n  // Additional custom options can be added here\n}\n\nexport interface FuzzySearchResult<T> {\n  item: T;\n  score?: number;\n  matches?: FuseResult<T>['matches'];\n}\n\nexport class FuzzySearch<T> {\n  private fuse: Fuse<T>;\n  private originalData: T[];\n  private options: FuzzySearchOptions<T>;\n\n  constructor(data: T[], options: FuzzySearchOptions<T> = {}) {\n    this.originalData = data;\n    \n    // Default options optimized for performance and accuracy\n    const defaultOptions: FuzzySearchOptions<T> = {\n      threshold: 0.3, // Lower = more strict matching\n      distance: 100, // Maximum distance for fuzzy matching\n      minMatchCharLength: 2, // Minimum character length to trigger search\n      findAllMatches: false, // Stop at first match for performance\n      includeScore: true,\n      includeMatches: true,\n      shouldSort: true,\n      ...options,\n    };\n\n    this.options = defaultOptions;\n    this.fuse = new Fuse(data, defaultOptions);\n  }\n\n  /**\n   * Perform fuzzy search on the data\n   */\n  search(query: string): FuzzySearchResult<T>[] {\n    if (!query || query.length < 2) {\n      return this.originalData.map(item => ({ item }));\n    }\n\n    const results = this.fuse.search(query);\n    return results.map(result => ({\n      item: result.item,\n      score: result.score,\n      matches: result.matches,\n    }));\n  }\n\n  /**\n   * Update the search data\n   */\n  setData(data: T[]): void {\n    this.originalData = data;\n    this.fuse.setCollection(data);\n  }\n\n  /**\n   * Add new items to the search data\n   */\n  addItems(items: T[]): void {\n    this.originalData = [...this.originalData, ...items];\n    this.fuse.setCollection(this.originalData);\n  }\n\n  /**\n   * Remove items from the search data\n   */\n  removeItems(predicate: (item: T) => boolean): void {\n    this.originalData = this.originalData.filter(item => !predicate(item));\n    this.fuse.setCollection(this.originalData);\n  }\n\n  /**\n   * Get all original data\n   */\n  getAllData(): T[] {\n    return this.originalData;\n  }\n\n  /**\n   * Get search statistics\n   */\n  getStats() {\n    return {\n      totalItems: this.originalData.length,\n      searchKeys: this.options.keys,\n      threshold: this.options.threshold,\n    };\n  }\n}\n\n/**\n * Factory function for creating fuzzy search instances\n */\nexport function createFuzzySearch<T>(\n  data: T[],\n  options: FuzzySearchOptions<T> = {}\n): FuzzySearch<T> {\n  return new FuzzySearch(data, options);\n}\n\n/**\n * Simple utility function for one-off searches\n */\nexport function fuzzySearch<T>(\n  data: T[],\n  query: string,\n  options: FuzzySearchOptions<T> = {}\n): FuzzySearchResult<T>[] {\n  const searcher = new FuzzySearch(data, options);\n  return searcher.search(query);\n}\n\n/**\n * Predefined search configurations for common use cases\n */\nexport const FuzzySearchPresets = {\n  // For searching user names, titles, etc.\n  strict: {\n    threshold: 0.2,\n    distance: 50,\n    minMatchCharLength: 3,\n  },\n  \n  // For general purpose searching\n  balanced: {\n    threshold: 0.3,\n    distance: 100,\n    minMatchCharLength: 2,\n  },\n  \n  // For very lenient searching\n  lenient: {\n    threshold: 0.6,\n    distance: 200,\n    minMatchCharLength: 1,\n  },\n  \n  // For exact matching with typo tolerance\n  exactWithTypos: {\n    threshold: 0.1,\n    distance: 20,\n    minMatchCharLength: 3,\n    findAllMatches: true,\n  },\n} as const;\n\nexport type FuzzySearchPreset = keyof typeof FuzzySearchPresets;","import { useState, useCallback, useRef } from 'react';\nimport { FileParserService, ParsedData, ParseOptions, FileParseError } from '../services/file-parser';\nimport { TypeConverter, ColumnTypeInfo, ConversionOptions } from '../utils/type-converter';\n\nexport interface FileUploadState {\n  file: File | null;\n  isUploading: boolean;\n  isProcessing: boolean;\n  progress: number;\n  error: string | null;\n  parsedData: ParsedData | null;\n  columnTypes: ColumnTypeInfo[] | null;\n  previewData: any[][] | null;\n}\n\nexport interface FileUploadOptions {\n  maxFileSize?: number; // in bytes\n  allowedTypes?: string[];\n  parseOptions?: ParseOptions;\n  conversionOptions?: ConversionOptions;\n  previewRows?: number;\n  autoDetectTypes?: boolean;\n}\n\nexport interface FileUploadActions {\n  uploadFile: (file: File) => Promise<void>;\n  processFile: () => Promise<void>;\n  convertColumn: (columnIndex: number, targetType: string) => Promise<void>;\n  convertAllColumns: () => Promise<void>;\n  reset: () => void;\n  removeFile: () => void;\n  updateParseOptions: (options: Partial<ParseOptions>) => void;\n  updateConversionOptions: (options: Partial<ConversionOptions>) => void;\n  getPreviewData: (rows?: number) => any[][];\n  downloadProcessedData: (filename?: string) => void;\n}\n\nexport interface UseFileUploadReturn {\n  state: FileUploadState;\n  actions: FileUploadActions;\n}\n\nconst DEFAULT_OPTIONS: FileUploadOptions = {\n  maxFileSize: 10 * 1024 * 1024, // 10MB\n  allowedTypes: ['.csv', '.xlsx', '.xls'],\n  previewRows: 10,\n  autoDetectTypes: true,\n  parseOptions: {\n    hasHeaders: true,\n    skipEmptyLines: true,\n    trimHeaders: true,\n  },\n  conversionOptions: {\n    trimWhitespace: true,\n    strictMode: false,\n  },\n};\n\nexport function useFileUpload(options: FileUploadOptions = {}): UseFileUploadReturn {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const parseOptionsRef = useRef<ParseOptions>(opts.parseOptions || {});\n  const conversionOptionsRef = useRef<ConversionOptions>(opts.conversionOptions || {});\n\n  const [state, setState] = useState<FileUploadState>({\n    file: null,\n    isUploading: false,\n    isProcessing: false,\n    progress: 0,\n    error: null,\n    parsedData: null,\n    columnTypes: null,\n    previewData: null,\n  });\n\n  const validateFile = useCallback((file: File): string | null => {\n    // Check file size\n    if (opts.maxFileSize && file.size > opts.maxFileSize) {\n      return `File size (${Math.round(file.size / 1024 / 1024)}MB) exceeds maximum allowed size (${Math.round(opts.maxFileSize / 1024 / 1024)}MB)`;\n    }\n\n    // Check file type\n    if (opts.allowedTypes && opts.allowedTypes.length > 0) {\n      const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();\n      if (!opts.allowedTypes.includes(fileExtension)) {\n        return `File type \"${fileExtension}\" is not allowed. Allowed types: ${opts.allowedTypes.join(', ')}`;\n      }\n    }\n\n    return null;\n  }, [opts.maxFileSize, opts.allowedTypes]);\n\n  const uploadFile = useCallback(async (file: File) => {\n    // Validate file\n    const validationError = validateFile(file);\n    if (validationError) {\n      setState(prev => ({ ...prev, error: validationError }));\n      return;\n    }\n\n    setState(prev => ({\n      ...prev,\n      file,\n      isUploading: true,\n      error: null,\n      progress: 0,\n    }));\n\n    try {\n      // Simulate upload progress\n      for (let i = 0; i <= 100; i += 10) {\n        setState(prev => ({ ...prev, progress: i }));\n        await new Promise(resolve => setTimeout(resolve, 50));\n      }\n\n      setState(prev => ({\n        ...prev,\n        isUploading: false,\n        progress: 100,\n      }));\n\n      // Auto-process if enabled\n      if (opts.autoDetectTypes) {\n        await processFile();\n      }\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isUploading: false,\n        error: error instanceof Error ? error.message : 'Upload failed',\n      }));\n    }\n  }, [validateFile, opts.autoDetectTypes]);\n\n  const processFile = useCallback(async () => {\n    if (!state.file) {\n      setState(prev => ({ ...prev, error: 'No file selected' }));\n      return;\n    }\n\n    setState(prev => ({\n      ...prev,\n      isProcessing: true,\n      error: null,\n    }));\n\n    try {\n      // Parse file\n      const parsedData = await FileParserService.parseFile(\n        state.file,\n        parseOptionsRef.current\n      );\n\n      // Analyze column types if auto-detection is enabled\n      let columnTypes: ColumnTypeInfo[] | null = null;\n      if (opts.autoDetectTypes && parsedData.rows.length > 0) {\n        columnTypes = parsedData.headers.map((header, index) => {\n          const columnValues = parsedData.rows.map((row: any[]) => row[index]);\n          return TypeConverter.analyzeColumn(\n            columnValues,\n            header,\n            index,\n            conversionOptionsRef.current\n          );\n        });\n      }\n\n      // Generate preview data\n      const previewData = parsedData.rows.slice(0, opts.previewRows || 10);\n\n      setState(prev => ({\n        ...prev,\n        isProcessing: false,\n        parsedData,\n        columnTypes,\n        previewData,\n      }));\n    } catch (error) {\n      const errorMessage = error instanceof Error \n        ? `Parse error: ${error.message}` \n        : 'Processing failed';\n\n      setState(prev => ({\n        ...prev,\n        isProcessing: false,\n        error: errorMessage,\n      }));\n    }\n  }, [state.file, opts.autoDetectTypes, opts.previewRows]);\n\n  const convertColumn = useCallback(async (columnIndex: number, targetType: string) => {\n    if (!state.parsedData || !state.columnTypes) {\n      setState(prev => ({ ...prev, error: 'No data to convert' }));\n      return;\n    }\n\n    try {\n      const columnValues = state.parsedData.rows.map((row: any[]) => row[columnIndex]);\n      const { converted, errors } = TypeConverter.convertColumn(\n        columnValues,\n        targetType as any,\n        conversionOptionsRef.current\n      );\n\n      // Update parsed data with converted values\n      const newData = state.parsedData.rows.map((row: any[], rowIndex: number) => {\n        const newRow = [...row];\n        newRow[columnIndex] = converted[rowIndex];\n        return newRow;\n      });\n\n      // Update column type info\n      const newColumnTypes = [...state.columnTypes];\n      newColumnTypes[columnIndex] = {\n        ...newColumnTypes[columnIndex],\n        detectedType: targetType as any,\n        confidence: errors.length === 0 ? 1 : 1 - (errors.length / columnValues.length),\n        errors: errors.map(e => e.error),\n      };\n\n      setState(prev => ({\n        ...prev,\n        parsedData: prev.parsedData ? { ...prev.parsedData, rows: newData } : null,\n        columnTypes: newColumnTypes,\n        previewData: newData.slice(0, opts.previewRows || 10),\n      }));\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Conversion failed',\n      }));\n    }\n  }, [state.parsedData, state.columnTypes, opts.previewRows]);\n\n  const convertAllColumns = useCallback(async () => {\n    if (!state.columnTypes) {\n      setState(prev => ({ ...prev, error: 'No column type information available' }));\n      return;\n    }\n\n    try {\n      for (const columnType of state.columnTypes) {\n        await convertColumn(columnType.columnIndex, columnType.detectedType);\n      }\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Batch conversion failed',\n      }));\n    }\n  }, [state.columnTypes, convertColumn]);\n\n  const reset = useCallback(() => {\n    setState({\n      file: null,\n      isUploading: false,\n      isProcessing: false,\n      progress: 0,\n      error: null,\n      parsedData: null,\n      columnTypes: null,\n      previewData: null,\n    });\n  }, []);\n\n  const removeFile = useCallback(() => {\n    setState(prev => ({\n      ...prev,\n      file: null,\n      parsedData: null,\n      columnTypes: null,\n      previewData: null,\n      error: null,\n    }));\n  }, []);\n\n  const updateParseOptions = useCallback((newOptions: Partial<ParseOptions>) => {\n    parseOptionsRef.current = { ...parseOptionsRef.current, ...newOptions };\n  }, []);\n\n  const updateConversionOptions = useCallback((newOptions: Partial<ConversionOptions>) => {\n    conversionOptionsRef.current = { ...conversionOptionsRef.current, ...newOptions };\n  }, []);\n\n  const getPreviewData = useCallback((rows?: number): any[][] => {\n    if (!state.parsedData) return [];\n    const numRows = rows || opts.previewRows || 10;\n    return state.parsedData.rows.slice(0, numRows);\n  }, [state.parsedData, opts.previewRows]);\n\n  const downloadProcessedData = useCallback((filename?: string) => {\n    if (!state.parsedData) {\n      setState(prev => ({ ...prev, error: 'No data to download' }));\n      return;\n    }\n\n    try {\n      // Convert data to CSV format\n      const csvContent = [\n        state.parsedData.headers.join(','),\n        ...state.parsedData.rows.map((row: any[]) => \n          row.map((cell: any) => \n            typeof cell === 'string' && cell.includes(',') \n              ? `\"${cell.replace(/\"/g, '\"\"')}\"` \n              : String(cell)\n          ).join(',')\n        )\n      ].join('\\n');\n\n      // Create and download file\n      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n      const link = document.createElement('a');\n      const url = URL.createObjectURL(blob);\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', filename || `processed_${state.file?.name || 'data.csv'}`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      URL.revokeObjectURL(url);\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Download failed',\n      }));\n    }\n  }, [state.parsedData, state.file]);\n\n  return {\n    state,\n    actions: {\n      uploadFile,\n      processFile,\n      convertColumn,\n      convertAllColumns,\n      reset,\n      removeFile,\n      updateParseOptions,\n      updateConversionOptions,\n      getPreviewData,\n      downloadProcessedData,\n    },\n  };\n}\n\n// Additional utility hooks for specific use cases\n\n/**\n * Simple file upload hook for basic CSV/XLSX parsing\n */\nexport function useSimpleFileUpload() {\n  return useFileUpload({\n    autoDetectTypes: false,\n    previewRows: 5,\n  });\n}\n\n/**\n * Advanced file upload hook with full type detection and conversion\n */\nexport function useAdvancedFileUpload(options?: Partial<FileUploadOptions>) {\n  return useFileUpload({\n    autoDetectTypes: true,\n    previewRows: 20,\n    ...options,\n  });\n}\n\n/**\n * Hook for drag and drop file upload\n */\nexport function useDragDropFileUpload(options?: FileUploadOptions) {\n  const fileUpload = useFileUpload(options);\n  const [isDragOver, setIsDragOver] = useState(false);\n\n  const handleDragOver = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(true);\n  }, []);\n\n  const handleDragLeave = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(false);\n  }, []);\n\n  const handleDrop = useCallback(async (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(false);\n\n    const files = Array.from(e.dataTransfer.files);\n    if (files.length > 0) {\n      await fileUpload.actions.uploadFile(files[0]);\n    }\n  }, [fileUpload.actions]);\n\n  return {\n    ...fileUpload,\n    dragProps: {\n      onDragOver: handleDragOver,\n      onDragLeave: handleDragLeave,\n      onDrop: handleDrop,\n    },\n    isDragOver,\n  };\n}","import Papa from 'papaparse';\nimport * as XLSX from 'xlsx';\n\nexport interface ParsedData {\n  headers: string[];\n  rows: any[][];\n  totalRows: number;\n  preview: any[][];\n  metadata: {\n    fileName: string;\n    fileSize: number;\n    fileType: string;\n    encoding?: string;\n    delimiter?: string;\n    hasHeaders: boolean;\n    parseTime: number;\n  };\n}\n\nexport interface ParseOptions {\n  preview?: boolean;\n  previewRows?: number;\n  hasHeaders?: boolean;\n  delimiter?: string;\n  encoding?: string;\n  skipEmptyLines?: boolean;\n  trimHeaders?: boolean;\n  transformHeader?: (header: string) => string;\n}\n\nexport interface FileParseError {\n  type: 'PARSE_ERROR' | 'UNSUPPORTED_FORMAT' | 'FILE_TOO_LARGE' | 'INVALID_DATA';\n  message: string;\n  details?: any;\n}\n\nexport class FileParserService {\n  private static readonly MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB\n  private static readonly DEFAULT_PREVIEW_ROWS = 10;\n  private static readonly SUPPORTED_TYPES = [\n    'text/csv',\n    'application/vnd.ms-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'text/plain',\n  ];\n\n  /**\n   * Parse CSV file using Papa Parse\n   */\n  static async parseCSV(\n    file: File,\n    options: ParseOptions = {}\n  ): Promise<ParsedData> {\n    const startTime = Date.now();\n    \n    return new Promise((resolve, reject) => {\n      const {\n        preview = false,\n        previewRows = this.DEFAULT_PREVIEW_ROWS,\n        hasHeaders = true,\n        delimiter = '',\n        skipEmptyLines = true,\n        trimHeaders = true,\n        transformHeader,\n      } = options;\n\n      Papa.parse(file, {\n        header: false, // We'll handle headers manually for better control\n        delimiter: delimiter || undefined,\n        skipEmptyLines,\n        preview: preview ? previewRows + (hasHeaders ? 1 : 0) : 0,\n        encoding: options.encoding || 'UTF-8',\n        complete: (results) => {\n          try {\n            const parseTime = Date.now() - startTime;\n            const allRows = results.data as string[][];\n            \n            if (allRows.length === 0) {\n              reject({\n                type: 'INVALID_DATA',\n                message: 'File appears to be empty or contains no valid data',\n              } as FileParseError);\n              return;\n            }\n\n            let headers: string[] = [];\n            let dataRows: any[][] = [];\n\n            if (hasHeaders && allRows.length > 0) {\n              const headerRow = allRows[0];\n              headers = headerRow.map((header, index) => {\n                let processedHeader = trimHeaders ? header.trim() : header;\n                if (transformHeader) {\n                  processedHeader = transformHeader(processedHeader);\n                }\n                return processedHeader || `Column ${index + 1}`;\n              });\n              dataRows = allRows.slice(1);\n            } else {\n              // Generate column headers\n              const maxColumns = Math.max(...allRows.map(row => row.length));\n              headers = Array.from({ length: maxColumns }, (_, i) => `Column ${i + 1}`);\n              dataRows = allRows;\n            }\n\n            const previewData = preview ? dataRows.slice(0, previewRows) : dataRows;\n\n            const parsedData: ParsedData = {\n              headers,\n              rows: dataRows,\n              totalRows: dataRows.length,\n              preview: previewData,\n              metadata: {\n                fileName: file.name,\n                fileSize: file.size,\n                fileType: file.type || 'text/csv',\n                encoding: options.encoding || 'UTF-8',\n                delimiter: results.meta.delimiter,\n                hasHeaders,\n                parseTime,\n              },\n            };\n\n            resolve(parsedData);\n          } catch (error) {\n            reject({\n              type: 'PARSE_ERROR',\n              message: 'Failed to process CSV data',\n              details: error,\n            } as FileParseError);\n          }\n        },\n        error: (error) => {\n          reject({\n            type: 'PARSE_ERROR',\n            message: `CSV parsing failed: ${error.message}`,\n            details: error,\n          } as FileParseError);\n        },\n      });\n    });\n  }\n\n  /**\n   * Parse Excel file using SheetJS\n   */\n  static async parseExcel(\n    file: File,\n    options: ParseOptions = {}\n  ): Promise<ParsedData> {\n    const startTime = Date.now();\n    \n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (e) => {\n        try {\n          const {\n            preview = false,\n            previewRows = this.DEFAULT_PREVIEW_ROWS,\n            hasHeaders = true,\n            trimHeaders = true,\n            transformHeader,\n          } = options;\n\n          const data = new Uint8Array(e.target?.result as ArrayBuffer);\n          const workbook = XLSX.read(data, { type: 'array' });\n          \n          // Get first worksheet\n          const firstSheetName = workbook.SheetNames[0];\n          const worksheet = workbook.Sheets[firstSheetName];\n          \n          if (!worksheet) {\n            reject({\n              type: 'INVALID_DATA',\n              message: 'Excel file contains no readable worksheets',\n            } as FileParseError);\n            return;\n          }\n\n          // Convert to array of arrays\n          const allRows: any[][] = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1,\n            defval: '',\n            blankrows: false,\n          });\n\n          if (allRows.length === 0) {\n            reject({\n              type: 'INVALID_DATA',\n              message: 'Excel file appears to be empty',\n            } as FileParseError);\n            return;\n          }\n\n          let headers: string[] = [];\n          let dataRows: any[][] = [];\n\n          if (hasHeaders && allRows.length > 0) {\n            const headerRow = allRows[0];\n            headers = headerRow.map((header, index) => {\n              let processedHeader = String(header || '');\n              if (trimHeaders) {\n                processedHeader = processedHeader.trim();\n              }\n              if (transformHeader) {\n                processedHeader = transformHeader(processedHeader);\n              }\n              return processedHeader || `Column ${index + 1}`;\n            });\n            dataRows = allRows.slice(1);\n          } else {\n            const maxColumns = Math.max(...allRows.map(row => row.length));\n            headers = Array.from({ length: maxColumns }, (_, i) => `Column ${i + 1}`);\n            dataRows = allRows;\n          }\n\n          const previewData = preview ? dataRows.slice(0, previewRows) : dataRows;\n          const parseTime = Date.now() - startTime;\n\n          const parsedData: ParsedData = {\n            headers,\n            rows: dataRows,\n            totalRows: dataRows.length,\n            preview: previewData,\n            metadata: {\n              fileName: file.name,\n              fileSize: file.size,\n              fileType: file.type || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n              hasHeaders,\n              parseTime,\n            },\n          };\n\n          resolve(parsedData);\n        } catch (error) {\n          reject({\n            type: 'PARSE_ERROR',\n            message: 'Failed to parse Excel file',\n            details: error,\n          } as FileParseError);\n        }\n      };\n\n      reader.onerror = () => {\n        reject({\n          type: 'PARSE_ERROR',\n          message: 'Failed to read Excel file',\n        } as FileParseError);\n      };\n\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * Auto-detect file type and parse accordingly\n   */\n  static async parseFile(\n    file: File,\n    options: ParseOptions = {}\n  ): Promise<ParsedData> {\n    // Validate file size\n    if (file.size > this.MAX_FILE_SIZE) {\n      throw {\n        type: 'FILE_TOO_LARGE',\n        message: `File size (${Math.round(file.size / 1024 / 1024)}MB) exceeds maximum allowed size (${Math.round(this.MAX_FILE_SIZE / 1024 / 1024)}MB)`,\n      } as FileParseError;\n    }\n\n    // Validate file type\n    const fileType = file.type || this.getFileTypeFromExtension(file.name);\n    if (!this.SUPPORTED_TYPES.includes(fileType)) {\n      throw {\n        type: 'UNSUPPORTED_FORMAT',\n        message: `Unsupported file format: ${fileType}. Supported formats: CSV, Excel (.xlsx, .xls)`,\n      } as FileParseError;\n    }\n\n    // Route to appropriate parser\n    if (fileType === 'text/csv' || fileType === 'text/plain') {\n      return this.parseCSV(file, options);\n    } else if (\n      fileType === 'application/vnd.ms-excel' ||\n      fileType === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n    ) {\n      return this.parseExcel(file, options);\n    }\n\n    throw {\n      type: 'UNSUPPORTED_FORMAT',\n      message: `Unable to determine parser for file type: ${fileType}`,\n    } as FileParseError;\n  }\n\n  /**\n   * Get file type from extension when MIME type is not available\n   */\n  private static getFileTypeFromExtension(fileName: string): string {\n    const extension = fileName.toLowerCase().split('.').pop();\n    \n    switch (extension) {\n      case 'csv':\n        return 'text/csv';\n      case 'xlsx':\n        return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n      case 'xls':\n        return 'application/vnd.ms-excel';\n      case 'txt':\n        return 'text/plain';\n      default:\n        return 'application/octet-stream';\n    }\n  }\n\n  /**\n   * Validate parsed data structure\n   */\n  static validateParsedData(data: ParsedData): boolean {\n    return (\n      data &&\n      Array.isArray(data.headers) &&\n      Array.isArray(data.rows) &&\n      data.headers.length > 0 &&\n      typeof data.totalRows === 'number' &&\n      data.metadata &&\n      typeof data.metadata.fileName === 'string'\n    );\n  }\n\n  /**\n   * Get file parsing statistics\n   */\n  static getParsingStats(data: ParsedData) {\n    const columnStats = data.headers.map((header, index) => {\n      const columnData = data.rows.map(row => row[index]);\n      const nonEmptyValues = columnData.filter(val => val !== null && val !== undefined && val !== '');\n      \n      return {\n        name: header,\n        index,\n        totalValues: columnData.length,\n        nonEmptyValues: nonEmptyValues.length,\n        emptyValues: columnData.length - nonEmptyValues.length,\n        fillRate: nonEmptyValues.length / columnData.length,\n        sampleValues: nonEmptyValues.slice(0, 5),\n      };\n    });\n\n    return {\n      totalColumns: data.headers.length,\n      totalRows: data.totalRows,\n      parseTime: data.metadata.parseTime,\n      fileSize: data.metadata.fileSize,\n      columnStats,\n    };\n  }\n}","export type DataType = \n  | 'string' \n  | 'number' \n  | 'integer' \n  | 'float' \n  | 'boolean' \n  | 'date' \n  | 'datetime' \n  | 'time'\n  | 'email' \n  | 'url' \n  | 'phone' \n  | 'currency'\n  | 'percentage'\n  | 'null'\n  | 'unknown';\n\nexport interface TypeDetectionResult {\n  type: DataType;\n  confidence: number; // 0-1\n  pattern?: string;\n  samples: any[];\n  convertedSamples: any[];\n  errors: string[];\n}\n\nexport interface ColumnTypeInfo {\n  columnName: string;\n  columnIndex: number;\n  detectedType: DataType;\n  confidence: number;\n  totalValues: number;\n  nonEmptyValues: number;\n  nullValues: number;\n  uniqueValues: number;\n  samples: any[];\n  convertedSamples: any[];\n  errors: string[];\n  suggestions?: string[];\n}\n\nexport interface ConversionOptions {\n  dateFormats?: string[];\n  currencySymbols?: string[];\n  decimalSeparator?: '.' | ',';\n  thousandsSeparator?: ',' | '.' | ' ';\n  booleanTrueValues?: string[];\n  booleanFalseValues?: string[];\n  nullValues?: string[];\n  trimWhitespace?: boolean;\n  strictMode?: boolean;\n}\n\nexport class TypeConverter {\n  private static readonly DEFAULT_OPTIONS: ConversionOptions = {\n    dateFormats: [\n      'YYYY-MM-DD',\n      'DD/MM/YYYY',\n      'MM/DD/YYYY',\n      'DD-MM-YYYY',\n      'MM-DD-YYYY',\n      'YYYY/MM/DD',\n      'DD.MM.YYYY',\n      'YYYY-MM-DD HH:mm:ss',\n      'DD/MM/YYYY HH:mm:ss',\n      'MM/DD/YYYY HH:mm:ss',\n    ],\n    currencySymbols: ['$', '€', '£', '¥', '₺', '₹'],\n    decimalSeparator: '.',\n    thousandsSeparator: ',',\n    booleanTrueValues: ['true', 'yes', 'y', '1', 'on', 'enabled', 'active'],\n    booleanFalseValues: ['false', 'no', 'n', '0', 'off', 'disabled', 'inactive'],\n    nullValues: ['', 'null', 'NULL', 'nil', 'NIL', 'n/a', 'N/A', 'undefined'],\n    trimWhitespace: true,\n    strictMode: false,\n  };\n\n  /**\n   * Detect data type for a single value\n   */\n  static detectValueType(value: any, options: ConversionOptions = {}): DataType {\n    const opts = { ...this.DEFAULT_OPTIONS, ...options };\n    \n    if (value === null || value === undefined) {\n      return 'null';\n    }\n\n    const strValue = String(value);\n    const trimmedValue = opts.trimWhitespace ? strValue.trim() : strValue;\n\n    // Check for null values\n    if (opts.nullValues?.includes(trimmedValue.toLowerCase())) {\n      return 'null';\n    }\n\n    // Check for boolean\n    if (opts.booleanTrueValues?.includes(trimmedValue.toLowerCase()) ||\n        opts.booleanFalseValues?.includes(trimmedValue.toLowerCase())) {\n      return 'boolean';\n    }\n\n    // Check for email\n    if (this.isEmail(trimmedValue)) {\n      return 'email';\n    }\n\n    // Check for URL\n    if (this.isUrl(trimmedValue)) {\n      return 'url';\n    }\n\n    // Check for phone\n    if (this.isPhone(trimmedValue)) {\n      return 'phone';\n    }\n\n    // Check for currency\n    if (this.isCurrency(trimmedValue, opts.currencySymbols || [])) {\n      return 'currency';\n    }\n\n    // Check for percentage\n    if (this.isPercentage(trimmedValue)) {\n      return 'percentage';\n    }\n\n    // Check for date/time\n    if (this.isDateTime(trimmedValue)) {\n      return 'datetime';\n    }\n\n    if (this.isDate(trimmedValue)) {\n      return 'date';\n    }\n\n    if (this.isTime(trimmedValue)) {\n      return 'time';\n    }\n\n    // Check for numbers\n    if (this.isInteger(trimmedValue, opts)) {\n      return 'integer';\n    }\n\n    if (this.isFloat(trimmedValue, opts)) {\n      return 'float';\n    }\n\n    // Default to string\n    return 'string';\n  }\n\n  /**\n   * Analyze column data and detect the most likely type\n   */\n  static analyzeColumn(\n    values: any[],\n    columnName: string,\n    columnIndex: number,\n    options: ConversionOptions = {}\n  ): ColumnTypeInfo {\n    const opts = { ...this.DEFAULT_OPTIONS, ...options };\n    const nonEmptyValues = values.filter(v => \n      v !== null && v !== undefined && String(v).trim() !== ''\n    );\n\n    if (nonEmptyValues.length === 0) {\n      return {\n        columnName,\n        columnIndex,\n        detectedType: 'string',\n        confidence: 0,\n        totalValues: values.length,\n        nonEmptyValues: 0,\n        nullValues: values.length,\n        uniqueValues: 0,\n        samples: [],\n        convertedSamples: [],\n        errors: ['Column contains no data'],\n      };\n    }\n\n    // Count type occurrences\n    const typeCounts: Record<DataType, number> = {\n      string: 0, number: 0, integer: 0, float: 0, boolean: 0,\n      date: 0, datetime: 0, time: 0, email: 0, url: 0,\n      phone: 0, currency: 0, percentage: 0, null: 0, unknown: 0,\n    };\n\n    const samples = nonEmptyValues.slice(0, 10);\n    const convertedSamples: any[] = [];\n    const errors: string[] = [];\n\n    // Analyze each value\n    nonEmptyValues.forEach(value => {\n      const detectedType = this.detectValueType(value, opts);\n      typeCounts[detectedType]++;\n    });\n\n    // Find the most common type\n    const sortedTypes = Object.entries(typeCounts)\n      .filter(([_, count]) => count > 0)\n      .sort(([, a], [, b]) => b - a);\n\n    const [mostCommonType, mostCommonCount] = sortedTypes[0] || ['string', 0];\n    const confidence = mostCommonCount / nonEmptyValues.length;\n\n    // Convert samples\n    samples.forEach(sample => {\n      try {\n        const converted = this.convertValue(sample, mostCommonType as DataType, opts);\n        convertedSamples.push(converted);\n      } catch (error) {\n        convertedSamples.push(sample);\n        errors.push(`Failed to convert \"${sample}\": ${error}`);\n      }\n    });\n\n    // Generate suggestions\n    const suggestions: string[] = [];\n    if (confidence < 0.8) {\n      suggestions.push(`Low confidence (${Math.round(confidence * 100)}%) - consider manual review`);\n    }\n    if (sortedTypes.length > 1) {\n      const [, secondType] = sortedTypes[1];\n      suggestions.push(`Alternative type detected: ${secondType}`);\n    }\n\n    return {\n      columnName,\n      columnIndex,\n      detectedType: mostCommonType as DataType,\n      confidence,\n      totalValues: values.length,\n      nonEmptyValues: nonEmptyValues.length,\n      nullValues: values.length - nonEmptyValues.length,\n      uniqueValues: new Set(nonEmptyValues).size,\n      samples,\n      convertedSamples,\n      errors,\n      suggestions: suggestions.length > 0 ? suggestions : undefined,\n    };\n  }\n\n  /**\n   * Convert a value to the specified type\n   */\n  static convertValue(value: any, targetType: DataType, options: ConversionOptions = {}): any {\n    const opts = { ...this.DEFAULT_OPTIONS, ...options };\n    \n    if (value === null || value === undefined) {\n      return null;\n    }\n\n    const strValue = String(value);\n    const trimmedValue = opts.trimWhitespace ? strValue.trim() : strValue;\n\n    switch (targetType) {\n      case 'null':\n        return null;\n\n      case 'boolean':\n        if (opts.booleanTrueValues?.includes(trimmedValue.toLowerCase())) {\n          return true;\n        }\n        if (opts.booleanFalseValues?.includes(trimmedValue.toLowerCase())) {\n          return false;\n        }\n        throw new Error(`Cannot convert \"${trimmedValue}\" to boolean`);\n\n      case 'integer':\n        const intValue = this.parseNumber(trimmedValue, opts);\n        if (!Number.isInteger(intValue)) {\n          throw new Error(`\"${trimmedValue}\" is not a valid integer`);\n        }\n        return intValue;\n\n      case 'float':\n      case 'number':\n        return this.parseNumber(trimmedValue, opts);\n\n      case 'currency':\n        return this.parseCurrency(trimmedValue, opts);\n\n      case 'percentage':\n        return this.parsePercentage(trimmedValue);\n\n      case 'date':\n        return this.parseDate(trimmedValue);\n\n      case 'datetime':\n        return this.parseDateTime(trimmedValue);\n\n      case 'time':\n        return this.parseTime(trimmedValue);\n\n      case 'email':\n      case 'url':\n      case 'phone':\n      case 'string':\n      default:\n        return trimmedValue;\n    }\n  }\n\n  /**\n   * Convert entire column data\n   */\n  static convertColumn(\n    values: any[],\n    targetType: DataType,\n    options: ConversionOptions = {}\n  ): { converted: any[]; errors: Array<{ index: number; value: any; error: string }> } {\n    const converted: any[] = [];\n    const errors: Array<{ index: number; value: any; error: string }> = [];\n\n    values.forEach((value, index) => {\n      try {\n        const convertedValue = this.convertValue(value, targetType, options);\n        converted.push(convertedValue);\n      } catch (error) {\n        converted.push(value); // Keep original value on error\n        errors.push({\n          index,\n          value,\n          error: String(error),\n        });\n      }\n    });\n\n    return { converted, errors };\n  }\n\n  // Type detection helper methods\n  private static isEmail(value: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(value);\n  }\n\n  private static isUrl(value: string): boolean {\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private static isPhone(value: string): boolean {\n    const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;\n    const cleanValue = value.replace(/[\\s\\-\\(\\)\\.]/g, '');\n    return phoneRegex.test(cleanValue) && cleanValue.length >= 7;\n  }\n\n  private static isCurrency(value: string, symbols: string[]): boolean {\n    const hasSymbol = symbols.some(symbol => value.includes(symbol));\n    if (!hasSymbol) return false;\n    \n    const numericPart = value.replace(/[^\\d\\.,\\-]/g, '');\n    return this.isFloat(numericPart, {});\n  }\n\n  private static isPercentage(value: string): boolean {\n    return value.includes('%') && this.isFloat(value.replace('%', ''), {});\n  }\n\n  private static isInteger(value: string, options: ConversionOptions): boolean {\n    try {\n      const num = this.parseNumber(value, options);\n      return Number.isInteger(num);\n    } catch {\n      return false;\n    }\n  }\n\n  private static isFloat(value: string, options: ConversionOptions): boolean {\n    try {\n      const num = this.parseNumber(value, options);\n      return !isNaN(num) && isFinite(num);\n    } catch {\n      return false;\n    }\n  }\n\n  private static isDate(value: string): boolean {\n    const dateRegex = /^\\d{1,4}[-\\/\\.]\\d{1,2}[-\\/\\.]\\d{1,4}$/;\n    return dateRegex.test(value) && !isNaN(Date.parse(value));\n  }\n\n  private static isDateTime(value: string): boolean {\n    const dateTimeRegex = /^\\d{1,4}[-\\/\\.]\\d{1,2}[-\\/\\.]\\d{1,4}\\s+\\d{1,2}:\\d{2}(:\\d{2})?/;\n    return dateTimeRegex.test(value) && !isNaN(Date.parse(value));\n  }\n\n  private static isTime(value: string): boolean {\n    const timeRegex = /^\\d{1,2}:\\d{2}(:\\d{2})?(\\s*(AM|PM))?$/i;\n    return timeRegex.test(value);\n  }\n\n  // Parsing helper methods\n  private static parseNumber(value: string, options: ConversionOptions): number {\n    const { decimalSeparator = '.', thousandsSeparator = ',' } = options;\n    \n    let cleanValue = value.replace(/\\s/g, '');\n    \n    // Handle thousands separator\n    if (thousandsSeparator && thousandsSeparator !== decimalSeparator) {\n      cleanValue = cleanValue.replace(new RegExp(`\\\\${thousandsSeparator}`, 'g'), '');\n    }\n    \n    // Handle decimal separator\n    if (decimalSeparator !== '.') {\n      cleanValue = cleanValue.replace(decimalSeparator, '.');\n    }\n    \n    const num = parseFloat(cleanValue);\n    if (isNaN(num)) {\n      throw new Error(`Cannot parse \"${value}\" as number`);\n    }\n    \n    return num;\n  }\n\n  private static parseCurrency(value: string, options: ConversionOptions): number {\n    const cleanValue = value.replace(/[^\\d\\.,\\-]/g, '');\n    return this.parseNumber(cleanValue, options);\n  }\n\n  private static parsePercentage(value: string): number {\n    const numericValue = value.replace('%', '');\n    return parseFloat(numericValue) / 100;\n  }\n\n  private static parseDate(value: string): Date {\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n      throw new Error(`Cannot parse \"${value}\" as date`);\n    }\n    return date;\n  }\n\n  private static parseDateTime(value: string): Date {\n    return this.parseDate(value);\n  }\n\n  private static parseTime(value: string): string {\n    // Return as string for now, could be enhanced to return Date or time object\n    return value;\n  }\n}","import { format, parseISO, isValid, differenceInYears, addDays, startOfDay, endOfDay } from 'date-fns';\nimport { tr } from 'date-fns/locale';\n\n/**\n * Formats a date string or Date object to Turkish locale format\n */\nexport const formatDate = (date: string | Date, formatStr: string = 'dd.MM.yyyy'): string => {\n  try {\n    const dateObj = typeof date === 'string' ? parseISO(date) : date;\n    if (!isValid(dateObj)) return '';\n    return format(dateObj, formatStr, { locale: tr });\n  } catch {\n    return '';\n  }\n};\n\n/**\n * Formats a date for display in Turkish format\n */\nexport const formatDateTurkish = (date: string | Date): string => {\n  return formatDate(date, 'dd MMMM yyyy');\n};\n\n/**\n * Formats a date and time for display\n */\nexport const formatDateTime = (date: string | Date): string => {\n  return formatDate(date, 'dd.MM.yyyy HH:mm');\n};\n\n/**\n * Calculates age from birth date\n */\nexport const calculateAge = (birthDate: string | Date): number => {\n  try {\n    const birth = typeof birthDate === 'string' ? parseISO(birthDate) : birthDate;\n    if (!isValid(birth)) return 0;\n    return differenceInYears(new Date(), birth);\n  } catch {\n    return 0;\n  }\n};\n\n/**\n * Checks if a date is today\n */\nexport const isToday = (date: string | Date): boolean => {\n  try {\n    const dateObj = typeof date === 'string' ? parseISO(date) : date;\n    if (!isValid(dateObj)) return false;\n    const today = new Date();\n    return formatDate(dateObj, 'yyyy-MM-dd') === formatDate(today, 'yyyy-MM-dd');\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Gets the start of day for a date\n */\nexport const getStartOfDay = (date: string | Date): Date => {\n  const dateObj = typeof date === 'string' ? parseISO(date) : date;\n  return startOfDay(dateObj);\n};\n\n/**\n * Gets the end of day for a date\n */\nexport const getEndOfDay = (date: string | Date): Date => {\n  const dateObj = typeof date === 'string' ? parseISO(date) : date;\n  return endOfDay(dateObj);\n};\n\n/**\n * Adds days to a date\n */\nexport const addDaysToDate = (date: string | Date, days: number): Date => {\n  const dateObj = typeof date === 'string' ? parseISO(date) : date;\n  return addDays(dateObj, days);\n};\n\n/**\n * Converts a date to ISO string format\n */\nexport const toISOString = (date: Date): string => {\n  return date.toISOString();\n};\n\n/**\n * Validates if a string is a valid date\n */\nexport const isValidDate = (dateString: string): boolean => {\n  try {\n    const date = parseISO(dateString);\n    return isValid(date);\n  } catch {\n    return false;\n  }\n};","import { Money } from '../domain/types/common';\n\n/**\n * Formats a phone number to Turkish format\n */\nexport const formatPhoneNumber = (phone: string): string => {\n  if (!phone) return '';\n  \n  // Remove all non-digit characters\n  const digits = phone.replace(/\\D/g, '');\n  \n  // Handle Turkish phone numbers\n  if (digits.startsWith('90')) {\n    // +90 format\n    const number = digits.slice(2);\n    if (number.length === 10) {\n      return `+90 ${number.slice(0, 3)} ${number.slice(3, 6)} ${number.slice(6, 8)} ${number.slice(8)}`;\n    }\n  } else if (digits.startsWith('0') && digits.length === 11) {\n    // 0xxx format\n    const number = digits.slice(1);\n    return `0${number.slice(0, 3)} ${number.slice(3, 6)} ${number.slice(6, 8)} ${number.slice(8)}`;\n  } else if (digits.length === 10) {\n    // xxx format\n    return `${digits.slice(0, 3)} ${digits.slice(3, 6)} ${digits.slice(6, 8)} ${digits.slice(8)}`;\n  }\n  \n  return phone; // Return original if can't format\n};\n\n/**\n * Formats Turkish Citizenship Number (TC Kimlik No)\n */\nexport const formatTcNumber = (tcNumber: string): string => {\n  if (!tcNumber) return '';\n  \n  const digits = tcNumber.replace(/\\D/g, '');\n  if (digits.length === 11) {\n    return `${digits.slice(0, 3)} ${digits.slice(3, 6)} ${digits.slice(6, 8)} ${digits.slice(8)}`;\n  }\n  \n  return tcNumber;\n};\n\n/**\n * Formats money amount with currency\n */\nexport const formatMoney = (money: Money): string => {\n  if (!money || money.amount === undefined) return '';\n  \n  const formatter = new Intl.NumberFormat('tr-TR', {\n    style: 'currency',\n    currency: money.currency || 'TRY',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  });\n  \n  return formatter.format(money.amount);\n};\n\n/**\n * Formats a number with Turkish locale\n */\nexport const formatNumber = (number: number, decimals: number = 0): string => {\n  if (number === undefined || number === null) return '';\n  \n  return new Intl.NumberFormat('tr-TR', {\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals,\n  }).format(number);\n};\n\n/**\n * Formats percentage\n */\nexport const formatPercentage = (value: number, decimals: number = 1): string => {\n  if (value === undefined || value === null) return '';\n  \n  return new Intl.NumberFormat('tr-TR', {\n    style: 'percent',\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals,\n  }).format(value / 100);\n};\n\n/**\n * Capitalizes first letter of each word\n */\nexport const capitalizeWords = (text: string): string => {\n  if (!text) return '';\n  \n  return text\n    .toLowerCase()\n    .split(' ')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n};\n\n/**\n * Truncates text with ellipsis\n */\nexport const truncateText = (text: string, maxLength: number): string => {\n  if (!text || text.length <= maxLength) return text;\n  \n  return text.slice(0, maxLength - 3) + '...';\n};\n\n/**\n * Formats file size in human readable format\n */\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\n/**\n * Masks sensitive information (like TC number)\n */\nexport const maskSensitiveInfo = (text: string, visibleChars: number = 4): string => {\n  if (!text || text.length <= visibleChars) return text;\n  \n  const visible = text.slice(-visibleChars);\n  const masked = '*'.repeat(text.length - visibleChars);\n  \n  return masked + visible;\n};","/**\n * Validates Turkish Citizenship Number (TC Kimlik No)\n */\nexport const validateTcNumber = (tcNumber: string): boolean => {\n  if (!tcNumber || tcNumber.length !== 11) return false;\n  \n  const digits = tcNumber.split('').map(Number);\n  \n  // First digit cannot be 0\n  if (digits[0] === 0) return false;\n  \n  // TC Number algorithm validation\n  const sum1 = digits[0] + digits[2] + digits[4] + digits[6] + digits[8];\n  const sum2 = digits[1] + digits[3] + digits[5] + digits[7];\n  const check1 = (sum1 * 7 - sum2) % 10;\n  const check2 = (sum1 + sum2 + digits[9]) % 10;\n  \n  return digits[9] === check1 && digits[10] === check2;\n};\n\n/**\n * Validates Turkish phone number\n */\nexport const validatePhoneNumber = (phone: string): boolean => {\n  if (!phone) return false;\n  \n  const phoneRegex = /^(\\+90|0)?[5][0-9]{9}$/;\n  return phoneRegex.test(phone.replace(/\\s/g, ''));\n};\n\n/**\n * Validates email address\n */\nexport const validateEmail = (email: string): boolean => {\n  if (!email) return false;\n  \n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\n/**\n * Validates password strength\n */\nexport const validatePassword = (password: string): {\n  isValid: boolean;\n  errors: string[];\n} => {\n  const errors: string[] = [];\n  \n  if (!password) {\n    errors.push('Password is required');\n    return { isValid: false, errors };\n  }\n  \n  if (password.length < 8) {\n    errors.push('Password must be at least 8 characters long');\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain at least one uppercase letter');\n  }\n  \n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain at least one lowercase letter');\n  }\n  \n  if (!/\\d/.test(password)) {\n    errors.push('Password must contain at least one number');\n  }\n  \n  if (!/[!@#$%^&*(),.?\":{}|<>]/.test(password)) {\n    errors.push('Password must contain at least one special character');\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Validates required field\n */\nexport const validateRequired = (value: any, fieldName: string): string | null => {\n  if (value === null || value === undefined || value === '') {\n    return `${fieldName} is required`;\n  }\n  return null;\n};\n\n/**\n * Validates string length\n */\nexport const validateLength = (\n  value: string, \n  min: number, \n  max: number, \n  fieldName: string\n): string | null => {\n  if (!value) return null;\n  \n  if (value.length < min) {\n    return `${fieldName} must be at least ${min} characters long`;\n  }\n  \n  if (value.length > max) {\n    return `${fieldName} must not exceed ${max} characters`;\n  }\n  \n  return null;\n};\n\n/**\n * Validates numeric range\n */\nexport const validateRange = (\n  value: number, \n  min: number, \n  max: number, \n  fieldName: string\n): string | null => {\n  if (value === null || value === undefined) return null;\n  \n  if (value < min) {\n    return `${fieldName} must be at least ${min}`;\n  }\n  \n  if (value > max) {\n    return `${fieldName} must not exceed ${max}`;\n  }\n  \n  return null;\n};\n\n/**\n * Validates date format and range\n */\nexport const validateDate = (\n  dateString: string, \n  fieldName: string,\n  options?: {\n    minDate?: Date;\n    maxDate?: Date;\n    allowFuture?: boolean;\n    allowPast?: boolean;\n  }\n): string | null => {\n  if (!dateString) return null;\n  \n  const date = new Date(dateString);\n  \n  if (isNaN(date.getTime())) {\n    return `${fieldName} must be a valid date`;\n  }\n  \n  const now = new Date();\n  \n  if (options?.allowFuture === false && date > now) {\n    return `${fieldName} cannot be in the future`;\n  }\n  \n  if (options?.allowPast === false && date < now) {\n    return `${fieldName} cannot be in the past`;\n  }\n  \n  if (options?.minDate && date < options.minDate) {\n    return `${fieldName} cannot be before ${options.minDate.toDateString()}`;\n  }\n  \n  if (options?.maxDate && date > options.maxDate) {\n    return `${fieldName} cannot be after ${options.maxDate.toDateString()}`;\n  }\n  \n  return null;\n};\n\n/**\n * Validates URL format\n */\nexport const validateUrl = (url: string): boolean => {\n  if (!url) return false;\n  \n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n};","/**\n * Storage utility functions for localStorage and sessionStorage\n */\n\nexport type StorageType = 'localStorage' | 'sessionStorage';\n\n/**\n * Safely gets an item from storage\n */\nexport const getStorageItem = <T = string>(\n  key: string, \n  storageType: StorageType = 'localStorage',\n  defaultValue?: T\n): T | null => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    const item = storage.getItem(key);\n    \n    if (item === null) {\n      return defaultValue ?? null;\n    }\n    \n    // Try to parse as JSON, fallback to string\n    try {\n      return JSON.parse(item);\n    } catch {\n      return item as T;\n    }\n  } catch (error) {\n    console.warn(`Failed to get item from ${storageType}:`, error);\n    return defaultValue ?? null;\n  }\n};\n\n/**\n * Safely sets an item in storage\n */\nexport const setStorageItem = (\n  key: string, \n  value: any, \n  storageType: StorageType = 'localStorage'\n): boolean => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);\n    storage.setItem(key, serializedValue);\n    return true;\n  } catch (error) {\n    console.warn(`Failed to set item in ${storageType}:`, error);\n    return false;\n  }\n};\n\n/**\n * Safely removes an item from storage\n */\nexport const removeStorageItem = (\n  key: string, \n  storageType: StorageType = 'localStorage'\n): boolean => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    storage.removeItem(key);\n    return true;\n  } catch (error) {\n    console.warn(`Failed to remove item from ${storageType}:`, error);\n    return false;\n  }\n};\n\n/**\n * Clears all items from storage\n */\nexport const clearStorage = (storageType: StorageType = 'localStorage'): boolean => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    storage.clear();\n    return true;\n  } catch (error) {\n    console.warn(`Failed to clear ${storageType}:`, error);\n    return false;\n  }\n};\n\n/**\n * Gets all keys from storage\n */\nexport const getStorageKeys = (storageType: StorageType = 'localStorage'): string[] => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    return Object.keys(storage);\n  } catch (error) {\n    console.warn(`Failed to get keys from ${storageType}:`, error);\n    return [];\n  }\n};\n\n/**\n * Checks if storage is available\n */\nexport const isStorageAvailable = (storageType: StorageType = 'localStorage'): boolean => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    const testKey = '__storage_test__';\n    storage.setItem(testKey, 'test');\n    storage.removeItem(testKey);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Gets storage usage information\n */\nexport const getStorageUsage = (storageType: StorageType = 'localStorage'): {\n  used: number;\n  total: number;\n  available: number;\n  percentage: number;\n} => {\n  try {\n    const storage = storageType === 'localStorage' ? localStorage : sessionStorage;\n    let used = 0;\n    \n    for (let key in storage) {\n      if (storage.hasOwnProperty(key)) {\n        used += storage[key].length + key.length;\n      }\n    }\n    \n    // Estimate total storage (usually 5-10MB for localStorage)\n    const total = 5 * 1024 * 1024; // 5MB estimate\n    const available = total - used;\n    const percentage = (used / total) * 100;\n    \n    return {\n      used,\n      total,\n      available,\n      percentage: Math.round(percentage * 100) / 100\n    };\n  } catch (error) {\n    console.warn(`Failed to get storage usage for ${storageType}:`, error);\n    return { used: 0, total: 0, available: 0, percentage: 0 };\n  }\n};\n\n/**\n * Creates a storage manager for a specific prefix\n */\nexport const createStorageManager = (prefix: string, storageType: StorageType = 'localStorage') => {\n  const prefixedKey = (key: string) => `${prefix}_${key}`;\n  \n  return {\n    get: <T = string>(key: string, defaultValue?: T) => \n      getStorageItem<T>(prefixedKey(key), storageType, defaultValue),\n    \n    set: (key: string, value: any) => \n      setStorageItem(prefixedKey(key), value, storageType),\n    \n    remove: (key: string) => \n      removeStorageItem(prefixedKey(key), storageType),\n    \n    clear: () => {\n      const keys = getStorageKeys(storageType);\n      const prefixedKeys = keys.filter(key => key.startsWith(`${prefix}_`));\n      return prefixedKeys.every(key => removeStorageItem(key, storageType));\n    },\n    \n    getKeys: () => {\n      const keys = getStorageKeys(storageType);\n      return keys\n        .filter(key => key.startsWith(`${prefix}_`))\n        .map(key => key.replace(`${prefix}_`, ''));\n    }\n  };\n};"],"mappings":"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","names":["fuzzySearch","useState","useCallback","useState","useCallback"]}